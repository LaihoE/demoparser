// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.12.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `fatdemo.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:MLDict)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLDict {
    // message fields
    // @@protoc_insertion_point(field:MLDict.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLDict.val_string)
    pub val_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLDict.val_int)
    pub val_int: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLDict.val_float)
    pub val_float: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:MLDict.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLDict {
    fn default() -> &'a MLDict {
        <MLDict as ::protobuf::Message>::default_instance()
    }
}

impl MLDict {
    pub fn new() -> MLDict {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string val_string = 2;

    pub fn val_string(&self) -> &str {
        match self.val_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_val_string(&mut self) {
        self.val_string = ::std::option::Option::None;
    }

    pub fn has_val_string(&self) -> bool {
        self.val_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_string(&mut self, v: ::std::string::String) {
        self.val_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val_string(&mut self) -> &mut ::std::string::String {
        if self.val_string.is_none() {
            self.val_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.val_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_val_string(&mut self) -> ::std::string::String {
        self.val_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 val_int = 3;

    pub fn val_int(&self) -> i32 {
        self.val_int.unwrap_or(0)
    }

    pub fn clear_val_int(&mut self) {
        self.val_int = ::std::option::Option::None;
    }

    pub fn has_val_int(&self) -> bool {
        self.val_int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_int(&mut self, v: i32) {
        self.val_int = ::std::option::Option::Some(v);
    }

    // optional float val_float = 4;

    pub fn val_float(&self) -> f32 {
        self.val_float.unwrap_or(0.)
    }

    pub fn clear_val_float(&mut self) {
        self.val_float = ::std::option::Option::None;
    }

    pub fn has_val_float(&self) -> bool {
        self.val_float.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val_float(&mut self, v: f32) {
        self.val_float = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key",
            |m: &MLDict| { &m.key },
            |m: &mut MLDict| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "val_string",
            |m: &MLDict| { &m.val_string },
            |m: &mut MLDict| { &mut m.val_string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "val_int",
            |m: &MLDict| { &m.val_int },
            |m: &mut MLDict| { &mut m.val_int },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "val_float",
            |m: &MLDict| { &m.val_float },
            |m: &mut MLDict| { &mut m.val_float },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MLDict>(
            "MLDict",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MLDict {
    const NAME: &'static str = "MLDict";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.val_string = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.val_int = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.val_float = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.val_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.val_int {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.val_float {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.val_string.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.val_int {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.val_float {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLDict {
        MLDict::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.val_string = ::std::option::Option::None;
        self.val_int = ::std::option::Option::None;
        self.val_float = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLDict {
        static instance: MLDict = MLDict {
            key: ::std::option::Option::None,
            val_string: ::std::option::Option::None,
            val_int: ::std::option::Option::None,
            val_float: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MLDict {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MLDict").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MLDict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MLDict {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MLEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLEvent {
    // message fields
    // @@protoc_insertion_point(field:MLEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLEvent.data)
    pub data: ::std::vec::Vec<MLDict>,
    // special fields
    // @@protoc_insertion_point(special_field:MLEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLEvent {
    fn default() -> &'a MLEvent {
        <MLEvent as ::protobuf::Message>::default_instance()
    }
}

impl MLEvent {
    pub fn new() -> MLEvent {
        ::std::default::Default::default()
    }

    // optional string event_name = 1;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_name",
            |m: &MLEvent| { &m.event_name },
            |m: &mut MLEvent| { &mut m.event_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &MLEvent| { &m.data },
            |m: &mut MLEvent| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MLEvent>(
            "MLEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MLEvent {
    const NAME: &'static str = "MLEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLEvent {
        MLEvent::new()
    }

    fn clear(&mut self) {
        self.event_name = ::std::option::Option::None;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLEvent {
        static instance: MLEvent = MLEvent {
            event_name: ::std::option::Option::None,
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MLEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MLEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MLEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MLEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MLMatchState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLMatchState {
    // message fields
    // @@protoc_insertion_point(field:MLMatchState.game_mode)
    pub game_mode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLMatchState.phase)
    pub phase: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLMatchState.round)
    pub round: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLMatchState.score_ct)
    pub score_ct: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLMatchState.score_t)
    pub score_t: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:MLMatchState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLMatchState {
    fn default() -> &'a MLMatchState {
        <MLMatchState as ::protobuf::Message>::default_instance()
    }
}

impl MLMatchState {
    pub fn new() -> MLMatchState {
        ::std::default::Default::default()
    }

    // optional string game_mode = 1;

    pub fn game_mode(&self) -> &str {
        match self.game_mode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: ::std::string::String) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mode(&mut self) -> &mut ::std::string::String {
        if self.game_mode.is_none() {
            self.game_mode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mode(&mut self) -> ::std::string::String {
        self.game_mode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string phase = 2;

    pub fn phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 round = 3;

    pub fn round(&self) -> i32 {
        self.round.unwrap_or(0)
    }

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i32) {
        self.round = ::std::option::Option::Some(v);
    }

    // optional int32 score_ct = 4;

    pub fn score_ct(&self) -> i32 {
        self.score_ct.unwrap_or(0)
    }

    pub fn clear_score_ct(&mut self) {
        self.score_ct = ::std::option::Option::None;
    }

    pub fn has_score_ct(&self) -> bool {
        self.score_ct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_ct(&mut self, v: i32) {
        self.score_ct = ::std::option::Option::Some(v);
    }

    // optional int32 score_t = 5;

    pub fn score_t(&self) -> i32 {
        self.score_t.unwrap_or(0)
    }

    pub fn clear_score_t(&mut self) {
        self.score_t = ::std::option::Option::None;
    }

    pub fn has_score_t(&self) -> bool {
        self.score_t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_t(&mut self, v: i32) {
        self.score_t = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &MLMatchState| { &m.game_mode },
            |m: &mut MLMatchState| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase",
            |m: &MLMatchState| { &m.phase },
            |m: &mut MLMatchState| { &mut m.phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round",
            |m: &MLMatchState| { &m.round },
            |m: &mut MLMatchState| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_ct",
            |m: &MLMatchState| { &m.score_ct },
            |m: &mut MLMatchState| { &mut m.score_ct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score_t",
            |m: &MLMatchState| { &m.score_t },
            |m: &mut MLMatchState| { &mut m.score_t },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MLMatchState>(
            "MLMatchState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MLMatchState {
    const NAME: &'static str = "MLMatchState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.game_mode = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.phase = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.round = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.score_ct = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.score_t = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_mode.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.round {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.score_ct {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.score_t {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_mode.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.phase.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.round {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.score_ct {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.score_t {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLMatchState {
        MLMatchState::new()
    }

    fn clear(&mut self) {
        self.game_mode = ::std::option::Option::None;
        self.phase = ::std::option::Option::None;
        self.round = ::std::option::Option::None;
        self.score_ct = ::std::option::Option::None;
        self.score_t = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLMatchState {
        static instance: MLMatchState = MLMatchState {
            game_mode: ::std::option::Option::None,
            phase: ::std::option::Option::None,
            round: ::std::option::Option::None,
            score_ct: ::std::option::Option::None,
            score_t: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MLMatchState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MLMatchState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MLMatchState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MLMatchState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MLRoundState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLRoundState {
    // message fields
    // @@protoc_insertion_point(field:MLRoundState.phase)
    pub phase: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLRoundState.win_team)
    pub win_team: ::std::option::Option<::protobuf::EnumOrUnknown<ETeam>>,
    // @@protoc_insertion_point(field:MLRoundState.bomb_state)
    pub bomb_state: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:MLRoundState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLRoundState {
    fn default() -> &'a MLRoundState {
        <MLRoundState as ::protobuf::Message>::default_instance()
    }
}

impl MLRoundState {
    pub fn new() -> MLRoundState {
        ::std::default::Default::default()
    }

    // optional string phase = 1;

    pub fn phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_phase(&mut self) {
        self.phase = ::std::option::Option::None;
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase = ::std::option::Option::Some(::std::string::String::new());
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ETeam win_team = 2;

    pub fn win_team(&self) -> ETeam {
        match self.win_team {
            Some(e) => e.enum_value_or(ETeam::ET_Unknown),
            None => ETeam::ET_Unknown,
        }
    }

    pub fn clear_win_team(&mut self) {
        self.win_team = ::std::option::Option::None;
    }

    pub fn has_win_team(&self) -> bool {
        self.win_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_team(&mut self, v: ETeam) {
        self.win_team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string bomb_state = 3;

    pub fn bomb_state(&self) -> &str {
        match self.bomb_state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_bomb_state(&mut self) {
        self.bomb_state = ::std::option::Option::None;
    }

    pub fn has_bomb_state(&self) -> bool {
        self.bomb_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bomb_state(&mut self, v: ::std::string::String) {
        self.bomb_state = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bomb_state(&mut self) -> &mut ::std::string::String {
        if self.bomb_state.is_none() {
            self.bomb_state = ::std::option::Option::Some(::std::string::String::new());
        }
        self.bomb_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_bomb_state(&mut self) -> ::std::string::String {
        self.bomb_state.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "phase",
            |m: &MLRoundState| { &m.phase },
            |m: &mut MLRoundState| { &mut m.phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "win_team",
            |m: &MLRoundState| { &m.win_team },
            |m: &mut MLRoundState| { &mut m.win_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bomb_state",
            |m: &MLRoundState| { &m.bomb_state },
            |m: &mut MLRoundState| { &mut m.bomb_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MLRoundState>(
            "MLRoundState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MLRoundState {
    const NAME: &'static str = "MLRoundState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.phase = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.win_team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.bomb_state = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.win_team {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.bomb_state.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.phase.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.win_team {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bomb_state.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLRoundState {
        MLRoundState::new()
    }

    fn clear(&mut self) {
        self.phase = ::std::option::Option::None;
        self.win_team = ::std::option::Option::None;
        self.bomb_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLRoundState {
        static instance: MLRoundState = MLRoundState {
            phase: ::std::option::Option::None,
            win_team: ::std::option::Option::None,
            bomb_state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MLRoundState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MLRoundState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MLRoundState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MLRoundState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MLWeaponState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLWeaponState {
    // message fields
    // @@protoc_insertion_point(field:MLWeaponState.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLWeaponState.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLWeaponState.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<EWeaponType>>,
    // @@protoc_insertion_point(field:MLWeaponState.ammo_clip)
    pub ammo_clip: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLWeaponState.ammo_clip_max)
    pub ammo_clip_max: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLWeaponState.ammo_reserve)
    pub ammo_reserve: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLWeaponState.state)
    pub state: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLWeaponState.recoil_index)
    pub recoil_index: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:MLWeaponState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLWeaponState {
    fn default() -> &'a MLWeaponState {
        <MLWeaponState as ::protobuf::Message>::default_instance()
    }
}

impl MLWeaponState {
    pub fn new() -> MLWeaponState {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EWeaponType type = 3;

    pub fn type_(&self) -> EWeaponType {
        match self.type_ {
            Some(e) => e.enum_value_or(EWeaponType::EWT_Knife),
            None => EWeaponType::EWT_Knife,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EWeaponType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 ammo_clip = 4;

    pub fn ammo_clip(&self) -> i32 {
        self.ammo_clip.unwrap_or(0)
    }

    pub fn clear_ammo_clip(&mut self) {
        self.ammo_clip = ::std::option::Option::None;
    }

    pub fn has_ammo_clip(&self) -> bool {
        self.ammo_clip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammo_clip(&mut self, v: i32) {
        self.ammo_clip = ::std::option::Option::Some(v);
    }

    // optional int32 ammo_clip_max = 5;

    pub fn ammo_clip_max(&self) -> i32 {
        self.ammo_clip_max.unwrap_or(0)
    }

    pub fn clear_ammo_clip_max(&mut self) {
        self.ammo_clip_max = ::std::option::Option::None;
    }

    pub fn has_ammo_clip_max(&self) -> bool {
        self.ammo_clip_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammo_clip_max(&mut self, v: i32) {
        self.ammo_clip_max = ::std::option::Option::Some(v);
    }

    // optional int32 ammo_reserve = 6;

    pub fn ammo_reserve(&self) -> i32 {
        self.ammo_reserve.unwrap_or(0)
    }

    pub fn clear_ammo_reserve(&mut self) {
        self.ammo_reserve = ::std::option::Option::None;
    }

    pub fn has_ammo_reserve(&self) -> bool {
        self.ammo_reserve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammo_reserve(&mut self, v: i32) {
        self.ammo_reserve = ::std::option::Option::Some(v);
    }

    // optional string state = 7;

    pub fn state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        if self.state.is_none() {
            self.state = ::std::option::Option::Some(::std::string::String::new());
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        self.state.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float recoil_index = 8;

    pub fn recoil_index(&self) -> f32 {
        self.recoil_index.unwrap_or(0.)
    }

    pub fn clear_recoil_index(&mut self) {
        self.recoil_index = ::std::option::Option::None;
    }

    pub fn has_recoil_index(&self) -> bool {
        self.recoil_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recoil_index(&mut self, v: f32) {
        self.recoil_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &MLWeaponState| { &m.index },
            |m: &mut MLWeaponState| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MLWeaponState| { &m.name },
            |m: &mut MLWeaponState| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &MLWeaponState| { &m.type_ },
            |m: &mut MLWeaponState| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ammo_clip",
            |m: &MLWeaponState| { &m.ammo_clip },
            |m: &mut MLWeaponState| { &mut m.ammo_clip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ammo_clip_max",
            |m: &MLWeaponState| { &m.ammo_clip_max },
            |m: &mut MLWeaponState| { &mut m.ammo_clip_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ammo_reserve",
            |m: &MLWeaponState| { &m.ammo_reserve },
            |m: &mut MLWeaponState| { &mut m.ammo_reserve },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &MLWeaponState| { &m.state },
            |m: &mut MLWeaponState| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "recoil_index",
            |m: &MLWeaponState| { &m.recoil_index },
            |m: &mut MLWeaponState| { &mut m.recoil_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MLWeaponState>(
            "MLWeaponState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MLWeaponState {
    const NAME: &'static str = "MLWeaponState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.ammo_clip = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.ammo_clip_max = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.ammo_reserve = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.state = ::std::option::Option::Some(is.read_string()?);
                },
                69 => {
                    self.recoil_index = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.ammo_clip {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.ammo_clip_max {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.ammo_reserve {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.recoil_index {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ammo_clip {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.ammo_clip_max {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.ammo_reserve {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.recoil_index {
            os.write_float(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLWeaponState {
        MLWeaponState::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.ammo_clip = ::std::option::Option::None;
        self.ammo_clip_max = ::std::option::Option::None;
        self.ammo_reserve = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.recoil_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLWeaponState {
        static instance: MLWeaponState = MLWeaponState {
            index: ::std::option::Option::None,
            name: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            ammo_clip: ::std::option::Option::None,
            ammo_clip_max: ::std::option::Option::None,
            ammo_reserve: ::std::option::Option::None,
            state: ::std::option::Option::None,
            recoil_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MLWeaponState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MLWeaponState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MLWeaponState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MLWeaponState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MLPlayerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLPlayerState {
    // message fields
    // @@protoc_insertion_point(field:MLPlayerState.account_id)
    pub account_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLPlayerState.clan)
    pub clan: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLPlayerState.team)
    pub team: ::std::option::Option<::protobuf::EnumOrUnknown<ETeam>>,
    // @@protoc_insertion_point(field:MLPlayerState.abspos)
    pub abspos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:MLPlayerState.eyeangle)
    pub eyeangle: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:MLPlayerState.eyeangle_fwd)
    pub eyeangle_fwd: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:MLPlayerState.health)
    pub health: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.armor)
    pub armor: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.flashed)
    pub flashed: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MLPlayerState.smoked)
    pub smoked: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MLPlayerState.money)
    pub money: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.round_kills)
    pub round_kills: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.round_killhs)
    pub round_killhs: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLPlayerState.burning)
    pub burning: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:MLPlayerState.helmet)
    pub helmet: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MLPlayerState.defuse_kit)
    pub defuse_kit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:MLPlayerState.weapons)
    pub weapons: ::std::vec::Vec<MLWeaponState>,
    // special fields
    // @@protoc_insertion_point(special_field:MLPlayerState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLPlayerState {
    fn default() -> &'a MLPlayerState {
        <MLPlayerState as ::protobuf::Message>::default_instance()
    }
}

impl MLPlayerState {
    pub fn new() -> MLPlayerState {
        ::std::default::Default::default()
    }

    // optional int32 account_id = 1;

    pub fn account_id(&self) -> i32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: i32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot = 2;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional int32 entindex = 3;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional string name = 4;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string clan = 5;

    pub fn clan(&self) -> &str {
        match self.clan.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clan(&mut self) {
        self.clan = ::std::option::Option::None;
    }

    pub fn has_clan(&self) -> bool {
        self.clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan(&mut self, v: ::std::string::String) {
        self.clan = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clan(&mut self) -> &mut ::std::string::String {
        if self.clan.is_none() {
            self.clan = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clan.as_mut().unwrap()
    }

    // Take field
    pub fn take_clan(&mut self) -> ::std::string::String {
        self.clan.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ETeam team = 6;

    pub fn team(&self) -> ETeam {
        match self.team {
            Some(e) => e.enum_value_or(ETeam::ET_Unknown),
            None => ETeam::ET_Unknown,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: ETeam) {
        self.team = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 health = 10;

    pub fn health(&self) -> i32 {
        self.health.unwrap_or(0)
    }

    pub fn clear_health(&mut self) {
        self.health = ::std::option::Option::None;
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: i32) {
        self.health = ::std::option::Option::Some(v);
    }

    // optional int32 armor = 11;

    pub fn armor(&self) -> i32 {
        self.armor.unwrap_or(0)
    }

    pub fn clear_armor(&mut self) {
        self.armor = ::std::option::Option::None;
    }

    pub fn has_armor(&self) -> bool {
        self.armor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_armor(&mut self, v: i32) {
        self.armor = ::std::option::Option::Some(v);
    }

    // optional float flashed = 12;

    pub fn flashed(&self) -> f32 {
        self.flashed.unwrap_or(0.)
    }

    pub fn clear_flashed(&mut self) {
        self.flashed = ::std::option::Option::None;
    }

    pub fn has_flashed(&self) -> bool {
        self.flashed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flashed(&mut self, v: f32) {
        self.flashed = ::std::option::Option::Some(v);
    }

    // optional float smoked = 13;

    pub fn smoked(&self) -> f32 {
        self.smoked.unwrap_or(0.)
    }

    pub fn clear_smoked(&mut self) {
        self.smoked = ::std::option::Option::None;
    }

    pub fn has_smoked(&self) -> bool {
        self.smoked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_smoked(&mut self, v: f32) {
        self.smoked = ::std::option::Option::Some(v);
    }

    // optional int32 money = 14;

    pub fn money(&self) -> i32 {
        self.money.unwrap_or(0)
    }

    pub fn clear_money(&mut self) {
        self.money = ::std::option::Option::None;
    }

    pub fn has_money(&self) -> bool {
        self.money.is_some()
    }

    // Param is passed by value, moved
    pub fn set_money(&mut self, v: i32) {
        self.money = ::std::option::Option::Some(v);
    }

    // optional int32 round_kills = 15;

    pub fn round_kills(&self) -> i32 {
        self.round_kills.unwrap_or(0)
    }

    pub fn clear_round_kills(&mut self) {
        self.round_kills = ::std::option::Option::None;
    }

    pub fn has_round_kills(&self) -> bool {
        self.round_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_kills(&mut self, v: i32) {
        self.round_kills = ::std::option::Option::Some(v);
    }

    // optional int32 round_killhs = 16;

    pub fn round_killhs(&self) -> i32 {
        self.round_killhs.unwrap_or(0)
    }

    pub fn clear_round_killhs(&mut self) {
        self.round_killhs = ::std::option::Option::None;
    }

    pub fn has_round_killhs(&self) -> bool {
        self.round_killhs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_killhs(&mut self, v: i32) {
        self.round_killhs = ::std::option::Option::Some(v);
    }

    // optional float burning = 17;

    pub fn burning(&self) -> f32 {
        self.burning.unwrap_or(0.)
    }

    pub fn clear_burning(&mut self) {
        self.burning = ::std::option::Option::None;
    }

    pub fn has_burning(&self) -> bool {
        self.burning.is_some()
    }

    // Param is passed by value, moved
    pub fn set_burning(&mut self, v: f32) {
        self.burning = ::std::option::Option::Some(v);
    }

    // optional bool helmet = 18;

    pub fn helmet(&self) -> bool {
        self.helmet.unwrap_or(false)
    }

    pub fn clear_helmet(&mut self) {
        self.helmet = ::std::option::Option::None;
    }

    pub fn has_helmet(&self) -> bool {
        self.helmet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_helmet(&mut self, v: bool) {
        self.helmet = ::std::option::Option::Some(v);
    }

    // optional bool defuse_kit = 19;

    pub fn defuse_kit(&self) -> bool {
        self.defuse_kit.unwrap_or(false)
    }

    pub fn clear_defuse_kit(&mut self) {
        self.defuse_kit = ::std::option::Option::None;
    }

    pub fn has_defuse_kit(&self) -> bool {
        self.defuse_kit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defuse_kit(&mut self, v: bool) {
        self.defuse_kit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &MLPlayerState| { &m.account_id },
            |m: &mut MLPlayerState| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &MLPlayerState| { &m.player_slot },
            |m: &mut MLPlayerState| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entindex",
            |m: &MLPlayerState| { &m.entindex },
            |m: &mut MLPlayerState| { &mut m.entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MLPlayerState| { &m.name },
            |m: &mut MLPlayerState| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clan",
            |m: &MLPlayerState| { &m.clan },
            |m: &mut MLPlayerState| { &mut m.clan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &MLPlayerState| { &m.team },
            |m: &mut MLPlayerState| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "abspos",
            |m: &MLPlayerState| { &m.abspos },
            |m: &mut MLPlayerState| { &mut m.abspos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "eyeangle",
            |m: &MLPlayerState| { &m.eyeangle },
            |m: &mut MLPlayerState| { &mut m.eyeangle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "eyeangle_fwd",
            |m: &MLPlayerState| { &m.eyeangle_fwd },
            |m: &mut MLPlayerState| { &mut m.eyeangle_fwd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "health",
            |m: &MLPlayerState| { &m.health },
            |m: &mut MLPlayerState| { &mut m.health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "armor",
            |m: &MLPlayerState| { &m.armor },
            |m: &mut MLPlayerState| { &mut m.armor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flashed",
            |m: &MLPlayerState| { &m.flashed },
            |m: &mut MLPlayerState| { &mut m.flashed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "smoked",
            |m: &MLPlayerState| { &m.smoked },
            |m: &mut MLPlayerState| { &mut m.smoked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "money",
            |m: &MLPlayerState| { &m.money },
            |m: &mut MLPlayerState| { &mut m.money },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round_kills",
            |m: &MLPlayerState| { &m.round_kills },
            |m: &mut MLPlayerState| { &mut m.round_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round_killhs",
            |m: &MLPlayerState| { &m.round_killhs },
            |m: &mut MLPlayerState| { &mut m.round_killhs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "burning",
            |m: &MLPlayerState| { &m.burning },
            |m: &mut MLPlayerState| { &mut m.burning },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "helmet",
            |m: &MLPlayerState| { &m.helmet },
            |m: &mut MLPlayerState| { &mut m.helmet },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defuse_kit",
            |m: &MLPlayerState| { &m.defuse_kit },
            |m: &mut MLPlayerState| { &mut m.defuse_kit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "weapons",
            |m: &MLPlayerState| { &m.weapons },
            |m: &mut MLPlayerState| { &mut m.weapons },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MLPlayerState>(
            "MLPlayerState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MLPlayerState {
    const NAME: &'static str = "MLPlayerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.clan = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.abspos)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eyeangle)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eyeangle_fwd)?;
                },
                80 => {
                    self.health = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.armor = ::std::option::Option::Some(is.read_int32()?);
                },
                101 => {
                    self.flashed = ::std::option::Option::Some(is.read_float()?);
                },
                109 => {
                    self.smoked = ::std::option::Option::Some(is.read_float()?);
                },
                112 => {
                    self.money = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.round_kills = ::std::option::Option::Some(is.read_int32()?);
                },
                128 => {
                    self.round_killhs = ::std::option::Option::Some(is.read_int32()?);
                },
                141 => {
                    self.burning = ::std::option::Option::Some(is.read_float()?);
                },
                144 => {
                    self.helmet = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.defuse_kit = ::std::option::Option::Some(is.read_bool()?);
                },
                162 => {
                    self.weapons.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.clan.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.abspos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eyeangle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eyeangle_fwd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.health {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.armor {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.flashed {
            my_size += 1 + 4;
        }
        if let Some(v) = self.smoked {
            my_size += 1 + 4;
        }
        if let Some(v) = self.money {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.round_kills {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.round_killhs {
            my_size += ::protobuf::rt::int32_size(16, v);
        }
        if let Some(v) = self.burning {
            my_size += 2 + 4;
        }
        if let Some(v) = self.helmet {
            my_size += 2 + 1;
        }
        if let Some(v) = self.defuse_kit {
            my_size += 2 + 1;
        }
        for value in &self.weapons {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.clan.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.team {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.abspos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.eyeangle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.eyeangle_fwd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.health {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.armor {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.flashed {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.smoked {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.money {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.round_kills {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.round_killhs {
            os.write_int32(16, v)?;
        }
        if let Some(v) = self.burning {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.helmet {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.defuse_kit {
            os.write_bool(19, v)?;
        }
        for v in &self.weapons {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLPlayerState {
        MLPlayerState::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.entindex = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.clan = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.abspos.clear();
        self.eyeangle.clear();
        self.eyeangle_fwd.clear();
        self.health = ::std::option::Option::None;
        self.armor = ::std::option::Option::None;
        self.flashed = ::std::option::Option::None;
        self.smoked = ::std::option::Option::None;
        self.money = ::std::option::Option::None;
        self.round_kills = ::std::option::Option::None;
        self.round_killhs = ::std::option::Option::None;
        self.burning = ::std::option::Option::None;
        self.helmet = ::std::option::Option::None;
        self.defuse_kit = ::std::option::Option::None;
        self.weapons.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLPlayerState {
        static instance: MLPlayerState = MLPlayerState {
            account_id: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            entindex: ::std::option::Option::None,
            name: ::std::option::Option::None,
            clan: ::std::option::Option::None,
            team: ::std::option::Option::None,
            abspos: ::protobuf::MessageField::none(),
            eyeangle: ::protobuf::MessageField::none(),
            eyeangle_fwd: ::protobuf::MessageField::none(),
            health: ::std::option::Option::None,
            armor: ::std::option::Option::None,
            flashed: ::std::option::Option::None,
            smoked: ::std::option::Option::None,
            money: ::std::option::Option::None,
            round_kills: ::std::option::Option::None,
            round_killhs: ::std::option::Option::None,
            burning: ::std::option::Option::None,
            helmet: ::std::option::Option::None,
            defuse_kit: ::std::option::Option::None,
            weapons: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MLPlayerState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MLPlayerState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MLPlayerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MLPlayerState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MLGameState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLGameState {
    // message fields
    // @@protoc_insertion_point(field:MLGameState.match)
    pub match_: ::protobuf::MessageField<MLMatchState>,
    // @@protoc_insertion_point(field:MLGameState.round)
    pub round: ::protobuf::MessageField<MLRoundState>,
    // @@protoc_insertion_point(field:MLGameState.players)
    pub players: ::std::vec::Vec<MLPlayerState>,
    // special fields
    // @@protoc_insertion_point(special_field:MLGameState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLGameState {
    fn default() -> &'a MLGameState {
        <MLGameState as ::protobuf::Message>::default_instance()
    }
}

impl MLGameState {
    pub fn new() -> MLGameState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MLMatchState>(
            "match",
            |m: &MLGameState| { &m.match_ },
            |m: &mut MLGameState| { &mut m.match_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MLRoundState>(
            "round",
            |m: &MLGameState| { &m.round },
            |m: &mut MLGameState| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &MLGameState| { &m.players },
            |m: &mut MLGameState| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MLGameState>(
            "MLGameState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MLGameState {
    const NAME: &'static str = "MLGameState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.round)?;
                },
                26 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.round.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.round.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLGameState {
        MLGameState::new()
    }

    fn clear(&mut self) {
        self.match_.clear();
        self.round.clear();
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLGameState {
        static instance: MLGameState = MLGameState {
            match_: ::protobuf::MessageField::none(),
            round: ::protobuf::MessageField::none(),
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MLGameState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MLGameState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MLGameState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MLGameState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MLDemoHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLDemoHeader {
    // message fields
    // @@protoc_insertion_point(field:MLDemoHeader.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:MLDemoHeader.tick_rate)
    pub tick_rate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLDemoHeader.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MLDemoHeader.steam_universe)
    pub steam_universe: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:MLDemoHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLDemoHeader {
    fn default() -> &'a MLDemoHeader {
        <MLDemoHeader as ::protobuf::Message>::default_instance()
    }
}

impl MLDemoHeader {
    pub fn new() -> MLDemoHeader {
        ::std::default::Default::default()
    }

    // optional string map_name = 1;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 tick_rate = 2;

    pub fn tick_rate(&self) -> i32 {
        self.tick_rate.unwrap_or(0)
    }

    pub fn clear_tick_rate(&mut self) {
        self.tick_rate = ::std::option::Option::None;
    }

    pub fn has_tick_rate(&self) -> bool {
        self.tick_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_rate(&mut self, v: i32) {
        self.tick_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 version = 3;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 steam_universe = 4;

    pub fn steam_universe(&self) -> u32 {
        self.steam_universe.unwrap_or(0)
    }

    pub fn clear_steam_universe(&mut self) {
        self.steam_universe = ::std::option::Option::None;
    }

    pub fn has_steam_universe(&self) -> bool {
        self.steam_universe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_universe(&mut self, v: u32) {
        self.steam_universe = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &MLDemoHeader| { &m.map_name },
            |m: &mut MLDemoHeader| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick_rate",
            |m: &MLDemoHeader| { &m.tick_rate },
            |m: &mut MLDemoHeader| { &mut m.tick_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &MLDemoHeader| { &m.version },
            |m: &mut MLDemoHeader| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_universe",
            |m: &MLDemoHeader| { &m.steam_universe },
            |m: &mut MLDemoHeader| { &mut m.steam_universe },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MLDemoHeader>(
            "MLDemoHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MLDemoHeader {
    const NAME: &'static str = "MLDemoHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.tick_rate = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.steam_universe = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.tick_rate {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.steam_universe {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.tick_rate {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.steam_universe {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLDemoHeader {
        MLDemoHeader::new()
    }

    fn clear(&mut self) {
        self.map_name = ::std::option::Option::None;
        self.tick_rate = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.steam_universe = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLDemoHeader {
        static instance: MLDemoHeader = MLDemoHeader {
            map_name: ::std::option::Option::None,
            tick_rate: ::std::option::Option::None,
            version: ::std::option::Option::None,
            steam_universe: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MLDemoHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MLDemoHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MLDemoHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MLDemoHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MLTick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MLTick {
    // message fields
    // @@protoc_insertion_point(field:MLTick.tick_count)
    pub tick_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:MLTick.state)
    pub state: ::protobuf::MessageField<MLGameState>,
    // @@protoc_insertion_point(field:MLTick.events)
    pub events: ::std::vec::Vec<MLEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:MLTick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MLTick {
    fn default() -> &'a MLTick {
        <MLTick as ::protobuf::Message>::default_instance()
    }
}

impl MLTick {
    pub fn new() -> MLTick {
        ::std::default::Default::default()
    }

    // optional int32 tick_count = 1;

    pub fn tick_count(&self) -> i32 {
        self.tick_count.unwrap_or(0)
    }

    pub fn clear_tick_count(&mut self) {
        self.tick_count = ::std::option::Option::None;
    }

    pub fn has_tick_count(&self) -> bool {
        self.tick_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_count(&mut self, v: i32) {
        self.tick_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick_count",
            |m: &MLTick| { &m.tick_count },
            |m: &mut MLTick| { &mut m.tick_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MLGameState>(
            "state",
            |m: &MLTick| { &m.state },
            |m: &mut MLTick| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &MLTick| { &m.events },
            |m: &mut MLTick| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MLTick>(
            "MLTick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MLTick {
    const NAME: &'static str = "MLTick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick_count = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                26 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick_count {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tick_count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MLTick {
        MLTick::new()
    }

    fn clear(&mut self) {
        self.tick_count = ::std::option::Option::None;
        self.state.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MLTick {
        static instance: MLTick = MLTick {
            tick_count: ::std::option::Option::None,
            state: ::protobuf::MessageField::none(),
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MLTick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MLTick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MLTick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MLTick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VacNetShot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VacNetShot {
    // message fields
    // @@protoc_insertion_point(field:VacNetShot.steamid_player)
    pub steamid_player: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:VacNetShot.round_number)
    pub round_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:VacNetShot.hit_type)
    pub hit_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:VacNetShot.weapon_type)
    pub weapon_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:VacNetShot.distance_to_hurt_target)
    pub distance_to_hurt_target: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:VacNetShot.delta_yaw_window)
    pub delta_yaw_window: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:VacNetShot.delta_pitch_window)
    pub delta_pitch_window: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:VacNetShot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VacNetShot {
    fn default() -> &'a VacNetShot {
        <VacNetShot as ::protobuf::Message>::default_instance()
    }
}

impl VacNetShot {
    pub fn new() -> VacNetShot {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_player = 1;

    pub fn steamid_player(&self) -> u64 {
        self.steamid_player.unwrap_or(0)
    }

    pub fn clear_steamid_player(&mut self) {
        self.steamid_player = ::std::option::Option::None;
    }

    pub fn has_steamid_player(&self) -> bool {
        self.steamid_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_player(&mut self, v: u64) {
        self.steamid_player = ::std::option::Option::Some(v);
    }

    // optional int32 round_number = 2;

    pub fn round_number(&self) -> i32 {
        self.round_number.unwrap_or(0)
    }

    pub fn clear_round_number(&mut self) {
        self.round_number = ::std::option::Option::None;
    }

    pub fn has_round_number(&self) -> bool {
        self.round_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_number(&mut self, v: i32) {
        self.round_number = ::std::option::Option::Some(v);
    }

    // optional int32 hit_type = 3;

    pub fn hit_type(&self) -> i32 {
        self.hit_type.unwrap_or(0)
    }

    pub fn clear_hit_type(&mut self) {
        self.hit_type = ::std::option::Option::None;
    }

    pub fn has_hit_type(&self) -> bool {
        self.hit_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hit_type(&mut self, v: i32) {
        self.hit_type = ::std::option::Option::Some(v);
    }

    // optional int32 weapon_type = 4;

    pub fn weapon_type(&self) -> i32 {
        self.weapon_type.unwrap_or(0)
    }

    pub fn clear_weapon_type(&mut self) {
        self.weapon_type = ::std::option::Option::None;
    }

    pub fn has_weapon_type(&self) -> bool {
        self.weapon_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weapon_type(&mut self, v: i32) {
        self.weapon_type = ::std::option::Option::Some(v);
    }

    // optional float distance_to_hurt_target = 5;

    pub fn distance_to_hurt_target(&self) -> f32 {
        self.distance_to_hurt_target.unwrap_or(0.)
    }

    pub fn clear_distance_to_hurt_target(&mut self) {
        self.distance_to_hurt_target = ::std::option::Option::None;
    }

    pub fn has_distance_to_hurt_target(&self) -> bool {
        self.distance_to_hurt_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance_to_hurt_target(&mut self, v: f32) {
        self.distance_to_hurt_target = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_player",
            |m: &VacNetShot| { &m.steamid_player },
            |m: &mut VacNetShot| { &mut m.steamid_player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round_number",
            |m: &VacNetShot| { &m.round_number },
            |m: &mut VacNetShot| { &mut m.round_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hit_type",
            |m: &VacNetShot| { &m.hit_type },
            |m: &mut VacNetShot| { &mut m.hit_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "weapon_type",
            |m: &VacNetShot| { &m.weapon_type },
            |m: &mut VacNetShot| { &mut m.weapon_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "distance_to_hurt_target",
            |m: &VacNetShot| { &m.distance_to_hurt_target },
            |m: &mut VacNetShot| { &mut m.distance_to_hurt_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "delta_yaw_window",
            |m: &VacNetShot| { &m.delta_yaw_window },
            |m: &mut VacNetShot| { &mut m.delta_yaw_window },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "delta_pitch_window",
            |m: &VacNetShot| { &m.delta_pitch_window },
            |m: &mut VacNetShot| { &mut m.delta_pitch_window },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VacNetShot>(
            "VacNetShot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VacNetShot {
    const NAME: &'static str = "VacNetShot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_player = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.round_number = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.hit_type = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.weapon_type = ::std::option::Option::Some(is.read_int32()?);
                },
                45 => {
                    self.distance_to_hurt_target = ::std::option::Option::Some(is.read_float()?);
                },
                50 => {
                    is.read_repeated_packed_float_into(&mut self.delta_yaw_window)?;
                },
                53 => {
                    self.delta_yaw_window.push(is.read_float()?);
                },
                58 => {
                    is.read_repeated_packed_float_into(&mut self.delta_pitch_window)?;
                },
                61 => {
                    self.delta_pitch_window.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_player {
            my_size += 1 + 8;
        }
        if let Some(v) = self.round_number {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.hit_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.weapon_type {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.distance_to_hurt_target {
            my_size += 1 + 4;
        }
        my_size += 5 * self.delta_yaw_window.len() as u64;
        my_size += 5 * self.delta_pitch_window.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid_player {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.round_number {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.hit_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.weapon_type {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.distance_to_hurt_target {
            os.write_float(5, v)?;
        }
        for v in &self.delta_yaw_window {
            os.write_float(6, *v)?;
        };
        for v in &self.delta_pitch_window {
            os.write_float(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VacNetShot {
        VacNetShot::new()
    }

    fn clear(&mut self) {
        self.steamid_player = ::std::option::Option::None;
        self.round_number = ::std::option::Option::None;
        self.hit_type = ::std::option::Option::None;
        self.weapon_type = ::std::option::Option::None;
        self.distance_to_hurt_target = ::std::option::Option::None;
        self.delta_yaw_window.clear();
        self.delta_pitch_window.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VacNetShot {
        static instance: VacNetShot = VacNetShot {
            steamid_player: ::std::option::Option::None,
            round_number: ::std::option::Option::None,
            hit_type: ::std::option::Option::None,
            weapon_type: ::std::option::Option::None,
            distance_to_hurt_target: ::std::option::Option::None,
            delta_yaw_window: ::std::vec::Vec::new(),
            delta_pitch_window: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VacNetShot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VacNetShot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VacNetShot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VacNetShot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHitGroup)
pub enum EHitGroup {
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Generic)
    EHG_Generic = 0,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Head)
    EHG_Head = 1,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Chest)
    EHG_Chest = 2,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Stomach)
    EHG_Stomach = 3,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_LeftArm)
    EHG_LeftArm = 4,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_RightArm)
    EHG_RightArm = 5,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_LeftLeg)
    EHG_LeftLeg = 6,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_RightLeg)
    EHG_RightLeg = 7,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Gear)
    EHG_Gear = 8,
    // @@protoc_insertion_point(enum_value:EHitGroup.EHG_Miss)
    EHG_Miss = 9,
}

impl ::protobuf::Enum for EHitGroup {
    const NAME: &'static str = "EHitGroup";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHitGroup> {
        match value {
            0 => ::std::option::Option::Some(EHitGroup::EHG_Generic),
            1 => ::std::option::Option::Some(EHitGroup::EHG_Head),
            2 => ::std::option::Option::Some(EHitGroup::EHG_Chest),
            3 => ::std::option::Option::Some(EHitGroup::EHG_Stomach),
            4 => ::std::option::Option::Some(EHitGroup::EHG_LeftArm),
            5 => ::std::option::Option::Some(EHitGroup::EHG_RightArm),
            6 => ::std::option::Option::Some(EHitGroup::EHG_LeftLeg),
            7 => ::std::option::Option::Some(EHitGroup::EHG_RightLeg),
            8 => ::std::option::Option::Some(EHitGroup::EHG_Gear),
            9 => ::std::option::Option::Some(EHitGroup::EHG_Miss),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHitGroup> {
        match str {
            "EHG_Generic" => ::std::option::Option::Some(EHitGroup::EHG_Generic),
            "EHG_Head" => ::std::option::Option::Some(EHitGroup::EHG_Head),
            "EHG_Chest" => ::std::option::Option::Some(EHitGroup::EHG_Chest),
            "EHG_Stomach" => ::std::option::Option::Some(EHitGroup::EHG_Stomach),
            "EHG_LeftArm" => ::std::option::Option::Some(EHitGroup::EHG_LeftArm),
            "EHG_RightArm" => ::std::option::Option::Some(EHitGroup::EHG_RightArm),
            "EHG_LeftLeg" => ::std::option::Option::Some(EHitGroup::EHG_LeftLeg),
            "EHG_RightLeg" => ::std::option::Option::Some(EHitGroup::EHG_RightLeg),
            "EHG_Gear" => ::std::option::Option::Some(EHitGroup::EHG_Gear),
            "EHG_Miss" => ::std::option::Option::Some(EHitGroup::EHG_Miss),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHitGroup] = &[
        EHitGroup::EHG_Generic,
        EHitGroup::EHG_Head,
        EHitGroup::EHG_Chest,
        EHitGroup::EHG_Stomach,
        EHitGroup::EHG_LeftArm,
        EHitGroup::EHG_RightArm,
        EHitGroup::EHG_LeftLeg,
        EHitGroup::EHG_RightLeg,
        EHitGroup::EHG_Gear,
        EHitGroup::EHG_Miss,
    ];
}

impl ::protobuf::EnumFull for EHitGroup {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EHitGroup").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EHitGroup {
    fn default() -> Self {
        EHitGroup::EHG_Generic
    }
}

impl EHitGroup {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EHitGroup>("EHitGroup")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETeam)
pub enum ETeam {
    // @@protoc_insertion_point(enum_value:ETeam.ET_Unknown)
    ET_Unknown = 0,
    // @@protoc_insertion_point(enum_value:ETeam.ET_Spectator)
    ET_Spectator = 1,
    // @@protoc_insertion_point(enum_value:ETeam.ET_Terrorist)
    ET_Terrorist = 2,
    // @@protoc_insertion_point(enum_value:ETeam.ET_CT)
    ET_CT = 3,
}

impl ::protobuf::Enum for ETeam {
    const NAME: &'static str = "ETeam";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETeam> {
        match value {
            0 => ::std::option::Option::Some(ETeam::ET_Unknown),
            1 => ::std::option::Option::Some(ETeam::ET_Spectator),
            2 => ::std::option::Option::Some(ETeam::ET_Terrorist),
            3 => ::std::option::Option::Some(ETeam::ET_CT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETeam> {
        match str {
            "ET_Unknown" => ::std::option::Option::Some(ETeam::ET_Unknown),
            "ET_Spectator" => ::std::option::Option::Some(ETeam::ET_Spectator),
            "ET_Terrorist" => ::std::option::Option::Some(ETeam::ET_Terrorist),
            "ET_CT" => ::std::option::Option::Some(ETeam::ET_CT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETeam] = &[
        ETeam::ET_Unknown,
        ETeam::ET_Spectator,
        ETeam::ET_Terrorist,
        ETeam::ET_CT,
    ];
}

impl ::protobuf::EnumFull for ETeam {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETeam").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ETeam {
    fn default() -> Self {
        ETeam::ET_Unknown
    }
}

impl ETeam {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETeam>("ETeam")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EWeaponType)
pub enum EWeaponType {
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Knife)
    EWT_Knife = 0,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Pistol)
    EWT_Pistol = 1,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_SubMachineGun)
    EWT_SubMachineGun = 2,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Rifle)
    EWT_Rifle = 3,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Shotgun)
    EWT_Shotgun = 4,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_SniperRifle)
    EWT_SniperRifle = 5,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_MachineGun)
    EWT_MachineGun = 6,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_C4)
    EWT_C4 = 7,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Grenade)
    EWT_Grenade = 8,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Equipment)
    EWT_Equipment = 9,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_StackableItem)
    EWT_StackableItem = 10,
    // @@protoc_insertion_point(enum_value:EWeaponType.EWT_Unknown)
    EWT_Unknown = 11,
}

impl ::protobuf::Enum for EWeaponType {
    const NAME: &'static str = "EWeaponType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EWeaponType> {
        match value {
            0 => ::std::option::Option::Some(EWeaponType::EWT_Knife),
            1 => ::std::option::Option::Some(EWeaponType::EWT_Pistol),
            2 => ::std::option::Option::Some(EWeaponType::EWT_SubMachineGun),
            3 => ::std::option::Option::Some(EWeaponType::EWT_Rifle),
            4 => ::std::option::Option::Some(EWeaponType::EWT_Shotgun),
            5 => ::std::option::Option::Some(EWeaponType::EWT_SniperRifle),
            6 => ::std::option::Option::Some(EWeaponType::EWT_MachineGun),
            7 => ::std::option::Option::Some(EWeaponType::EWT_C4),
            8 => ::std::option::Option::Some(EWeaponType::EWT_Grenade),
            9 => ::std::option::Option::Some(EWeaponType::EWT_Equipment),
            10 => ::std::option::Option::Some(EWeaponType::EWT_StackableItem),
            11 => ::std::option::Option::Some(EWeaponType::EWT_Unknown),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EWeaponType> {
        match str {
            "EWT_Knife" => ::std::option::Option::Some(EWeaponType::EWT_Knife),
            "EWT_Pistol" => ::std::option::Option::Some(EWeaponType::EWT_Pistol),
            "EWT_SubMachineGun" => ::std::option::Option::Some(EWeaponType::EWT_SubMachineGun),
            "EWT_Rifle" => ::std::option::Option::Some(EWeaponType::EWT_Rifle),
            "EWT_Shotgun" => ::std::option::Option::Some(EWeaponType::EWT_Shotgun),
            "EWT_SniperRifle" => ::std::option::Option::Some(EWeaponType::EWT_SniperRifle),
            "EWT_MachineGun" => ::std::option::Option::Some(EWeaponType::EWT_MachineGun),
            "EWT_C4" => ::std::option::Option::Some(EWeaponType::EWT_C4),
            "EWT_Grenade" => ::std::option::Option::Some(EWeaponType::EWT_Grenade),
            "EWT_Equipment" => ::std::option::Option::Some(EWeaponType::EWT_Equipment),
            "EWT_StackableItem" => ::std::option::Option::Some(EWeaponType::EWT_StackableItem),
            "EWT_Unknown" => ::std::option::Option::Some(EWeaponType::EWT_Unknown),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EWeaponType] = &[
        EWeaponType::EWT_Knife,
        EWeaponType::EWT_Pistol,
        EWeaponType::EWT_SubMachineGun,
        EWeaponType::EWT_Rifle,
        EWeaponType::EWT_Shotgun,
        EWeaponType::EWT_SniperRifle,
        EWeaponType::EWT_MachineGun,
        EWeaponType::EWT_C4,
        EWeaponType::EWT_Grenade,
        EWeaponType::EWT_Equipment,
        EWeaponType::EWT_StackableItem,
        EWeaponType::EWT_Unknown,
    ];
}

impl ::protobuf::EnumFull for EWeaponType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EWeaponType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EWeaponType {
    fn default() -> Self {
        EWeaponType::EWT_Knife
    }
}

impl EWeaponType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EWeaponType>("EWeaponType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rfatdemo.proto\x1a\x16networkbasetypes.proto\"o\n\x06MLDict\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x1d\n\nval_string\x18\x02\x20\x01\
    (\tR\tvalString\x12\x17\n\x07val_int\x18\x03\x20\x01(\x05R\x06valInt\x12\
    \x1b\n\tval_float\x18\x04\x20\x01(\x02R\x08valFloat\"E\n\x07MLEvent\x12\
    \x1d\n\nevent_name\x18\x01\x20\x01(\tR\teventName\x12\x1b\n\x04data\x18\
    \x02\x20\x03(\x0b2\x07.MLDictR\x04data\"\x8b\x01\n\x0cMLMatchState\x12\
    \x1b\n\tgame_mode\x18\x01\x20\x01(\tR\x08gameMode\x12\x14\n\x05phase\x18\
    \x02\x20\x01(\tR\x05phase\x12\x14\n\x05round\x18\x03\x20\x01(\x05R\x05ro\
    und\x12\x19\n\x08score_ct\x18\x04\x20\x01(\x05R\x07scoreCt\x12\x17\n\x07\
    score_t\x18\x05\x20\x01(\x05R\x06scoreT\"r\n\x0cMLRoundState\x12\x14\n\
    \x05phase\x18\x01\x20\x01(\tR\x05phase\x12-\n\x08win_team\x18\x02\x20\
    \x01(\x0e2\x06.ETeam:\nET_UnknownR\x07winTeam\x12\x1d\n\nbomb_state\x18\
    \x03\x20\x01(\tR\tbombState\"\x83\x02\n\rMLWeaponState\x12\x14\n\x05inde\
    x\x18\x01\x20\x01(\x05R\x05index\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12+\n\x04type\x18\x03\x20\x01(\x0e2\x0c.EWeaponType:\tEWT_Knif\
    eR\x04type\x12\x1b\n\tammo_clip\x18\x04\x20\x01(\x05R\x08ammoClip\x12\"\
    \n\rammo_clip_max\x18\x05\x20\x01(\x05R\x0bammoClipMax\x12!\n\x0cammo_re\
    serve\x18\x06\x20\x01(\x05R\x0bammoReserve\x12\x14\n\x05state\x18\x07\
    \x20\x01(\tR\x05state\x12!\n\x0crecoil_index\x18\x08\x20\x01(\x02R\x0bre\
    coilIndex\"\xf2\x04\n\rMLPlayerState\x12\x1d\n\naccount_id\x18\x01\x20\
    \x01(\x05R\taccountId\x12#\n\x0bplayer_slot\x18\x02\x20\x01(\x05:\x02-1R\
    \nplayerSlot\x12\x1a\n\x08entindex\x18\x03\x20\x01(\x05R\x08entindex\x12\
    \x12\n\x04name\x18\x04\x20\x01(\tR\x04name\x12\x12\n\x04clan\x18\x05\x20\
    \x01(\tR\x04clan\x12&\n\x04team\x18\x06\x20\x01(\x0e2\x06.ETeam:\nET_Unk\
    nownR\x04team\x12#\n\x06abspos\x18\x07\x20\x01(\x0b2\x0b.CMsgVectorR\x06\
    abspos\x12'\n\x08eyeangle\x18\x08\x20\x01(\x0b2\x0b.CMsgQAngleR\x08eyean\
    gle\x12.\n\x0ceyeangle_fwd\x18\t\x20\x01(\x0b2\x0b.CMsgVectorR\x0beyeang\
    leFwd\x12\x16\n\x06health\x18\n\x20\x01(\x05R\x06health\x12\x14\n\x05arm\
    or\x18\x0b\x20\x01(\x05R\x05armor\x12\x18\n\x07flashed\x18\x0c\x20\x01(\
    \x02R\x07flashed\x12\x16\n\x06smoked\x18\r\x20\x01(\x02R\x06smoked\x12\
    \x14\n\x05money\x18\x0e\x20\x01(\x05R\x05money\x12\x1f\n\x0bround_kills\
    \x18\x0f\x20\x01(\x05R\nroundKills\x12!\n\x0cround_killhs\x18\x10\x20\
    \x01(\x05R\x0broundKillhs\x12\x18\n\x07burning\x18\x11\x20\x01(\x02R\x07\
    burning\x12\x16\n\x06helmet\x18\x12\x20\x01(\x08R\x06helmet\x12\x1d\n\nd\
    efuse_kit\x18\x13\x20\x01(\x08R\tdefuseKit\x12(\n\x07weapons\x18\x14\x20\
    \x03(\x0b2\x0e.MLWeaponStateR\x07weapons\"\x81\x01\n\x0bMLGameState\x12#\
    \n\x05match\x18\x01\x20\x01(\x0b2\r.MLMatchStateR\x05match\x12#\n\x05rou\
    nd\x18\x02\x20\x01(\x0b2\r.MLRoundStateR\x05round\x12(\n\x07players\x18\
    \x03\x20\x03(\x0b2\x0e.MLPlayerStateR\x07players\"\x87\x01\n\x0cMLDemoHe\
    ader\x12\x19\n\x08map_name\x18\x01\x20\x01(\tR\x07mapName\x12\x1b\n\ttic\
    k_rate\x18\x02\x20\x01(\x05R\x08tickRate\x12\x18\n\x07version\x18\x03\
    \x20\x01(\rR\x07version\x12%\n\x0esteam_universe\x18\x04\x20\x01(\rR\rst\
    eamUniverse\"m\n\x06MLTick\x12\x1d\n\ntick_count\x18\x01\x20\x01(\x05R\t\
    tickCount\x12\"\n\x05state\x18\x02\x20\x01(\x0b2\x0c.MLGameStateR\x05sta\
    te\x12\x20\n\x06events\x18\x03\x20\x03(\x0b2\x08.MLEventR\x06events\"\
    \xa1\x02\n\nVacNetShot\x12%\n\x0esteamid_player\x18\x01\x20\x01(\x06R\rs\
    teamidPlayer\x12!\n\x0cround_number\x18\x02\x20\x01(\x05R\x0broundNumber\
    \x12\x19\n\x08hit_type\x18\x03\x20\x01(\x05R\x07hitType\x12\x1f\n\x0bwea\
    pon_type\x18\x04\x20\x01(\x05R\nweaponType\x125\n\x17distance_to_hurt_ta\
    rget\x18\x05\x20\x01(\x02R\x14distanceToHurtTarget\x12(\n\x10delta_yaw_w\
    indow\x18\x06\x20\x03(\x02R\x0edeltaYawWindow\x12,\n\x12delta_pitch_wind\
    ow\x18\x07\x20\x03(\x02R\x10deltaPitchWindow*\xac\x01\n\tEHitGroup\x12\
    \x0f\n\x0bEHG_Generic\x10\0\x12\x0c\n\x08EHG_Head\x10\x01\x12\r\n\tEHG_C\
    hest\x10\x02\x12\x0f\n\x0bEHG_Stomach\x10\x03\x12\x0f\n\x0bEHG_LeftArm\
    \x10\x04\x12\x10\n\x0cEHG_RightArm\x10\x05\x12\x0f\n\x0bEHG_LeftLeg\x10\
    \x06\x12\x10\n\x0cEHG_RightLeg\x10\x07\x12\x0c\n\x08EHG_Gear\x10\x08\x12\
    \x0c\n\x08EHG_Miss\x10\t*F\n\x05ETeam\x12\x0e\n\nET_Unknown\x10\0\x12\
    \x10\n\x0cET_Spectator\x10\x01\x12\x10\n\x0cET_Terrorist\x10\x02\x12\t\n\
    \x05ET_CT\x10\x03*\xe4\x01\n\x0bEWeaponType\x12\r\n\tEWT_Knife\x10\0\x12\
    \x0e\n\nEWT_Pistol\x10\x01\x12\x15\n\x11EWT_SubMachineGun\x10\x02\x12\r\
    \n\tEWT_Rifle\x10\x03\x12\x0f\n\x0bEWT_Shotgun\x10\x04\x12\x13\n\x0fEWT_\
    SniperRifle\x10\x05\x12\x12\n\x0eEWT_MachineGun\x10\x06\x12\n\n\x06EWT_C\
    4\x10\x07\x12\x0f\n\x0bEWT_Grenade\x10\x08\x12\x11\n\rEWT_Equipment\x10\
    \t\x12\x15\n\x11EWT_StackableItem\x10\n\x12\x0f\n\x0bEWT_Unknown\x10\x0b\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::networkbasetypes::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(10);
            messages.push(MLDict::generated_message_descriptor_data());
            messages.push(MLEvent::generated_message_descriptor_data());
            messages.push(MLMatchState::generated_message_descriptor_data());
            messages.push(MLRoundState::generated_message_descriptor_data());
            messages.push(MLWeaponState::generated_message_descriptor_data());
            messages.push(MLPlayerState::generated_message_descriptor_data());
            messages.push(MLGameState::generated_message_descriptor_data());
            messages.push(MLDemoHeader::generated_message_descriptor_data());
            messages.push(MLTick::generated_message_descriptor_data());
            messages.push(VacNetShot::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(EHitGroup::generated_enum_descriptor_data());
            enums.push(ETeam::generated_enum_descriptor_data());
            enums.push(EWeaponType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
