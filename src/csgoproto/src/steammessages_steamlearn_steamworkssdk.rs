// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_steamlearn.steamworkssdk.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgSteamLearnDataSourceDescObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnDataSourceDescObject {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSourceDescObject.elements)
    pub elements: ::std::vec::Vec<CMsgSteamLearnDataSourceDescElement>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnDataSourceDescObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnDataSourceDescObject {
    fn default() -> &'a CMsgSteamLearnDataSourceDescObject {
        <CMsgSteamLearnDataSourceDescObject as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnDataSourceDescObject {
    pub fn new() -> CMsgSteamLearnDataSourceDescObject {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "elements",
            |m: &CMsgSteamLearnDataSourceDescObject| { &m.elements },
            |m: &mut CMsgSteamLearnDataSourceDescObject| { &mut m.elements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnDataSourceDescObject>(
            "CMsgSteamLearnDataSourceDescObject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnDataSourceDescObject {
    const NAME: &'static str = "CMsgSteamLearnDataSourceDescObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.elements.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.elements {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnDataSourceDescObject {
        CMsgSteamLearnDataSourceDescObject::new()
    }

    fn clear(&mut self) {
        self.elements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnDataSourceDescObject {
        static instance: CMsgSteamLearnDataSourceDescObject = CMsgSteamLearnDataSourceDescObject {
            elements: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnDataSourceDescObject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnDataSourceDescObject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnDataSourceDescObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnDataSourceDescObject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearnDataSourceDescElement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnDataSourceDescElement {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSourceDescElement.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSourceDescElement.data_type)
    pub data_type: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamLearnDataType>>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSourceDescElement.object)
    pub object: ::protobuf::MessageField<CMsgSteamLearnDataSourceDescObject>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSourceDescElement.count)
    pub count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnDataSourceDescElement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnDataSourceDescElement {
    fn default() -> &'a CMsgSteamLearnDataSourceDescElement {
        <CMsgSteamLearnDataSourceDescElement as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnDataSourceDescElement {
    pub fn new() -> CMsgSteamLearnDataSourceDescElement {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ESteamLearnDataType data_type = 2;

    pub fn data_type(&self) -> ESteamLearnDataType {
        match self.data_type {
            Some(e) => e.enum_value_or(ESteamLearnDataType::STEAMLEARN_DATATYPE_INVALID),
            None => ESteamLearnDataType::STEAMLEARN_DATATYPE_INVALID,
        }
    }

    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: ESteamLearnDataType) {
        self.data_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 count = 4;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgSteamLearnDataSourceDescElement| { &m.name },
            |m: &mut CMsgSteamLearnDataSourceDescElement| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_type",
            |m: &CMsgSteamLearnDataSourceDescElement| { &m.data_type },
            |m: &mut CMsgSteamLearnDataSourceDescElement| { &mut m.data_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearnDataSourceDescObject>(
            "object",
            |m: &CMsgSteamLearnDataSourceDescElement| { &m.object },
            |m: &mut CMsgSteamLearnDataSourceDescElement| { &mut m.object },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CMsgSteamLearnDataSourceDescElement| { &m.count },
            |m: &mut CMsgSteamLearnDataSourceDescElement| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnDataSourceDescElement>(
            "CMsgSteamLearnDataSourceDescElement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnDataSourceDescElement {
    const NAME: &'static str = "CMsgSteamLearnDataSourceDescElement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.data_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.object)?;
                },
                32 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.object.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.data_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.object.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnDataSourceDescElement {
        CMsgSteamLearnDataSourceDescElement::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.data_type = ::std::option::Option::None;
        self.object.clear();
        self.count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnDataSourceDescElement {
        static instance: CMsgSteamLearnDataSourceDescElement = CMsgSteamLearnDataSourceDescElement {
            name: ::std::option::Option::None,
            data_type: ::std::option::Option::None,
            object: ::protobuf::MessageField::none(),
            count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnDataSourceDescElement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnDataSourceDescElement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnDataSourceDescElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnDataSourceDescElement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearnDataSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnDataSource {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSource.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSource.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSource.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSource.source_description)
    pub source_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSource.structure)
    pub structure: ::protobuf::MessageField<CMsgSteamLearnDataSourceDescObject>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSource.structure_crc)
    pub structure_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataSource.cache_duration_seconds)
    pub cache_duration_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnDataSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnDataSource {
    fn default() -> &'a CMsgSteamLearnDataSource {
        <CMsgSteamLearnDataSource as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnDataSource {
    pub fn new() -> CMsgSteamLearnDataSource {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 version = 3;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional string source_description = 4;

    pub fn source_description(&self) -> &str {
        match self.source_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_source_description(&mut self) {
        self.source_description = ::std::option::Option::None;
    }

    pub fn has_source_description(&self) -> bool {
        self.source_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_description(&mut self, v: ::std::string::String) {
        self.source_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_description(&mut self) -> &mut ::std::string::String {
        if self.source_description.is_none() {
            self.source_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.source_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_description(&mut self) -> ::std::string::String {
        self.source_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 structure_crc = 6;

    pub fn structure_crc(&self) -> u32 {
        self.structure_crc.unwrap_or(0)
    }

    pub fn clear_structure_crc(&mut self) {
        self.structure_crc = ::std::option::Option::None;
    }

    pub fn has_structure_crc(&self) -> bool {
        self.structure_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_structure_crc(&mut self, v: u32) {
        self.structure_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 cache_duration_seconds = 7;

    pub fn cache_duration_seconds(&self) -> u32 {
        self.cache_duration_seconds.unwrap_or(0)
    }

    pub fn clear_cache_duration_seconds(&mut self) {
        self.cache_duration_seconds = ::std::option::Option::None;
    }

    pub fn has_cache_duration_seconds(&self) -> bool {
        self.cache_duration_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_duration_seconds(&mut self, v: u32) {
        self.cache_duration_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgSteamLearnDataSource| { &m.id },
            |m: &mut CMsgSteamLearnDataSource| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgSteamLearnDataSource| { &m.name },
            |m: &mut CMsgSteamLearnDataSource| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSteamLearnDataSource| { &m.version },
            |m: &mut CMsgSteamLearnDataSource| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_description",
            |m: &CMsgSteamLearnDataSource| { &m.source_description },
            |m: &mut CMsgSteamLearnDataSource| { &mut m.source_description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearnDataSourceDescObject>(
            "structure",
            |m: &CMsgSteamLearnDataSource| { &m.structure },
            |m: &mut CMsgSteamLearnDataSource| { &mut m.structure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "structure_crc",
            |m: &CMsgSteamLearnDataSource| { &m.structure_crc },
            |m: &mut CMsgSteamLearnDataSource| { &mut m.structure_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cache_duration_seconds",
            |m: &CMsgSteamLearnDataSource| { &m.cache_duration_seconds },
            |m: &mut CMsgSteamLearnDataSource| { &mut m.cache_duration_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnDataSource>(
            "CMsgSteamLearnDataSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnDataSource {
    const NAME: &'static str = "CMsgSteamLearnDataSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.source_description = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.structure)?;
                },
                48 => {
                    self.structure_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.cache_duration_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.source_description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.structure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.structure_crc {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.cache_duration_seconds {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.source_description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.structure.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.structure_crc {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.cache_duration_seconds {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnDataSource {
        CMsgSteamLearnDataSource::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.source_description = ::std::option::Option::None;
        self.structure.clear();
        self.structure_crc = ::std::option::Option::None;
        self.cache_duration_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnDataSource {
        static instance: CMsgSteamLearnDataSource = CMsgSteamLearnDataSource {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            version: ::std::option::Option::None,
            source_description: ::std::option::Option::None,
            structure: ::protobuf::MessageField::none(),
            structure_crc: ::std::option::Option::None,
            cache_duration_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnDataSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnDataSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnDataSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnDataSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearnDataObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnDataObject {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnDataObject.elements)
    pub elements: ::std::vec::Vec<CMsgSteamLearnDataElement>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnDataObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnDataObject {
    fn default() -> &'a CMsgSteamLearnDataObject {
        <CMsgSteamLearnDataObject as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnDataObject {
    pub fn new() -> CMsgSteamLearnDataObject {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "elements",
            |m: &CMsgSteamLearnDataObject| { &m.elements },
            |m: &mut CMsgSteamLearnDataObject| { &mut m.elements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnDataObject>(
            "CMsgSteamLearnDataObject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnDataObject {
    const NAME: &'static str = "CMsgSteamLearnDataObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.elements.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.elements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.elements {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnDataObject {
        CMsgSteamLearnDataObject::new()
    }

    fn clear(&mut self) {
        self.elements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnDataObject {
        static instance: CMsgSteamLearnDataObject = CMsgSteamLearnDataObject {
            elements: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnDataObject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnDataObject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnDataObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnDataObject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearnDataElement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnDataElement {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnDataElement.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataElement.data_int32s)
    pub data_int32s: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataElement.data_floats)
    pub data_floats: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataElement.data_bools)
    pub data_bools: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataElement.data_strings)
    pub data_strings: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearnDataElement.data_objects)
    pub data_objects: ::std::vec::Vec<CMsgSteamLearnDataObject>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnDataElement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnDataElement {
    fn default() -> &'a CMsgSteamLearnDataElement {
        <CMsgSteamLearnDataElement as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnDataElement {
    pub fn new() -> CMsgSteamLearnDataElement {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgSteamLearnDataElement| { &m.name },
            |m: &mut CMsgSteamLearnDataElement| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_int32s",
            |m: &CMsgSteamLearnDataElement| { &m.data_int32s },
            |m: &mut CMsgSteamLearnDataElement| { &mut m.data_int32s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_floats",
            |m: &CMsgSteamLearnDataElement| { &m.data_floats },
            |m: &mut CMsgSteamLearnDataElement| { &mut m.data_floats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_bools",
            |m: &CMsgSteamLearnDataElement| { &m.data_bools },
            |m: &mut CMsgSteamLearnDataElement| { &mut m.data_bools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_strings",
            |m: &CMsgSteamLearnDataElement| { &m.data_strings },
            |m: &mut CMsgSteamLearnDataElement| { &mut m.data_strings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_objects",
            |m: &CMsgSteamLearnDataElement| { &m.data_objects },
            |m: &mut CMsgSteamLearnDataElement| { &mut m.data_objects },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnDataElement>(
            "CMsgSteamLearnDataElement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnDataElement {
    const NAME: &'static str = "CMsgSteamLearnDataElement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    is.read_repeated_packed_int32_into(&mut self.data_int32s)?;
                },
                160 => {
                    self.data_int32s.push(is.read_int32()?);
                },
                170 => {
                    is.read_repeated_packed_float_into(&mut self.data_floats)?;
                },
                173 => {
                    self.data_floats.push(is.read_float()?);
                },
                178 => {
                    is.read_repeated_packed_bool_into(&mut self.data_bools)?;
                },
                176 => {
                    self.data_bools.push(is.read_bool()?);
                },
                186 => {
                    self.data_strings.push(is.read_string()?);
                },
                194 => {
                    self.data_objects.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.data_int32s {
            my_size += ::protobuf::rt::int32_size(20, *value);
        };
        my_size += 6 * self.data_floats.len() as u64;
        my_size += 3 * self.data_bools.len() as u64;
        for value in &self.data_strings {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        for value in &self.data_objects {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.data_int32s {
            os.write_int32(20, *v)?;
        };
        for v in &self.data_floats {
            os.write_float(21, *v)?;
        };
        for v in &self.data_bools {
            os.write_bool(22, *v)?;
        };
        for v in &self.data_strings {
            os.write_string(23, &v)?;
        };
        for v in &self.data_objects {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnDataElement {
        CMsgSteamLearnDataElement::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.data_int32s.clear();
        self.data_floats.clear();
        self.data_bools.clear();
        self.data_strings.clear();
        self.data_objects.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnDataElement {
        static instance: CMsgSteamLearnDataElement = CMsgSteamLearnDataElement {
            name: ::std::option::Option::None,
            data_int32s: ::std::vec::Vec::new(),
            data_floats: ::std::vec::Vec::new(),
            data_bools: ::std::vec::Vec::new(),
            data_strings: ::std::vec::Vec::new(),
            data_objects: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnDataElement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnDataElement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnDataElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnDataElement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearnData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnData {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnData.data_source_id)
    pub data_source_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnData.keys)
    pub keys: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgSteamLearnData.data_object)
    pub data_object: ::protobuf::MessageField<CMsgSteamLearnDataObject>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnData {
    fn default() -> &'a CMsgSteamLearnData {
        <CMsgSteamLearnData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnData {
    pub fn new() -> CMsgSteamLearnData {
        ::std::default::Default::default()
    }

    // optional uint32 data_source_id = 1;

    pub fn data_source_id(&self) -> u32 {
        self.data_source_id.unwrap_or(0)
    }

    pub fn clear_data_source_id(&mut self) {
        self.data_source_id = ::std::option::Option::None;
    }

    pub fn has_data_source_id(&self) -> bool {
        self.data_source_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_source_id(&mut self, v: u32) {
        self.data_source_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_source_id",
            |m: &CMsgSteamLearnData| { &m.data_source_id },
            |m: &mut CMsgSteamLearnData| { &mut m.data_source_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &CMsgSteamLearnData| { &m.keys },
            |m: &mut CMsgSteamLearnData| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearnDataObject>(
            "data_object",
            |m: &CMsgSteamLearnData| { &m.data_object },
            |m: &mut CMsgSteamLearnData| { &mut m.data_object },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnData>(
            "CMsgSteamLearnData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnData {
    const NAME: &'static str = "CMsgSteamLearnData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.data_source_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.keys)?;
                },
                16 => {
                    self.keys.push(is.read_uint64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data_object)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data_source_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        if let Some(v) = self.data_object.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data_source_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.keys {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.data_object.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnData {
        CMsgSteamLearnData::new()
    }

    fn clear(&mut self) {
        self.data_source_id = ::std::option::Option::None;
        self.keys.clear();
        self.data_object.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnData {
        static instance: CMsgSteamLearnData = CMsgSteamLearnData {
            data_source_id: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            data_object: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearnDataList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnDataList {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnDataList.data)
    pub data: ::std::vec::Vec<CMsgSteamLearnData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnDataList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnDataList {
    fn default() -> &'a CMsgSteamLearnDataList {
        <CMsgSteamLearnDataList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnDataList {
    pub fn new() -> CMsgSteamLearnDataList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &CMsgSteamLearnDataList| { &m.data },
            |m: &mut CMsgSteamLearnDataList| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnDataList>(
            "CMsgSteamLearnDataList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnDataList {
    const NAME: &'static str = "CMsgSteamLearnDataList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnDataList {
        CMsgSteamLearnDataList::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnDataList {
        static instance: CMsgSteamLearnDataList = CMsgSteamLearnDataList {
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnDataList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnDataList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnDataList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnDataList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_AccessData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_AccessData {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_AccessData.publisher_id)
    pub publisher_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_AccessData.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_AccessData.random_value)
    pub random_value: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_AccessData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_AccessData {
    fn default() -> &'a CMsgSteamLearn_AccessData {
        <CMsgSteamLearn_AccessData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_AccessData {
    pub fn new() -> CMsgSteamLearn_AccessData {
        ::std::default::Default::default()
    }

    // optional uint32 publisher_id = 1;

    pub fn publisher_id(&self) -> u32 {
        self.publisher_id.unwrap_or(0)
    }

    pub fn clear_publisher_id(&mut self) {
        self.publisher_id = ::std::option::Option::None;
    }

    pub fn has_publisher_id(&self) -> bool {
        self.publisher_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publisher_id(&mut self, v: u32) {
        self.publisher_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 random_value = 3;

    pub fn random_value(&self) -> u64 {
        self.random_value.unwrap_or(0)
    }

    pub fn clear_random_value(&mut self) {
        self.random_value = ::std::option::Option::None;
    }

    pub fn has_random_value(&self) -> bool {
        self.random_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random_value(&mut self, v: u64) {
        self.random_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "publisher_id",
            |m: &CMsgSteamLearn_AccessData| { &m.publisher_id },
            |m: &mut CMsgSteamLearn_AccessData| { &mut m.publisher_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgSteamLearn_AccessData| { &m.timestamp },
            |m: &mut CMsgSteamLearn_AccessData| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "random_value",
            |m: &CMsgSteamLearn_AccessData| { &m.random_value },
            |m: &mut CMsgSteamLearn_AccessData| { &mut m.random_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_AccessData>(
            "CMsgSteamLearn_AccessData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_AccessData {
    const NAME: &'static str = "CMsgSteamLearn_AccessData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.publisher_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.random_value = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.publisher_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.random_value {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.publisher_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.random_value {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_AccessData {
        CMsgSteamLearn_AccessData::new()
    }

    fn clear(&mut self) {
        self.publisher_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.random_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_AccessData {
        static instance: CMsgSteamLearn_AccessData = CMsgSteamLearn_AccessData {
            publisher_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            random_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_AccessData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_AccessData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_AccessData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_AccessData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_RegisterDataSource_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_RegisterDataSource_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_RegisterDataSource_Request.access_token)
    pub access_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_RegisterDataSource_Request.access_data)
    pub access_data: ::protobuf::MessageField<CMsgSteamLearn_AccessData>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_RegisterDataSource_Request.data_source)
    pub data_source: ::protobuf::MessageField<CMsgSteamLearnDataSource>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_RegisterDataSource_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_RegisterDataSource_Request {
    fn default() -> &'a CMsgSteamLearn_RegisterDataSource_Request {
        <CMsgSteamLearn_RegisterDataSource_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_RegisterDataSource_Request {
    pub fn new() -> CMsgSteamLearn_RegisterDataSource_Request {
        ::std::default::Default::default()
    }

    // optional string access_token = 1;

    pub fn access_token(&self) -> &str {
        match self.access_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: ::std::string::String) {
        self.access_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_token(&mut self) -> &mut ::std::string::String {
        if self.access_token.is_none() {
            self.access_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.access_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_token(&mut self) -> ::std::string::String {
        self.access_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "access_token",
            |m: &CMsgSteamLearn_RegisterDataSource_Request| { &m.access_token },
            |m: &mut CMsgSteamLearn_RegisterDataSource_Request| { &mut m.access_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearn_AccessData>(
            "access_data",
            |m: &CMsgSteamLearn_RegisterDataSource_Request| { &m.access_data },
            |m: &mut CMsgSteamLearn_RegisterDataSource_Request| { &mut m.access_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearnDataSource>(
            "data_source",
            |m: &CMsgSteamLearn_RegisterDataSource_Request| { &m.data_source },
            |m: &mut CMsgSteamLearn_RegisterDataSource_Request| { &mut m.data_source },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_RegisterDataSource_Request>(
            "CMsgSteamLearn_RegisterDataSource_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_RegisterDataSource_Request {
    const NAME: &'static str = "CMsgSteamLearn_RegisterDataSource_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.access_token = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.access_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data_source)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.access_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.access_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.access_token.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.access_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.data_source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_RegisterDataSource_Request {
        CMsgSteamLearn_RegisterDataSource_Request::new()
    }

    fn clear(&mut self) {
        self.access_token = ::std::option::Option::None;
        self.access_data.clear();
        self.data_source.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_RegisterDataSource_Request {
        static instance: CMsgSteamLearn_RegisterDataSource_Request = CMsgSteamLearn_RegisterDataSource_Request {
            access_token: ::std::option::Option::None,
            access_data: ::protobuf::MessageField::none(),
            data_source: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_RegisterDataSource_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_RegisterDataSource_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_RegisterDataSource_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_RegisterDataSource_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_RegisterDataSource_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_RegisterDataSource_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_RegisterDataSource_Response.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<ESteammLearnRegisterDataSourceResult>>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_RegisterDataSource_Response.data_source)
    pub data_source: ::protobuf::MessageField<CMsgSteamLearnDataSource>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_RegisterDataSource_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_RegisterDataSource_Response {
    fn default() -> &'a CMsgSteamLearn_RegisterDataSource_Response {
        <CMsgSteamLearn_RegisterDataSource_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_RegisterDataSource_Response {
    pub fn new() -> CMsgSteamLearn_RegisterDataSource_Response {
        ::std::default::Default::default()
    }

    // optional .ESteammLearnRegisterDataSourceResult result = 1;

    pub fn result(&self) -> ESteammLearnRegisterDataSourceResult {
        match self.result {
            Some(e) => e.enum_value_or(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR),
            None => ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ESteammLearnRegisterDataSourceResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgSteamLearn_RegisterDataSource_Response| { &m.result },
            |m: &mut CMsgSteamLearn_RegisterDataSource_Response| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearnDataSource>(
            "data_source",
            |m: &CMsgSteamLearn_RegisterDataSource_Response| { &m.data_source },
            |m: &mut CMsgSteamLearn_RegisterDataSource_Response| { &mut m.data_source },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_RegisterDataSource_Response>(
            "CMsgSteamLearn_RegisterDataSource_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_RegisterDataSource_Response {
    const NAME: &'static str = "CMsgSteamLearn_RegisterDataSource_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data_source)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.data_source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.data_source.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_RegisterDataSource_Response {
        CMsgSteamLearn_RegisterDataSource_Response::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.data_source.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_RegisterDataSource_Response {
        static instance: CMsgSteamLearn_RegisterDataSource_Response = CMsgSteamLearn_RegisterDataSource_Response {
            result: ::std::option::Option::None,
            data_source: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_RegisterDataSource_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_RegisterDataSource_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_RegisterDataSource_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_RegisterDataSource_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_CacheData_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_CacheData_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_CacheData_Request.access_token)
    pub access_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_CacheData_Request.access_data)
    pub access_data: ::protobuf::MessageField<CMsgSteamLearn_AccessData>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_CacheData_Request.data)
    pub data: ::protobuf::MessageField<CMsgSteamLearnData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_CacheData_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_CacheData_Request {
    fn default() -> &'a CMsgSteamLearn_CacheData_Request {
        <CMsgSteamLearn_CacheData_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_CacheData_Request {
    pub fn new() -> CMsgSteamLearn_CacheData_Request {
        ::std::default::Default::default()
    }

    // optional string access_token = 1;

    pub fn access_token(&self) -> &str {
        match self.access_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: ::std::string::String) {
        self.access_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_token(&mut self) -> &mut ::std::string::String {
        if self.access_token.is_none() {
            self.access_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.access_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_token(&mut self) -> ::std::string::String {
        self.access_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "access_token",
            |m: &CMsgSteamLearn_CacheData_Request| { &m.access_token },
            |m: &mut CMsgSteamLearn_CacheData_Request| { &mut m.access_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearn_AccessData>(
            "access_data",
            |m: &CMsgSteamLearn_CacheData_Request| { &m.access_data },
            |m: &mut CMsgSteamLearn_CacheData_Request| { &mut m.access_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearnData>(
            "data",
            |m: &CMsgSteamLearn_CacheData_Request| { &m.data },
            |m: &mut CMsgSteamLearn_CacheData_Request| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_CacheData_Request>(
            "CMsgSteamLearn_CacheData_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_CacheData_Request {
    const NAME: &'static str = "CMsgSteamLearn_CacheData_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.access_token = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.access_data)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.access_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.access_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.access_token.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.access_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_CacheData_Request {
        CMsgSteamLearn_CacheData_Request::new()
    }

    fn clear(&mut self) {
        self.access_token = ::std::option::Option::None;
        self.access_data.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_CacheData_Request {
        static instance: CMsgSteamLearn_CacheData_Request = CMsgSteamLearn_CacheData_Request {
            access_token: ::std::option::Option::None,
            access_data: ::protobuf::MessageField::none(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_CacheData_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_CacheData_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_CacheData_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_CacheData_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_CacheData_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_CacheData_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_CacheData_Response.cache_data_result)
    pub cache_data_result: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamLearnCacheDataResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_CacheData_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_CacheData_Response {
    fn default() -> &'a CMsgSteamLearn_CacheData_Response {
        <CMsgSteamLearn_CacheData_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_CacheData_Response {
    pub fn new() -> CMsgSteamLearn_CacheData_Response {
        ::std::default::Default::default()
    }

    // optional .ESteamLearnCacheDataResult cache_data_result = 1;

    pub fn cache_data_result(&self) -> ESteamLearnCacheDataResult {
        match self.cache_data_result {
            Some(e) => e.enum_value_or(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR),
            None => ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR,
        }
    }

    pub fn clear_cache_data_result(&mut self) {
        self.cache_data_result = ::std::option::Option::None;
    }

    pub fn has_cache_data_result(&self) -> bool {
        self.cache_data_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_data_result(&mut self, v: ESteamLearnCacheDataResult) {
        self.cache_data_result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cache_data_result",
            |m: &CMsgSteamLearn_CacheData_Response| { &m.cache_data_result },
            |m: &mut CMsgSteamLearn_CacheData_Response| { &mut m.cache_data_result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_CacheData_Response>(
            "CMsgSteamLearn_CacheData_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_CacheData_Response {
    const NAME: &'static str = "CMsgSteamLearn_CacheData_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cache_data_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cache_data_result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cache_data_result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_CacheData_Response {
        CMsgSteamLearn_CacheData_Response::new()
    }

    fn clear(&mut self) {
        self.cache_data_result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_CacheData_Response {
        static instance: CMsgSteamLearn_CacheData_Response = CMsgSteamLearn_CacheData_Response {
            cache_data_result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_CacheData_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_CacheData_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_CacheData_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_CacheData_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_SnapshotProject_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_SnapshotProject_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_SnapshotProject_Request.access_token)
    pub access_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_SnapshotProject_Request.access_data)
    pub access_data: ::protobuf::MessageField<CMsgSteamLearn_AccessData>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_SnapshotProject_Request.project_id)
    pub project_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_SnapshotProject_Request.published_version)
    pub published_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_SnapshotProject_Request.keys)
    pub keys: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_SnapshotProject_Request.data)
    pub data: ::std::vec::Vec<CMsgSteamLearnData>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_SnapshotProject_Request.pending_data_limit_seconds)
    pub pending_data_limit_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_SnapshotProject_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_SnapshotProject_Request {
    fn default() -> &'a CMsgSteamLearn_SnapshotProject_Request {
        <CMsgSteamLearn_SnapshotProject_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_SnapshotProject_Request {
    pub fn new() -> CMsgSteamLearn_SnapshotProject_Request {
        ::std::default::Default::default()
    }

    // optional string access_token = 1;

    pub fn access_token(&self) -> &str {
        match self.access_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: ::std::string::String) {
        self.access_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_token(&mut self) -> &mut ::std::string::String {
        if self.access_token.is_none() {
            self.access_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.access_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_token(&mut self) -> ::std::string::String {
        self.access_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 project_id = 3;

    pub fn project_id(&self) -> u32 {
        self.project_id.unwrap_or(0)
    }

    pub fn clear_project_id(&mut self) {
        self.project_id = ::std::option::Option::None;
    }

    pub fn has_project_id(&self) -> bool {
        self.project_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: u32) {
        self.project_id = ::std::option::Option::Some(v);
    }

    // optional uint32 published_version = 7;

    pub fn published_version(&self) -> u32 {
        self.published_version.unwrap_or(0)
    }

    pub fn clear_published_version(&mut self) {
        self.published_version = ::std::option::Option::None;
    }

    pub fn has_published_version(&self) -> bool {
        self.published_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_version(&mut self, v: u32) {
        self.published_version = ::std::option::Option::Some(v);
    }

    // optional uint32 pending_data_limit_seconds = 6;

    pub fn pending_data_limit_seconds(&self) -> u32 {
        self.pending_data_limit_seconds.unwrap_or(0)
    }

    pub fn clear_pending_data_limit_seconds(&mut self) {
        self.pending_data_limit_seconds = ::std::option::Option::None;
    }

    pub fn has_pending_data_limit_seconds(&self) -> bool {
        self.pending_data_limit_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_data_limit_seconds(&mut self, v: u32) {
        self.pending_data_limit_seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "access_token",
            |m: &CMsgSteamLearn_SnapshotProject_Request| { &m.access_token },
            |m: &mut CMsgSteamLearn_SnapshotProject_Request| { &mut m.access_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearn_AccessData>(
            "access_data",
            |m: &CMsgSteamLearn_SnapshotProject_Request| { &m.access_data },
            |m: &mut CMsgSteamLearn_SnapshotProject_Request| { &mut m.access_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "project_id",
            |m: &CMsgSteamLearn_SnapshotProject_Request| { &m.project_id },
            |m: &mut CMsgSteamLearn_SnapshotProject_Request| { &mut m.project_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_version",
            |m: &CMsgSteamLearn_SnapshotProject_Request| { &m.published_version },
            |m: &mut CMsgSteamLearn_SnapshotProject_Request| { &mut m.published_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &CMsgSteamLearn_SnapshotProject_Request| { &m.keys },
            |m: &mut CMsgSteamLearn_SnapshotProject_Request| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &CMsgSteamLearn_SnapshotProject_Request| { &m.data },
            |m: &mut CMsgSteamLearn_SnapshotProject_Request| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pending_data_limit_seconds",
            |m: &CMsgSteamLearn_SnapshotProject_Request| { &m.pending_data_limit_seconds },
            |m: &mut CMsgSteamLearn_SnapshotProject_Request| { &mut m.pending_data_limit_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_SnapshotProject_Request>(
            "CMsgSteamLearn_SnapshotProject_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_SnapshotProject_Request {
    const NAME: &'static str = "CMsgSteamLearn_SnapshotProject_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.access_token = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.access_data)?;
                },
                24 => {
                    self.project_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.published_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.keys)?;
                },
                32 => {
                    self.keys.push(is.read_uint64()?);
                },
                42 => {
                    self.data.push(is.read_message()?);
                },
                48 => {
                    self.pending_data_limit_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.access_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.access_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.project_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.published_version {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        for value in &self.keys {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pending_data_limit_seconds {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.access_token.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.access_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.project_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.published_version {
            os.write_uint32(7, v)?;
        }
        for v in &self.keys {
            os.write_uint64(4, *v)?;
        };
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.pending_data_limit_seconds {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_SnapshotProject_Request {
        CMsgSteamLearn_SnapshotProject_Request::new()
    }

    fn clear(&mut self) {
        self.access_token = ::std::option::Option::None;
        self.access_data.clear();
        self.project_id = ::std::option::Option::None;
        self.published_version = ::std::option::Option::None;
        self.keys.clear();
        self.data.clear();
        self.pending_data_limit_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_SnapshotProject_Request {
        static instance: CMsgSteamLearn_SnapshotProject_Request = CMsgSteamLearn_SnapshotProject_Request {
            access_token: ::std::option::Option::None,
            access_data: ::protobuf::MessageField::none(),
            project_id: ::std::option::Option::None,
            published_version: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            data: ::std::vec::Vec::new(),
            pending_data_limit_seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_SnapshotProject_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_SnapshotProject_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_SnapshotProject_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_SnapshotProject_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_SnapshotProject_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_SnapshotProject_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_SnapshotProject_Response.snapshot_result)
    pub snapshot_result: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamLearnSnapshotProjectResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_SnapshotProject_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_SnapshotProject_Response {
    fn default() -> &'a CMsgSteamLearn_SnapshotProject_Response {
        <CMsgSteamLearn_SnapshotProject_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_SnapshotProject_Response {
    pub fn new() -> CMsgSteamLearn_SnapshotProject_Response {
        ::std::default::Default::default()
    }

    // optional .ESteamLearnSnapshotProjectResult snapshot_result = 1;

    pub fn snapshot_result(&self) -> ESteamLearnSnapshotProjectResult {
        match self.snapshot_result {
            Some(e) => e.enum_value_or(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR),
            None => ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR,
        }
    }

    pub fn clear_snapshot_result(&mut self) {
        self.snapshot_result = ::std::option::Option::None;
    }

    pub fn has_snapshot_result(&self) -> bool {
        self.snapshot_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_snapshot_result(&mut self, v: ESteamLearnSnapshotProjectResult) {
        self.snapshot_result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "snapshot_result",
            |m: &CMsgSteamLearn_SnapshotProject_Response| { &m.snapshot_result },
            |m: &mut CMsgSteamLearn_SnapshotProject_Response| { &mut m.snapshot_result },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_SnapshotProject_Response>(
            "CMsgSteamLearn_SnapshotProject_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_SnapshotProject_Response {
    const NAME: &'static str = "CMsgSteamLearn_SnapshotProject_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.snapshot_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.snapshot_result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.snapshot_result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_SnapshotProject_Response {
        CMsgSteamLearn_SnapshotProject_Response::new()
    }

    fn clear(&mut self) {
        self.snapshot_result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_SnapshotProject_Response {
        static instance: CMsgSteamLearn_SnapshotProject_Response = CMsgSteamLearn_SnapshotProject_Response {
            snapshot_result: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_SnapshotProject_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_SnapshotProject_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_SnapshotProject_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_SnapshotProject_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_BatchOperation_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_BatchOperation_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_BatchOperation_Request.cache_data_requests)
    pub cache_data_requests: ::std::vec::Vec<CMsgSteamLearn_CacheData_Request>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_BatchOperation_Request.snapshot_requests)
    pub snapshot_requests: ::std::vec::Vec<CMsgSteamLearn_SnapshotProject_Request>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_BatchOperation_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_BatchOperation_Request {
    fn default() -> &'a CMsgSteamLearn_BatchOperation_Request {
        <CMsgSteamLearn_BatchOperation_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_BatchOperation_Request {
    pub fn new() -> CMsgSteamLearn_BatchOperation_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cache_data_requests",
            |m: &CMsgSteamLearn_BatchOperation_Request| { &m.cache_data_requests },
            |m: &mut CMsgSteamLearn_BatchOperation_Request| { &mut m.cache_data_requests },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snapshot_requests",
            |m: &CMsgSteamLearn_BatchOperation_Request| { &m.snapshot_requests },
            |m: &mut CMsgSteamLearn_BatchOperation_Request| { &mut m.snapshot_requests },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_BatchOperation_Request>(
            "CMsgSteamLearn_BatchOperation_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_BatchOperation_Request {
    const NAME: &'static str = "CMsgSteamLearn_BatchOperation_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cache_data_requests.push(is.read_message()?);
                },
                18 => {
                    self.snapshot_requests.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cache_data_requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.snapshot_requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cache_data_requests {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.snapshot_requests {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_BatchOperation_Request {
        CMsgSteamLearn_BatchOperation_Request::new()
    }

    fn clear(&mut self) {
        self.cache_data_requests.clear();
        self.snapshot_requests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_BatchOperation_Request {
        static instance: CMsgSteamLearn_BatchOperation_Request = CMsgSteamLearn_BatchOperation_Request {
            cache_data_requests: ::std::vec::Vec::new(),
            snapshot_requests: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_BatchOperation_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_BatchOperation_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_BatchOperation_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_BatchOperation_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_BatchOperation_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_BatchOperation_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_BatchOperation_Response.cache_data_responses)
    pub cache_data_responses: ::std::vec::Vec<CMsgSteamLearn_CacheData_Response>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_BatchOperation_Response.snapshot_responses)
    pub snapshot_responses: ::std::vec::Vec<CMsgSteamLearn_SnapshotProject_Response>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_BatchOperation_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_BatchOperation_Response {
    fn default() -> &'a CMsgSteamLearn_BatchOperation_Response {
        <CMsgSteamLearn_BatchOperation_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_BatchOperation_Response {
    pub fn new() -> CMsgSteamLearn_BatchOperation_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cache_data_responses",
            |m: &CMsgSteamLearn_BatchOperation_Response| { &m.cache_data_responses },
            |m: &mut CMsgSteamLearn_BatchOperation_Response| { &mut m.cache_data_responses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snapshot_responses",
            |m: &CMsgSteamLearn_BatchOperation_Response| { &m.snapshot_responses },
            |m: &mut CMsgSteamLearn_BatchOperation_Response| { &mut m.snapshot_responses },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_BatchOperation_Response>(
            "CMsgSteamLearn_BatchOperation_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_BatchOperation_Response {
    const NAME: &'static str = "CMsgSteamLearn_BatchOperation_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cache_data_responses.push(is.read_message()?);
                },
                18 => {
                    self.snapshot_responses.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cache_data_responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.snapshot_responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cache_data_responses {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.snapshot_responses {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_BatchOperation_Response {
        CMsgSteamLearn_BatchOperation_Response::new()
    }

    fn clear(&mut self) {
        self.cache_data_responses.clear();
        self.snapshot_responses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_BatchOperation_Response {
        static instance: CMsgSteamLearn_BatchOperation_Response = CMsgSteamLearn_BatchOperation_Response {
            cache_data_responses: ::std::vec::Vec::new(),
            snapshot_responses: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_BatchOperation_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_BatchOperation_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_BatchOperation_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_BatchOperation_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearnHMACKeys)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnHMACKeys {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnHMACKeys.register_data_source_key)
    pub register_data_source_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearnHMACKeys.cache_data_keys)
    pub cache_data_keys: ::std::vec::Vec<cmsg_steam_learn_hmackeys::CacheDataKeys>,
    // @@protoc_insertion_point(field:CMsgSteamLearnHMACKeys.snapshot_project_keys)
    pub snapshot_project_keys: ::std::vec::Vec<cmsg_steam_learn_hmackeys::SnapshotProjectKeys>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnHMACKeys.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnHMACKeys {
    fn default() -> &'a CMsgSteamLearnHMACKeys {
        <CMsgSteamLearnHMACKeys as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnHMACKeys {
    pub fn new() -> CMsgSteamLearnHMACKeys {
        ::std::default::Default::default()
    }

    // optional string register_data_source_key = 1;

    pub fn register_data_source_key(&self) -> &str {
        match self.register_data_source_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_register_data_source_key(&mut self) {
        self.register_data_source_key = ::std::option::Option::None;
    }

    pub fn has_register_data_source_key(&self) -> bool {
        self.register_data_source_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_register_data_source_key(&mut self, v: ::std::string::String) {
        self.register_data_source_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_register_data_source_key(&mut self) -> &mut ::std::string::String {
        if self.register_data_source_key.is_none() {
            self.register_data_source_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.register_data_source_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_register_data_source_key(&mut self) -> ::std::string::String {
        self.register_data_source_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "register_data_source_key",
            |m: &CMsgSteamLearnHMACKeys| { &m.register_data_source_key },
            |m: &mut CMsgSteamLearnHMACKeys| { &mut m.register_data_source_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cache_data_keys",
            |m: &CMsgSteamLearnHMACKeys| { &m.cache_data_keys },
            |m: &mut CMsgSteamLearnHMACKeys| { &mut m.cache_data_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snapshot_project_keys",
            |m: &CMsgSteamLearnHMACKeys| { &m.snapshot_project_keys },
            |m: &mut CMsgSteamLearnHMACKeys| { &mut m.snapshot_project_keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearnHMACKeys>(
            "CMsgSteamLearnHMACKeys",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearnHMACKeys {
    const NAME: &'static str = "CMsgSteamLearnHMACKeys";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.register_data_source_key = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.cache_data_keys.push(is.read_message()?);
                },
                26 => {
                    self.snapshot_project_keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.register_data_source_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.cache_data_keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.snapshot_project_keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.register_data_source_key.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.cache_data_keys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.snapshot_project_keys {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnHMACKeys {
        CMsgSteamLearnHMACKeys::new()
    }

    fn clear(&mut self) {
        self.register_data_source_key = ::std::option::Option::None;
        self.cache_data_keys.clear();
        self.snapshot_project_keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnHMACKeys {
        static instance: CMsgSteamLearnHMACKeys = CMsgSteamLearnHMACKeys {
            register_data_source_key: ::std::option::Option::None,
            cache_data_keys: ::std::vec::Vec::new(),
            snapshot_project_keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearnHMACKeys {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearnHMACKeys").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearnHMACKeys {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearnHMACKeys {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamLearnHMACKeys`
pub mod cmsg_steam_learn_hmackeys {
    // @@protoc_insertion_point(message:CMsgSteamLearnHMACKeys.CacheDataKeys)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CacheDataKeys {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearnHMACKeys.CacheDataKeys.data_source_id)
        pub data_source_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnHMACKeys.CacheDataKeys.version)
        pub version: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnHMACKeys.CacheDataKeys.key)
        pub key: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearnHMACKeys.CacheDataKeys.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CacheDataKeys {
        fn default() -> &'a CacheDataKeys {
            <CacheDataKeys as ::protobuf::Message>::default_instance()
        }
    }

    impl CacheDataKeys {
        pub fn new() -> CacheDataKeys {
            ::std::default::Default::default()
        }

        // optional uint32 data_source_id = 1;

        pub fn data_source_id(&self) -> u32 {
            self.data_source_id.unwrap_or(0)
        }

        pub fn clear_data_source_id(&mut self) {
            self.data_source_id = ::std::option::Option::None;
        }

        pub fn has_data_source_id(&self) -> bool {
            self.data_source_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_source_id(&mut self, v: u32) {
            self.data_source_id = ::std::option::Option::Some(v);
        }

        // optional uint32 version = 3;

        pub fn version(&self) -> u32 {
            self.version.unwrap_or(0)
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: u32) {
            self.version = ::std::option::Option::Some(v);
        }

        // optional string key = 2;

        pub fn key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::string::String::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_source_id",
                |m: &CacheDataKeys| { &m.data_source_id },
                |m: &mut CacheDataKeys| { &mut m.data_source_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "version",
                |m: &CacheDataKeys| { &m.version },
                |m: &mut CacheDataKeys| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "key",
                |m: &CacheDataKeys| { &m.key },
                |m: &mut CacheDataKeys| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheDataKeys>(
                "CMsgSteamLearnHMACKeys.CacheDataKeys",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CacheDataKeys {
        const NAME: &'static str = "CacheDataKeys";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.data_source_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.version = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.key = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data_source_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.version {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data_source_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.version {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.key.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CacheDataKeys {
            CacheDataKeys::new()
        }

        fn clear(&mut self) {
            self.data_source_id = ::std::option::Option::None;
            self.version = ::std::option::Option::None;
            self.key = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CacheDataKeys {
            static instance: CacheDataKeys = CacheDataKeys {
                data_source_id: ::std::option::Option::None,
                version: ::std::option::Option::None,
                key: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CacheDataKeys {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearnHMACKeys.CacheDataKeys").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CacheDataKeys {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CacheDataKeys {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamLearnHMACKeys.SnapshotProjectKeys)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SnapshotProjectKeys {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearnHMACKeys.SnapshotProjectKeys.project_id)
        pub project_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnHMACKeys.SnapshotProjectKeys.published_version)
        pub published_version: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnHMACKeys.SnapshotProjectKeys.key)
        pub key: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearnHMACKeys.SnapshotProjectKeys.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SnapshotProjectKeys {
        fn default() -> &'a SnapshotProjectKeys {
            <SnapshotProjectKeys as ::protobuf::Message>::default_instance()
        }
    }

    impl SnapshotProjectKeys {
        pub fn new() -> SnapshotProjectKeys {
            ::std::default::Default::default()
        }

        // optional uint32 project_id = 1;

        pub fn project_id(&self) -> u32 {
            self.project_id.unwrap_or(0)
        }

        pub fn clear_project_id(&mut self) {
            self.project_id = ::std::option::Option::None;
        }

        pub fn has_project_id(&self) -> bool {
            self.project_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_project_id(&mut self, v: u32) {
            self.project_id = ::std::option::Option::Some(v);
        }

        // optional uint32 published_version = 3;

        pub fn published_version(&self) -> u32 {
            self.published_version.unwrap_or(0)
        }

        pub fn clear_published_version(&mut self) {
            self.published_version = ::std::option::Option::None;
        }

        pub fn has_published_version(&self) -> bool {
            self.published_version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_published_version(&mut self, v: u32) {
            self.published_version = ::std::option::Option::Some(v);
        }

        // optional string key = 2;

        pub fn key(&self) -> &str {
            match self.key.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_key(&mut self) {
            self.key = ::std::option::Option::None;
        }

        pub fn has_key(&self) -> bool {
            self.key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_key(&mut self, v: ::std::string::String) {
            self.key = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_key(&mut self) -> &mut ::std::string::String {
            if self.key.is_none() {
                self.key = ::std::option::Option::Some(::std::string::String::new());
            }
            self.key.as_mut().unwrap()
        }

        // Take field
        pub fn take_key(&mut self) -> ::std::string::String {
            self.key.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "project_id",
                |m: &SnapshotProjectKeys| { &m.project_id },
                |m: &mut SnapshotProjectKeys| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "published_version",
                |m: &SnapshotProjectKeys| { &m.published_version },
                |m: &mut SnapshotProjectKeys| { &mut m.published_version },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "key",
                |m: &SnapshotProjectKeys| { &m.key },
                |m: &mut SnapshotProjectKeys| { &mut m.key },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SnapshotProjectKeys>(
                "CMsgSteamLearnHMACKeys.SnapshotProjectKeys",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SnapshotProjectKeys {
        const NAME: &'static str = "SnapshotProjectKeys";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.project_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.published_version = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.key = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.project_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.published_version {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.key.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.project_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.published_version {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.key.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SnapshotProjectKeys {
            SnapshotProjectKeys::new()
        }

        fn clear(&mut self) {
            self.project_id = ::std::option::Option::None;
            self.published_version = ::std::option::Option::None;
            self.key = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SnapshotProjectKeys {
            static instance: SnapshotProjectKeys = SnapshotProjectKeys {
                project_id: ::std::option::Option::None,
                published_version: ::std::option::Option::None,
                key: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SnapshotProjectKeys {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearnHMACKeys.SnapshotProjectKeys").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SnapshotProjectKeys {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SnapshotProjectKeys {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearn_GetHMACKeys_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_GetHMACKeys_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_GetHMACKeys_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_GetHMACKeys_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_GetHMACKeys_Request {
    fn default() -> &'a CMsgSteamLearn_GetHMACKeys_Request {
        <CMsgSteamLearn_GetHMACKeys_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_GetHMACKeys_Request {
    pub fn new() -> CMsgSteamLearn_GetHMACKeys_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CMsgSteamLearn_GetHMACKeys_Request| { &m.appid },
            |m: &mut CMsgSteamLearn_GetHMACKeys_Request| { &mut m.appid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_GetHMACKeys_Request>(
            "CMsgSteamLearn_GetHMACKeys_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_GetHMACKeys_Request {
    const NAME: &'static str = "CMsgSteamLearn_GetHMACKeys_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_GetHMACKeys_Request {
        CMsgSteamLearn_GetHMACKeys_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_GetHMACKeys_Request {
        static instance: CMsgSteamLearn_GetHMACKeys_Request = CMsgSteamLearn_GetHMACKeys_Request {
            appid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_GetHMACKeys_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_GetHMACKeys_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_GetHMACKeys_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_GetHMACKeys_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_GetHMACKeys_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_GetHMACKeys_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_GetHMACKeys_Response.result)
    pub result: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamLearnGetHMACKeysResult>>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_GetHMACKeys_Response.keys)
    pub keys: ::protobuf::MessageField<CMsgSteamLearnHMACKeys>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_GetHMACKeys_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_GetHMACKeys_Response {
    fn default() -> &'a CMsgSteamLearn_GetHMACKeys_Response {
        <CMsgSteamLearn_GetHMACKeys_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_GetHMACKeys_Response {
    pub fn new() -> CMsgSteamLearn_GetHMACKeys_Response {
        ::std::default::Default::default()
    }

    // optional .ESteamLearnGetHMACKeysResult result = 1;

    pub fn result(&self) -> ESteamLearnGetHMACKeysResult {
        match self.result {
            Some(e) => e.enum_value_or(ESteamLearnGetHMACKeysResult::STEAMLEARN_GET_HMAC_KEYS_SUCCESS),
            None => ESteamLearnGetHMACKeysResult::STEAMLEARN_GET_HMAC_KEYS_SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ESteamLearnGetHMACKeysResult) {
        self.result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgSteamLearn_GetHMACKeys_Response| { &m.result },
            |m: &mut CMsgSteamLearn_GetHMACKeys_Response| { &mut m.result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearnHMACKeys>(
            "keys",
            |m: &CMsgSteamLearn_GetHMACKeys_Response| { &m.keys },
            |m: &mut CMsgSteamLearn_GetHMACKeys_Response| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_GetHMACKeys_Response>(
            "CMsgSteamLearn_GetHMACKeys_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_GetHMACKeys_Response {
    const NAME: &'static str = "CMsgSteamLearn_GetHMACKeys_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.keys)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.keys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.keys.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_GetHMACKeys_Response {
        CMsgSteamLearn_GetHMACKeys_Response::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_GetHMACKeys_Response {
        static instance: CMsgSteamLearn_GetHMACKeys_Response = CMsgSteamLearn_GetHMACKeys_Response {
            result: ::std::option::Option::None,
            keys: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_GetHMACKeys_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_GetHMACKeys_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_GetHMACKeys_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_GetHMACKeys_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_Inference_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_Inference_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_Inference_Request.access_token)
    pub access_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_Inference_Request.access_data)
    pub access_data: ::protobuf::MessageField<CMsgSteamLearn_AccessData>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_Inference_Request.project_id)
    pub project_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_Inference_Request.published_version)
    pub published_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_Inference_Request.override_train_id)
    pub override_train_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_Inference_Request.data)
    pub data: ::protobuf::MessageField<CMsgSteamLearnDataList>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_Inference_Request.additional_data)
    pub additional_data: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_Inference_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_Inference_Request {
    fn default() -> &'a CMsgSteamLearn_Inference_Request {
        <CMsgSteamLearn_Inference_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_Inference_Request {
    pub fn new() -> CMsgSteamLearn_Inference_Request {
        ::std::default::Default::default()
    }

    // optional string access_token = 1;

    pub fn access_token(&self) -> &str {
        match self.access_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: ::std::string::String) {
        self.access_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_token(&mut self) -> &mut ::std::string::String {
        if self.access_token.is_none() {
            self.access_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.access_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_token(&mut self) -> ::std::string::String {
        self.access_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 project_id = 3;

    pub fn project_id(&self) -> u32 {
        self.project_id.unwrap_or(0)
    }

    pub fn clear_project_id(&mut self) {
        self.project_id = ::std::option::Option::None;
    }

    pub fn has_project_id(&self) -> bool {
        self.project_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: u32) {
        self.project_id = ::std::option::Option::Some(v);
    }

    // optional uint32 published_version = 4;

    pub fn published_version(&self) -> u32 {
        self.published_version.unwrap_or(0)
    }

    pub fn clear_published_version(&mut self) {
        self.published_version = ::std::option::Option::None;
    }

    pub fn has_published_version(&self) -> bool {
        self.published_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_version(&mut self, v: u32) {
        self.published_version = ::std::option::Option::Some(v);
    }

    // optional uint32 override_train_id = 5;

    pub fn override_train_id(&self) -> u32 {
        self.override_train_id.unwrap_or(0)
    }

    pub fn clear_override_train_id(&mut self) {
        self.override_train_id = ::std::option::Option::None;
    }

    pub fn has_override_train_id(&self) -> bool {
        self.override_train_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_train_id(&mut self, v: u32) {
        self.override_train_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "access_token",
            |m: &CMsgSteamLearn_Inference_Request| { &m.access_token },
            |m: &mut CMsgSteamLearn_Inference_Request| { &mut m.access_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearn_AccessData>(
            "access_data",
            |m: &CMsgSteamLearn_Inference_Request| { &m.access_data },
            |m: &mut CMsgSteamLearn_Inference_Request| { &mut m.access_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "project_id",
            |m: &CMsgSteamLearn_Inference_Request| { &m.project_id },
            |m: &mut CMsgSteamLearn_Inference_Request| { &mut m.project_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_version",
            |m: &CMsgSteamLearn_Inference_Request| { &m.published_version },
            |m: &mut CMsgSteamLearn_Inference_Request| { &mut m.published_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_train_id",
            |m: &CMsgSteamLearn_Inference_Request| { &m.override_train_id },
            |m: &mut CMsgSteamLearn_Inference_Request| { &mut m.override_train_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearnDataList>(
            "data",
            |m: &CMsgSteamLearn_Inference_Request| { &m.data },
            |m: &mut CMsgSteamLearn_Inference_Request| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "additional_data",
            |m: &CMsgSteamLearn_Inference_Request| { &m.additional_data },
            |m: &mut CMsgSteamLearn_Inference_Request| { &mut m.additional_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_Inference_Request>(
            "CMsgSteamLearn_Inference_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_Inference_Request {
    const NAME: &'static str = "CMsgSteamLearn_Inference_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.access_token = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.access_data)?;
                },
                24 => {
                    self.project_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.published_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.override_train_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                58 => {
                    is.read_repeated_packed_float_into(&mut self.additional_data)?;
                },
                61 => {
                    self.additional_data.push(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.access_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.access_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.project_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.published_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.override_train_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += 5 * self.additional_data.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.access_token.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.access_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.project_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.published_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.override_train_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.additional_data {
            os.write_float(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_Inference_Request {
        CMsgSteamLearn_Inference_Request::new()
    }

    fn clear(&mut self) {
        self.access_token = ::std::option::Option::None;
        self.access_data.clear();
        self.project_id = ::std::option::Option::None;
        self.published_version = ::std::option::Option::None;
        self.override_train_id = ::std::option::Option::None;
        self.data.clear();
        self.additional_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_Inference_Request {
        static instance: CMsgSteamLearn_Inference_Request = CMsgSteamLearn_Inference_Request {
            access_token: ::std::option::Option::None,
            access_data: ::protobuf::MessageField::none(),
            project_id: ::std::option::Option::None,
            published_version: ::std::option::Option::None,
            override_train_id: ::std::option::Option::None,
            data: ::protobuf::MessageField::none(),
            additional_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_Inference_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_Inference_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_Inference_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_Inference_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_InferenceMetadata_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Request.access_token)
    pub access_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Request.access_data)
    pub access_data: ::protobuf::MessageField<CMsgSteamLearn_AccessData>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Request.project_id)
    pub project_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Request.published_version)
    pub published_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Request.override_train_id)
    pub override_train_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_InferenceMetadata_Request {
    fn default() -> &'a CMsgSteamLearn_InferenceMetadata_Request {
        <CMsgSteamLearn_InferenceMetadata_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_InferenceMetadata_Request {
    pub fn new() -> CMsgSteamLearn_InferenceMetadata_Request {
        ::std::default::Default::default()
    }

    // optional string access_token = 1;

    pub fn access_token(&self) -> &str {
        match self.access_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: ::std::string::String) {
        self.access_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_token(&mut self) -> &mut ::std::string::String {
        if self.access_token.is_none() {
            self.access_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.access_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_access_token(&mut self) -> ::std::string::String {
        self.access_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 project_id = 3;

    pub fn project_id(&self) -> u32 {
        self.project_id.unwrap_or(0)
    }

    pub fn clear_project_id(&mut self) {
        self.project_id = ::std::option::Option::None;
    }

    pub fn has_project_id(&self) -> bool {
        self.project_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: u32) {
        self.project_id = ::std::option::Option::Some(v);
    }

    // optional uint32 published_version = 4;

    pub fn published_version(&self) -> u32 {
        self.published_version.unwrap_or(0)
    }

    pub fn clear_published_version(&mut self) {
        self.published_version = ::std::option::Option::None;
    }

    pub fn has_published_version(&self) -> bool {
        self.published_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_version(&mut self, v: u32) {
        self.published_version = ::std::option::Option::Some(v);
    }

    // optional uint32 override_train_id = 5;

    pub fn override_train_id(&self) -> u32 {
        self.override_train_id.unwrap_or(0)
    }

    pub fn clear_override_train_id(&mut self) {
        self.override_train_id = ::std::option::Option::None;
    }

    pub fn has_override_train_id(&self) -> bool {
        self.override_train_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_train_id(&mut self, v: u32) {
        self.override_train_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "access_token",
            |m: &CMsgSteamLearn_InferenceMetadata_Request| { &m.access_token },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Request| { &mut m.access_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearn_AccessData>(
            "access_data",
            |m: &CMsgSteamLearn_InferenceMetadata_Request| { &m.access_data },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Request| { &mut m.access_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "project_id",
            |m: &CMsgSteamLearn_InferenceMetadata_Request| { &m.project_id },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Request| { &mut m.project_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "published_version",
            |m: &CMsgSteamLearn_InferenceMetadata_Request| { &m.published_version },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Request| { &mut m.published_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_train_id",
            |m: &CMsgSteamLearn_InferenceMetadata_Request| { &m.override_train_id },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Request| { &mut m.override_train_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_InferenceMetadata_Request>(
            "CMsgSteamLearn_InferenceMetadata_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_InferenceMetadata_Request {
    const NAME: &'static str = "CMsgSteamLearn_InferenceMetadata_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.access_token = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.access_data)?;
                },
                24 => {
                    self.project_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.published_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.override_train_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.access_token.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.access_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.project_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.published_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.override_train_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.access_token.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.access_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.project_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.published_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.override_train_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_InferenceMetadata_Request {
        CMsgSteamLearn_InferenceMetadata_Request::new()
    }

    fn clear(&mut self) {
        self.access_token = ::std::option::Option::None;
        self.access_data.clear();
        self.project_id = ::std::option::Option::None;
        self.published_version = ::std::option::Option::None;
        self.override_train_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_InferenceMetadata_Request {
        static instance: CMsgSteamLearn_InferenceMetadata_Request = CMsgSteamLearn_InferenceMetadata_Request {
            access_token: ::std::option::Option::None,
            access_data: ::protobuf::MessageField::none(),
            project_id: ::std::option::Option::None,
            published_version: ::std::option::Option::None,
            override_train_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_InferenceMetadata_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_InferenceMetadata_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_InferenceMetadata_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadataBackend_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_InferenceMetadataBackend_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadataBackend_Request.project_id)
    pub project_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadataBackend_Request.fetch_id)
    pub fetch_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadataBackend_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_InferenceMetadataBackend_Request {
    fn default() -> &'a CMsgSteamLearn_InferenceMetadataBackend_Request {
        <CMsgSteamLearn_InferenceMetadataBackend_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_InferenceMetadataBackend_Request {
    pub fn new() -> CMsgSteamLearn_InferenceMetadataBackend_Request {
        ::std::default::Default::default()
    }

    // optional uint32 project_id = 1;

    pub fn project_id(&self) -> u32 {
        self.project_id.unwrap_or(0)
    }

    pub fn clear_project_id(&mut self) {
        self.project_id = ::std::option::Option::None;
    }

    pub fn has_project_id(&self) -> bool {
        self.project_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: u32) {
        self.project_id = ::std::option::Option::Some(v);
    }

    // optional uint32 fetch_id = 2;

    pub fn fetch_id(&self) -> u32 {
        self.fetch_id.unwrap_or(0)
    }

    pub fn clear_fetch_id(&mut self) {
        self.fetch_id = ::std::option::Option::None;
    }

    pub fn has_fetch_id(&self) -> bool {
        self.fetch_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fetch_id(&mut self, v: u32) {
        self.fetch_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "project_id",
            |m: &CMsgSteamLearn_InferenceMetadataBackend_Request| { &m.project_id },
            |m: &mut CMsgSteamLearn_InferenceMetadataBackend_Request| { &mut m.project_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fetch_id",
            |m: &CMsgSteamLearn_InferenceMetadataBackend_Request| { &m.fetch_id },
            |m: &mut CMsgSteamLearn_InferenceMetadataBackend_Request| { &mut m.fetch_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_InferenceMetadataBackend_Request>(
            "CMsgSteamLearn_InferenceMetadataBackend_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_InferenceMetadataBackend_Request {
    const NAME: &'static str = "CMsgSteamLearn_InferenceMetadataBackend_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.project_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.fetch_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.project_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.fetch_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.project_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fetch_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_InferenceMetadataBackend_Request {
        CMsgSteamLearn_InferenceMetadataBackend_Request::new()
    }

    fn clear(&mut self) {
        self.project_id = ::std::option::Option::None;
        self.fetch_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_InferenceMetadataBackend_Request {
        static instance: CMsgSteamLearn_InferenceMetadataBackend_Request = CMsgSteamLearn_InferenceMetadataBackend_Request {
            project_id: ::std::option::Option::None,
            fetch_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_InferenceMetadataBackend_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadataBackend_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_InferenceMetadataBackend_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_InferenceMetadataBackend_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_InferenceMetadata_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.inference_metadata_result)
    pub inference_metadata_result: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamLearnInferenceMetadataResult>>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.row_range)
    pub row_range: ::protobuf::MessageField<cmsg_steam_learn_inference_metadata_response::RowRange>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.ranges)
    pub ranges: ::std::vec::Vec<cmsg_steam_learn_inference_metadata_response::Range>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.std_devs)
    pub std_devs: ::std::vec::Vec<cmsg_steam_learn_inference_metadata_response::StdDev>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.compact_tables)
    pub compact_tables: ::std::vec::Vec<cmsg_steam_learn_inference_metadata_response::CompactTable>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.kmeans)
    pub kmeans: ::std::vec::Vec<cmsg_steam_learn_inference_metadata_response::KMeans>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.snapshot_histogram)
    pub snapshot_histogram: ::protobuf::MessageField<cmsg_steam_learn_inference_metadata_response::SnapshotHistogram>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_InferenceMetadata_Response {
    fn default() -> &'a CMsgSteamLearn_InferenceMetadata_Response {
        <CMsgSteamLearn_InferenceMetadata_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_InferenceMetadata_Response {
    pub fn new() -> CMsgSteamLearn_InferenceMetadata_Response {
        ::std::default::Default::default()
    }

    // optional .ESteamLearnInferenceMetadataResult inference_metadata_result = 1;

    pub fn inference_metadata_result(&self) -> ESteamLearnInferenceMetadataResult {
        match self.inference_metadata_result {
            Some(e) => e.enum_value_or(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR),
            None => ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR,
        }
    }

    pub fn clear_inference_metadata_result(&mut self) {
        self.inference_metadata_result = ::std::option::Option::None;
    }

    pub fn has_inference_metadata_result(&self) -> bool {
        self.inference_metadata_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inference_metadata_result(&mut self, v: ESteamLearnInferenceMetadataResult) {
        self.inference_metadata_result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inference_metadata_result",
            |m: &CMsgSteamLearn_InferenceMetadata_Response| { &m.inference_metadata_result },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Response| { &mut m.inference_metadata_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_learn_inference_metadata_response::RowRange>(
            "row_range",
            |m: &CMsgSteamLearn_InferenceMetadata_Response| { &m.row_range },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Response| { &mut m.row_range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ranges",
            |m: &CMsgSteamLearn_InferenceMetadata_Response| { &m.ranges },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Response| { &mut m.ranges },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "std_devs",
            |m: &CMsgSteamLearn_InferenceMetadata_Response| { &m.std_devs },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Response| { &mut m.std_devs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "compact_tables",
            |m: &CMsgSteamLearn_InferenceMetadata_Response| { &m.compact_tables },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Response| { &mut m.compact_tables },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kmeans",
            |m: &CMsgSteamLearn_InferenceMetadata_Response| { &m.kmeans },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Response| { &mut m.kmeans },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_learn_inference_metadata_response::SnapshotHistogram>(
            "snapshot_histogram",
            |m: &CMsgSteamLearn_InferenceMetadata_Response| { &m.snapshot_histogram },
            |m: &mut CMsgSteamLearn_InferenceMetadata_Response| { &mut m.snapshot_histogram },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_InferenceMetadata_Response>(
            "CMsgSteamLearn_InferenceMetadata_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_InferenceMetadata_Response {
    const NAME: &'static str = "CMsgSteamLearn_InferenceMetadata_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.inference_metadata_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.row_range)?;
                },
                26 => {
                    self.ranges.push(is.read_message()?);
                },
                34 => {
                    self.std_devs.push(is.read_message()?);
                },
                42 => {
                    self.compact_tables.push(is.read_message()?);
                },
                50 => {
                    self.kmeans.push(is.read_message()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.snapshot_histogram)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.inference_metadata_result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.row_range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.std_devs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.compact_tables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.kmeans {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.snapshot_histogram.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.inference_metadata_result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.row_range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.ranges {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.std_devs {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.compact_tables {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.kmeans {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.snapshot_histogram.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_InferenceMetadata_Response {
        CMsgSteamLearn_InferenceMetadata_Response::new()
    }

    fn clear(&mut self) {
        self.inference_metadata_result = ::std::option::Option::None;
        self.row_range.clear();
        self.ranges.clear();
        self.std_devs.clear();
        self.compact_tables.clear();
        self.kmeans.clear();
        self.snapshot_histogram.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_InferenceMetadata_Response {
        static instance: CMsgSteamLearn_InferenceMetadata_Response = CMsgSteamLearn_InferenceMetadata_Response {
            inference_metadata_result: ::std::option::Option::None,
            row_range: ::protobuf::MessageField::none(),
            ranges: ::std::vec::Vec::new(),
            std_devs: ::std::vec::Vec::new(),
            compact_tables: ::std::vec::Vec::new(),
            kmeans: ::std::vec::Vec::new(),
            snapshot_histogram: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_InferenceMetadata_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_InferenceMetadata_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_InferenceMetadata_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamLearn_InferenceMetadata_Response`
pub mod cmsg_steam_learn_inference_metadata_response {
    // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response.RowRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RowRange {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.RowRange.min_row)
        pub min_row: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.RowRange.max_row)
        pub max_row: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.RowRange.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RowRange {
        fn default() -> &'a RowRange {
            <RowRange as ::protobuf::Message>::default_instance()
        }
    }

    impl RowRange {
        pub fn new() -> RowRange {
            ::std::default::Default::default()
        }

        // optional uint64 min_row = 1;

        pub fn min_row(&self) -> u64 {
            self.min_row.unwrap_or(0)
        }

        pub fn clear_min_row(&mut self) {
            self.min_row = ::std::option::Option::None;
        }

        pub fn has_min_row(&self) -> bool {
            self.min_row.is_some()
        }

        // Param is passed by value, moved
        pub fn set_min_row(&mut self, v: u64) {
            self.min_row = ::std::option::Option::Some(v);
        }

        // optional uint64 max_row = 2;

        pub fn max_row(&self) -> u64 {
            self.max_row.unwrap_or(0)
        }

        pub fn clear_max_row(&mut self) {
            self.max_row = ::std::option::Option::None;
        }

        pub fn has_max_row(&self) -> bool {
            self.max_row.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_row(&mut self, v: u64) {
            self.max_row = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "min_row",
                |m: &RowRange| { &m.min_row },
                |m: &mut RowRange| { &mut m.min_row },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_row",
                |m: &RowRange| { &m.max_row },
                |m: &mut RowRange| { &mut m.max_row },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RowRange>(
                "CMsgSteamLearn_InferenceMetadata_Response.RowRange",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RowRange {
        const NAME: &'static str = "RowRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.min_row = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.max_row = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.min_row {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.max_row {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.min_row {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.max_row {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RowRange {
            RowRange::new()
        }

        fn clear(&mut self) {
            self.min_row = ::std::option::Option::None;
            self.max_row = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RowRange {
            static instance: RowRange = RowRange {
                min_row: ::std::option::Option::None,
                max_row: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RowRange {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response.RowRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RowRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RowRange {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response.Range)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Range {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.Range.data_element_path)
        pub data_element_path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.Range.min_value)
        pub min_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.Range.max_value)
        pub max_value: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.Range.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Range {
        fn default() -> &'a Range {
            <Range as ::protobuf::Message>::default_instance()
        }
    }

    impl Range {
        pub fn new() -> Range {
            ::std::default::Default::default()
        }

        // optional string data_element_path = 1;

        pub fn data_element_path(&self) -> &str {
            match self.data_element_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_data_element_path(&mut self) {
            self.data_element_path = ::std::option::Option::None;
        }

        pub fn has_data_element_path(&self) -> bool {
            self.data_element_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_element_path(&mut self, v: ::std::string::String) {
            self.data_element_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data_element_path(&mut self) -> &mut ::std::string::String {
            if self.data_element_path.is_none() {
                self.data_element_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.data_element_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_data_element_path(&mut self) -> ::std::string::String {
            self.data_element_path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float min_value = 2;

        pub fn min_value(&self) -> f32 {
            self.min_value.unwrap_or(0.)
        }

        pub fn clear_min_value(&mut self) {
            self.min_value = ::std::option::Option::None;
        }

        pub fn has_min_value(&self) -> bool {
            self.min_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_min_value(&mut self, v: f32) {
            self.min_value = ::std::option::Option::Some(v);
        }

        // optional float max_value = 3;

        pub fn max_value(&self) -> f32 {
            self.max_value.unwrap_or(0.)
        }

        pub fn clear_max_value(&mut self) {
            self.max_value = ::std::option::Option::None;
        }

        pub fn has_max_value(&self) -> bool {
            self.max_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_value(&mut self, v: f32) {
            self.max_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_element_path",
                |m: &Range| { &m.data_element_path },
                |m: &mut Range| { &mut m.data_element_path },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "min_value",
                |m: &Range| { &m.min_value },
                |m: &mut Range| { &mut m.min_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_value",
                |m: &Range| { &m.max_value },
                |m: &mut Range| { &mut m.max_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Range>(
                "CMsgSteamLearn_InferenceMetadata_Response.Range",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Range {
        const NAME: &'static str = "Range";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.data_element_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    21 => {
                        self.min_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    29 => {
                        self.max_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data_element_path.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.min_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.max_value {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data_element_path.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.min_value {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.max_value {
                os.write_float(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Range {
            Range::new()
        }

        fn clear(&mut self) {
            self.data_element_path = ::std::option::Option::None;
            self.min_value = ::std::option::Option::None;
            self.max_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Range {
            static instance: Range = Range {
                data_element_path: ::std::option::Option::None,
                min_value: ::std::option::Option::None,
                max_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Range {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response.Range").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Range {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Range {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response.StdDev)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StdDev {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.StdDev.data_element_path)
        pub data_element_path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.StdDev.mean)
        pub mean: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.StdDev.std_dev)
        pub std_dev: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.StdDev.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StdDev {
        fn default() -> &'a StdDev {
            <StdDev as ::protobuf::Message>::default_instance()
        }
    }

    impl StdDev {
        pub fn new() -> StdDev {
            ::std::default::Default::default()
        }

        // optional string data_element_path = 1;

        pub fn data_element_path(&self) -> &str {
            match self.data_element_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_data_element_path(&mut self) {
            self.data_element_path = ::std::option::Option::None;
        }

        pub fn has_data_element_path(&self) -> bool {
            self.data_element_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_element_path(&mut self, v: ::std::string::String) {
            self.data_element_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data_element_path(&mut self) -> &mut ::std::string::String {
            if self.data_element_path.is_none() {
                self.data_element_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.data_element_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_data_element_path(&mut self) -> ::std::string::String {
            self.data_element_path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float mean = 2;

        pub fn mean(&self) -> f32 {
            self.mean.unwrap_or(0.)
        }

        pub fn clear_mean(&mut self) {
            self.mean = ::std::option::Option::None;
        }

        pub fn has_mean(&self) -> bool {
            self.mean.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mean(&mut self, v: f32) {
            self.mean = ::std::option::Option::Some(v);
        }

        // optional float std_dev = 3;

        pub fn std_dev(&self) -> f32 {
            self.std_dev.unwrap_or(0.)
        }

        pub fn clear_std_dev(&mut self) {
            self.std_dev = ::std::option::Option::None;
        }

        pub fn has_std_dev(&self) -> bool {
            self.std_dev.is_some()
        }

        // Param is passed by value, moved
        pub fn set_std_dev(&mut self, v: f32) {
            self.std_dev = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_element_path",
                |m: &StdDev| { &m.data_element_path },
                |m: &mut StdDev| { &mut m.data_element_path },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mean",
                |m: &StdDev| { &m.mean },
                |m: &mut StdDev| { &mut m.mean },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "std_dev",
                |m: &StdDev| { &m.std_dev },
                |m: &mut StdDev| { &mut m.std_dev },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StdDev>(
                "CMsgSteamLearn_InferenceMetadata_Response.StdDev",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StdDev {
        const NAME: &'static str = "StdDev";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.data_element_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    21 => {
                        self.mean = ::std::option::Option::Some(is.read_float()?);
                    },
                    29 => {
                        self.std_dev = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data_element_path.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.mean {
                my_size += 1 + 4;
            }
            if let Some(v) = self.std_dev {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data_element_path.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.mean {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.std_dev {
                os.write_float(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StdDev {
            StdDev::new()
        }

        fn clear(&mut self) {
            self.data_element_path = ::std::option::Option::None;
            self.mean = ::std::option::Option::None;
            self.std_dev = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StdDev {
            static instance: StdDev = StdDev {
                data_element_path: ::std::option::Option::None,
                mean: ::std::option::Option::None,
                std_dev: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StdDev {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response.StdDev").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StdDev {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StdDev {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response.CompactTable)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CompactTable {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.map_values)
        pub map_values: ::std::vec::Vec<compact_table::MapValuesEntry>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.map_mappings)
        pub map_mappings: ::std::vec::Vec<compact_table::MapMappingsEntry>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CompactTable {
        fn default() -> &'a CompactTable {
            <CompactTable as ::protobuf::Message>::default_instance()
        }
    }

    impl CompactTable {
        pub fn new() -> CompactTable {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &CompactTable| { &m.name },
                |m: &mut CompactTable| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "map_values",
                |m: &CompactTable| { &m.map_values },
                |m: &mut CompactTable| { &mut m.map_values },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "map_mappings",
                |m: &CompactTable| { &m.map_mappings },
                |m: &mut CompactTable| { &mut m.map_mappings },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CompactTable>(
                "CMsgSteamLearn_InferenceMetadata_Response.CompactTable",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CompactTable {
        const NAME: &'static str = "CompactTable";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.map_values.push(is.read_message()?);
                    },
                    26 => {
                        self.map_mappings.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.map_values {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.map_mappings {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.map_values {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.map_mappings {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CompactTable {
            CompactTable::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.map_values.clear();
            self.map_mappings.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CompactTable {
            static instance: CompactTable = CompactTable {
                name: ::std::option::Option::None,
                map_values: ::std::vec::Vec::new(),
                map_mappings: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CompactTable {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response.CompactTable").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CompactTable {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CompactTable {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `CompactTable`
    pub mod compact_table {
        // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Entry {
            // message fields
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry.value)
            pub value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry.mapping)
            pub mapping: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry.count)
            pub count: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Entry {
            fn default() -> &'a Entry {
                <Entry as ::protobuf::Message>::default_instance()
            }
        }

        impl Entry {
            pub fn new() -> Entry {
                ::std::default::Default::default()
            }

            // optional uint32 value = 1;

            pub fn value(&self) -> u32 {
                self.value.unwrap_or(0)
            }

            pub fn clear_value(&mut self) {
                self.value = ::std::option::Option::None;
            }

            pub fn has_value(&self) -> bool {
                self.value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: u32) {
                self.value = ::std::option::Option::Some(v);
            }

            // optional uint32 mapping = 2;

            pub fn mapping(&self) -> u32 {
                self.mapping.unwrap_or(0)
            }

            pub fn clear_mapping(&mut self) {
                self.mapping = ::std::option::Option::None;
            }

            pub fn has_mapping(&self) -> bool {
                self.mapping.is_some()
            }

            // Param is passed by value, moved
            pub fn set_mapping(&mut self, v: u32) {
                self.mapping = ::std::option::Option::Some(v);
            }

            // optional uint64 count = 3;

            pub fn count(&self) -> u64 {
                self.count.unwrap_or(0)
            }

            pub fn clear_count(&mut self) {
                self.count = ::std::option::Option::None;
            }

            pub fn has_count(&self) -> bool {
                self.count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_count(&mut self, v: u64) {
                self.count = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value",
                    |m: &Entry| { &m.value },
                    |m: &mut Entry| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "mapping",
                    |m: &Entry| { &m.mapping },
                    |m: &mut Entry| { &mut m.mapping },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "count",
                    |m: &Entry| { &m.count },
                    |m: &mut Entry| { &mut m.count },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                    "CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Entry {
            const NAME: &'static str = "Entry";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.mapping = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.count = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.value {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.mapping {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.count {
                    my_size += ::protobuf::rt::uint64_size(3, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.value {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.mapping {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.count {
                    os.write_uint64(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Entry {
                Entry::new()
            }

            fn clear(&mut self) {
                self.value = ::std::option::Option::None;
                self.mapping = ::std::option::Option::None;
                self.count = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Entry {
                static instance: Entry = Entry {
                    value: ::std::option::Option::None,
                    mapping: ::std::option::Option::None,
                    count: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Entry {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response.CompactTable.Entry").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Entry {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Entry {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MapValuesEntry {
            // message fields
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry.key)
            pub key: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry.value)
            pub value: ::protobuf::MessageField<Entry>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MapValuesEntry {
            fn default() -> &'a MapValuesEntry {
                <MapValuesEntry as ::protobuf::Message>::default_instance()
            }
        }

        impl MapValuesEntry {
            pub fn new() -> MapValuesEntry {
                ::std::default::Default::default()
            }

            // optional uint32 key = 1;

            pub fn key(&self) -> u32 {
                self.key.unwrap_or(0)
            }

            pub fn clear_key(&mut self) {
                self.key = ::std::option::Option::None;
            }

            pub fn has_key(&self) -> bool {
                self.key.is_some()
            }

            // Param is passed by value, moved
            pub fn set_key(&mut self, v: u32) {
                self.key = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "key",
                    |m: &MapValuesEntry| { &m.key },
                    |m: &mut MapValuesEntry| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entry>(
                    "value",
                    |m: &MapValuesEntry| { &m.value },
                    |m: &mut MapValuesEntry| { &mut m.value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapValuesEntry>(
                    "CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MapValuesEntry {
            const NAME: &'static str = "MapValuesEntry";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.key = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.key {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.value.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.key {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.value.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MapValuesEntry {
                MapValuesEntry::new()
            }

            fn clear(&mut self) {
                self.key = ::std::option::Option::None;
                self.value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MapValuesEntry {
                static instance: MapValuesEntry = MapValuesEntry {
                    key: ::std::option::Option::None,
                    value: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for MapValuesEntry {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapValuesEntry").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MapValuesEntry {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MapValuesEntry {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MapMappingsEntry {
            // message fields
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry.key)
            pub key: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry.value)
            pub value: ::protobuf::MessageField<Entry>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MapMappingsEntry {
            fn default() -> &'a MapMappingsEntry {
                <MapMappingsEntry as ::protobuf::Message>::default_instance()
            }
        }

        impl MapMappingsEntry {
            pub fn new() -> MapMappingsEntry {
                ::std::default::Default::default()
            }

            // optional uint32 key = 1;

            pub fn key(&self) -> u32 {
                self.key.unwrap_or(0)
            }

            pub fn clear_key(&mut self) {
                self.key = ::std::option::Option::None;
            }

            pub fn has_key(&self) -> bool {
                self.key.is_some()
            }

            // Param is passed by value, moved
            pub fn set_key(&mut self, v: u32) {
                self.key = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "key",
                    |m: &MapMappingsEntry| { &m.key },
                    |m: &mut MapMappingsEntry| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entry>(
                    "value",
                    |m: &MapMappingsEntry| { &m.value },
                    |m: &mut MapMappingsEntry| { &mut m.value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapMappingsEntry>(
                    "CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MapMappingsEntry {
            const NAME: &'static str = "MapMappingsEntry";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.key = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.key {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.value.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.key {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.value.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MapMappingsEntry {
                MapMappingsEntry::new()
            }

            fn clear(&mut self) {
                self.key = ::std::option::Option::None;
                self.value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MapMappingsEntry {
                static instance: MapMappingsEntry = MapMappingsEntry {
                    key: ::std::option::Option::None,
                    value: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for MapMappingsEntry {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response.CompactTable.MapMappingsEntry").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MapMappingsEntry {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MapMappingsEntry {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response.KMeans)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KMeans {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.KMeans.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.KMeans.clusters)
        pub clusters: ::std::vec::Vec<kmeans::Cluster>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.KMeans.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KMeans {
        fn default() -> &'a KMeans {
            <KMeans as ::protobuf::Message>::default_instance()
        }
    }

    impl KMeans {
        pub fn new() -> KMeans {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &KMeans| { &m.name },
                |m: &mut KMeans| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "clusters",
                |m: &KMeans| { &m.clusters },
                |m: &mut KMeans| { &mut m.clusters },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KMeans>(
                "CMsgSteamLearn_InferenceMetadata_Response.KMeans",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for KMeans {
        const NAME: &'static str = "KMeans";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.clusters.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.clusters {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.clusters {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KMeans {
            KMeans::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.clusters.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KMeans {
            static instance: KMeans = KMeans {
                name: ::std::option::Option::None,
                clusters: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for KMeans {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response.KMeans").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for KMeans {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for KMeans {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `KMeans`
    pub mod kmeans {
        // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Cluster {
            // message fields
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster.x)
            pub x: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster.y)
            pub y: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster.radius)
            pub radius: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster.radius_75pct)
            pub radius_75pct: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster.radius_50pct)
            pub radius_50pct: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster.radius_25pct)
            pub radius_25pct: ::std::option::Option<f32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Cluster {
            fn default() -> &'a Cluster {
                <Cluster as ::protobuf::Message>::default_instance()
            }
        }

        impl Cluster {
            pub fn new() -> Cluster {
                ::std::default::Default::default()
            }

            // optional float x = 1;

            pub fn x(&self) -> f32 {
                self.x.unwrap_or(0.)
            }

            pub fn clear_x(&mut self) {
                self.x = ::std::option::Option::None;
            }

            pub fn has_x(&self) -> bool {
                self.x.is_some()
            }

            // Param is passed by value, moved
            pub fn set_x(&mut self, v: f32) {
                self.x = ::std::option::Option::Some(v);
            }

            // optional float y = 2;

            pub fn y(&self) -> f32 {
                self.y.unwrap_or(0.)
            }

            pub fn clear_y(&mut self) {
                self.y = ::std::option::Option::None;
            }

            pub fn has_y(&self) -> bool {
                self.y.is_some()
            }

            // Param is passed by value, moved
            pub fn set_y(&mut self, v: f32) {
                self.y = ::std::option::Option::Some(v);
            }

            // optional float radius = 3;

            pub fn radius(&self) -> f32 {
                self.radius.unwrap_or(0.)
            }

            pub fn clear_radius(&mut self) {
                self.radius = ::std::option::Option::None;
            }

            pub fn has_radius(&self) -> bool {
                self.radius.is_some()
            }

            // Param is passed by value, moved
            pub fn set_radius(&mut self, v: f32) {
                self.radius = ::std::option::Option::Some(v);
            }

            // optional float radius_75pct = 4;

            pub fn radius_75pct(&self) -> f32 {
                self.radius_75pct.unwrap_or(0.)
            }

            pub fn clear_radius_75pct(&mut self) {
                self.radius_75pct = ::std::option::Option::None;
            }

            pub fn has_radius_75pct(&self) -> bool {
                self.radius_75pct.is_some()
            }

            // Param is passed by value, moved
            pub fn set_radius_75pct(&mut self, v: f32) {
                self.radius_75pct = ::std::option::Option::Some(v);
            }

            // optional float radius_50pct = 5;

            pub fn radius_50pct(&self) -> f32 {
                self.radius_50pct.unwrap_or(0.)
            }

            pub fn clear_radius_50pct(&mut self) {
                self.radius_50pct = ::std::option::Option::None;
            }

            pub fn has_radius_50pct(&self) -> bool {
                self.radius_50pct.is_some()
            }

            // Param is passed by value, moved
            pub fn set_radius_50pct(&mut self, v: f32) {
                self.radius_50pct = ::std::option::Option::Some(v);
            }

            // optional float radius_25pct = 6;

            pub fn radius_25pct(&self) -> f32 {
                self.radius_25pct.unwrap_or(0.)
            }

            pub fn clear_radius_25pct(&mut self) {
                self.radius_25pct = ::std::option::Option::None;
            }

            pub fn has_radius_25pct(&self) -> bool {
                self.radius_25pct.is_some()
            }

            // Param is passed by value, moved
            pub fn set_radius_25pct(&mut self, v: f32) {
                self.radius_25pct = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "x",
                    |m: &Cluster| { &m.x },
                    |m: &mut Cluster| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "y",
                    |m: &Cluster| { &m.y },
                    |m: &mut Cluster| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "radius",
                    |m: &Cluster| { &m.radius },
                    |m: &mut Cluster| { &mut m.radius },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "radius_75pct",
                    |m: &Cluster| { &m.radius_75pct },
                    |m: &mut Cluster| { &mut m.radius_75pct },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "radius_50pct",
                    |m: &Cluster| { &m.radius_50pct },
                    |m: &mut Cluster| { &mut m.radius_50pct },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "radius_25pct",
                    |m: &Cluster| { &m.radius_25pct },
                    |m: &mut Cluster| { &mut m.radius_25pct },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cluster>(
                    "CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Cluster {
            const NAME: &'static str = "Cluster";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        13 => {
                            self.x = ::std::option::Option::Some(is.read_float()?);
                        },
                        21 => {
                            self.y = ::std::option::Option::Some(is.read_float()?);
                        },
                        29 => {
                            self.radius = ::std::option::Option::Some(is.read_float()?);
                        },
                        37 => {
                            self.radius_75pct = ::std::option::Option::Some(is.read_float()?);
                        },
                        45 => {
                            self.radius_50pct = ::std::option::Option::Some(is.read_float()?);
                        },
                        53 => {
                            self.radius_25pct = ::std::option::Option::Some(is.read_float()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.x {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.y {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.radius {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.radius_75pct {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.radius_50pct {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.radius_25pct {
                    my_size += 1 + 4;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.x {
                    os.write_float(1, v)?;
                }
                if let Some(v) = self.y {
                    os.write_float(2, v)?;
                }
                if let Some(v) = self.radius {
                    os.write_float(3, v)?;
                }
                if let Some(v) = self.radius_75pct {
                    os.write_float(4, v)?;
                }
                if let Some(v) = self.radius_50pct {
                    os.write_float(5, v)?;
                }
                if let Some(v) = self.radius_25pct {
                    os.write_float(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Cluster {
                Cluster::new()
            }

            fn clear(&mut self) {
                self.x = ::std::option::Option::None;
                self.y = ::std::option::Option::None;
                self.radius = ::std::option::Option::None;
                self.radius_75pct = ::std::option::Option::None;
                self.radius_50pct = ::std::option::Option::None;
                self.radius_25pct = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Cluster {
                static instance: Cluster = Cluster {
                    x: ::std::option::Option::None,
                    y: ::std::option::Option::None,
                    radius: ::std::option::Option::None,
                    radius_75pct: ::std::option::Option::None,
                    radius_50pct: ::std::option::Option::None,
                    radius_25pct: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Cluster {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response.KMeans.Cluster").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Cluster {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Cluster {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SnapshotHistogram {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram.min_value)
        pub min_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram.max_value)
        pub max_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram.num_buckets)
        pub num_buckets: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram.bucket_counts)
        pub bucket_counts: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SnapshotHistogram {
        fn default() -> &'a SnapshotHistogram {
            <SnapshotHistogram as ::protobuf::Message>::default_instance()
        }
    }

    impl SnapshotHistogram {
        pub fn new() -> SnapshotHistogram {
            ::std::default::Default::default()
        }

        // optional float min_value = 1;

        pub fn min_value(&self) -> f32 {
            self.min_value.unwrap_or(0.)
        }

        pub fn clear_min_value(&mut self) {
            self.min_value = ::std::option::Option::None;
        }

        pub fn has_min_value(&self) -> bool {
            self.min_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_min_value(&mut self, v: f32) {
            self.min_value = ::std::option::Option::Some(v);
        }

        // optional float max_value = 2;

        pub fn max_value(&self) -> f32 {
            self.max_value.unwrap_or(0.)
        }

        pub fn clear_max_value(&mut self) {
            self.max_value = ::std::option::Option::None;
        }

        pub fn has_max_value(&self) -> bool {
            self.max_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_value(&mut self, v: f32) {
            self.max_value = ::std::option::Option::Some(v);
        }

        // optional uint32 num_buckets = 3;

        pub fn num_buckets(&self) -> u32 {
            self.num_buckets.unwrap_or(0)
        }

        pub fn clear_num_buckets(&mut self) {
            self.num_buckets = ::std::option::Option::None;
        }

        pub fn has_num_buckets(&self) -> bool {
            self.num_buckets.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_buckets(&mut self, v: u32) {
            self.num_buckets = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "min_value",
                |m: &SnapshotHistogram| { &m.min_value },
                |m: &mut SnapshotHistogram| { &mut m.min_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "max_value",
                |m: &SnapshotHistogram| { &m.max_value },
                |m: &mut SnapshotHistogram| { &mut m.max_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_buckets",
                |m: &SnapshotHistogram| { &m.num_buckets },
                |m: &mut SnapshotHistogram| { &mut m.num_buckets },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "bucket_counts",
                |m: &SnapshotHistogram| { &m.bucket_counts },
                |m: &mut SnapshotHistogram| { &mut m.bucket_counts },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SnapshotHistogram>(
                "CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SnapshotHistogram {
        const NAME: &'static str = "SnapshotHistogram";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.min_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.max_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.num_buckets = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        is.read_repeated_packed_uint32_into(&mut self.bucket_counts)?;
                    },
                    32 => {
                        self.bucket_counts.push(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.min_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.max_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.num_buckets {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            for value in &self.bucket_counts {
                my_size += ::protobuf::rt::uint32_size(4, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.min_value {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.max_value {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.num_buckets {
                os.write_uint32(3, v)?;
            }
            for v in &self.bucket_counts {
                os.write_uint32(4, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SnapshotHistogram {
            SnapshotHistogram::new()
        }

        fn clear(&mut self) {
            self.min_value = ::std::option::Option::None;
            self.max_value = ::std::option::Option::None;
            self.num_buckets = ::std::option::Option::None;
            self.bucket_counts.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SnapshotHistogram {
            static instance: SnapshotHistogram = SnapshotHistogram {
                min_value: ::std::option::Option::None,
                max_value: ::std::option::Option::None,
                num_buckets: ::std::option::Option::None,
                bucket_counts: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SnapshotHistogram {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceMetadata_Response.SnapshotHistogram").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SnapshotHistogram {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SnapshotHistogram {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearn_InferenceBackend_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_InferenceBackend_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceBackend_Response.outputs)
    pub outputs: ::std::vec::Vec<cmsg_steam_learn_inference_backend_response::Output>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceBackend_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_InferenceBackend_Response {
    fn default() -> &'a CMsgSteamLearn_InferenceBackend_Response {
        <CMsgSteamLearn_InferenceBackend_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_InferenceBackend_Response {
    pub fn new() -> CMsgSteamLearn_InferenceBackend_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outputs",
            |m: &CMsgSteamLearn_InferenceBackend_Response| { &m.outputs },
            |m: &mut CMsgSteamLearn_InferenceBackend_Response| { &mut m.outputs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_InferenceBackend_Response>(
            "CMsgSteamLearn_InferenceBackend_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_InferenceBackend_Response {
    const NAME: &'static str = "CMsgSteamLearn_InferenceBackend_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.outputs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.outputs {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_InferenceBackend_Response {
        CMsgSteamLearn_InferenceBackend_Response::new()
    }

    fn clear(&mut self) {
        self.outputs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_InferenceBackend_Response {
        static instance: CMsgSteamLearn_InferenceBackend_Response = CMsgSteamLearn_InferenceBackend_Response {
            outputs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_InferenceBackend_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceBackend_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_InferenceBackend_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_InferenceBackend_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamLearn_InferenceBackend_Response`
pub mod cmsg_steam_learn_inference_backend_response {
    // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BinaryCrossEntropyOutput {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput.value)
        pub value: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BinaryCrossEntropyOutput {
        fn default() -> &'a BinaryCrossEntropyOutput {
            <BinaryCrossEntropyOutput as ::protobuf::Message>::default_instance()
        }
    }

    impl BinaryCrossEntropyOutput {
        pub fn new() -> BinaryCrossEntropyOutput {
            ::std::default::Default::default()
        }

        // optional float value = 1;

        pub fn value(&self) -> f32 {
            self.value.unwrap_or(0.)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: f32) {
            self.value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &BinaryCrossEntropyOutput| { &m.value },
                |m: &mut BinaryCrossEntropyOutput| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BinaryCrossEntropyOutput>(
                "CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for BinaryCrossEntropyOutput {
        const NAME: &'static str = "BinaryCrossEntropyOutput";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.value = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.value {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.value {
                os.write_float(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BinaryCrossEntropyOutput {
            BinaryCrossEntropyOutput::new()
        }

        fn clear(&mut self) {
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BinaryCrossEntropyOutput {
            static instance: BinaryCrossEntropyOutput = BinaryCrossEntropyOutput {
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for BinaryCrossEntropyOutput {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BinaryCrossEntropyOutput {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for BinaryCrossEntropyOutput {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MutliBinaryCrossEntropyOutput {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput.weight)
        pub weight: ::std::vec::Vec<f32>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput.value)
        pub value: ::std::vec::Vec<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MutliBinaryCrossEntropyOutput {
        fn default() -> &'a MutliBinaryCrossEntropyOutput {
            <MutliBinaryCrossEntropyOutput as ::protobuf::Message>::default_instance()
        }
    }

    impl MutliBinaryCrossEntropyOutput {
        pub fn new() -> MutliBinaryCrossEntropyOutput {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "weight",
                |m: &MutliBinaryCrossEntropyOutput| { &m.weight },
                |m: &mut MutliBinaryCrossEntropyOutput| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "value",
                |m: &MutliBinaryCrossEntropyOutput| { &m.value },
                |m: &mut MutliBinaryCrossEntropyOutput| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MutliBinaryCrossEntropyOutput>(
                "CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for MutliBinaryCrossEntropyOutput {
        const NAME: &'static str = "MutliBinaryCrossEntropyOutput";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_float_into(&mut self.weight)?;
                    },
                    13 => {
                        self.weight.push(is.read_float()?);
                    },
                    18 => {
                        is.read_repeated_packed_float_into(&mut self.value)?;
                    },
                    21 => {
                        self.value.push(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += 5 * self.weight.len() as u64;
            my_size += 5 * self.value.len() as u64;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.weight {
                os.write_float(1, *v)?;
            };
            for v in &self.value {
                os.write_float(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MutliBinaryCrossEntropyOutput {
            MutliBinaryCrossEntropyOutput::new()
        }

        fn clear(&mut self) {
            self.weight.clear();
            self.value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MutliBinaryCrossEntropyOutput {
            static instance: MutliBinaryCrossEntropyOutput = MutliBinaryCrossEntropyOutput {
                weight: ::std::vec::Vec::new(),
                value: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for MutliBinaryCrossEntropyOutput {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MutliBinaryCrossEntropyOutput {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MutliBinaryCrossEntropyOutput {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CategoricalCrossEntropyOutput {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput.weight)
        pub weight: ::std::vec::Vec<f32>,
        // @@protoc_insertion_point(field:CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput.value)
        pub value: ::std::vec::Vec<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CategoricalCrossEntropyOutput {
        fn default() -> &'a CategoricalCrossEntropyOutput {
            <CategoricalCrossEntropyOutput as ::protobuf::Message>::default_instance()
        }
    }

    impl CategoricalCrossEntropyOutput {
        pub fn new() -> CategoricalCrossEntropyOutput {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "weight",
                |m: &CategoricalCrossEntropyOutput| { &m.weight },
                |m: &mut CategoricalCrossEntropyOutput| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "value",
                |m: &CategoricalCrossEntropyOutput| { &m.value },
                |m: &mut CategoricalCrossEntropyOutput| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CategoricalCrossEntropyOutput>(
                "CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CategoricalCrossEntropyOutput {
        const NAME: &'static str = "CategoricalCrossEntropyOutput";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_float_into(&mut self.weight)?;
                    },
                    13 => {
                        self.weight.push(is.read_float()?);
                    },
                    18 => {
                        is.read_repeated_packed_float_into(&mut self.value)?;
                    },
                    21 => {
                        self.value.push(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += 5 * self.weight.len() as u64;
            my_size += 5 * self.value.len() as u64;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.weight {
                os.write_float(1, *v)?;
            };
            for v in &self.value {
                os.write_float(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CategoricalCrossEntropyOutput {
            CategoricalCrossEntropyOutput::new()
        }

        fn clear(&mut self) {
            self.weight.clear();
            self.value.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CategoricalCrossEntropyOutput {
            static instance: CategoricalCrossEntropyOutput = CategoricalCrossEntropyOutput {
                weight: ::std::vec::Vec::new(),
                value: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CategoricalCrossEntropyOutput {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CategoricalCrossEntropyOutput {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CategoricalCrossEntropyOutput {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamLearn_InferenceBackend_Response.Output)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Output {
        // message oneof groups
        pub ResponseType: ::std::option::Option<output::ResponseType>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearn_InferenceBackend_Response.Output.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Output {
        fn default() -> &'a Output {
            <Output as ::protobuf::Message>::default_instance()
        }
    }

    impl Output {
        pub fn new() -> Output {
            ::std::default::Default::default()
        }

        // optional .CMsgSteamLearn_InferenceBackend_Response.BinaryCrossEntropyOutput binary_crossentropy = 1;

        pub fn binary_crossentropy(&self) -> &BinaryCrossEntropyOutput {
            match self.ResponseType {
                ::std::option::Option::Some(output::ResponseType::BinaryCrossentropy(ref v)) => v,
                _ => <BinaryCrossEntropyOutput as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_binary_crossentropy(&mut self) {
            self.ResponseType = ::std::option::Option::None;
        }

        pub fn has_binary_crossentropy(&self) -> bool {
            match self.ResponseType {
                ::std::option::Option::Some(output::ResponseType::BinaryCrossentropy(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_binary_crossentropy(&mut self, v: BinaryCrossEntropyOutput) {
            self.ResponseType = ::std::option::Option::Some(output::ResponseType::BinaryCrossentropy(v))
        }

        // Mutable pointer to the field.
        pub fn mut_binary_crossentropy(&mut self) -> &mut BinaryCrossEntropyOutput {
            if let ::std::option::Option::Some(output::ResponseType::BinaryCrossentropy(_)) = self.ResponseType {
            } else {
                self.ResponseType = ::std::option::Option::Some(output::ResponseType::BinaryCrossentropy(BinaryCrossEntropyOutput::new()));
            }
            match self.ResponseType {
                ::std::option::Option::Some(output::ResponseType::BinaryCrossentropy(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_binary_crossentropy(&mut self) -> BinaryCrossEntropyOutput {
            if self.has_binary_crossentropy() {
                match self.ResponseType.take() {
                    ::std::option::Option::Some(output::ResponseType::BinaryCrossentropy(v)) => v,
                    _ => panic!(),
                }
            } else {
                BinaryCrossEntropyOutput::new()
            }
        }

        // optional .CMsgSteamLearn_InferenceBackend_Response.CategoricalCrossEntropyOutput categorical_crossentropy = 2;

        pub fn categorical_crossentropy(&self) -> &CategoricalCrossEntropyOutput {
            match self.ResponseType {
                ::std::option::Option::Some(output::ResponseType::CategoricalCrossentropy(ref v)) => v,
                _ => <CategoricalCrossEntropyOutput as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_categorical_crossentropy(&mut self) {
            self.ResponseType = ::std::option::Option::None;
        }

        pub fn has_categorical_crossentropy(&self) -> bool {
            match self.ResponseType {
                ::std::option::Option::Some(output::ResponseType::CategoricalCrossentropy(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_categorical_crossentropy(&mut self, v: CategoricalCrossEntropyOutput) {
            self.ResponseType = ::std::option::Option::Some(output::ResponseType::CategoricalCrossentropy(v))
        }

        // Mutable pointer to the field.
        pub fn mut_categorical_crossentropy(&mut self) -> &mut CategoricalCrossEntropyOutput {
            if let ::std::option::Option::Some(output::ResponseType::CategoricalCrossentropy(_)) = self.ResponseType {
            } else {
                self.ResponseType = ::std::option::Option::Some(output::ResponseType::CategoricalCrossentropy(CategoricalCrossEntropyOutput::new()));
            }
            match self.ResponseType {
                ::std::option::Option::Some(output::ResponseType::CategoricalCrossentropy(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_categorical_crossentropy(&mut self) -> CategoricalCrossEntropyOutput {
            if self.has_categorical_crossentropy() {
                match self.ResponseType.take() {
                    ::std::option::Option::Some(output::ResponseType::CategoricalCrossentropy(v)) => v,
                    _ => panic!(),
                }
            } else {
                CategoricalCrossEntropyOutput::new()
            }
        }

        // optional .CMsgSteamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutput multi_binary_crossentropy = 3;

        pub fn multi_binary_crossentropy(&self) -> &MutliBinaryCrossEntropyOutput {
            match self.ResponseType {
                ::std::option::Option::Some(output::ResponseType::MultiBinaryCrossentropy(ref v)) => v,
                _ => <MutliBinaryCrossEntropyOutput as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_multi_binary_crossentropy(&mut self) {
            self.ResponseType = ::std::option::Option::None;
        }

        pub fn has_multi_binary_crossentropy(&self) -> bool {
            match self.ResponseType {
                ::std::option::Option::Some(output::ResponseType::MultiBinaryCrossentropy(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_multi_binary_crossentropy(&mut self, v: MutliBinaryCrossEntropyOutput) {
            self.ResponseType = ::std::option::Option::Some(output::ResponseType::MultiBinaryCrossentropy(v))
        }

        // Mutable pointer to the field.
        pub fn mut_multi_binary_crossentropy(&mut self) -> &mut MutliBinaryCrossEntropyOutput {
            if let ::std::option::Option::Some(output::ResponseType::MultiBinaryCrossentropy(_)) = self.ResponseType {
            } else {
                self.ResponseType = ::std::option::Option::Some(output::ResponseType::MultiBinaryCrossentropy(MutliBinaryCrossEntropyOutput::new()));
            }
            match self.ResponseType {
                ::std::option::Option::Some(output::ResponseType::MultiBinaryCrossentropy(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_multi_binary_crossentropy(&mut self) -> MutliBinaryCrossEntropyOutput {
            if self.has_multi_binary_crossentropy() {
                match self.ResponseType.take() {
                    ::std::option::Option::Some(output::ResponseType::MultiBinaryCrossentropy(v)) => v,
                    _ => panic!(),
                }
            } else {
                MutliBinaryCrossEntropyOutput::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BinaryCrossEntropyOutput>(
                "binary_crossentropy",
                Output::has_binary_crossentropy,
                Output::binary_crossentropy,
                Output::mut_binary_crossentropy,
                Output::set_binary_crossentropy,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CategoricalCrossEntropyOutput>(
                "categorical_crossentropy",
                Output::has_categorical_crossentropy,
                Output::categorical_crossentropy,
                Output::mut_categorical_crossentropy,
                Output::set_categorical_crossentropy,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MutliBinaryCrossEntropyOutput>(
                "multi_binary_crossentropy",
                Output::has_multi_binary_crossentropy,
                Output::multi_binary_crossentropy,
                Output::mut_multi_binary_crossentropy,
                Output::set_multi_binary_crossentropy,
            ));
            oneofs.push(output::ResponseType::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Output>(
                "CMsgSteamLearn_InferenceBackend_Response.Output",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Output {
        const NAME: &'static str = "Output";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.ResponseType = ::std::option::Option::Some(output::ResponseType::BinaryCrossentropy(is.read_message()?));
                    },
                    18 => {
                        self.ResponseType = ::std::option::Option::Some(output::ResponseType::CategoricalCrossentropy(is.read_message()?));
                    },
                    26 => {
                        self.ResponseType = ::std::option::Option::Some(output::ResponseType::MultiBinaryCrossentropy(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.ResponseType {
                match v {
                    &output::ResponseType::BinaryCrossentropy(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &output::ResponseType::CategoricalCrossentropy(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &output::ResponseType::MultiBinaryCrossentropy(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.ResponseType {
                match v {
                    &output::ResponseType::BinaryCrossentropy(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                    },
                    &output::ResponseType::CategoricalCrossentropy(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                    },
                    &output::ResponseType::MultiBinaryCrossentropy(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Output {
            Output::new()
        }

        fn clear(&mut self) {
            self.ResponseType = ::std::option::Option::None;
            self.ResponseType = ::std::option::Option::None;
            self.ResponseType = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Output {
            static instance: Output = Output {
                ResponseType: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Output {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamLearn_InferenceBackend_Response.Output").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Output {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Output {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Output`
    pub mod output {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:CMsgSteamLearn_InferenceBackend_Response.Output.ResponseType)
        pub enum ResponseType {
            // @@protoc_insertion_point(oneof_field:CMsgSteamLearn_InferenceBackend_Response.Output.binary_crossentropy)
            BinaryCrossentropy(super::BinaryCrossEntropyOutput),
            // @@protoc_insertion_point(oneof_field:CMsgSteamLearn_InferenceBackend_Response.Output.categorical_crossentropy)
            CategoricalCrossentropy(super::CategoricalCrossEntropyOutput),
            // @@protoc_insertion_point(oneof_field:CMsgSteamLearn_InferenceBackend_Response.Output.multi_binary_crossentropy)
            MultiBinaryCrossentropy(super::MutliBinaryCrossEntropyOutput),
        }

        impl ::protobuf::Oneof for ResponseType {
        }

        impl ::protobuf::OneofFull for ResponseType {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Output as ::protobuf::MessageFull>::descriptor().oneof_by_name("ResponseType").unwrap()).clone()
            }
        }

        impl ResponseType {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<ResponseType>("ResponseType")
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearn_Inference_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearn_Inference_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearn_Inference_Response.inference_result)
    pub inference_result: ::std::option::Option<::protobuf::EnumOrUnknown<ESteamLearnInferenceResult>>,
    // @@protoc_insertion_point(field:CMsgSteamLearn_Inference_Response.backend_response)
    pub backend_response: ::protobuf::MessageField<CMsgSteamLearn_InferenceBackend_Response>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearn_Inference_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearn_Inference_Response {
    fn default() -> &'a CMsgSteamLearn_Inference_Response {
        <CMsgSteamLearn_Inference_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearn_Inference_Response {
    pub fn new() -> CMsgSteamLearn_Inference_Response {
        ::std::default::Default::default()
    }

    // optional .ESteamLearnInferenceResult inference_result = 1;

    pub fn inference_result(&self) -> ESteamLearnInferenceResult {
        match self.inference_result {
            Some(e) => e.enum_value_or(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR),
            None => ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR,
        }
    }

    pub fn clear_inference_result(&mut self) {
        self.inference_result = ::std::option::Option::None;
    }

    pub fn has_inference_result(&self) -> bool {
        self.inference_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inference_result(&mut self, v: ESteamLearnInferenceResult) {
        self.inference_result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inference_result",
            |m: &CMsgSteamLearn_Inference_Response| { &m.inference_result },
            |m: &mut CMsgSteamLearn_Inference_Response| { &mut m.inference_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamLearn_InferenceBackend_Response>(
            "backend_response",
            |m: &CMsgSteamLearn_Inference_Response| { &m.backend_response },
            |m: &mut CMsgSteamLearn_Inference_Response| { &mut m.backend_response },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamLearn_Inference_Response>(
            "CMsgSteamLearn_Inference_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamLearn_Inference_Response {
    const NAME: &'static str = "CMsgSteamLearn_Inference_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.inference_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.backend_response)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.inference_result {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.backend_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.inference_result {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.backend_response.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearn_Inference_Response {
        CMsgSteamLearn_Inference_Response::new()
    }

    fn clear(&mut self) {
        self.inference_result = ::std::option::Option::None;
        self.backend_response.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearn_Inference_Response {
        static instance: CMsgSteamLearn_Inference_Response = CMsgSteamLearn_Inference_Response {
            inference_result: ::std::option::Option::None,
            backend_response: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamLearn_Inference_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamLearn_Inference_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamLearn_Inference_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamLearn_Inference_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamLearnDataType)
pub enum ESteamLearnDataType {
    // @@protoc_insertion_point(enum_value:ESteamLearnDataType.STEAMLEARN_DATATYPE_INVALID)
    STEAMLEARN_DATATYPE_INVALID = 0,
    // @@protoc_insertion_point(enum_value:ESteamLearnDataType.STEAMLEARN_DATATYPE_INT32)
    STEAMLEARN_DATATYPE_INT32 = 1,
    // @@protoc_insertion_point(enum_value:ESteamLearnDataType.STEAMLEARN_DATATYPE_FLOAT32)
    STEAMLEARN_DATATYPE_FLOAT32 = 2,
    // @@protoc_insertion_point(enum_value:ESteamLearnDataType.STEAMLEARN_DATATYPE_BOOL)
    STEAMLEARN_DATATYPE_BOOL = 3,
    // @@protoc_insertion_point(enum_value:ESteamLearnDataType.STEAMLEARN_DATATYPE_STRING)
    STEAMLEARN_DATATYPE_STRING = 4,
    // @@protoc_insertion_point(enum_value:ESteamLearnDataType.STEAMLEARN_DATATYPE_OBJECT)
    STEAMLEARN_DATATYPE_OBJECT = 5,
}

impl ::protobuf::Enum for ESteamLearnDataType {
    const NAME: &'static str = "ESteamLearnDataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamLearnDataType> {
        match value {
            0 => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_INVALID),
            1 => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_INT32),
            2 => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_FLOAT32),
            3 => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_BOOL),
            4 => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_STRING),
            5 => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_OBJECT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamLearnDataType> {
        match str {
            "STEAMLEARN_DATATYPE_INVALID" => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_INVALID),
            "STEAMLEARN_DATATYPE_INT32" => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_INT32),
            "STEAMLEARN_DATATYPE_FLOAT32" => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_FLOAT32),
            "STEAMLEARN_DATATYPE_BOOL" => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_BOOL),
            "STEAMLEARN_DATATYPE_STRING" => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_STRING),
            "STEAMLEARN_DATATYPE_OBJECT" => ::std::option::Option::Some(ESteamLearnDataType::STEAMLEARN_DATATYPE_OBJECT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamLearnDataType] = &[
        ESteamLearnDataType::STEAMLEARN_DATATYPE_INVALID,
        ESteamLearnDataType::STEAMLEARN_DATATYPE_INT32,
        ESteamLearnDataType::STEAMLEARN_DATATYPE_FLOAT32,
        ESteamLearnDataType::STEAMLEARN_DATATYPE_BOOL,
        ESteamLearnDataType::STEAMLEARN_DATATYPE_STRING,
        ESteamLearnDataType::STEAMLEARN_DATATYPE_OBJECT,
    ];
}

impl ::protobuf::EnumFull for ESteamLearnDataType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamLearnDataType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamLearnDataType {
    fn default() -> Self {
        ESteamLearnDataType::STEAMLEARN_DATATYPE_INVALID
    }
}

impl ESteamLearnDataType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamLearnDataType>("ESteamLearnDataType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteammLearnRegisterDataSourceResult)
pub enum ESteammLearnRegisterDataSourceResult {
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR = 0,
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED = 1,
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND = 2,
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC = 3,
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME = 4,
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION = 5,
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED = 6,
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID = 7,
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN = 8,
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP = 9,
    // @@protoc_insertion_point(enum_value:ESteammLearnRegisterDataSourceResult.STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED)
    STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED = 10,
}

impl ::protobuf::Enum for ESteammLearnRegisterDataSourceResult {
    const NAME: &'static str = "ESteammLearnRegisterDataSourceResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteammLearnRegisterDataSourceResult> {
        match value {
            0 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR),
            1 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED),
            2 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND),
            3 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC),
            4 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME),
            5 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION),
            6 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED),
            7 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID),
            8 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN),
            9 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP),
            10 => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteammLearnRegisterDataSourceResult> {
        match str {
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR),
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED),
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND),
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC),
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME),
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION),
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED),
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID),
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN),
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP),
            "STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED" => ::std::option::Option::Some(ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteammLearnRegisterDataSourceResult] = &[
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR,
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_CREATED,
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_SUCCESS_FOUND,
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_GENERIC,
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_NAME,
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_VERSION,
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_CHANGED,
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_DATA_INVALID,
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_FORBIDDEN,
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP,
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_DISABLED,
    ];
}

impl ::protobuf::EnumFull for ESteammLearnRegisterDataSourceResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteammLearnRegisterDataSourceResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteammLearnRegisterDataSourceResult {
    fn default() -> Self {
        ESteammLearnRegisterDataSourceResult::STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR
    }
}

impl ESteammLearnRegisterDataSourceResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteammLearnRegisterDataSourceResult>("ESteammLearnRegisterDataSourceResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamLearnCacheDataResult)
pub enum ESteamLearnCacheDataResult {
    // @@protoc_insertion_point(enum_value:ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR)
    STEAMLEARN_CACHE_DATA_ERROR = 0,
    // @@protoc_insertion_point(enum_value:ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_SUCCESS)
    STEAMLEARN_CACHE_DATA_SUCCESS = 1,
    // @@protoc_insertion_point(enum_value:ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE)
    STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE = 2,
    // @@protoc_insertion_point(enum_value:ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE)
    STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE = 3,
    // @@protoc_insertion_point(enum_value:ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS)
    STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS = 4,
    // @@protoc_insertion_point(enum_value:ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN)
    STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN = 5,
    // @@protoc_insertion_point(enum_value:ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP)
    STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP = 6,
    // @@protoc_insertion_point(enum_value:ESteamLearnCacheDataResult.STEAMLEARN_CACHE_DATA_DISABLED)
    STEAMLEARN_CACHE_DATA_DISABLED = 7,
}

impl ::protobuf::Enum for ESteamLearnCacheDataResult {
    const NAME: &'static str = "ESteamLearnCacheDataResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamLearnCacheDataResult> {
        match value {
            0 => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR),
            1 => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_SUCCESS),
            2 => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE),
            3 => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE),
            4 => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS),
            5 => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN),
            6 => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP),
            7 => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_DISABLED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamLearnCacheDataResult> {
        match str {
            "STEAMLEARN_CACHE_DATA_ERROR" => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR),
            "STEAMLEARN_CACHE_DATA_SUCCESS" => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_SUCCESS),
            "STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE" => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE),
            "STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE" => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE),
            "STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS" => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS),
            "STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN" => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN),
            "STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP" => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP),
            "STEAMLEARN_CACHE_DATA_DISABLED" => ::std::option::Option::Some(ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_DISABLED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamLearnCacheDataResult] = &[
        ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR,
        ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_SUCCESS,
        ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_DATA_SOURCE,
        ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOURCE,
        ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS,
        ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN,
        ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR_INVALID_TIMESTAMP,
        ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_DISABLED,
    ];
}

impl ::protobuf::EnumFull for ESteamLearnCacheDataResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamLearnCacheDataResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamLearnCacheDataResult {
    fn default() -> Self {
        ESteamLearnCacheDataResult::STEAMLEARN_CACHE_DATA_ERROR
    }
}

impl ESteamLearnCacheDataResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamLearnCacheDataResult>("ESteamLearnCacheDataResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamLearnSnapshotProjectResult)
pub enum ESteamLearnSnapshotProjectResult {
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR)
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR = 0,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED)
    STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED = 1,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED)
    STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED = 2,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID)
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID = 3,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE)
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE = 4,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY)
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY = 5,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION)
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION = 6,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG)
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG = 7,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN)
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN = 8,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP)
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP = 9,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR)
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR = 10,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_DISABLED)
    STEAMLEARN_SNAPSHOT_PROJECT_DISABLED = 11,
    // @@protoc_insertion_point(enum_value:ESteamLearnSnapshotProjectResult.STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION)
    STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION = 12,
}

impl ::protobuf::Enum for ESteamLearnSnapshotProjectResult {
    const NAME: &'static str = "ESteamLearnSnapshotProjectResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamLearnSnapshotProjectResult> {
        match value {
            0 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR),
            1 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED),
            2 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED),
            3 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID),
            4 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE),
            5 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY),
            6 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION),
            7 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG),
            8 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN),
            9 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP),
            10 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR),
            11 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_DISABLED),
            12 => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamLearnSnapshotProjectResult> {
        match str {
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR),
            "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED),
            "STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED),
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID),
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE),
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY),
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION),
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG),
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN),
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP),
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR),
            "STEAMLEARN_SNAPSHOT_PROJECT_DISABLED" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_DISABLED),
            "STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION" => ::std::option::Option::Some(ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamLearnSnapshotProjectResult] = &[
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_STORED,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUED,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KEY,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATION,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_DISABLED,
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PUBLISHED_VERSION,
    ];
}

impl ::protobuf::EnumFull for ESteamLearnSnapshotProjectResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamLearnSnapshotProjectResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamLearnSnapshotProjectResult {
    fn default() -> Self {
        ESteamLearnSnapshotProjectResult::STEAMLEARN_SNAPSHOT_PROJECT_ERROR
    }
}

impl ESteamLearnSnapshotProjectResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamLearnSnapshotProjectResult>("ESteamLearnSnapshotProjectResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamLearnGetHMACKeysResult)
pub enum ESteamLearnGetHMACKeysResult {
    // @@protoc_insertion_point(enum_value:ESteamLearnGetHMACKeysResult.STEAMLEARN_GET_HMAC_KEYS_SUCCESS)
    STEAMLEARN_GET_HMAC_KEYS_SUCCESS = 0,
}

impl ::protobuf::Enum for ESteamLearnGetHMACKeysResult {
    const NAME: &'static str = "ESteamLearnGetHMACKeysResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamLearnGetHMACKeysResult> {
        match value {
            0 => ::std::option::Option::Some(ESteamLearnGetHMACKeysResult::STEAMLEARN_GET_HMAC_KEYS_SUCCESS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamLearnGetHMACKeysResult> {
        match str {
            "STEAMLEARN_GET_HMAC_KEYS_SUCCESS" => ::std::option::Option::Some(ESteamLearnGetHMACKeysResult::STEAMLEARN_GET_HMAC_KEYS_SUCCESS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamLearnGetHMACKeysResult] = &[
        ESteamLearnGetHMACKeysResult::STEAMLEARN_GET_HMAC_KEYS_SUCCESS,
    ];
}

impl ::protobuf::EnumFull for ESteamLearnGetHMACKeysResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamLearnGetHMACKeysResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamLearnGetHMACKeysResult {
    fn default() -> Self {
        ESteamLearnGetHMACKeysResult::STEAMLEARN_GET_HMAC_KEYS_SUCCESS
    }
}

impl ESteamLearnGetHMACKeysResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamLearnGetHMACKeysResult>("ESteamLearnGetHMACKeysResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamLearnInferenceResult)
pub enum ESteamLearnInferenceResult {
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR)
    STEAMLEARN_INFERENCE_ERROR = 0,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_SUCCESS)
    STEAMLEARN_INFERENCE_SUCCESS = 1,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID)
    STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID = 2,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA)
    STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA = 3,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG)
    STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG = 4,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_FORBIDDEN)
    STEAMLEARN_INFERENCE_ERROR_FORBIDDEN = 5,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP)
    STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP = 6,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION)
    STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION = 7,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND)
    STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND = 8,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceResult.STEAMLEARN_INFERENCE_ERROR_TOO_BUSY)
    STEAMLEARN_INFERENCE_ERROR_TOO_BUSY = 9,
}

impl ::protobuf::Enum for ESteamLearnInferenceResult {
    const NAME: &'static str = "ESteamLearnInferenceResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamLearnInferenceResult> {
        match value {
            0 => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR),
            1 => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_SUCCESS),
            2 => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID),
            3 => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA),
            4 => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG),
            5 => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_FORBIDDEN),
            6 => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP),
            7 => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION),
            8 => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND),
            9 => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_TOO_BUSY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamLearnInferenceResult> {
        match str {
            "STEAMLEARN_INFERENCE_ERROR" => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR),
            "STEAMLEARN_INFERENCE_SUCCESS" => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_SUCCESS),
            "STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID" => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID),
            "STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA" => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA),
            "STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG" => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG),
            "STEAMLEARN_INFERENCE_ERROR_FORBIDDEN" => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_FORBIDDEN),
            "STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP" => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP),
            "STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION" => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION),
            "STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND" => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND),
            "STEAMLEARN_INFERENCE_ERROR_TOO_BUSY" => ::std::option::Option::Some(ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_TOO_BUSY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamLearnInferenceResult] = &[
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR,
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_SUCCESS,
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_INVALID_PROJECT_ID,
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_MISSING_CACHED_SCHEMA_DATA,
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_NO_PUBLISHED_CONFIG,
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_FORBIDDEN,
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP,
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION,
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND,
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR_TOO_BUSY,
    ];
}

impl ::protobuf::EnumFull for ESteamLearnInferenceResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamLearnInferenceResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamLearnInferenceResult {
    fn default() -> Self {
        ESteamLearnInferenceResult::STEAMLEARN_INFERENCE_ERROR
    }
}

impl ESteamLearnInferenceResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamLearnInferenceResult>("ESteamLearnInferenceResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamLearnInferenceMetadataResult)
pub enum ESteamLearnInferenceMetadataResult {
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR)
    STEAMLEARN_INFERENCE_METADATA_ERROR = 0,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_SUCCESS)
    STEAMLEARN_INFERENCE_METADATA_SUCCESS = 1,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID)
    STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID = 2,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG)
    STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG = 3,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN)
    STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN = 4,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP)
    STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP = 5,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION)
    STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION = 6,
    // @@protoc_insertion_point(enum_value:ESteamLearnInferenceMetadataResult.STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND)
    STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND = 7,
}

impl ::protobuf::Enum for ESteamLearnInferenceMetadataResult {
    const NAME: &'static str = "ESteamLearnInferenceMetadataResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamLearnInferenceMetadataResult> {
        match value {
            0 => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR),
            1 => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_SUCCESS),
            2 => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID),
            3 => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG),
            4 => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN),
            5 => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP),
            6 => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION),
            7 => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamLearnInferenceMetadataResult> {
        match str {
            "STEAMLEARN_INFERENCE_METADATA_ERROR" => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR),
            "STEAMLEARN_INFERENCE_METADATA_SUCCESS" => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_SUCCESS),
            "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID" => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID),
            "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG" => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG),
            "STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN" => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN),
            "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP" => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP),
            "STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION" => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION),
            "STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND" => ::std::option::Option::Some(ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamLearnInferenceMetadataResult] = &[
        ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR,
        ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_SUCCESS,
        ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PROJECT_ID,
        ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_NO_PUBLISHED_CONFIG,
        ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_FORBIDDEN,
        ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_TIMESTAMP,
        ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID_PUBLISHED_VERSION,
        ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR_NO_FETCH_ID_FOUND,
    ];
}

impl ::protobuf::EnumFull for ESteamLearnInferenceMetadataResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamLearnInferenceMetadataResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamLearnInferenceMetadataResult {
    fn default() -> Self {
        ESteamLearnInferenceMetadataResult::STEAMLEARN_INFERENCE_METADATA_ERROR
    }
}

impl ESteamLearnInferenceMetadataResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamLearnInferenceMetadataResult>("ESteamLearnInferenceMetadataResult")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n,steammessages_steamlearn.steamworkssdk.proto\x1a.steammessages_unifie\
    d_base.steamworkssdk.proto\"f\n\"CMsgSteamLearnDataSourceDescObject\x12@\
    \n\x08elements\x18\x01\x20\x03(\x0b2$.CMsgSteamLearnDataSourceDescElemen\
    tR\x08elements\"\xdc\x01\n#CMsgSteamLearnDataSourceDescElement\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12N\n\tdata_type\x18\x02\x20\x01(\
    \x0e2\x14.ESteamLearnDataType:\x1bSTEAMLEARN_DATATYPE_INVALIDR\x08dataTy\
    pe\x12;\n\x06object\x18\x03\x20\x01(\x0b2#.CMsgSteamLearnDataSourceDescO\
    bjectR\x06object\x12\x14\n\x05count\x18\x04\x20\x01(\rR\x05count\"\xa5\
    \x02\n\x18CMsgSteamLearnDataSource\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\
    \x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x18\n\x07versio\
    n\x18\x03\x20\x01(\rR\x07version\x12-\n\x12source_description\x18\x04\
    \x20\x01(\tR\x11sourceDescription\x12A\n\tstructure\x18\x05\x20\x01(\x0b\
    2#.CMsgSteamLearnDataSourceDescObjectR\tstructure\x12#\n\rstructure_crc\
    \x18\x06\x20\x01(\rR\x0cstructureCrc\x124\n\x16cache_duration_seconds\
    \x18\x07\x20\x01(\rR\x14cacheDurationSeconds\"R\n\x18CMsgSteamLearnDataO\
    bject\x126\n\x08elements\x18\x01\x20\x03(\x0b2\x1a.CMsgSteamLearnDataEle\
    mentR\x08elements\"\xf1\x01\n\x19CMsgSteamLearnDataElement\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x12\x1f\n\x0bdata_int32s\x18\x14\x20\
    \x03(\x05R\ndataInt32s\x12\x1f\n\x0bdata_floats\x18\x15\x20\x03(\x02R\nd\
    ataFloats\x12\x1d\n\ndata_bools\x18\x16\x20\x03(\x08R\tdataBools\x12!\n\
    \x0cdata_strings\x18\x17\x20\x03(\tR\x0bdataStrings\x12<\n\x0cdata_objec\
    ts\x18\x18\x20\x03(\x0b2\x19.CMsgSteamLearnDataObjectR\x0bdataObjects\"\
    \x8a\x01\n\x12CMsgSteamLearnData\x12$\n\x0edata_source_id\x18\x01\x20\
    \x01(\rR\x0cdataSourceId\x12\x12\n\x04keys\x18\x02\x20\x03(\x04R\x04keys\
    \x12:\n\x0bdata_object\x18\x03\x20\x01(\x0b2\x19.CMsgSteamLearnDataObjec\
    tR\ndataObject\"A\n\x16CMsgSteamLearnDataList\x12'\n\x04data\x18\x01\x20\
    \x03(\x0b2\x13.CMsgSteamLearnDataR\x04data\"\x7f\n\x19CMsgSteamLearn_Acc\
    essData\x12!\n\x0cpublisher_id\x18\x01\x20\x01(\rR\x0bpublisherId\x12\
    \x1c\n\ttimestamp\x18\x02\x20\x01(\rR\ttimestamp\x12!\n\x0crandom_value\
    \x18\x03\x20\x01(\x04R\x0brandomValue\"\xc7\x01\n)CMsgSteamLearn_Registe\
    rDataSource_Request\x12!\n\x0caccess_token\x18\x01\x20\x01(\tR\x0baccess\
    Token\x12;\n\x0baccess_data\x18\x02\x20\x01(\x0b2\x1a.CMsgSteamLearn_Acc\
    essDataR\naccessData\x12:\n\x0bdata_source\x18\x03\x20\x01(\x0b2\x19.CMs\
    gSteamLearnDataSourceR\ndataSource\"\xd5\x01\n*CMsgSteamLearn_RegisterDa\
    taSource_Response\x12k\n\x06result\x18\x01\x20\x01(\x0e2%.ESteammLearnRe\
    gisterDataSourceResult:,STEAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERRORR\
    \x06result\x12:\n\x0bdata_source\x18\x02\x20\x01(\x0b2\x19.CMsgSteamLear\
    nDataSourceR\ndataSource\"\xab\x01\n\x20CMsgSteamLearn_CacheData_Request\
    \x12!\n\x0caccess_token\x18\x01\x20\x01(\tR\x0baccessToken\x12;\n\x0bacc\
    ess_data\x18\x02\x20\x01(\x0b2\x1a.CMsgSteamLearn_AccessDataR\naccessDat\
    a\x12'\n\x04data\x18\x03\x20\x01(\x0b2\x13.CMsgSteamLearnDataR\x04data\"\
    \x89\x01\n!CMsgSteamLearn_CacheData_Response\x12d\n\x11cache_data_result\
    \x18\x01\x20\x01(\x0e2\x1b.ESteamLearnCacheDataResult:\x1bSTEAMLEARN_CAC\
    HE_DATA_ERRORR\x0fcacheDataResult\"\xce\x02\n&CMsgSteamLearn_SnapshotPro\
    ject_Request\x12!\n\x0caccess_token\x18\x01\x20\x01(\tR\x0baccessToken\
    \x12;\n\x0baccess_data\x18\x02\x20\x01(\x0b2\x1a.CMsgSteamLearn_AccessDa\
    taR\naccessData\x12\x1d\n\nproject_id\x18\x03\x20\x01(\rR\tprojectId\x12\
    +\n\x11published_version\x18\x07\x20\x01(\rR\x10publishedVersion\x12\x12\
    \n\x04keys\x18\x04\x20\x03(\x04R\x04keys\x12'\n\x04data\x18\x05\x20\x03(\
    \x0b2\x13.CMsgSteamLearnDataR\x04data\x12;\n\x1apending_data_limit_secon\
    ds\x18\x06\x20\x01(\rR\x17pendingDataLimitSeconds\"\x98\x01\n'CMsgSteamL\
    earn_SnapshotProject_Response\x12m\n\x0fsnapshot_result\x18\x01\x20\x01(\
    \x0e2!.ESteamLearnSnapshotProjectResult:!STEAMLEARN_SNAPSHOT_PROJECT_ERR\
    ORR\x0esnapshotResult\"\xd0\x01\n%CMsgSteamLearn_BatchOperation_Request\
    \x12Q\n\x13cache_data_requests\x18\x01\x20\x03(\x0b2!.CMsgSteamLearn_Cac\
    heData_RequestR\x11cacheDataRequests\x12T\n\x11snapshot_requests\x18\x02\
    \x20\x03(\x0b2'.CMsgSteamLearn_SnapshotProject_RequestR\x10snapshotReque\
    sts\"\xd7\x01\n&CMsgSteamLearn_BatchOperation_Response\x12T\n\x14cache_d\
    ata_responses\x18\x01\x20\x03(\x0b2\".CMsgSteamLearn_CacheData_ResponseR\
    \x12cacheDataResponses\x12W\n\x12snapshot_responses\x18\x02\x20\x03(\x0b\
    2(.CMsgSteamLearn_SnapshotProject_ResponseR\x11snapshotResponses\"\xd9\
    \x03\n\x16CMsgSteamLearnHMACKeys\x127\n\x18register_data_source_key\x18\
    \x01\x20\x01(\tR\x15registerDataSourceKey\x12M\n\x0fcache_data_keys\x18\
    \x02\x20\x03(\x0b2%.CMsgSteamLearnHMACKeys.CacheDataKeysR\rcacheDataKeys\
    \x12_\n\x15snapshot_project_keys\x18\x03\x20\x03(\x0b2+.CMsgSteamLearnHM\
    ACKeys.SnapshotProjectKeysR\x13snapshotProjectKeys\x1aa\n\rCacheDataKeys\
    \x12$\n\x0edata_source_id\x18\x01\x20\x01(\rR\x0cdataSourceId\x12\x18\n\
    \x07version\x18\x03\x20\x01(\rR\x07version\x12\x10\n\x03key\x18\x02\x20\
    \x01(\tR\x03key\x1as\n\x13SnapshotProjectKeys\x12\x1d\n\nproject_id\x18\
    \x01\x20\x01(\rR\tprojectId\x12+\n\x11published_version\x18\x03\x20\x01(\
    \rR\x10publishedVersion\x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\":\n\
    \"CMsgSteamLearn_GetHMACKeys_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\
    \rR\x05appid\"\xab\x01\n#CMsgSteamLearn_GetHMACKeys_Response\x12W\n\x06r\
    esult\x18\x01\x20\x01(\x0e2\x1d.ESteamLearnGetHMACKeysResult:\x20STEAMLE\
    ARN_GET_HMAC_KEYS_SUCCESSR\x06result\x12+\n\x04keys\x18\x02\x20\x01(\x0b\
    2\x17.CMsgSteamLearnHMACKeysR\x04keys\"\xd0\x02\n\x20CMsgSteamLearn_Infe\
    rence_Request\x12!\n\x0caccess_token\x18\x01\x20\x01(\tR\x0baccessToken\
    \x12;\n\x0baccess_data\x18\x02\x20\x01(\x0b2\x1a.CMsgSteamLearn_AccessDa\
    taR\naccessData\x12\x1d\n\nproject_id\x18\x03\x20\x01(\rR\tprojectId\x12\
    +\n\x11published_version\x18\x04\x20\x01(\rR\x10publishedVersion\x12*\n\
    \x11override_train_id\x18\x05\x20\x01(\rR\x0foverrideTrainId\x12+\n\x04d\
    ata\x18\x06\x20\x01(\x0b2\x17.CMsgSteamLearnDataListR\x04data\x12'\n\x0f\
    additional_data\x18\x07\x20\x03(\x02R\x0eadditionalData\"\x82\x02\n(CMsg\
    SteamLearn_InferenceMetadata_Request\x12!\n\x0caccess_token\x18\x01\x20\
    \x01(\tR\x0baccessToken\x12;\n\x0baccess_data\x18\x02\x20\x01(\x0b2\x1a.\
    CMsgSteamLearn_AccessDataR\naccessData\x12\x1d\n\nproject_id\x18\x03\x20\
    \x01(\rR\tprojectId\x12+\n\x11published_version\x18\x04\x20\x01(\rR\x10p\
    ublishedVersion\x12*\n\x11override_train_id\x18\x05\x20\x01(\rR\x0foverr\
    ideTrainId\"k\n/CMsgSteamLearn_InferenceMetadataBackend_Request\x12\x1d\
    \n\nproject_id\x18\x01\x20\x01(\rR\tprojectId\x12\x19\n\x08fetch_id\x18\
    \x02\x20\x01(\rR\x07fetchId\"\xb5\x0f\n)CMsgSteamLearn_InferenceMetadata\
    _Response\x12\x84\x01\n\x19inference_metadata_result\x18\x01\x20\x01(\
    \x0e2#.ESteamLearnInferenceMetadataResult:#STEAMLEARN_INFERENCE_METADATA\
    _ERRORR\x17inferenceMetadataResult\x12P\n\trow_range\x18\x02\x20\x01(\
    \x0b23.CMsgSteamLearn_InferenceMetadata_Response.RowRangeR\x08rowRange\
    \x12H\n\x06ranges\x18\x03\x20\x03(\x0b20.CMsgSteamLearn_InferenceMetadat\
    a_Response.RangeR\x06ranges\x12L\n\x08std_devs\x18\x04\x20\x03(\x0b21.CM\
    sgSteamLearn_InferenceMetadata_Response.StdDevR\x07stdDevs\x12^\n\x0ecom\
    pact_tables\x18\x05\x20\x03(\x0b27.CMsgSteamLearn_InferenceMetadata_Resp\
    onse.CompactTableR\rcompactTables\x12I\n\x06kmeans\x18\x06\x20\x03(\x0b2\
    1.CMsgSteamLearn_InferenceMetadata_Response.KMeansR\x06kmeans\x12k\n\x12\
    snapshot_histogram\x18\x07\x20\x01(\x0b2<.CMsgSteamLearn_InferenceMetada\
    ta_Response.SnapshotHistogramR\x11snapshotHistogram\x1a<\n\x08RowRange\
    \x12\x17\n\x07min_row\x18\x01\x20\x01(\x04R\x06minRow\x12\x17\n\x07max_r\
    ow\x18\x02\x20\x01(\x04R\x06maxRow\x1am\n\x05Range\x12*\n\x11data_elemen\
    t_path\x18\x01\x20\x01(\tR\x0fdataElementPath\x12\x1b\n\tmin_value\x18\
    \x02\x20\x01(\x02R\x08minValue\x12\x1b\n\tmax_value\x18\x03\x20\x01(\x02\
    R\x08maxValue\x1aa\n\x06StdDev\x12*\n\x11data_element_path\x18\x01\x20\
    \x01(\tR\x0fdataElementPath\x12\x12\n\x04mean\x18\x02\x20\x01(\x02R\x04m\
    ean\x12\x17\n\x07std_dev\x18\x03\x20\x01(\x02R\x06stdDev\x1a\xb9\x04\n\
    \x0cCompactTable\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12e\n\nm\
    ap_values\x18\x02\x20\x03(\x0b2F.CMsgSteamLearn_InferenceMetadata_Respon\
    se.CompactTable.MapValuesEntryR\tmapValues\x12k\n\x0cmap_mappings\x18\
    \x03\x20\x03(\x0b2H.CMsgSteamLearn_InferenceMetadata_Response.CompactTab\
    le.MapMappingsEntryR\x0bmapMappings\x1aM\n\x05Entry\x12\x14\n\x05value\
    \x18\x01\x20\x01(\rR\x05value\x12\x18\n\x07mapping\x18\x02\x20\x01(\rR\
    \x07mapping\x12\x14\n\x05count\x18\x03\x20\x01(\x04R\x05count\x1aw\n\x0e\
    MapValuesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\rR\x03key\x12S\n\x05val\
    ue\x18\x02\x20\x01(\x0b2=.CMsgSteamLearn_InferenceMetadata_Response.Comp\
    actTable.EntryR\x05value\x1ay\n\x10MapMappingsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\rR\x03key\x12S\n\x05value\x18\x02\x20\x01(\x0b2=.CMsgSteam\
    Learn_InferenceMetadata_Response.CompactTable.EntryR\x05value\x1a\x9c\
    \x02\n\x06KMeans\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12U\n\
    \x08clusters\x18\x02\x20\x03(\x0b29.CMsgSteamLearn_InferenceMetadata_Res\
    ponse.KMeans.ClusterR\x08clusters\x1a\xa6\x01\n\x07Cluster\x12\x0c\n\x01\
    x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x02R\x01y\
    \x12\x16\n\x06radius\x18\x03\x20\x01(\x02R\x06radius\x12!\n\x0cradius_75\
    pct\x18\x04\x20\x01(\x02R\x0bradius75pct\x12!\n\x0cradius_50pct\x18\x05\
    \x20\x01(\x02R\x0bradius50pct\x12!\n\x0cradius_25pct\x18\x06\x20\x01(\
    \x02R\x0bradius25pct\x1a\x93\x01\n\x11SnapshotHistogram\x12\x1b\n\tmin_v\
    alue\x18\x01\x20\x01(\x02R\x08minValue\x12\x1b\n\tmax_value\x18\x02\x20\
    \x01(\x02R\x08maxValue\x12\x1f\n\x0bnum_buckets\x18\x03\x20\x01(\rR\nnum\
    Buckets\x12#\n\rbucket_counts\x18\x04\x20\x03(\rR\x0cbucketCounts\"\xe7\
    \x05\n(CMsgSteamLearn_InferenceBackend_Response\x12J\n\x07outputs\x18\
    \x01\x20\x03(\x0b20.CMsgSteamLearn_InferenceBackend_Response.OutputR\x07\
    outputs\x1a0\n\x18BinaryCrossEntropyOutput\x12\x14\n\x05value\x18\x01\
    \x20\x01(\x02R\x05value\x1aM\n\x1dMutliBinaryCrossEntropyOutput\x12\x16\
    \n\x06weight\x18\x01\x20\x03(\x02R\x06weight\x12\x14\n\x05value\x18\x02\
    \x20\x03(\x02R\x05value\x1aM\n\x1dCategoricalCrossEntropyOutput\x12\x16\
    \n\x06weight\x18\x01\x20\x03(\x02R\x06weight\x12\x14\n\x05value\x18\x02\
    \x20\x03(\x02R\x05value\x1a\x9e\x03\n\x06Output\x12u\n\x13binary_crossen\
    tropy\x18\x01\x20\x01(\x0b2B.CMsgSteamLearn_InferenceBackend_Response.Bi\
    naryCrossEntropyOutputH\0R\x12binaryCrossentropy\x12\x84\x01\n\x18catego\
    rical_crossentropy\x18\x02\x20\x01(\x0b2G.CMsgSteamLearn_InferenceBacken\
    d_Response.CategoricalCrossEntropyOutputH\0R\x17categoricalCrossentropy\
    \x12\x85\x01\n\x19multi_binary_crossentropy\x18\x03\x20\x01(\x0b2G.CMsgS\
    teamLearn_InferenceBackend_Response.MutliBinaryCrossEntropyOutputH\0R\
    \x17multiBinaryCrossentropyB\x0e\n\x0cResponseType\"\xdd\x01\n!CMsgSteam\
    Learn_Inference_Response\x12b\n\x10inference_result\x18\x01\x20\x01(\x0e\
    2\x1b.ESteamLearnInferenceResult:\x1aSTEAMLEARN_INFERENCE_ERRORR\x0finfe\
    renceResult\x12T\n\x10backend_response\x18\x02\x20\x01(\x0b2).CMsgSteamL\
    earn_InferenceBackend_ResponseR\x0fbackendResponse*\xd4\x01\n\x13ESteamL\
    earnDataType\x12\x1f\n\x1bSTEAMLEARN_DATATYPE_INVALID\x10\0\x12\x1d\n\
    \x19STEAMLEARN_DATATYPE_INT32\x10\x01\x12\x1f\n\x1bSTEAMLEARN_DATATYPE_F\
    LOAT32\x10\x02\x12\x1c\n\x18STEAMLEARN_DATATYPE_BOOL\x10\x03\x12\x1e\n\
    \x1aSTEAMLEARN_DATATYPE_STRING\x10\x04\x12\x1e\n\x1aSTEAMLEARN_DATATYPE_\
    OBJECT\x10\x05*\xbc\x05\n$ESteammLearnRegisterDataSourceResult\x120\n,ST\
    EAMLEARN_REGISTER_DATA_SOURCE_RESULT_ERROR\x10\0\x12:\n6STEAMLEARN_REGIS\
    TER_DATA_SOURCE_RESULT_SUCCESS_CREATED\x10\x01\x128\n4STEAMLEARN_REGISTE\
    R_DATA_SOURCE_RESULT_SUCCESS_FOUND\x10\x02\x128\n4STEAMLEARN_REGISTER_DA\
    TA_SOURCE_RESULT_ERROR_GENERIC\x10\x03\x12=\n9STEAMLEARN_REGISTER_DATA_S\
    OURCE_RESULT_ERROR_INVALID_NAME\x10\x04\x12@\n<STEAMLEARN_REGISTER_DATA_\
    SOURCE_RESULT_ERROR_INVALID_VERSION\x10\x05\x12=\n9STEAMLEARN_REGISTER_D\
    ATA_SOURCE_RESULT_ERROR_DATA_CHANGED\x10\x06\x12=\n9STEAMLEARN_REGISTER_\
    DATA_SOURCE_RESULT_ERROR_DATA_INVALID\x10\x07\x12:\n6STEAMLEARN_REGISTER\
    _DATA_SOURCE_RESULT_ERROR_FORBIDDEN\x10\x08\x12B\n>STEAMLEARN_REGISTER_D\
    ATA_SOURCE_RESULT_ERROR_INVALID_TIMESTAMP\x10\t\x123\n/STEAMLEARN_REGIST\
    ER_DATA_SOURCE_RESULT_DISABLED\x10\n*\xfb\x02\n\x1aESteamLearnCacheDataR\
    esult\x12\x1f\n\x1bSTEAMLEARN_CACHE_DATA_ERROR\x10\0\x12!\n\x1dSTEAMLEAR\
    N_CACHE_DATA_SUCCESS\x10\x01\x123\n/STEAMLEARN_CACHE_DATA_ERROR_UNKNOWN_\
    DATA_SOURCE\x10\x02\x124\n0STEAMLEARN_CACHE_DATA_ERROR_UNCACHED_DATA_SOU\
    RCE\x10\x03\x12,\n(STEAMLEARN_CACHE_DATA_ERROR_INVALID_KEYS\x10\x04\x12)\
    \n%STEAMLEARN_CACHE_DATA_ERROR_FORBIDDEN\x10\x05\x121\n-STEAMLEARN_CACHE\
    _DATA_ERROR_INVALID_TIMESTAMP\x10\x06\x12\"\n\x1eSTEAMLEARN_CACHE_DATA_D\
    ISABLED\x10\x07*\xed\x05\n\x20ESteamLearnSnapshotProjectResult\x12%\n!ST\
    EAMLEARN_SNAPSHOT_PROJECT_ERROR\x10\0\x12.\n*STEAMLEARN_SNAPSHOT_PROJECT\
    _SUCCESS_STORED\x10\x01\x12.\n*STEAMLEARN_SNAPSHOT_PROJECT_SUCCESS_QUEUE\
    D\x10\x02\x128\n4STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_PROJECT_ID\
    \x10\x03\x129\n5STEAMLEARN_SNAPSHOT_PROJECT_ERROR_UNKNOWN_DATA_SOURCE\
    \x10\x04\x12=\n9STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_DATA_SOURCE_KE\
    Y\x10\x05\x12<\n8STEAMLEARN_SNAPSHOT_PROJECT_ERROR_MISSING_CACHE_DURATIO\
    N\x10\x06\x129\n5STEAMLEARN_SNAPSHOT_PROJECT_ERROR_NO_PUBLISHED_CONFIG\
    \x10\x07\x12/\n+STEAMLEARN_SNAPSHOT_PROJECT_ERROR_FORBIDDEN\x10\x08\x127\
    \n3STEAMLEARN_SNAPSHOT_PROJECT_ERROR_INVALID_TIMESTAMP\x10\t\x12@\n<STEA\
    MLEARN_SNAPSHOT_PROJECT_ERROR_INTERNAL_DATA_SOURCE_ERROR\x10\n\x12(\n$ST\
    EAMLEARN_SNAPSHOT_PROJECT_DISABLED\x10\x0b\x12?\n;STEAMLEARN_SNAPSHOT_PR\
    OJECT_ERROR_INVALID_PUBLISHED_VERSION\x10\x0c*D\n\x1cESteamLearnGetHMACK\
    eysResult\x12$\n\x20STEAMLEARN_GET_HMAC_KEYS_SUCCESS\x10\0*\xf1\x03\n\
    \x1aESteamLearnInferenceResult\x12\x1e\n\x1aSTEAMLEARN_INFERENCE_ERROR\
    \x10\0\x12\x20\n\x1cSTEAMLEARN_INFERENCE_SUCCESS\x10\x01\x121\n-STEAMLEA\
    RN_INFERENCE_ERROR_INVALID_PROJECT_ID\x10\x02\x129\n5STEAMLEARN_INFERENC\
    E_ERROR_MISSING_CACHED_SCHEMA_DATA\x10\x03\x122\n.STEAMLEARN_INFERENCE_E\
    RROR_NO_PUBLISHED_CONFIG\x10\x04\x12(\n$STEAMLEARN_INFERENCE_ERROR_FORBI\
    DDEN\x10\x05\x120\n,STEAMLEARN_INFERENCE_ERROR_INVALID_TIMESTAMP\x10\x06\
    \x128\n4STEAMLEARN_INFERENCE_ERROR_INVALID_PUBLISHED_VERSION\x10\x07\x12\
    0\n,STEAMLEARN_INFERENCE_ERROR_NO_FETCH_ID_FOUND\x10\x08\x12'\n#STEAMLEA\
    RN_INFERENCE_ERROR_TOO_BUSY\x10\t*\xdd\x03\n\"ESteamLearnInferenceMetada\
    taResult\x12'\n#STEAMLEARN_INFERENCE_METADATA_ERROR\x10\0\x12)\n%STEAMLE\
    ARN_INFERENCE_METADATA_SUCCESS\x10\x01\x12:\n6STEAMLEARN_INFERENCE_METAD\
    ATA_ERROR_INVALID_PROJECT_ID\x10\x02\x12;\n7STEAMLEARN_INFERENCE_METADAT\
    A_ERROR_NO_PUBLISHED_CONFIG\x10\x03\x121\n-STEAMLEARN_INFERENCE_METADATA\
    _ERROR_FORBIDDEN\x10\x04\x129\n5STEAMLEARN_INFERENCE_METADATA_ERROR_INVA\
    LID_TIMESTAMP\x10\x05\x12A\n=STEAMLEARN_INFERENCE_METADATA_ERROR_INVALID\
    _PUBLISHED_VERSION\x10\x06\x129\n5STEAMLEARN_INFERENCE_METADATA_ERROR_NO\
    _FETCH_ID_FOUND\x10\x072\x83\n\n\nSteamLearn\x12\xbb\x01\n\x12RegisterDa\
    taSource\x12*.CMsgSteamLearn_RegisterDataSource_Request\x1a+.CMsgSteamLe\
    arn_RegisterDataSource_Response\"L\x82\xb5\x18HRegisters\x20a\x20data\
    \x20desc\x20(or\x20finds\x20a\x20data\x20desc\x20if\x20it's\x20already\
    \x20registered).\x12t\n\tCacheData\x12!.CMsgSteamLearn_CacheData_Request\
    \x1a\".CMsgSteamLearn_CacheData_Response\"\x20\x82\xb5\x18\x1cUpdates\
    \x20a\x20cached\x20data\x20entry.\x12\x93\x01\n\x0fSnapshotProject\x12'.\
    CMsgSteamLearn_SnapshotProject_Request\x1a(.CMsgSteamLearn_SnapshotProje\
    ct_Response\"-\x82\xb5\x18)Snapshots\x20the\x20current\x20data\x20for\
    \x20a\x20project.\x12\xba\x01\n\x0eBatchOperation\x12&.CMsgSteamLearn_Ba\
    tchOperation_Request\x1a'.CMsgSteamLearn_BatchOperation_Response\"W\x82\
    \xb5\x18SBatches\x20multiple\x20data\x20updates,\x20snapshots,\x20and\
    \x20inference\x20requests\x20into\x20a\x20single\x20call\x12\xc8\x01\n\
    \x0bGetHMACKeys\x12#.CMsgSteamLearn_GetHMACKeys_Request\x1a$.CMsgSteamLe\
    arn_GetHMACKeys_Response\"n\x82\xb5\x18jGets\x20the\x20HMAC\x20keys\x20n\
    eeded\x20for\x20registering\x20data\x20sources,\x20submitting\x20data\
    \x20to\x20them,\x20and\x20snapshotting\x20projects\x12\xa2\x01\n\tInfere\
    nce\x12!.CMsgSteamLearn_Inference_Request\x1a\".CMsgSteamLearn_Inference\
    _Response\"N\x82\xb5\x18JInferences\x20using\x20supplied\x20data,\x20or\
    \x20data\x20associated\x20with\x20the\x20specified\x20key.\x12\xb0\x01\n\
    \x11InferenceMetadata\x12).CMsgSteamLearn_InferenceMetadata_Request\x1a*\
    .CMsgSteamLearn_InferenceMetadata_Response\"D\x82\xb5\x18@Requests\x20th\
    e\x20metadata\x20that\x20was\x20generated\x20from\x20a\x20specified\x20f\
    etch.\x1aK\x82\xb5\x18GService\x20for\x20submitting\x20data,\x20training\
    ,\x20and\x20inferencing\x20with\x20SteamLearn.\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages_unified_base_steamworkssdk::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(41);
            messages.push(CMsgSteamLearnDataSourceDescObject::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnDataSourceDescElement::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnDataSource::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnDataObject::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnDataElement::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnData::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnDataList::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_AccessData::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_RegisterDataSource_Request::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_RegisterDataSource_Response::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_CacheData_Request::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_CacheData_Response::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_SnapshotProject_Request::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_SnapshotProject_Response::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_BatchOperation_Request::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_BatchOperation_Response::generated_message_descriptor_data());
            messages.push(CMsgSteamLearnHMACKeys::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_GetHMACKeys_Request::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_GetHMACKeys_Response::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_Inference_Request::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_InferenceMetadata_Request::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_InferenceMetadataBackend_Request::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_InferenceMetadata_Response::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_InferenceBackend_Response::generated_message_descriptor_data());
            messages.push(CMsgSteamLearn_Inference_Response::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_hmackeys::CacheDataKeys::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_hmackeys::SnapshotProjectKeys::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_metadata_response::RowRange::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_metadata_response::Range::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_metadata_response::StdDev::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_metadata_response::CompactTable::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_metadata_response::KMeans::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_metadata_response::SnapshotHistogram::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_metadata_response::compact_table::Entry::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_metadata_response::compact_table::MapValuesEntry::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_metadata_response::compact_table::MapMappingsEntry::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_metadata_response::kmeans::Cluster::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_backend_response::BinaryCrossEntropyOutput::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_backend_response::MutliBinaryCrossEntropyOutput::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_backend_response::CategoricalCrossEntropyOutput::generated_message_descriptor_data());
            messages.push(cmsg_steam_learn_inference_backend_response::Output::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(7);
            enums.push(ESteamLearnDataType::generated_enum_descriptor_data());
            enums.push(ESteammLearnRegisterDataSourceResult::generated_enum_descriptor_data());
            enums.push(ESteamLearnCacheDataResult::generated_enum_descriptor_data());
            enums.push(ESteamLearnSnapshotProjectResult::generated_enum_descriptor_data());
            enums.push(ESteamLearnGetHMACKeysResult::generated_enum_descriptor_data());
            enums.push(ESteamLearnInferenceResult::generated_enum_descriptor_data());
            enums.push(ESteamLearnInferenceMetadataResult::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
