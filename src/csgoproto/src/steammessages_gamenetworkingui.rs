// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_gamenetworkingui.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CGameNetworkingUI_GlobalState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_GlobalState {
    // special fields
    // @@protoc_insertion_point(special_field:CGameNetworkingUI_GlobalState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_GlobalState {
    fn default() -> &'a CGameNetworkingUI_GlobalState {
        <CGameNetworkingUI_GlobalState as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_GlobalState {
    pub fn new() -> CGameNetworkingUI_GlobalState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameNetworkingUI_GlobalState>(
            "CGameNetworkingUI_GlobalState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameNetworkingUI_GlobalState {
    const NAME: &'static str = "CGameNetworkingUI_GlobalState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_GlobalState {
        CGameNetworkingUI_GlobalState::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_GlobalState {
        static instance: CGameNetworkingUI_GlobalState = CGameNetworkingUI_GlobalState {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameNetworkingUI_GlobalState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameNetworkingUI_GlobalState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameNetworkingUI_GlobalState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameNetworkingUI_GlobalState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGameNetworkingUI_ConnectionState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_ConnectionState {
    // message fields
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.connection_key)
    pub connection_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.connection_id_local)
    pub connection_id_local: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.identity_local)
    pub identity_local: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.identity_remote)
    pub identity_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.connection_state)
    pub connection_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.close_time)
    pub close_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.close_reason)
    pub close_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.close_message)
    pub close_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.status_loc_token)
    pub status_loc_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.transport_kind)
    pub transport_kind: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.sdrpopid_local)
    pub sdrpopid_local: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.sdrpopid_remote)
    pub sdrpopid_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.address_remote)
    pub address_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.p2p_routing)
    pub p2p_routing: ::protobuf::MessageField<super::steamdatagram_messages_sdr::CMsgSteamDatagramP2PRoutingSummary>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.ping_interior)
    pub ping_interior: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.ping_remote_front)
    pub ping_remote_front: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.ping_default_internet_route)
    pub ping_default_internet_route: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.e2e_quality_local)
    pub e2e_quality_local: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.e2e_quality_remote)
    pub e2e_quality_remote: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.e2e_quality_remote_instantaneous_time)
    pub e2e_quality_remote_instantaneous_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.e2e_quality_remote_lifetime_time)
    pub e2e_quality_remote_lifetime_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.front_quality_local)
    pub front_quality_local: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.front_quality_remote)
    pub front_quality_remote: ::protobuf::MessageField<super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.front_quality_remote_instantaneous_time)
    pub front_quality_remote_instantaneous_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionState.front_quality_remote_lifetime_time)
    pub front_quality_remote_lifetime_time: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameNetworkingUI_ConnectionState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_ConnectionState {
    fn default() -> &'a CGameNetworkingUI_ConnectionState {
        <CGameNetworkingUI_ConnectionState as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_ConnectionState {
    pub fn new() -> CGameNetworkingUI_ConnectionState {
        ::std::default::Default::default()
    }

    // optional string connection_key = 1;

    pub fn connection_key(&self) -> &str {
        match self.connection_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connection_key(&mut self) {
        self.connection_key = ::std::option::Option::None;
    }

    pub fn has_connection_key(&self) -> bool {
        self.connection_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_key(&mut self, v: ::std::string::String) {
        self.connection_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_key(&mut self) -> &mut ::std::string::String {
        if self.connection_key.is_none() {
            self.connection_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connection_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_key(&mut self) -> ::std::string::String {
        self.connection_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional fixed32 connection_id_local = 3;

    pub fn connection_id_local(&self) -> u32 {
        self.connection_id_local.unwrap_or(0)
    }

    pub fn clear_connection_id_local(&mut self) {
        self.connection_id_local = ::std::option::Option::None;
    }

    pub fn has_connection_id_local(&self) -> bool {
        self.connection_id_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_id_local(&mut self, v: u32) {
        self.connection_id_local = ::std::option::Option::Some(v);
    }

    // optional string identity_local = 4;

    pub fn identity_local(&self) -> &str {
        match self.identity_local.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identity_local(&mut self) {
        self.identity_local = ::std::option::Option::None;
    }

    pub fn has_identity_local(&self) -> bool {
        self.identity_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity_local(&mut self, v: ::std::string::String) {
        self.identity_local = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_local(&mut self) -> &mut ::std::string::String {
        if self.identity_local.is_none() {
            self.identity_local = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identity_local.as_mut().unwrap()
    }

    // Take field
    pub fn take_identity_local(&mut self) -> ::std::string::String {
        self.identity_local.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string identity_remote = 5;

    pub fn identity_remote(&self) -> &str {
        match self.identity_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identity_remote(&mut self) {
        self.identity_remote = ::std::option::Option::None;
    }

    pub fn has_identity_remote(&self) -> bool {
        self.identity_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity_remote(&mut self, v: ::std::string::String) {
        self.identity_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_remote(&mut self) -> &mut ::std::string::String {
        if self.identity_remote.is_none() {
            self.identity_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identity_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_identity_remote(&mut self) -> ::std::string::String {
        self.identity_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 connection_state = 10;

    pub fn connection_state(&self) -> u32 {
        self.connection_state.unwrap_or(0)
    }

    pub fn clear_connection_state(&mut self) {
        self.connection_state = ::std::option::Option::None;
    }

    pub fn has_connection_state(&self) -> bool {
        self.connection_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_state(&mut self, v: u32) {
        self.connection_state = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 12;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 close_time = 13;

    pub fn close_time(&self) -> u32 {
        self.close_time.unwrap_or(0)
    }

    pub fn clear_close_time(&mut self) {
        self.close_time = ::std::option::Option::None;
    }

    pub fn has_close_time(&self) -> bool {
        self.close_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_time(&mut self, v: u32) {
        self.close_time = ::std::option::Option::Some(v);
    }

    // optional uint32 close_reason = 14;

    pub fn close_reason(&self) -> u32 {
        self.close_reason.unwrap_or(0)
    }

    pub fn clear_close_reason(&mut self) {
        self.close_reason = ::std::option::Option::None;
    }

    pub fn has_close_reason(&self) -> bool {
        self.close_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_reason(&mut self, v: u32) {
        self.close_reason = ::std::option::Option::Some(v);
    }

    // optional string close_message = 15;

    pub fn close_message(&self) -> &str {
        match self.close_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_close_message(&mut self) {
        self.close_message = ::std::option::Option::None;
    }

    pub fn has_close_message(&self) -> bool {
        self.close_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_close_message(&mut self, v: ::std::string::String) {
        self.close_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_close_message(&mut self) -> &mut ::std::string::String {
        if self.close_message.is_none() {
            self.close_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.close_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_close_message(&mut self) -> ::std::string::String {
        self.close_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status_loc_token = 16;

    pub fn status_loc_token(&self) -> &str {
        match self.status_loc_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_status_loc_token(&mut self) {
        self.status_loc_token = ::std::option::Option::None;
    }

    pub fn has_status_loc_token(&self) -> bool {
        self.status_loc_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_loc_token(&mut self, v: ::std::string::String) {
        self.status_loc_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_loc_token(&mut self) -> &mut ::std::string::String {
        if self.status_loc_token.is_none() {
            self.status_loc_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.status_loc_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_loc_token(&mut self) -> ::std::string::String {
        self.status_loc_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 transport_kind = 20;

    pub fn transport_kind(&self) -> u32 {
        self.transport_kind.unwrap_or(0)
    }

    pub fn clear_transport_kind(&mut self) {
        self.transport_kind = ::std::option::Option::None;
    }

    pub fn has_transport_kind(&self) -> bool {
        self.transport_kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_kind(&mut self, v: u32) {
        self.transport_kind = ::std::option::Option::Some(v);
    }

    // optional string sdrpopid_local = 21;

    pub fn sdrpopid_local(&self) -> &str {
        match self.sdrpopid_local.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdrpopid_local(&mut self) {
        self.sdrpopid_local = ::std::option::Option::None;
    }

    pub fn has_sdrpopid_local(&self) -> bool {
        self.sdrpopid_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdrpopid_local(&mut self, v: ::std::string::String) {
        self.sdrpopid_local = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdrpopid_local(&mut self) -> &mut ::std::string::String {
        if self.sdrpopid_local.is_none() {
            self.sdrpopid_local = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdrpopid_local.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdrpopid_local(&mut self) -> ::std::string::String {
        self.sdrpopid_local.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sdrpopid_remote = 22;

    pub fn sdrpopid_remote(&self) -> &str {
        match self.sdrpopid_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdrpopid_remote(&mut self) {
        self.sdrpopid_remote = ::std::option::Option::None;
    }

    pub fn has_sdrpopid_remote(&self) -> bool {
        self.sdrpopid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdrpopid_remote(&mut self, v: ::std::string::String) {
        self.sdrpopid_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdrpopid_remote(&mut self) -> &mut ::std::string::String {
        if self.sdrpopid_remote.is_none() {
            self.sdrpopid_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdrpopid_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdrpopid_remote(&mut self) -> ::std::string::String {
        self.sdrpopid_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address_remote = 23;

    pub fn address_remote(&self) -> &str {
        match self.address_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_address_remote(&mut self) {
        self.address_remote = ::std::option::Option::None;
    }

    pub fn has_address_remote(&self) -> bool {
        self.address_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address_remote(&mut self, v: ::std::string::String) {
        self.address_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address_remote(&mut self) -> &mut ::std::string::String {
        if self.address_remote.is_none() {
            self.address_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.address_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_address_remote(&mut self) -> ::std::string::String {
        self.address_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ping_interior = 25;

    pub fn ping_interior(&self) -> u32 {
        self.ping_interior.unwrap_or(0)
    }

    pub fn clear_ping_interior(&mut self) {
        self.ping_interior = ::std::option::Option::None;
    }

    pub fn has_ping_interior(&self) -> bool {
        self.ping_interior.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_interior(&mut self, v: u32) {
        self.ping_interior = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_remote_front = 26;

    pub fn ping_remote_front(&self) -> u32 {
        self.ping_remote_front.unwrap_or(0)
    }

    pub fn clear_ping_remote_front(&mut self) {
        self.ping_remote_front = ::std::option::Option::None;
    }

    pub fn has_ping_remote_front(&self) -> bool {
        self.ping_remote_front.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_remote_front(&mut self, v: u32) {
        self.ping_remote_front = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_default_internet_route = 27;

    pub fn ping_default_internet_route(&self) -> u32 {
        self.ping_default_internet_route.unwrap_or(0)
    }

    pub fn clear_ping_default_internet_route(&mut self) {
        self.ping_default_internet_route = ::std::option::Option::None;
    }

    pub fn has_ping_default_internet_route(&self) -> bool {
        self.ping_default_internet_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_default_internet_route(&mut self, v: u32) {
        self.ping_default_internet_route = ::std::option::Option::Some(v);
    }

    // optional uint64 e2e_quality_remote_instantaneous_time = 32;

    pub fn e2e_quality_remote_instantaneous_time(&self) -> u64 {
        self.e2e_quality_remote_instantaneous_time.unwrap_or(0)
    }

    pub fn clear_e2e_quality_remote_instantaneous_time(&mut self) {
        self.e2e_quality_remote_instantaneous_time = ::std::option::Option::None;
    }

    pub fn has_e2e_quality_remote_instantaneous_time(&self) -> bool {
        self.e2e_quality_remote_instantaneous_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2e_quality_remote_instantaneous_time(&mut self, v: u64) {
        self.e2e_quality_remote_instantaneous_time = ::std::option::Option::Some(v);
    }

    // optional uint64 e2e_quality_remote_lifetime_time = 33;

    pub fn e2e_quality_remote_lifetime_time(&self) -> u64 {
        self.e2e_quality_remote_lifetime_time.unwrap_or(0)
    }

    pub fn clear_e2e_quality_remote_lifetime_time(&mut self) {
        self.e2e_quality_remote_lifetime_time = ::std::option::Option::None;
    }

    pub fn has_e2e_quality_remote_lifetime_time(&self) -> bool {
        self.e2e_quality_remote_lifetime_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_e2e_quality_remote_lifetime_time(&mut self, v: u64) {
        self.e2e_quality_remote_lifetime_time = ::std::option::Option::Some(v);
    }

    // optional uint64 front_quality_remote_instantaneous_time = 42;

    pub fn front_quality_remote_instantaneous_time(&self) -> u64 {
        self.front_quality_remote_instantaneous_time.unwrap_or(0)
    }

    pub fn clear_front_quality_remote_instantaneous_time(&mut self) {
        self.front_quality_remote_instantaneous_time = ::std::option::Option::None;
    }

    pub fn has_front_quality_remote_instantaneous_time(&self) -> bool {
        self.front_quality_remote_instantaneous_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front_quality_remote_instantaneous_time(&mut self, v: u64) {
        self.front_quality_remote_instantaneous_time = ::std::option::Option::Some(v);
    }

    // optional uint64 front_quality_remote_lifetime_time = 43;

    pub fn front_quality_remote_lifetime_time(&self) -> u64 {
        self.front_quality_remote_lifetime_time.unwrap_or(0)
    }

    pub fn clear_front_quality_remote_lifetime_time(&mut self) {
        self.front_quality_remote_lifetime_time = ::std::option::Option::None;
    }

    pub fn has_front_quality_remote_lifetime_time(&self) -> bool {
        self.front_quality_remote_lifetime_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_front_quality_remote_lifetime_time(&mut self, v: u64) {
        self.front_quality_remote_lifetime_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(27);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_key",
            |m: &CGameNetworkingUI_ConnectionState| { &m.connection_key },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.connection_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CGameNetworkingUI_ConnectionState| { &m.appid },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_id_local",
            |m: &CGameNetworkingUI_ConnectionState| { &m.connection_id_local },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.connection_id_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identity_local",
            |m: &CGameNetworkingUI_ConnectionState| { &m.identity_local },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.identity_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "identity_remote",
            |m: &CGameNetworkingUI_ConnectionState| { &m.identity_remote },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.identity_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_state",
            |m: &CGameNetworkingUI_ConnectionState| { &m.connection_state },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.connection_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.start_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "close_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.close_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.close_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "close_reason",
            |m: &CGameNetworkingUI_ConnectionState| { &m.close_reason },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.close_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "close_message",
            |m: &CGameNetworkingUI_ConnectionState| { &m.close_message },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.close_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_loc_token",
            |m: &CGameNetworkingUI_ConnectionState| { &m.status_loc_token },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.status_loc_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transport_kind",
            |m: &CGameNetworkingUI_ConnectionState| { &m.transport_kind },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.transport_kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdrpopid_local",
            |m: &CGameNetworkingUI_ConnectionState| { &m.sdrpopid_local },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.sdrpopid_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdrpopid_remote",
            |m: &CGameNetworkingUI_ConnectionState| { &m.sdrpopid_remote },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.sdrpopid_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "address_remote",
            |m: &CGameNetworkingUI_ConnectionState| { &m.address_remote },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.address_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamdatagram_messages_sdr::CMsgSteamDatagramP2PRoutingSummary>(
            "p2p_routing",
            |m: &CGameNetworkingUI_ConnectionState| { &m.p2p_routing },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.p2p_routing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_interior",
            |m: &CGameNetworkingUI_ConnectionState| { &m.ping_interior },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.ping_interior },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_remote_front",
            |m: &CGameNetworkingUI_ConnectionState| { &m.ping_remote_front },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.ping_remote_front },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_default_internet_route",
            |m: &CGameNetworkingUI_ConnectionState| { &m.ping_default_internet_route },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.ping_default_internet_route },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "e2e_quality_local",
            |m: &CGameNetworkingUI_ConnectionState| { &m.e2e_quality_local },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.e2e_quality_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "e2e_quality_remote",
            |m: &CGameNetworkingUI_ConnectionState| { &m.e2e_quality_remote },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.e2e_quality_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "e2e_quality_remote_instantaneous_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.e2e_quality_remote_instantaneous_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.e2e_quality_remote_instantaneous_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "e2e_quality_remote_lifetime_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.e2e_quality_remote_lifetime_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.e2e_quality_remote_lifetime_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "front_quality_local",
            |m: &CGameNetworkingUI_ConnectionState| { &m.front_quality_local },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.front_quality_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::steamnetworkingsockets_messages::CMsgSteamDatagramConnectionQuality>(
            "front_quality_remote",
            |m: &CGameNetworkingUI_ConnectionState| { &m.front_quality_remote },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.front_quality_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "front_quality_remote_instantaneous_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.front_quality_remote_instantaneous_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.front_quality_remote_instantaneous_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "front_quality_remote_lifetime_time",
            |m: &CGameNetworkingUI_ConnectionState| { &m.front_quality_remote_lifetime_time },
            |m: &mut CGameNetworkingUI_ConnectionState| { &mut m.front_quality_remote_lifetime_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameNetworkingUI_ConnectionState>(
            "CGameNetworkingUI_ConnectionState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameNetworkingUI_ConnectionState {
    const NAME: &'static str = "CGameNetworkingUI_ConnectionState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection_key = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.connection_id_local = ::std::option::Option::Some(is.read_fixed32()?);
                },
                34 => {
                    self.identity_local = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.identity_remote = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.connection_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.close_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.close_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.close_message = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.status_loc_token = ::std::option::Option::Some(is.read_string()?);
                },
                160 => {
                    self.transport_kind = ::std::option::Option::Some(is.read_uint32()?);
                },
                170 => {
                    self.sdrpopid_local = ::std::option::Option::Some(is.read_string()?);
                },
                178 => {
                    self.sdrpopid_remote = ::std::option::Option::Some(is.read_string()?);
                },
                186 => {
                    self.address_remote = ::std::option::Option::Some(is.read_string()?);
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.p2p_routing)?;
                },
                200 => {
                    self.ping_interior = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.ping_remote_front = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.ping_default_internet_route = ::std::option::Option::Some(is.read_uint32()?);
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.e2e_quality_local)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.e2e_quality_remote)?;
                },
                256 => {
                    self.e2e_quality_remote_instantaneous_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                264 => {
                    self.e2e_quality_remote_lifetime_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                322 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.front_quality_local)?;
                },
                330 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.front_quality_remote)?;
                },
                336 => {
                    self.front_quality_remote_instantaneous_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                344 => {
                    self.front_quality_remote_lifetime_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connection_key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.connection_id_local {
            my_size += 1 + 4;
        }
        if let Some(v) = self.identity_local.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.identity_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.connection_state {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.close_time {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.close_reason {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.close_message.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.status_loc_token.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.transport_kind {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.sdrpopid_local.as_ref() {
            my_size += ::protobuf::rt::string_size(21, &v);
        }
        if let Some(v) = self.sdrpopid_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(22, &v);
        }
        if let Some(v) = self.address_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.p2p_routing.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ping_interior {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.ping_remote_front {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.ping_default_internet_route {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.e2e_quality_local.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.e2e_quality_remote.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.e2e_quality_remote_instantaneous_time {
            my_size += ::protobuf::rt::uint64_size(32, v);
        }
        if let Some(v) = self.e2e_quality_remote_lifetime_time {
            my_size += ::protobuf::rt::uint64_size(33, v);
        }
        if let Some(v) = self.front_quality_local.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.front_quality_remote.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.front_quality_remote_instantaneous_time {
            my_size += ::protobuf::rt::uint64_size(42, v);
        }
        if let Some(v) = self.front_quality_remote_lifetime_time {
            my_size += ::protobuf::rt::uint64_size(43, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connection_key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.connection_id_local {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.identity_local.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.identity_remote.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.connection_state {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.close_time {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.close_reason {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.close_message.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.status_loc_token.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.transport_kind {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.sdrpopid_local.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.sdrpopid_remote.as_ref() {
            os.write_string(22, v)?;
        }
        if let Some(v) = self.address_remote.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.p2p_routing.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.ping_interior {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.ping_remote_front {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.ping_default_internet_route {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.e2e_quality_local.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.e2e_quality_remote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.e2e_quality_remote_instantaneous_time {
            os.write_uint64(32, v)?;
        }
        if let Some(v) = self.e2e_quality_remote_lifetime_time {
            os.write_uint64(33, v)?;
        }
        if let Some(v) = self.front_quality_local.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        if let Some(v) = self.front_quality_remote.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        }
        if let Some(v) = self.front_quality_remote_instantaneous_time {
            os.write_uint64(42, v)?;
        }
        if let Some(v) = self.front_quality_remote_lifetime_time {
            os.write_uint64(43, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_ConnectionState {
        CGameNetworkingUI_ConnectionState::new()
    }

    fn clear(&mut self) {
        self.connection_key = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.connection_id_local = ::std::option::Option::None;
        self.identity_local = ::std::option::Option::None;
        self.identity_remote = ::std::option::Option::None;
        self.connection_state = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.close_time = ::std::option::Option::None;
        self.close_reason = ::std::option::Option::None;
        self.close_message = ::std::option::Option::None;
        self.status_loc_token = ::std::option::Option::None;
        self.transport_kind = ::std::option::Option::None;
        self.sdrpopid_local = ::std::option::Option::None;
        self.sdrpopid_remote = ::std::option::Option::None;
        self.address_remote = ::std::option::Option::None;
        self.p2p_routing.clear();
        self.ping_interior = ::std::option::Option::None;
        self.ping_remote_front = ::std::option::Option::None;
        self.ping_default_internet_route = ::std::option::Option::None;
        self.e2e_quality_local.clear();
        self.e2e_quality_remote.clear();
        self.e2e_quality_remote_instantaneous_time = ::std::option::Option::None;
        self.e2e_quality_remote_lifetime_time = ::std::option::Option::None;
        self.front_quality_local.clear();
        self.front_quality_remote.clear();
        self.front_quality_remote_instantaneous_time = ::std::option::Option::None;
        self.front_quality_remote_lifetime_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_ConnectionState {
        static instance: CGameNetworkingUI_ConnectionState = CGameNetworkingUI_ConnectionState {
            connection_key: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            connection_id_local: ::std::option::Option::None,
            identity_local: ::std::option::Option::None,
            identity_remote: ::std::option::Option::None,
            connection_state: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            close_time: ::std::option::Option::None,
            close_reason: ::std::option::Option::None,
            close_message: ::std::option::Option::None,
            status_loc_token: ::std::option::Option::None,
            transport_kind: ::std::option::Option::None,
            sdrpopid_local: ::std::option::Option::None,
            sdrpopid_remote: ::std::option::Option::None,
            address_remote: ::std::option::Option::None,
            p2p_routing: ::protobuf::MessageField::none(),
            ping_interior: ::std::option::Option::None,
            ping_remote_front: ::std::option::Option::None,
            ping_default_internet_route: ::std::option::Option::None,
            e2e_quality_local: ::protobuf::MessageField::none(),
            e2e_quality_remote: ::protobuf::MessageField::none(),
            e2e_quality_remote_instantaneous_time: ::std::option::Option::None,
            e2e_quality_remote_lifetime_time: ::std::option::Option::None,
            front_quality_local: ::protobuf::MessageField::none(),
            front_quality_remote: ::protobuf::MessageField::none(),
            front_quality_remote_instantaneous_time: ::std::option::Option::None,
            front_quality_remote_lifetime_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameNetworkingUI_ConnectionState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameNetworkingUI_ConnectionState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameNetworkingUI_ConnectionState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameNetworkingUI_ConnectionState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGameNetworkingUI_Message)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_Message {
    // message fields
    // @@protoc_insertion_point(field:CGameNetworkingUI_Message.connection_state)
    pub connection_state: ::std::vec::Vec<CGameNetworkingUI_ConnectionState>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameNetworkingUI_Message.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_Message {
    fn default() -> &'a CGameNetworkingUI_Message {
        <CGameNetworkingUI_Message as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_Message {
    pub fn new() -> CGameNetworkingUI_Message {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connection_state",
            |m: &CGameNetworkingUI_Message| { &m.connection_state },
            |m: &mut CGameNetworkingUI_Message| { &mut m.connection_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameNetworkingUI_Message>(
            "CGameNetworkingUI_Message",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameNetworkingUI_Message {
    const NAME: &'static str = "CGameNetworkingUI_Message";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connection_state.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.connection_state {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.connection_state {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_Message {
        CGameNetworkingUI_Message::new()
    }

    fn clear(&mut self) {
        self.connection_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_Message {
        static instance: CGameNetworkingUI_Message = CGameNetworkingUI_Message {
            connection_state: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameNetworkingUI_Message {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameNetworkingUI_Message").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameNetworkingUI_Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameNetworkingUI_Message {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGameNetworkingUI_ConnectionSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_ConnectionSummary {
    // message fields
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.transport_kind)
    pub transport_kind: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.connection_state)
    pub connection_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.sdrpop_local)
    pub sdrpop_local: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.sdrpop_remote)
    pub sdrpop_remote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.ping_ms)
    pub ping_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.packet_loss)
    pub packet_loss: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.ping_default_internet_route)
    pub ping_default_internet_route: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_ConnectionSummary.ip_was_shared)
    pub ip_was_shared: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameNetworkingUI_ConnectionSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_ConnectionSummary {
    fn default() -> &'a CGameNetworkingUI_ConnectionSummary {
        <CGameNetworkingUI_ConnectionSummary as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_ConnectionSummary {
    pub fn new() -> CGameNetworkingUI_ConnectionSummary {
        ::std::default::Default::default()
    }

    // optional uint32 transport_kind = 1;

    pub fn transport_kind(&self) -> u32 {
        self.transport_kind.unwrap_or(0)
    }

    pub fn clear_transport_kind(&mut self) {
        self.transport_kind = ::std::option::Option::None;
    }

    pub fn has_transport_kind(&self) -> bool {
        self.transport_kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_kind(&mut self, v: u32) {
        self.transport_kind = ::std::option::Option::Some(v);
    }

    // optional uint32 connection_state = 8;

    pub fn connection_state(&self) -> u32 {
        self.connection_state.unwrap_or(0)
    }

    pub fn clear_connection_state(&mut self) {
        self.connection_state = ::std::option::Option::None;
    }

    pub fn has_connection_state(&self) -> bool {
        self.connection_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_state(&mut self, v: u32) {
        self.connection_state = ::std::option::Option::Some(v);
    }

    // optional string sdrpop_local = 2;

    pub fn sdrpop_local(&self) -> &str {
        match self.sdrpop_local.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdrpop_local(&mut self) {
        self.sdrpop_local = ::std::option::Option::None;
    }

    pub fn has_sdrpop_local(&self) -> bool {
        self.sdrpop_local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdrpop_local(&mut self, v: ::std::string::String) {
        self.sdrpop_local = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdrpop_local(&mut self) -> &mut ::std::string::String {
        if self.sdrpop_local.is_none() {
            self.sdrpop_local = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdrpop_local.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdrpop_local(&mut self) -> ::std::string::String {
        self.sdrpop_local.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sdrpop_remote = 3;

    pub fn sdrpop_remote(&self) -> &str {
        match self.sdrpop_remote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sdrpop_remote(&mut self) {
        self.sdrpop_remote = ::std::option::Option::None;
    }

    pub fn has_sdrpop_remote(&self) -> bool {
        self.sdrpop_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdrpop_remote(&mut self, v: ::std::string::String) {
        self.sdrpop_remote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdrpop_remote(&mut self) -> &mut ::std::string::String {
        if self.sdrpop_remote.is_none() {
            self.sdrpop_remote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sdrpop_remote.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdrpop_remote(&mut self) -> ::std::string::String {
        self.sdrpop_remote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ping_ms = 4;

    pub fn ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }

    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }

    // optional float packet_loss = 5;

    pub fn packet_loss(&self) -> f32 {
        self.packet_loss.unwrap_or(0.)
    }

    pub fn clear_packet_loss(&mut self) {
        self.packet_loss = ::std::option::Option::None;
    }

    pub fn has_packet_loss(&self) -> bool {
        self.packet_loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_loss(&mut self, v: f32) {
        self.packet_loss = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_default_internet_route = 6;

    pub fn ping_default_internet_route(&self) -> u32 {
        self.ping_default_internet_route.unwrap_or(0)
    }

    pub fn clear_ping_default_internet_route(&mut self) {
        self.ping_default_internet_route = ::std::option::Option::None;
    }

    pub fn has_ping_default_internet_route(&self) -> bool {
        self.ping_default_internet_route.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_default_internet_route(&mut self, v: u32) {
        self.ping_default_internet_route = ::std::option::Option::Some(v);
    }

    // optional bool ip_was_shared = 7;

    pub fn ip_was_shared(&self) -> bool {
        self.ip_was_shared.unwrap_or(false)
    }

    pub fn clear_ip_was_shared(&mut self) {
        self.ip_was_shared = ::std::option::Option::None;
    }

    pub fn has_ip_was_shared(&self) -> bool {
        self.ip_was_shared.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_was_shared(&mut self, v: bool) {
        self.ip_was_shared = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transport_kind",
            |m: &CGameNetworkingUI_ConnectionSummary| { &m.transport_kind },
            |m: &mut CGameNetworkingUI_ConnectionSummary| { &mut m.transport_kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connection_state",
            |m: &CGameNetworkingUI_ConnectionSummary| { &m.connection_state },
            |m: &mut CGameNetworkingUI_ConnectionSummary| { &mut m.connection_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdrpop_local",
            |m: &CGameNetworkingUI_ConnectionSummary| { &m.sdrpop_local },
            |m: &mut CGameNetworkingUI_ConnectionSummary| { &mut m.sdrpop_local },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdrpop_remote",
            |m: &CGameNetworkingUI_ConnectionSummary| { &m.sdrpop_remote },
            |m: &mut CGameNetworkingUI_ConnectionSummary| { &mut m.sdrpop_remote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_ms",
            |m: &CGameNetworkingUI_ConnectionSummary| { &m.ping_ms },
            |m: &mut CGameNetworkingUI_ConnectionSummary| { &mut m.ping_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packet_loss",
            |m: &CGameNetworkingUI_ConnectionSummary| { &m.packet_loss },
            |m: &mut CGameNetworkingUI_ConnectionSummary| { &mut m.packet_loss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_default_internet_route",
            |m: &CGameNetworkingUI_ConnectionSummary| { &m.ping_default_internet_route },
            |m: &mut CGameNetworkingUI_ConnectionSummary| { &mut m.ping_default_internet_route },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_was_shared",
            |m: &CGameNetworkingUI_ConnectionSummary| { &m.ip_was_shared },
            |m: &mut CGameNetworkingUI_ConnectionSummary| { &mut m.ip_was_shared },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameNetworkingUI_ConnectionSummary>(
            "CGameNetworkingUI_ConnectionSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameNetworkingUI_ConnectionSummary {
    const NAME: &'static str = "CGameNetworkingUI_ConnectionSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.transport_kind = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.connection_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.sdrpop_local = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.sdrpop_remote = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.packet_loss = ::std::option::Option::Some(is.read_float()?);
                },
                48 => {
                    self.ping_default_internet_route = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ip_was_shared = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.transport_kind {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.connection_state {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.sdrpop_local.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sdrpop_remote.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ping_ms {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.packet_loss {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ping_default_internet_route {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ip_was_shared {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.transport_kind {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.connection_state {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.sdrpop_local.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.sdrpop_remote.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.packet_loss {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.ping_default_internet_route {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ip_was_shared {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_ConnectionSummary {
        CGameNetworkingUI_ConnectionSummary::new()
    }

    fn clear(&mut self) {
        self.transport_kind = ::std::option::Option::None;
        self.connection_state = ::std::option::Option::None;
        self.sdrpop_local = ::std::option::Option::None;
        self.sdrpop_remote = ::std::option::Option::None;
        self.ping_ms = ::std::option::Option::None;
        self.packet_loss = ::std::option::Option::None;
        self.ping_default_internet_route = ::std::option::Option::None;
        self.ip_was_shared = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_ConnectionSummary {
        static instance: CGameNetworkingUI_ConnectionSummary = CGameNetworkingUI_ConnectionSummary {
            transport_kind: ::std::option::Option::None,
            connection_state: ::std::option::Option::None,
            sdrpop_local: ::std::option::Option::None,
            sdrpop_remote: ::std::option::Option::None,
            ping_ms: ::std::option::Option::None,
            packet_loss: ::std::option::Option::None,
            ping_default_internet_route: ::std::option::Option::None,
            ip_was_shared: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameNetworkingUI_ConnectionSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameNetworkingUI_ConnectionSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameNetworkingUI_ConnectionSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameNetworkingUI_ConnectionSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGameNetworkingUI_AppSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameNetworkingUI_AppSummary {
    // message fields
    // @@protoc_insertion_point(field:CGameNetworkingUI_AppSummary.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_AppSummary.ip_was_shared_with_friend)
    pub ip_was_shared_with_friend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_AppSummary.ip_was_shared_with_nonfriend)
    pub ip_was_shared_with_nonfriend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_AppSummary.active_connections)
    pub active_connections: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGameNetworkingUI_AppSummary.main_cxn)
    pub main_cxn: ::protobuf::MessageField<CGameNetworkingUI_ConnectionSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameNetworkingUI_AppSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameNetworkingUI_AppSummary {
    fn default() -> &'a CGameNetworkingUI_AppSummary {
        <CGameNetworkingUI_AppSummary as ::protobuf::Message>::default_instance()
    }
}

impl CGameNetworkingUI_AppSummary {
    pub fn new() -> CGameNetworkingUI_AppSummary {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bool ip_was_shared_with_friend = 10;

    pub fn ip_was_shared_with_friend(&self) -> bool {
        self.ip_was_shared_with_friend.unwrap_or(false)
    }

    pub fn clear_ip_was_shared_with_friend(&mut self) {
        self.ip_was_shared_with_friend = ::std::option::Option::None;
    }

    pub fn has_ip_was_shared_with_friend(&self) -> bool {
        self.ip_was_shared_with_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_was_shared_with_friend(&mut self, v: bool) {
        self.ip_was_shared_with_friend = ::std::option::Option::Some(v);
    }

    // optional bool ip_was_shared_with_nonfriend = 11;

    pub fn ip_was_shared_with_nonfriend(&self) -> bool {
        self.ip_was_shared_with_nonfriend.unwrap_or(false)
    }

    pub fn clear_ip_was_shared_with_nonfriend(&mut self) {
        self.ip_was_shared_with_nonfriend = ::std::option::Option::None;
    }

    pub fn has_ip_was_shared_with_nonfriend(&self) -> bool {
        self.ip_was_shared_with_nonfriend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_was_shared_with_nonfriend(&mut self, v: bool) {
        self.ip_was_shared_with_nonfriend = ::std::option::Option::Some(v);
    }

    // optional uint32 active_connections = 20;

    pub fn active_connections(&self) -> u32 {
        self.active_connections.unwrap_or(0)
    }

    pub fn clear_active_connections(&mut self) {
        self.active_connections = ::std::option::Option::None;
    }

    pub fn has_active_connections(&self) -> bool {
        self.active_connections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_connections(&mut self, v: u32) {
        self.active_connections = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CGameNetworkingUI_AppSummary| { &m.appid },
            |m: &mut CGameNetworkingUI_AppSummary| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_was_shared_with_friend",
            |m: &CGameNetworkingUI_AppSummary| { &m.ip_was_shared_with_friend },
            |m: &mut CGameNetworkingUI_AppSummary| { &mut m.ip_was_shared_with_friend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_was_shared_with_nonfriend",
            |m: &CGameNetworkingUI_AppSummary| { &m.ip_was_shared_with_nonfriend },
            |m: &mut CGameNetworkingUI_AppSummary| { &mut m.ip_was_shared_with_nonfriend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_connections",
            |m: &CGameNetworkingUI_AppSummary| { &m.active_connections },
            |m: &mut CGameNetworkingUI_AppSummary| { &mut m.active_connections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CGameNetworkingUI_ConnectionSummary>(
            "main_cxn",
            |m: &CGameNetworkingUI_AppSummary| { &m.main_cxn },
            |m: &mut CGameNetworkingUI_AppSummary| { &mut m.main_cxn },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameNetworkingUI_AppSummary>(
            "CGameNetworkingUI_AppSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameNetworkingUI_AppSummary {
    const NAME: &'static str = "CGameNetworkingUI_AppSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.ip_was_shared_with_friend = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.ip_was_shared_with_nonfriend = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.active_connections = ::std::option::Option::Some(is.read_uint32()?);
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.main_cxn)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ip_was_shared_with_friend {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ip_was_shared_with_nonfriend {
            my_size += 1 + 1;
        }
        if let Some(v) = self.active_connections {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.main_cxn.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ip_was_shared_with_friend {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.ip_was_shared_with_nonfriend {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.active_connections {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.main_cxn.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameNetworkingUI_AppSummary {
        CGameNetworkingUI_AppSummary::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.ip_was_shared_with_friend = ::std::option::Option::None;
        self.ip_was_shared_with_nonfriend = ::std::option::Option::None;
        self.active_connections = ::std::option::Option::None;
        self.main_cxn.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameNetworkingUI_AppSummary {
        static instance: CGameNetworkingUI_AppSummary = CGameNetworkingUI_AppSummary {
            appid: ::std::option::Option::None,
            ip_was_shared_with_friend: ::std::option::Option::None,
            ip_was_shared_with_nonfriend: ::std::option::Option::None,
            active_connections: ::std::option::Option::None,
            main_cxn: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameNetworkingUI_AppSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameNetworkingUI_AppSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameNetworkingUI_AppSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameNetworkingUI_AppSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$steammessages_gamenetworkingui.proto\x1a%steamnetworkingsockets_messa\
    ges.proto\x1a\x20steamdatagram_messages_sdr.proto\"\x1f\n\x1dCGameNetwor\
    kingUI_GlobalState\"\xbb\x0b\n!CGameNetworkingUI_ConnectionState\x12%\n\
    \x0econnection_key\x18\x01\x20\x01(\tR\rconnectionKey\x12\x14\n\x05appid\
    \x18\x02\x20\x01(\rR\x05appid\x12.\n\x13connection_id_local\x18\x03\x20\
    \x01(\x07R\x11connectionIdLocal\x12%\n\x0eidentity_local\x18\x04\x20\x01\
    (\tR\ridentityLocal\x12'\n\x0fidentity_remote\x18\x05\x20\x01(\tR\x0eide\
    ntityRemote\x12)\n\x10connection_state\x18\n\x20\x01(\rR\x0fconnectionSt\
    ate\x12\x1d\n\nstart_time\x18\x0c\x20\x01(\rR\tstartTime\x12\x1d\n\nclos\
    e_time\x18\r\x20\x01(\rR\tcloseTime\x12!\n\x0cclose_reason\x18\x0e\x20\
    \x01(\rR\x0bcloseReason\x12#\n\rclose_message\x18\x0f\x20\x01(\tR\x0cclo\
    seMessage\x12(\n\x10status_loc_token\x18\x10\x20\x01(\tR\x0estatusLocTok\
    en\x12%\n\x0etransport_kind\x18\x14\x20\x01(\rR\rtransportKind\x12%\n\
    \x0esdrpopid_local\x18\x15\x20\x01(\tR\rsdrpopidLocal\x12'\n\x0fsdrpopid\
    _remote\x18\x16\x20\x01(\tR\x0esdrpopidRemote\x12%\n\x0eaddress_remote\
    \x18\x17\x20\x01(\tR\raddressRemote\x12D\n\x0bp2p_routing\x18\x18\x20\
    \x01(\x0b2#.CMsgSteamDatagramP2PRoutingSummaryR\np2pRouting\x12#\n\rping\
    _interior\x18\x19\x20\x01(\rR\x0cpingInterior\x12*\n\x11ping_remote_fron\
    t\x18\x1a\x20\x01(\rR\x0fpingRemoteFront\x12=\n\x1bping_default_internet\
    _route\x18\x1b\x20\x01(\rR\x18pingDefaultInternetRoute\x12O\n\x11e2e_qua\
    lity_local\x18\x1e\x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\
    \x0fe2eQualityLocal\x12Q\n\x12e2e_quality_remote\x18\x1f\x20\x01(\x0b2#.\
    CMsgSteamDatagramConnectionQualityR\x10e2eQualityRemote\x12P\n%e2e_quali\
    ty_remote_instantaneous_time\x18\x20\x20\x01(\x04R!e2eQualityRemoteInsta\
    ntaneousTime\x12F\n\x20e2e_quality_remote_lifetime_time\x18!\x20\x01(\
    \x04R\x1ce2eQualityRemoteLifetimeTime\x12S\n\x13front_quality_local\x18(\
    \x20\x01(\x0b2#.CMsgSteamDatagramConnectionQualityR\x11frontQualityLocal\
    \x12U\n\x14front_quality_remote\x18)\x20\x01(\x0b2#.CMsgSteamDatagramCon\
    nectionQualityR\x12frontQualityRemote\x12T\n'front_quality_remote_instan\
    taneous_time\x18*\x20\x01(\x04R#frontQualityRemoteInstantaneousTime\x12J\
    \n\"front_quality_remote_lifetime_time\x18+\x20\x01(\x04R\x1efrontQualit\
    yRemoteLifetimeTime\"j\n\x19CGameNetworkingUI_Message\x12M\n\x10connecti\
    on_state\x18\x01\x20\x03(\x0b2\".CGameNetworkingUI_ConnectionStateR\x0fc\
    onnectionState\"\xdc\x02\n#CGameNetworkingUI_ConnectionSummary\x12%\n\
    \x0etransport_kind\x18\x01\x20\x01(\rR\rtransportKind\x12)\n\x10connecti\
    on_state\x18\x08\x20\x01(\rR\x0fconnectionState\x12!\n\x0csdrpop_local\
    \x18\x02\x20\x01(\tR\x0bsdrpopLocal\x12#\n\rsdrpop_remote\x18\x03\x20\
    \x01(\tR\x0csdrpopRemote\x12\x17\n\x07ping_ms\x18\x04\x20\x01(\rR\x06pin\
    gMs\x12\x1f\n\x0bpacket_loss\x18\x05\x20\x01(\x02R\npacketLoss\x12=\n\
    \x1bping_default_internet_route\x18\x06\x20\x01(\rR\x18pingDefaultIntern\
    etRoute\x12\"\n\rip_was_shared\x18\x07\x20\x01(\x08R\x0bipWasShared\"\
    \x9e\x02\n\x1cCGameNetworkingUI_AppSummary\x12\x14\n\x05appid\x18\x01\
    \x20\x01(\rR\x05appid\x128\n\x19ip_was_shared_with_friend\x18\n\x20\x01(\
    \x08R\x15ipWasSharedWithFriend\x12>\n\x1cip_was_shared_with_nonfriend\
    \x18\x0b\x20\x01(\x08R\x18ipWasSharedWithNonfriend\x12-\n\x12active_conn\
    ections\x18\x14\x20\x01(\rR\x11activeConnections\x12?\n\x08main_cxn\x18\
    \x1e\x20\x01(\x0b2$.CGameNetworkingUI_ConnectionSummaryR\x07mainCxnB\x05\
    H\x01\x80\x01\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steamnetworkingsockets_messages::file_descriptor().clone());
            deps.push(super::steamdatagram_messages_sdr::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(5);
            messages.push(CGameNetworkingUI_GlobalState::generated_message_descriptor_data());
            messages.push(CGameNetworkingUI_ConnectionState::generated_message_descriptor_data());
            messages.push(CGameNetworkingUI_Message::generated_message_descriptor_data());
            messages.push(CGameNetworkingUI_ConnectionSummary::generated_message_descriptor_data());
            messages.push(CGameNetworkingUI_AppSummary::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
