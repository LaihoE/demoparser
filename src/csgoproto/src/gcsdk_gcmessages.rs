// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gcsdk_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgSOIDOwner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOIDOwner {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOIDOwner.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOIDOwner.id)
    pub id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOIDOwner.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOIDOwner {
    fn default() -> &'a CMsgSOIDOwner {
        <CMsgSOIDOwner as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOIDOwner {
    pub fn new() -> CMsgSOIDOwner {
        ::std::default::Default::default()
    }

    // optional uint32 type = 1;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint64 id = 2;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgSOIDOwner| { &m.type_ },
            |m: &mut CMsgSOIDOwner| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgSOIDOwner| { &m.id },
            |m: &mut CMsgSOIDOwner| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOIDOwner>(
            "CMsgSOIDOwner",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOIDOwner {
    const NAME: &'static str = "CMsgSOIDOwner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOIDOwner {
        CMsgSOIDOwner::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOIDOwner {
        static instance: CMsgSOIDOwner = CMsgSOIDOwner {
            type_: ::std::option::Option::None,
            id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOIDOwner {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOIDOwner").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOIDOwner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOIDOwner {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOSingleObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOSingleObject {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOSingleObject.type_id)
    pub type_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.object_data)
    pub object_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOSingleObject.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOSingleObject {
    fn default() -> &'a CMsgSOSingleObject {
        <CMsgSOSingleObject as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOSingleObject {
    pub fn new() -> CMsgSOSingleObject {
        ::std::default::Default::default()
    }

    // optional int32 type_id = 2;

    pub fn type_id(&self) -> i32 {
        self.type_id.unwrap_or(0)
    }

    pub fn clear_type_id(&mut self) {
        self.type_id = ::std::option::Option::None;
    }

    pub fn has_type_id(&self) -> bool {
        self.type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = ::std::option::Option::Some(v);
    }

    // optional bytes object_data = 3;

    pub fn object_data(&self) -> &[u8] {
        match self.object_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_object_data(&mut self) {
        self.object_data = ::std::option::Option::None;
    }

    pub fn has_object_data(&self) -> bool {
        self.object_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.object_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.object_data.is_none() {
            self.object_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.object_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
        self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 version = 4;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type_id",
            |m: &CMsgSOSingleObject| { &m.type_id },
            |m: &mut CMsgSOSingleObject| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "object_data",
            |m: &CMsgSOSingleObject| { &m.object_data },
            |m: &mut CMsgSOSingleObject| { &mut m.object_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOSingleObject| { &m.version },
            |m: &mut CMsgSOSingleObject| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOSingleObject| { &m.owner_soid },
            |m: &mut CMsgSOSingleObject| { &mut m.owner_soid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOSingleObject>(
            "CMsgSOSingleObject",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOSingleObject {
    const NAME: &'static str = "CMsgSOSingleObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.type_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.object_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                33 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.object_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.object_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOSingleObject {
        CMsgSOSingleObject::new()
    }

    fn clear(&mut self) {
        self.type_id = ::std::option::Option::None;
        self.object_data = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOSingleObject {
        static instance: CMsgSOSingleObject = CMsgSOSingleObject {
            type_id: ::std::option::Option::None,
            object_data: ::std::option::Option::None,
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOSingleObject {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOSingleObject").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOSingleObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOSingleObject {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOMultipleObjects)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOMultipleObjects {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.objects_modified)
    pub objects_modified: ::std::vec::Vec<cmsg_somultiple_objects::SingleObject>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOMultipleObjects.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOMultipleObjects {
    fn default() -> &'a CMsgSOMultipleObjects {
        <CMsgSOMultipleObjects as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOMultipleObjects {
    pub fn new() -> CMsgSOMultipleObjects {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 3;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects_modified",
            |m: &CMsgSOMultipleObjects| { &m.objects_modified },
            |m: &mut CMsgSOMultipleObjects| { &mut m.objects_modified },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOMultipleObjects| { &m.version },
            |m: &mut CMsgSOMultipleObjects| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOMultipleObjects| { &m.owner_soid },
            |m: &mut CMsgSOMultipleObjects| { &mut m.owner_soid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOMultipleObjects>(
            "CMsgSOMultipleObjects",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOMultipleObjects {
    const NAME: &'static str = "CMsgSOMultipleObjects";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.objects_modified.push(is.read_message()?);
                },
                25 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.objects_modified {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.objects_modified {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOMultipleObjects {
        CMsgSOMultipleObjects::new()
    }

    fn clear(&mut self) {
        self.objects_modified.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOMultipleObjects {
        static instance: CMsgSOMultipleObjects = CMsgSOMultipleObjects {
            objects_modified: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOMultipleObjects {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOMultipleObjects").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOMultipleObjects {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOMultipleObjects {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSOMultipleObjects`
pub mod cmsg_somultiple_objects {
    // @@protoc_insertion_point(message:CMsgSOMultipleObjects.SingleObject)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleObject {
        // message fields
        // @@protoc_insertion_point(field:CMsgSOMultipleObjects.SingleObject.type_id)
        pub type_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSOMultipleObjects.SingleObject.object_data)
        pub object_data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSOMultipleObjects.SingleObject.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleObject {
        fn default() -> &'a SingleObject {
            <SingleObject as ::protobuf::Message>::default_instance()
        }
    }

    impl SingleObject {
        pub fn new() -> SingleObject {
            ::std::default::Default::default()
        }

        // optional int32 type_id = 1;

        pub fn type_id(&self) -> i32 {
            self.type_id.unwrap_or(0)
        }

        pub fn clear_type_id(&mut self) {
            self.type_id = ::std::option::Option::None;
        }

        pub fn has_type_id(&self) -> bool {
            self.type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_id(&mut self, v: i32) {
            self.type_id = ::std::option::Option::Some(v);
        }

        // optional bytes object_data = 2;

        pub fn object_data(&self) -> &[u8] {
            match self.object_data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_object_data(&mut self) {
            self.object_data = ::std::option::Option::None;
        }

        pub fn has_object_data(&self) -> bool {
            self.object_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.object_data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.object_data.is_none() {
                self.object_data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.object_data.as_mut().unwrap()
        }

        // Take field
        pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
            self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type_id",
                |m: &SingleObject| { &m.type_id },
                |m: &mut SingleObject| { &mut m.type_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "object_data",
                |m: &SingleObject| { &m.object_data },
                |m: &mut SingleObject| { &mut m.object_data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleObject>(
                "CMsgSOMultipleObjects.SingleObject",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SingleObject {
        const NAME: &'static str = "SingleObject";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.object_data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.object_data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.object_data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleObject {
            SingleObject::new()
        }

        fn clear(&mut self) {
            self.type_id = ::std::option::Option::None;
            self.object_data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleObject {
            static instance: SingleObject = SingleObject {
                type_id: ::std::option::Option::None,
                object_data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SingleObject {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSOMultipleObjects.SingleObject").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SingleObject {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SingleObject {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscribed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.objects)
    pub objects: ::std::vec::Vec<cmsg_socache_subscribed::SubscribedType>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscribed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribed {
    fn default() -> &'a CMsgSOCacheSubscribed {
        <CMsgSOCacheSubscribed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribed {
    pub fn new() -> CMsgSOCacheSubscribed {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 3;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "objects",
            |m: &CMsgSOCacheSubscribed| { &m.objects },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.objects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheSubscribed| { &m.version },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscribed| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscribed| { &mut m.owner_soid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscribed>(
            "CMsgSOCacheSubscribed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscribed {
    const NAME: &'static str = "CMsgSOCacheSubscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.objects.push(is.read_message()?);
                },
                25 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.objects {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscribed {
        CMsgSOCacheSubscribed::new()
    }

    fn clear(&mut self) {
        self.objects.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribed {
        static instance: CMsgSOCacheSubscribed = CMsgSOCacheSubscribed {
            objects: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscribed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscribed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscribed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscribed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSOCacheSubscribed`
pub mod cmsg_socache_subscribed {
    // @@protoc_insertion_point(message:CMsgSOCacheSubscribed.SubscribedType)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SubscribedType {
        // message fields
        // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.SubscribedType.type_id)
        pub type_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.SubscribedType.object_data)
        pub object_data: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSOCacheSubscribed.SubscribedType.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SubscribedType {
        fn default() -> &'a SubscribedType {
            <SubscribedType as ::protobuf::Message>::default_instance()
        }
    }

    impl SubscribedType {
        pub fn new() -> SubscribedType {
            ::std::default::Default::default()
        }

        // optional int32 type_id = 1;

        pub fn type_id(&self) -> i32 {
            self.type_id.unwrap_or(0)
        }

        pub fn clear_type_id(&mut self) {
            self.type_id = ::std::option::Option::None;
        }

        pub fn has_type_id(&self) -> bool {
            self.type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_id(&mut self, v: i32) {
            self.type_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type_id",
                |m: &SubscribedType| { &m.type_id },
                |m: &mut SubscribedType| { &mut m.type_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "object_data",
                |m: &SubscribedType| { &m.object_data },
                |m: &mut SubscribedType| { &mut m.object_data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribedType>(
                "CMsgSOCacheSubscribed.SubscribedType",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SubscribedType {
        const NAME: &'static str = "SubscribedType";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.object_data.push(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            for value in &self.object_data {
                my_size += ::protobuf::rt::bytes_size(2, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_id {
                os.write_int32(1, v)?;
            }
            for v in &self.object_data {
                os.write_bytes(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SubscribedType {
            SubscribedType::new()
        }

        fn clear(&mut self) {
            self.type_id = ::std::option::Option::None;
            self.object_data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SubscribedType {
            static instance: SubscribedType = SubscribedType {
                type_id: ::std::option::Option::None,
                object_data: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SubscribedType {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscribed.SubscribedType").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SubscribedType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SubscribedType {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheUnsubscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheUnsubscribed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheUnsubscribed.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheUnsubscribed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheUnsubscribed {
    fn default() -> &'a CMsgSOCacheUnsubscribed {
        <CMsgSOCacheUnsubscribed as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheUnsubscribed {
    pub fn new() -> CMsgSOCacheUnsubscribed {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheUnsubscribed| { &m.owner_soid },
            |m: &mut CMsgSOCacheUnsubscribed| { &mut m.owner_soid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheUnsubscribed>(
            "CMsgSOCacheUnsubscribed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheUnsubscribed {
    const NAME: &'static str = "CMsgSOCacheUnsubscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheUnsubscribed {
        CMsgSOCacheUnsubscribed::new()
    }

    fn clear(&mut self) {
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheUnsubscribed {
        static instance: CMsgSOCacheUnsubscribed = CMsgSOCacheUnsubscribed {
            owner_soid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheUnsubscribed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheUnsubscribed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheUnsubscribed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheUnsubscribed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscriptionCheck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscriptionCheck {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscriptionCheck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionCheck {
    fn default() -> &'a CMsgSOCacheSubscriptionCheck {
        <CMsgSOCacheSubscriptionCheck as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionCheck {
    pub fn new() -> CMsgSOCacheSubscriptionCheck {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 2;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.version },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscriptionCheck| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscriptionCheck| { &mut m.owner_soid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscriptionCheck>(
            "CMsgSOCacheSubscriptionCheck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscriptionCheck {
    const NAME: &'static str = "CMsgSOCacheSubscriptionCheck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                17 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscriptionCheck {
        CMsgSOCacheSubscriptionCheck::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionCheck {
        static instance: CMsgSOCacheSubscriptionCheck = CMsgSOCacheSubscriptionCheck {
            version: ::std::option::Option::None,
            owner_soid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscriptionCheck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscriptionCheck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscriptionCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscriptionCheck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscriptionRefresh)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscriptionRefresh {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionRefresh.owner_soid)
    pub owner_soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscriptionRefresh.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionRefresh {
    fn default() -> &'a CMsgSOCacheSubscriptionRefresh {
        <CMsgSOCacheSubscriptionRefresh as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionRefresh {
    pub fn new() -> CMsgSOCacheSubscriptionRefresh {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "owner_soid",
            |m: &CMsgSOCacheSubscriptionRefresh| { &m.owner_soid },
            |m: &mut CMsgSOCacheSubscriptionRefresh| { &mut m.owner_soid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheSubscriptionRefresh>(
            "CMsgSOCacheSubscriptionRefresh",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheSubscriptionRefresh {
    const NAME: &'static str = "CMsgSOCacheSubscriptionRefresh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.owner_soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscriptionRefresh {
        CMsgSOCacheSubscriptionRefresh::new()
    }

    fn clear(&mut self) {
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionRefresh {
        static instance: CMsgSOCacheSubscriptionRefresh = CMsgSOCacheSubscriptionRefresh {
            owner_soid: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheSubscriptionRefresh {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheSubscriptionRefresh").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheSubscriptionRefresh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheSubscriptionRefresh {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOCacheVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheVersion {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheVersion.version)
    pub version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheVersion {
    fn default() -> &'a CMsgSOCacheVersion {
        <CMsgSOCacheVersion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheVersion {
    pub fn new() -> CMsgSOCacheVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 1;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheVersion| { &m.version },
            |m: &mut CMsgSOCacheVersion| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheVersion>(
            "CMsgSOCacheVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheVersion {
    const NAME: &'static str = "CMsgSOCacheVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheVersion {
        CMsgSOCacheVersion::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheVersion {
        static instance: CMsgSOCacheVersion = CMsgSOCacheVersion {
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgAccountDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAccountDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgAccountDetails.valid)
    pub valid: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.account_name)
    pub account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.public_profile)
    pub public_profile: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.public_inventory)
    pub public_inventory: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.vac_banned)
    pub vac_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.cyber_cafe)
    pub cyber_cafe: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.school_account)
    pub school_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.free_trial_account)
    pub free_trial_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.subscribed)
    pub subscribed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.low_violence)
    pub low_violence: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.limited)
    pub limited: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.trusted)
    pub trusted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.package)
    pub package: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.time_cached)
    pub time_cached: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.account_locked)
    pub account_locked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.community_banned)
    pub community_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.trade_banned)
    pub trade_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.eligible_for_community_market)
    pub eligible_for_community_market: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAccountDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAccountDetails {
    fn default() -> &'a CMsgAccountDetails {
        <CMsgAccountDetails as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAccountDetails {
    pub fn new() -> CMsgAccountDetails {
        ::std::default::Default::default()
    }

    // optional bool valid = 1;

    pub fn valid(&self) -> bool {
        self.valid.unwrap_or(false)
    }

    pub fn clear_valid(&mut self) {
        self.valid = ::std::option::Option::None;
    }

    pub fn has_valid(&self) -> bool {
        self.valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: bool) {
        self.valid = ::std::option::Option::Some(v);
    }

    // optional string account_name = 2;

    pub fn account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name = ::std::option::Option::None;
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool public_profile = 4;

    pub fn public_profile(&self) -> bool {
        self.public_profile.unwrap_or(false)
    }

    pub fn clear_public_profile(&mut self) {
        self.public_profile = ::std::option::Option::None;
    }

    pub fn has_public_profile(&self) -> bool {
        self.public_profile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_profile(&mut self, v: bool) {
        self.public_profile = ::std::option::Option::Some(v);
    }

    // optional bool public_inventory = 5;

    pub fn public_inventory(&self) -> bool {
        self.public_inventory.unwrap_or(false)
    }

    pub fn clear_public_inventory(&mut self) {
        self.public_inventory = ::std::option::Option::None;
    }

    pub fn has_public_inventory(&self) -> bool {
        self.public_inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_inventory(&mut self, v: bool) {
        self.public_inventory = ::std::option::Option::Some(v);
    }

    // optional bool vac_banned = 6;

    pub fn vac_banned(&self) -> bool {
        self.vac_banned.unwrap_or(false)
    }

    pub fn clear_vac_banned(&mut self) {
        self.vac_banned = ::std::option::Option::None;
    }

    pub fn has_vac_banned(&self) -> bool {
        self.vac_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vac_banned(&mut self, v: bool) {
        self.vac_banned = ::std::option::Option::Some(v);
    }

    // optional bool cyber_cafe = 7;

    pub fn cyber_cafe(&self) -> bool {
        self.cyber_cafe.unwrap_or(false)
    }

    pub fn clear_cyber_cafe(&mut self) {
        self.cyber_cafe = ::std::option::Option::None;
    }

    pub fn has_cyber_cafe(&self) -> bool {
        self.cyber_cafe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cyber_cafe(&mut self, v: bool) {
        self.cyber_cafe = ::std::option::Option::Some(v);
    }

    // optional bool school_account = 8;

    pub fn school_account(&self) -> bool {
        self.school_account.unwrap_or(false)
    }

    pub fn clear_school_account(&mut self) {
        self.school_account = ::std::option::Option::None;
    }

    pub fn has_school_account(&self) -> bool {
        self.school_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_school_account(&mut self, v: bool) {
        self.school_account = ::std::option::Option::Some(v);
    }

    // optional bool free_trial_account = 9;

    pub fn free_trial_account(&self) -> bool {
        self.free_trial_account.unwrap_or(false)
    }

    pub fn clear_free_trial_account(&mut self) {
        self.free_trial_account = ::std::option::Option::None;
    }

    pub fn has_free_trial_account(&self) -> bool {
        self.free_trial_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_free_trial_account(&mut self, v: bool) {
        self.free_trial_account = ::std::option::Option::Some(v);
    }

    // optional bool subscribed = 10;

    pub fn subscribed(&self) -> bool {
        self.subscribed.unwrap_or(false)
    }

    pub fn clear_subscribed(&mut self) {
        self.subscribed = ::std::option::Option::None;
    }

    pub fn has_subscribed(&self) -> bool {
        self.subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribed(&mut self, v: bool) {
        self.subscribed = ::std::option::Option::Some(v);
    }

    // optional bool low_violence = 11;

    pub fn low_violence(&self) -> bool {
        self.low_violence.unwrap_or(false)
    }

    pub fn clear_low_violence(&mut self) {
        self.low_violence = ::std::option::Option::None;
    }

    pub fn has_low_violence(&self) -> bool {
        self.low_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_violence(&mut self, v: bool) {
        self.low_violence = ::std::option::Option::Some(v);
    }

    // optional bool limited = 12;

    pub fn limited(&self) -> bool {
        self.limited.unwrap_or(false)
    }

    pub fn clear_limited(&mut self) {
        self.limited = ::std::option::Option::None;
    }

    pub fn has_limited(&self) -> bool {
        self.limited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limited(&mut self, v: bool) {
        self.limited = ::std::option::Option::Some(v);
    }

    // optional bool trusted = 13;

    pub fn trusted(&self) -> bool {
        self.trusted.unwrap_or(false)
    }

    pub fn clear_trusted(&mut self) {
        self.trusted = ::std::option::Option::None;
    }

    pub fn has_trusted(&self) -> bool {
        self.trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted(&mut self, v: bool) {
        self.trusted = ::std::option::Option::Some(v);
    }

    // optional uint32 package = 14;

    pub fn package(&self) -> u32 {
        self.package.unwrap_or(0)
    }

    pub fn clear_package(&mut self) {
        self.package = ::std::option::Option::None;
    }

    pub fn has_package(&self) -> bool {
        self.package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: u32) {
        self.package = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_cached = 15;

    pub fn time_cached(&self) -> u32 {
        self.time_cached.unwrap_or(0)
    }

    pub fn clear_time_cached(&mut self) {
        self.time_cached = ::std::option::Option::None;
    }

    pub fn has_time_cached(&self) -> bool {
        self.time_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_cached(&mut self, v: u32) {
        self.time_cached = ::std::option::Option::Some(v);
    }

    // optional bool account_locked = 16;

    pub fn account_locked(&self) -> bool {
        self.account_locked.unwrap_or(false)
    }

    pub fn clear_account_locked(&mut self) {
        self.account_locked = ::std::option::Option::None;
    }

    pub fn has_account_locked(&self) -> bool {
        self.account_locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_locked(&mut self, v: bool) {
        self.account_locked = ::std::option::Option::Some(v);
    }

    // optional bool community_banned = 17;

    pub fn community_banned(&self) -> bool {
        self.community_banned.unwrap_or(false)
    }

    pub fn clear_community_banned(&mut self) {
        self.community_banned = ::std::option::Option::None;
    }

    pub fn has_community_banned(&self) -> bool {
        self.community_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_community_banned(&mut self, v: bool) {
        self.community_banned = ::std::option::Option::Some(v);
    }

    // optional bool trade_banned = 18;

    pub fn trade_banned(&self) -> bool {
        self.trade_banned.unwrap_or(false)
    }

    pub fn clear_trade_banned(&mut self) {
        self.trade_banned = ::std::option::Option::None;
    }

    pub fn has_trade_banned(&self) -> bool {
        self.trade_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_banned(&mut self, v: bool) {
        self.trade_banned = ::std::option::Option::Some(v);
    }

    // optional bool eligible_for_community_market = 19;

    pub fn eligible_for_community_market(&self) -> bool {
        self.eligible_for_community_market.unwrap_or(false)
    }

    pub fn clear_eligible_for_community_market(&mut self) {
        self.eligible_for_community_market = ::std::option::Option::None;
    }

    pub fn has_eligible_for_community_market(&self) -> bool {
        self.eligible_for_community_market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eligible_for_community_market(&mut self, v: bool) {
        self.eligible_for_community_market = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "valid",
            |m: &CMsgAccountDetails| { &m.valid },
            |m: &mut CMsgAccountDetails| { &mut m.valid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_name",
            |m: &CMsgAccountDetails| { &m.account_name },
            |m: &mut CMsgAccountDetails| { &mut m.account_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_profile",
            |m: &CMsgAccountDetails| { &m.public_profile },
            |m: &mut CMsgAccountDetails| { &mut m.public_profile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_inventory",
            |m: &CMsgAccountDetails| { &m.public_inventory },
            |m: &mut CMsgAccountDetails| { &mut m.public_inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vac_banned",
            |m: &CMsgAccountDetails| { &m.vac_banned },
            |m: &mut CMsgAccountDetails| { &mut m.vac_banned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cyber_cafe",
            |m: &CMsgAccountDetails| { &m.cyber_cafe },
            |m: &mut CMsgAccountDetails| { &mut m.cyber_cafe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "school_account",
            |m: &CMsgAccountDetails| { &m.school_account },
            |m: &mut CMsgAccountDetails| { &mut m.school_account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "free_trial_account",
            |m: &CMsgAccountDetails| { &m.free_trial_account },
            |m: &mut CMsgAccountDetails| { &mut m.free_trial_account },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscribed",
            |m: &CMsgAccountDetails| { &m.subscribed },
            |m: &mut CMsgAccountDetails| { &mut m.subscribed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_violence",
            |m: &CMsgAccountDetails| { &m.low_violence },
            |m: &mut CMsgAccountDetails| { &mut m.low_violence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limited",
            |m: &CMsgAccountDetails| { &m.limited },
            |m: &mut CMsgAccountDetails| { &mut m.limited },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trusted",
            |m: &CMsgAccountDetails| { &m.trusted },
            |m: &mut CMsgAccountDetails| { &mut m.trusted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "package",
            |m: &CMsgAccountDetails| { &m.package },
            |m: &mut CMsgAccountDetails| { &mut m.package },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_cached",
            |m: &CMsgAccountDetails| { &m.time_cached },
            |m: &mut CMsgAccountDetails| { &mut m.time_cached },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_locked",
            |m: &CMsgAccountDetails| { &m.account_locked },
            |m: &mut CMsgAccountDetails| { &mut m.account_locked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "community_banned",
            |m: &CMsgAccountDetails| { &m.community_banned },
            |m: &mut CMsgAccountDetails| { &mut m.community_banned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trade_banned",
            |m: &CMsgAccountDetails| { &m.trade_banned },
            |m: &mut CMsgAccountDetails| { &mut m.trade_banned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eligible_for_community_market",
            |m: &CMsgAccountDetails| { &m.eligible_for_community_market },
            |m: &mut CMsgAccountDetails| { &mut m.eligible_for_community_market },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgAccountDetails>(
            "CMsgAccountDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgAccountDetails {
    const NAME: &'static str = "CMsgAccountDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.valid = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.account_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.public_profile = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.public_inventory = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.vac_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.cyber_cafe = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.school_account = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.free_trial_account = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.subscribed = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.low_violence = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.limited = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.trusted = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.package = ::std::option::Option::Some(is.read_uint32()?);
                },
                125 => {
                    self.time_cached = ::std::option::Option::Some(is.read_fixed32()?);
                },
                128 => {
                    self.account_locked = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.community_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.trade_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.eligible_for_community_market = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.valid {
            my_size += 1 + 1;
        }
        if let Some(v) = self.account_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.public_profile {
            my_size += 1 + 1;
        }
        if let Some(v) = self.public_inventory {
            my_size += 1 + 1;
        }
        if let Some(v) = self.vac_banned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cyber_cafe {
            my_size += 1 + 1;
        }
        if let Some(v) = self.school_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.free_trial_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.subscribed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.low_violence {
            my_size += 1 + 1;
        }
        if let Some(v) = self.limited {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trusted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.package {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.time_cached {
            my_size += 1 + 4;
        }
        if let Some(v) = self.account_locked {
            my_size += 2 + 1;
        }
        if let Some(v) = self.community_banned {
            my_size += 2 + 1;
        }
        if let Some(v) = self.trade_banned {
            my_size += 2 + 1;
        }
        if let Some(v) = self.eligible_for_community_market {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.valid {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.public_profile {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.public_inventory {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.vac_banned {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.cyber_cafe {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.school_account {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.free_trial_account {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.subscribed {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.low_violence {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.limited {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.trusted {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.package {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.time_cached {
            os.write_fixed32(15, v)?;
        }
        if let Some(v) = self.account_locked {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.community_banned {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.trade_banned {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.eligible_for_community_market {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAccountDetails {
        CMsgAccountDetails::new()
    }

    fn clear(&mut self) {
        self.valid = ::std::option::Option::None;
        self.account_name = ::std::option::Option::None;
        self.public_profile = ::std::option::Option::None;
        self.public_inventory = ::std::option::Option::None;
        self.vac_banned = ::std::option::Option::None;
        self.cyber_cafe = ::std::option::Option::None;
        self.school_account = ::std::option::Option::None;
        self.free_trial_account = ::std::option::Option::None;
        self.subscribed = ::std::option::Option::None;
        self.low_violence = ::std::option::Option::None;
        self.limited = ::std::option::Option::None;
        self.trusted = ::std::option::Option::None;
        self.package = ::std::option::Option::None;
        self.time_cached = ::std::option::Option::None;
        self.account_locked = ::std::option::Option::None;
        self.community_banned = ::std::option::Option::None;
        self.trade_banned = ::std::option::Option::None;
        self.eligible_for_community_market = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAccountDetails {
        static instance: CMsgAccountDetails = CMsgAccountDetails {
            valid: ::std::option::Option::None,
            account_name: ::std::option::Option::None,
            public_profile: ::std::option::Option::None,
            public_inventory: ::std::option::Option::None,
            vac_banned: ::std::option::Option::None,
            cyber_cafe: ::std::option::Option::None,
            school_account: ::std::option::Option::None,
            free_trial_account: ::std::option::Option::None,
            subscribed: ::std::option::Option::None,
            low_violence: ::std::option::Option::None,
            limited: ::std::option::Option::None,
            trusted: ::std::option::Option::None,
            package: ::std::option::Option::None,
            time_cached: ::std::option::Option::None,
            account_locked: ::std::option::Option::None,
            community_banned: ::std::option::Option::None,
            trade_banned: ::std::option::Option::None,
            eligible_for_community_market: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgAccountDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgAccountDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgAccountDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAccountDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCMultiplexMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMultiplexMessage {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.msgtype)
    pub msgtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.steamids)
    pub steamids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.replytogc)
    pub replytogc: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMultiplexMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMultiplexMessage {
    fn default() -> &'a CMsgGCMultiplexMessage {
        <CMsgGCMultiplexMessage as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMultiplexMessage {
    pub fn new() -> CMsgGCMultiplexMessage {
        ::std::default::Default::default()
    }

    // optional uint32 msgtype = 1;

    pub fn msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 2;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool replytogc = 4;

    pub fn replytogc(&self) -> bool {
        self.replytogc.unwrap_or(false)
    }

    pub fn clear_replytogc(&mut self) {
        self.replytogc = ::std::option::Option::None;
    }

    pub fn has_replytogc(&self) -> bool {
        self.replytogc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replytogc(&mut self, v: bool) {
        self.replytogc = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msgtype",
            |m: &CMsgGCMultiplexMessage| { &m.msgtype },
            |m: &mut CMsgGCMultiplexMessage| { &mut m.msgtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &CMsgGCMultiplexMessage| { &m.payload },
            |m: &mut CMsgGCMultiplexMessage| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamids",
            |m: &CMsgGCMultiplexMessage| { &m.steamids },
            |m: &mut CMsgGCMultiplexMessage| { &mut m.steamids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replytogc",
            |m: &CMsgGCMultiplexMessage| { &m.replytogc },
            |m: &mut CMsgGCMultiplexMessage| { &mut m.replytogc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCMultiplexMessage>(
            "CMsgGCMultiplexMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCMultiplexMessage {
    const NAME: &'static str = "CMsgGCMultiplexMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamids)?;
                },
                25 => {
                    self.steamids.push(is.read_fixed64()?);
                },
                32 => {
                    self.replytogc = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msgtype {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += 9 * self.steamids.len() as u64;
        if let Some(v) = self.replytogc {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msgtype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.steamids {
            os.write_fixed64(3, *v)?;
        };
        if let Some(v) = self.replytogc {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMultiplexMessage {
        CMsgGCMultiplexMessage::new()
    }

    fn clear(&mut self) {
        self.msgtype = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.steamids.clear();
        self.replytogc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMultiplexMessage {
        static instance: CMsgGCMultiplexMessage = CMsgGCMultiplexMessage {
            msgtype: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            steamids: ::std::vec::Vec::new(),
            replytogc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCMultiplexMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCMultiplexMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCMultiplexMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMultiplexMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCMultiplexMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMultiplexMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage_Response.msgtype)
    pub msgtype: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMultiplexMessage_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMultiplexMessage_Response {
    fn default() -> &'a CMsgGCMultiplexMessage_Response {
        <CMsgGCMultiplexMessage_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMultiplexMessage_Response {
    pub fn new() -> CMsgGCMultiplexMessage_Response {
        ::std::default::Default::default()
    }

    // optional uint32 msgtype = 1;

    pub fn msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msgtype",
            |m: &CMsgGCMultiplexMessage_Response| { &m.msgtype },
            |m: &mut CMsgGCMultiplexMessage_Response| { &mut m.msgtype },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCMultiplexMessage_Response>(
            "CMsgGCMultiplexMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCMultiplexMessage_Response {
    const NAME: &'static str = "CMsgGCMultiplexMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msgtype {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msgtype {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMultiplexMessage_Response {
        CMsgGCMultiplexMessage_Response::new()
    }

    fn clear(&mut self) {
        self.msgtype = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMultiplexMessage_Response {
        static instance: CMsgGCMultiplexMessage_Response = CMsgGCMultiplexMessage_Response {
            msgtype: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCMultiplexMessage_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCMultiplexMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCMultiplexMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCMultiplexMessage_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterAck {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.dir_index)
    pub dir_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.gc_type)
    pub gc_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck {
    fn default() -> &'a CGCToGCMsgMasterAck {
        <CGCToGCMsgMasterAck as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck {
    pub fn new() -> CGCToGCMsgMasterAck {
        ::std::default::Default::default()
    }

    // optional uint32 dir_index = 1;

    pub fn dir_index(&self) -> u32 {
        self.dir_index.unwrap_or(0)
    }

    pub fn clear_dir_index(&mut self) {
        self.dir_index = ::std::option::Option::None;
    }

    pub fn has_dir_index(&self) -> bool {
        self.dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dir_index(&mut self, v: u32) {
        self.dir_index = ::std::option::Option::Some(v);
    }

    // optional uint32 gc_type = 2;

    pub fn gc_type(&self) -> u32 {
        self.gc_type.unwrap_or(0)
    }

    pub fn clear_gc_type(&mut self) {
        self.gc_type = ::std::option::Option::None;
    }

    pub fn has_gc_type(&self) -> bool {
        self.gc_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_type(&mut self, v: u32) {
        self.gc_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dir_index",
            |m: &CGCToGCMsgMasterAck| { &m.dir_index },
            |m: &mut CGCToGCMsgMasterAck| { &mut m.dir_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gc_type",
            |m: &CGCToGCMsgMasterAck| { &m.gc_type },
            |m: &mut CGCToGCMsgMasterAck| { &mut m.gc_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgMasterAck>(
            "CGCToGCMsgMasterAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterAck {
    const NAME: &'static str = "CGCToGCMsgMasterAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dir_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gc_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dir_index {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gc_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dir_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gc_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterAck {
        CGCToGCMsgMasterAck::new()
    }

    fn clear(&mut self) {
        self.dir_index = ::std::option::Option::None;
        self.gc_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck {
        static instance: CGCToGCMsgMasterAck = CGCToGCMsgMasterAck {
            dir_index: ::std::option::Option::None,
            gc_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgMasterAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgMasterAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterAck_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterAck_Response {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck_Response.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterAck_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck_Response {
    fn default() -> &'a CGCToGCMsgMasterAck_Response {
        <CGCToGCMsgMasterAck_Response as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck_Response {
    pub fn new() -> CGCToGCMsgMasterAck_Response {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eresult",
            |m: &CGCToGCMsgMasterAck_Response| { &m.eresult },
            |m: &mut CGCToGCMsgMasterAck_Response| { &mut m.eresult },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgMasterAck_Response>(
            "CGCToGCMsgMasterAck_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterAck_Response {
    const NAME: &'static str = "CGCToGCMsgMasterAck_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterAck_Response {
        CGCToGCMsgMasterAck_Response::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck_Response {
        static instance: CGCToGCMsgMasterAck_Response = CGCToGCMsgMasterAck_Response {
            eresult: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgMasterAck_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterAck_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgMasterAck_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterAck_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterStartupComplete)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterStartupComplete {
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterStartupComplete.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterStartupComplete {
    fn default() -> &'a CGCToGCMsgMasterStartupComplete {
        <CGCToGCMsgMasterStartupComplete as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterStartupComplete {
    pub fn new() -> CGCToGCMsgMasterStartupComplete {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgMasterStartupComplete>(
            "CGCToGCMsgMasterStartupComplete",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgMasterStartupComplete {
    const NAME: &'static str = "CGCToGCMsgMasterStartupComplete";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterStartupComplete {
        CGCToGCMsgMasterStartupComplete::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterStartupComplete {
        static instance: CGCToGCMsgMasterStartupComplete = CGCToGCMsgMasterStartupComplete {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgMasterStartupComplete {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgMasterStartupComplete").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgMasterStartupComplete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgMasterStartupComplete {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCToGCMsgRouted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgRouted {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.net_message)
    pub net_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.ip)
    pub ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgRouted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRouted {
    fn default() -> &'a CGCToGCMsgRouted {
        <CGCToGCMsgRouted as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRouted {
    pub fn new() -> CGCToGCMsgRouted {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 3;

    pub fn net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_net_message(&mut self) {
        self.net_message = ::std::option::Option::None;
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ip = 4;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CGCToGCMsgRouted| { &m.msg_type },
            |m: &mut CGCToGCMsgRouted| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_id",
            |m: &CGCToGCMsgRouted| { &m.sender_id },
            |m: &mut CGCToGCMsgRouted| { &mut m.sender_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_message",
            |m: &CGCToGCMsgRouted| { &m.net_message },
            |m: &mut CGCToGCMsgRouted| { &mut m.net_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &CGCToGCMsgRouted| { &m.ip },
            |m: &mut CGCToGCMsgRouted| { &mut m.ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgRouted>(
            "CGCToGCMsgRouted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgRouted {
    const NAME: &'static str = "CGCToGCMsgRouted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.net_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.net_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.net_message.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgRouted {
        CGCToGCMsgRouted::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.net_message = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgRouted {
        static instance: CGCToGCMsgRouted = CGCToGCMsgRouted {
            msg_type: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            net_message: ::std::option::Option::None,
            ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgRouted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgRouted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgRouted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgRouted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGCToGCMsgRoutedReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgRoutedReply {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgRoutedReply.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgRoutedReply.net_message)
    pub net_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgRoutedReply.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRoutedReply {
    fn default() -> &'a CGCToGCMsgRoutedReply {
        <CGCToGCMsgRoutedReply as ::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRoutedReply {
    pub fn new() -> CGCToGCMsgRoutedReply {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 2;

    pub fn net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_net_message(&mut self) {
        self.net_message = ::std::option::Option::None;
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CGCToGCMsgRoutedReply| { &m.msg_type },
            |m: &mut CGCToGCMsgRoutedReply| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_message",
            |m: &CGCToGCMsgRoutedReply| { &m.net_message },
            |m: &mut CGCToGCMsgRoutedReply| { &mut m.net_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGCToGCMsgRoutedReply>(
            "CGCToGCMsgRoutedReply",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGCToGCMsgRoutedReply {
    const NAME: &'static str = "CGCToGCMsgRoutedReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.net_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.net_message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.net_message.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgRoutedReply {
        CGCToGCMsgRoutedReply::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.net_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgRoutedReply {
        static instance: CGCToGCMsgRoutedReply = CGCToGCMsgRoutedReply {
            msg_type: ::std::option::Option::None,
            net_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGCToGCMsgRoutedReply {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGCToGCMsgRoutedReply").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGCToGCMsgRoutedReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGCToGCMsgRoutedReply {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCUpdateSessionIP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCUpdateSessionIP {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCUpdateSessionIP.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCUpdateSessionIP.ip)
    pub ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCUpdateSessionIP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCUpdateSessionIP {
    fn default() -> &'a CMsgGCUpdateSessionIP {
        <CMsgGCUpdateSessionIP as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCUpdateSessionIP {
    pub fn new() -> CMsgGCUpdateSessionIP {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed32 ip = 2;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgGCUpdateSessionIP| { &m.steamid },
            |m: &mut CMsgGCUpdateSessionIP| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &CMsgGCUpdateSessionIP| { &m.ip },
            |m: &mut CMsgGCUpdateSessionIP| { &mut m.ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCUpdateSessionIP>(
            "CMsgGCUpdateSessionIP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCUpdateSessionIP {
    const NAME: &'static str = "CMsgGCUpdateSessionIP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                21 => {
                    self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ip {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.ip {
            os.write_fixed32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCUpdateSessionIP {
        CMsgGCUpdateSessionIP::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCUpdateSessionIP {
        static instance: CMsgGCUpdateSessionIP = CMsgGCUpdateSessionIP {
            steamid: ::std::option::Option::None,
            ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCUpdateSessionIP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCUpdateSessionIP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCUpdateSessionIP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCUpdateSessionIP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCRequestSessionIP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestSessionIP {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestSessionIP.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestSessionIP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSessionIP {
    fn default() -> &'a CMsgGCRequestSessionIP {
        <CMsgGCRequestSessionIP as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSessionIP {
    pub fn new() -> CMsgGCRequestSessionIP {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgGCRequestSessionIP| { &m.steamid },
            |m: &mut CMsgGCRequestSessionIP| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestSessionIP>(
            "CMsgGCRequestSessionIP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestSessionIP {
    const NAME: &'static str = "CMsgGCRequestSessionIP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestSessionIP {
        CMsgGCRequestSessionIP::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestSessionIP {
        static instance: CMsgGCRequestSessionIP = CMsgGCRequestSessionIP {
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestSessionIP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestSessionIP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestSessionIP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestSessionIP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCRequestSessionIPResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestSessionIPResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestSessionIPResponse.ip)
    pub ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestSessionIPResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSessionIPResponse {
    fn default() -> &'a CMsgGCRequestSessionIPResponse {
        <CMsgGCRequestSessionIPResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSessionIPResponse {
    pub fn new() -> CMsgGCRequestSessionIPResponse {
        ::std::default::Default::default()
    }

    // optional fixed32 ip = 1;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &CMsgGCRequestSessionIPResponse| { &m.ip },
            |m: &mut CMsgGCRequestSessionIPResponse| { &mut m.ip },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCRequestSessionIPResponse>(
            "CMsgGCRequestSessionIPResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCRequestSessionIPResponse {
    const NAME: &'static str = "CMsgGCRequestSessionIPResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ip {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestSessionIPResponse {
        CMsgGCRequestSessionIPResponse::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestSessionIPResponse {
        static instance: CMsgGCRequestSessionIPResponse = CMsgGCRequestSessionIPResponse {
            ip: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCRequestSessionIPResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCRequestSessionIPResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCRequestSessionIPResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCRequestSessionIPResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSOCacheHaveVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheHaveVersion {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.soid)
    pub soid: ::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.version)
    pub version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheHaveVersion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheHaveVersion {
    fn default() -> &'a CMsgSOCacheHaveVersion {
        <CMsgSOCacheHaveVersion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheHaveVersion {
    pub fn new() -> CMsgSOCacheHaveVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 2;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSOIDOwner>(
            "soid",
            |m: &CMsgSOCacheHaveVersion| { &m.soid },
            |m: &mut CMsgSOCacheHaveVersion| { &mut m.soid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgSOCacheHaveVersion| { &m.version },
            |m: &mut CMsgSOCacheHaveVersion| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSOCacheHaveVersion>(
            "CMsgSOCacheHaveVersion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSOCacheHaveVersion {
    const NAME: &'static str = "CMsgSOCacheHaveVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.soid)?;
                },
                17 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheHaveVersion {
        CMsgSOCacheHaveVersion::new()
    }

    fn clear(&mut self) {
        self.soid.clear();
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheHaveVersion {
        static instance: CMsgSOCacheHaveVersion = CMsgSOCacheHaveVersion {
            soid: ::protobuf::MessageField::none(),
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSOCacheHaveVersion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSOCacheHaveVersion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSOCacheHaveVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSOCacheHaveVersion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientHello.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.socache_have_versions)
    pub socache_have_versions: ::std::vec::Vec<CMsgSOCacheHaveVersion>,
    // @@protoc_insertion_point(field:CMsgClientHello.client_session_need)
    pub client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.client_launcher)
    pub client_launcher: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.partner_srcid)
    pub partner_srcid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.partner_accountid)
    pub partner_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.partner_accountflags)
    pub partner_accountflags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.partner_accountbalance)
    pub partner_accountbalance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.steam_launcher)
    pub steam_launcher: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientHello {
    fn default() -> &'a CMsgClientHello {
        <CMsgClientHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientHello {
    pub fn new() -> CMsgClientHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 client_session_need = 3;

    pub fn client_session_need(&self) -> u32 {
        self.client_session_need.unwrap_or(0)
    }

    pub fn clear_client_session_need(&mut self) {
        self.client_session_need = ::std::option::Option::None;
    }

    pub fn has_client_session_need(&self) -> bool {
        self.client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_need(&mut self, v: u32) {
        self.client_session_need = ::std::option::Option::Some(v);
    }

    // optional uint32 client_launcher = 4;

    pub fn client_launcher(&self) -> u32 {
        self.client_launcher.unwrap_or(0)
    }

    pub fn clear_client_launcher(&mut self) {
        self.client_launcher = ::std::option::Option::None;
    }

    pub fn has_client_launcher(&self) -> bool {
        self.client_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_launcher(&mut self, v: u32) {
        self.client_launcher = ::std::option::Option::Some(v);
    }

    // optional uint32 partner_srcid = 5;

    pub fn partner_srcid(&self) -> u32 {
        self.partner_srcid.unwrap_or(0)
    }

    pub fn clear_partner_srcid(&mut self) {
        self.partner_srcid = ::std::option::Option::None;
    }

    pub fn has_partner_srcid(&self) -> bool {
        self.partner_srcid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_srcid(&mut self, v: u32) {
        self.partner_srcid = ::std::option::Option::Some(v);
    }

    // optional uint32 partner_accountid = 6;

    pub fn partner_accountid(&self) -> u32 {
        self.partner_accountid.unwrap_or(0)
    }

    pub fn clear_partner_accountid(&mut self) {
        self.partner_accountid = ::std::option::Option::None;
    }

    pub fn has_partner_accountid(&self) -> bool {
        self.partner_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_accountid(&mut self, v: u32) {
        self.partner_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 partner_accountflags = 7;

    pub fn partner_accountflags(&self) -> u32 {
        self.partner_accountflags.unwrap_or(0)
    }

    pub fn clear_partner_accountflags(&mut self) {
        self.partner_accountflags = ::std::option::Option::None;
    }

    pub fn has_partner_accountflags(&self) -> bool {
        self.partner_accountflags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_accountflags(&mut self, v: u32) {
        self.partner_accountflags = ::std::option::Option::Some(v);
    }

    // optional uint32 partner_accountbalance = 8;

    pub fn partner_accountbalance(&self) -> u32 {
        self.partner_accountbalance.unwrap_or(0)
    }

    pub fn clear_partner_accountbalance(&mut self) {
        self.partner_accountbalance = ::std::option::Option::None;
    }

    pub fn has_partner_accountbalance(&self) -> bool {
        self.partner_accountbalance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_accountbalance(&mut self, v: u32) {
        self.partner_accountbalance = ::std::option::Option::Some(v);
    }

    // optional uint32 steam_launcher = 9;

    pub fn steam_launcher(&self) -> u32 {
        self.steam_launcher.unwrap_or(0)
    }

    pub fn clear_steam_launcher(&mut self) {
        self.steam_launcher = ::std::option::Option::None;
    }

    pub fn has_steam_launcher(&self) -> bool {
        self.steam_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_launcher(&mut self, v: u32) {
        self.steam_launcher = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgClientHello| { &m.version },
            |m: &mut CMsgClientHello| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "socache_have_versions",
            |m: &CMsgClientHello| { &m.socache_have_versions },
            |m: &mut CMsgClientHello| { &mut m.socache_have_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_session_need",
            |m: &CMsgClientHello| { &m.client_session_need },
            |m: &mut CMsgClientHello| { &mut m.client_session_need },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_launcher",
            |m: &CMsgClientHello| { &m.client_launcher },
            |m: &mut CMsgClientHello| { &mut m.client_launcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partner_srcid",
            |m: &CMsgClientHello| { &m.partner_srcid },
            |m: &mut CMsgClientHello| { &mut m.partner_srcid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partner_accountid",
            |m: &CMsgClientHello| { &m.partner_accountid },
            |m: &mut CMsgClientHello| { &mut m.partner_accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partner_accountflags",
            |m: &CMsgClientHello| { &m.partner_accountflags },
            |m: &mut CMsgClientHello| { &mut m.partner_accountflags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "partner_accountbalance",
            |m: &CMsgClientHello| { &m.partner_accountbalance },
            |m: &mut CMsgClientHello| { &mut m.partner_accountbalance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_launcher",
            |m: &CMsgClientHello| { &m.steam_launcher },
            |m: &mut CMsgClientHello| { &mut m.steam_launcher },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientHello>(
            "CMsgClientHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientHello {
    const NAME: &'static str = "CMsgClientHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.socache_have_versions.push(is.read_message()?);
                },
                24 => {
                    self.client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.client_launcher = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.partner_srcid = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.partner_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.partner_accountflags = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.partner_accountbalance = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.steam_launcher = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.socache_have_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.client_session_need {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.client_launcher {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.partner_srcid {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.partner_accountid {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.partner_accountflags {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.partner_accountbalance {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.steam_launcher {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.socache_have_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.client_session_need {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.client_launcher {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.partner_srcid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.partner_accountid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.partner_accountflags {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.partner_accountbalance {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.steam_launcher {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientHello {
        CMsgClientHello::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.socache_have_versions.clear();
        self.client_session_need = ::std::option::Option::None;
        self.client_launcher = ::std::option::Option::None;
        self.partner_srcid = ::std::option::Option::None;
        self.partner_accountid = ::std::option::Option::None;
        self.partner_accountflags = ::std::option::Option::None;
        self.partner_accountbalance = ::std::option::Option::None;
        self.steam_launcher = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientHello {
        static instance: CMsgClientHello = CMsgClientHello {
            version: ::std::option::Option::None,
            socache_have_versions: ::std::vec::Vec::new(),
            client_session_need: ::std::option::Option::None,
            client_launcher: ::std::option::Option::None,
            partner_srcid: ::std::option::Option::None,
            partner_accountid: ::std::option::Option::None,
            partner_accountflags: ::std::option::Option::None,
            partner_accountbalance: ::std::option::Option::None,
            steam_launcher: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgServerHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerHello.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerHello.socache_have_versions)
    pub socache_have_versions: ::std::vec::Vec<CMsgSOCacheHaveVersion>,
    // @@protoc_insertion_point(field:CMsgServerHello.legacy_client_session_need)
    pub legacy_client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerHello.client_launcher)
    pub client_launcher: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerHello.legacy_steamdatagram_routing)
    pub legacy_steamdatagram_routing: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgServerHello.required_internal_addr)
    pub required_internal_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerHello.steamdatagram_login)
    pub steamdatagram_login: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerHello {
    fn default() -> &'a CMsgServerHello {
        <CMsgServerHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerHello {
    pub fn new() -> CMsgServerHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_client_session_need = 3;

    pub fn legacy_client_session_need(&self) -> u32 {
        self.legacy_client_session_need.unwrap_or(0)
    }

    pub fn clear_legacy_client_session_need(&mut self) {
        self.legacy_client_session_need = ::std::option::Option::None;
    }

    pub fn has_legacy_client_session_need(&self) -> bool {
        self.legacy_client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_session_need(&mut self, v: u32) {
        self.legacy_client_session_need = ::std::option::Option::Some(v);
    }

    // optional uint32 client_launcher = 4;

    pub fn client_launcher(&self) -> u32 {
        self.client_launcher.unwrap_or(0)
    }

    pub fn clear_client_launcher(&mut self) {
        self.client_launcher = ::std::option::Option::None;
    }

    pub fn has_client_launcher(&self) -> bool {
        self.client_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_launcher(&mut self, v: u32) {
        self.client_launcher = ::std::option::Option::Some(v);
    }

    // optional bytes legacy_steamdatagram_routing = 6;

    pub fn legacy_steamdatagram_routing(&self) -> &[u8] {
        match self.legacy_steamdatagram_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_legacy_steamdatagram_routing(&mut self) {
        self.legacy_steamdatagram_routing = ::std::option::Option::None;
    }

    pub fn has_legacy_steamdatagram_routing(&self) -> bool {
        self.legacy_steamdatagram_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_steamdatagram_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.legacy_steamdatagram_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacy_steamdatagram_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.legacy_steamdatagram_routing.is_none() {
            self.legacy_steamdatagram_routing = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.legacy_steamdatagram_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacy_steamdatagram_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.legacy_steamdatagram_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 required_internal_addr = 7;

    pub fn required_internal_addr(&self) -> u32 {
        self.required_internal_addr.unwrap_or(0)
    }

    pub fn clear_required_internal_addr(&mut self) {
        self.required_internal_addr = ::std::option::Option::None;
    }

    pub fn has_required_internal_addr(&self) -> bool {
        self.required_internal_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_internal_addr(&mut self, v: u32) {
        self.required_internal_addr = ::std::option::Option::Some(v);
    }

    // optional bytes steamdatagram_login = 8;

    pub fn steamdatagram_login(&self) -> &[u8] {
        match self.steamdatagram_login.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_steamdatagram_login(&mut self) {
        self.steamdatagram_login = ::std::option::Option::None;
    }

    pub fn has_steamdatagram_login(&self) -> bool {
        self.steamdatagram_login.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamdatagram_login(&mut self, v: ::std::vec::Vec<u8>) {
        self.steamdatagram_login = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steamdatagram_login(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.steamdatagram_login.is_none() {
            self.steamdatagram_login = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.steamdatagram_login.as_mut().unwrap()
    }

    // Take field
    pub fn take_steamdatagram_login(&mut self) -> ::std::vec::Vec<u8> {
        self.steamdatagram_login.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgServerHello| { &m.version },
            |m: &mut CMsgServerHello| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "socache_have_versions",
            |m: &CMsgServerHello| { &m.socache_have_versions },
            |m: &mut CMsgServerHello| { &mut m.socache_have_versions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_client_session_need",
            |m: &CMsgServerHello| { &m.legacy_client_session_need },
            |m: &mut CMsgServerHello| { &mut m.legacy_client_session_need },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_launcher",
            |m: &CMsgServerHello| { &m.client_launcher },
            |m: &mut CMsgServerHello| { &mut m.client_launcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_steamdatagram_routing",
            |m: &CMsgServerHello| { &m.legacy_steamdatagram_routing },
            |m: &mut CMsgServerHello| { &mut m.legacy_steamdatagram_routing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "required_internal_addr",
            |m: &CMsgServerHello| { &m.required_internal_addr },
            |m: &mut CMsgServerHello| { &mut m.required_internal_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamdatagram_login",
            |m: &CMsgServerHello| { &m.steamdatagram_login },
            |m: &mut CMsgServerHello| { &mut m.steamdatagram_login },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerHello>(
            "CMsgServerHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerHello {
    const NAME: &'static str = "CMsgServerHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.socache_have_versions.push(is.read_message()?);
                },
                24 => {
                    self.legacy_client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.client_launcher = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.legacy_steamdatagram_routing = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.required_internal_addr = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.steamdatagram_login = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.socache_have_versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.legacy_client_session_need {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.client_launcher {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.legacy_steamdatagram_routing.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.required_internal_addr {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.steamdatagram_login.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.socache_have_versions {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.legacy_client_session_need {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.client_launcher {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.legacy_steamdatagram_routing.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.required_internal_addr {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.steamdatagram_login.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerHello {
        CMsgServerHello::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.socache_have_versions.clear();
        self.legacy_client_session_need = ::std::option::Option::None;
        self.client_launcher = ::std::option::Option::None;
        self.legacy_steamdatagram_routing = ::std::option::Option::None;
        self.required_internal_addr = ::std::option::Option::None;
        self.steamdatagram_login = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerHello {
        static instance: CMsgServerHello = CMsgServerHello {
            version: ::std::option::Option::None,
            socache_have_versions: ::std::vec::Vec::new(),
            legacy_client_session_need: ::std::option::Option::None,
            client_launcher: ::std::option::Option::None,
            legacy_steamdatagram_routing: ::std::option::Option::None,
            required_internal_addr: ::std::option::Option::None,
            steamdatagram_login: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClientWelcome)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWelcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWelcome.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.game_data)
    pub game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.outofdate_subscribed_caches)
    pub outofdate_subscribed_caches: ::std::vec::Vec<CMsgSOCacheSubscribed>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.uptodate_subscribed_caches)
    pub uptodate_subscribed_caches: ::std::vec::Vec<CMsgSOCacheSubscriptionCheck>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.location)
    pub location: ::protobuf::MessageField<cmsg_client_welcome::Location>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.game_data2)
    pub game_data2: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.rtime32_gc_welcome_timestamp)
    pub rtime32_gc_welcome_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.currency)
    pub currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.balance)
    pub balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.balance_url)
    pub balance_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.txn_country_code)
    pub txn_country_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWelcome.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWelcome {
    fn default() -> &'a CMsgClientWelcome {
        <CMsgClientWelcome as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWelcome {
    pub fn new() -> CMsgClientWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes game_data = 2;

    pub fn game_data(&self) -> &[u8] {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data = ::std::option::Option::None;
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data.is_none() {
            self.game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes game_data2 = 6;

    pub fn game_data2(&self) -> &[u8] {
        match self.game_data2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data2(&mut self) {
        self.game_data2 = ::std::option::Option::None;
    }

    pub fn has_game_data2(&self) -> bool {
        self.game_data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data2.is_none() {
            self.game_data2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 rtime32_gc_welcome_timestamp = 7;

    pub fn rtime32_gc_welcome_timestamp(&self) -> u32 {
        self.rtime32_gc_welcome_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_gc_welcome_timestamp(&mut self) {
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_gc_welcome_timestamp(&self) -> bool {
        self.rtime32_gc_welcome_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_gc_welcome_timestamp(&mut self, v: u32) {
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 8;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional uint32 balance = 9;

    pub fn balance(&self) -> u32 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: u32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional string balance_url = 10;

    pub fn balance_url(&self) -> &str {
        match self.balance_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_balance_url(&mut self) {
        self.balance_url = ::std::option::Option::None;
    }

    pub fn has_balance_url(&self) -> bool {
        self.balance_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_url(&mut self, v: ::std::string::String) {
        self.balance_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance_url(&mut self) -> &mut ::std::string::String {
        if self.balance_url.is_none() {
            self.balance_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.balance_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_balance_url(&mut self) -> ::std::string::String {
        self.balance_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string txn_country_code = 11;

    pub fn txn_country_code(&self) -> &str {
        match self.txn_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_txn_country_code(&mut self) {
        self.txn_country_code = ::std::option::Option::None;
    }

    pub fn has_txn_country_code(&self) -> bool {
        self.txn_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_country_code(&mut self, v: ::std::string::String) {
        self.txn_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_country_code(&mut self) -> &mut ::std::string::String {
        if self.txn_country_code.is_none() {
            self.txn_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.txn_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_country_code(&mut self) -> ::std::string::String {
        self.txn_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgClientWelcome| { &m.version },
            |m: &mut CMsgClientWelcome| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_data",
            |m: &CMsgClientWelcome| { &m.game_data },
            |m: &mut CMsgClientWelcome| { &mut m.game_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outofdate_subscribed_caches",
            |m: &CMsgClientWelcome| { &m.outofdate_subscribed_caches },
            |m: &mut CMsgClientWelcome| { &mut m.outofdate_subscribed_caches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uptodate_subscribed_caches",
            |m: &CMsgClientWelcome| { &m.uptodate_subscribed_caches },
            |m: &mut CMsgClientWelcome| { &mut m.uptodate_subscribed_caches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_client_welcome::Location>(
            "location",
            |m: &CMsgClientWelcome| { &m.location },
            |m: &mut CMsgClientWelcome| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_data2",
            |m: &CMsgClientWelcome| { &m.game_data2 },
            |m: &mut CMsgClientWelcome| { &mut m.game_data2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_gc_welcome_timestamp",
            |m: &CMsgClientWelcome| { &m.rtime32_gc_welcome_timestamp },
            |m: &mut CMsgClientWelcome| { &mut m.rtime32_gc_welcome_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgClientWelcome| { &m.currency },
            |m: &mut CMsgClientWelcome| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance",
            |m: &CMsgClientWelcome| { &m.balance },
            |m: &mut CMsgClientWelcome| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance_url",
            |m: &CMsgClientWelcome| { &m.balance_url },
            |m: &mut CMsgClientWelcome| { &mut m.balance_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_country_code",
            |m: &CMsgClientWelcome| { &m.txn_country_code },
            |m: &mut CMsgClientWelcome| { &mut m.txn_country_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClientWelcome>(
            "CMsgClientWelcome",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClientWelcome {
    const NAME: &'static str = "CMsgClientWelcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.outofdate_subscribed_caches.push(is.read_message()?);
                },
                34 => {
                    self.uptodate_subscribed_caches.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                50 => {
                    self.game_data2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.rtime32_gc_welcome_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.balance_url = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.txn_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.outofdate_subscribed_caches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.uptodate_subscribed_caches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.rtime32_gc_welcome_timestamp {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.balance_url.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.outofdate_subscribed_caches {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.uptodate_subscribed_caches {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.location.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.game_data2.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.rtime32_gc_welcome_timestamp {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.balance {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.balance_url.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWelcome {
        CMsgClientWelcome::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.game_data = ::std::option::Option::None;
        self.outofdate_subscribed_caches.clear();
        self.uptodate_subscribed_caches.clear();
        self.location.clear();
        self.game_data2 = ::std::option::Option::None;
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.balance_url = ::std::option::Option::None;
        self.txn_country_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWelcome {
        static instance: CMsgClientWelcome = CMsgClientWelcome {
            version: ::std::option::Option::None,
            game_data: ::std::option::Option::None,
            outofdate_subscribed_caches: ::std::vec::Vec::new(),
            uptodate_subscribed_caches: ::std::vec::Vec::new(),
            location: ::protobuf::MessageField::none(),
            game_data2: ::std::option::Option::None,
            rtime32_gc_welcome_timestamp: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            balance_url: ::std::option::Option::None,
            txn_country_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClientWelcome {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClientWelcome").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClientWelcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientWelcome {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgClientWelcome`
pub mod cmsg_client_welcome {
    // @@protoc_insertion_point(message:CMsgClientWelcome.Location)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientWelcome.Location.latitude)
        pub latitude: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgClientWelcome.Location.longitude)
        pub longitude: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgClientWelcome.Location.country)
        pub country: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientWelcome.Location.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as ::protobuf::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional float latitude = 1;

        pub fn latitude(&self) -> f32 {
            self.latitude.unwrap_or(0.)
        }

        pub fn clear_latitude(&mut self) {
            self.latitude = ::std::option::Option::None;
        }

        pub fn has_latitude(&self) -> bool {
            self.latitude.is_some()
        }

        // Param is passed by value, moved
        pub fn set_latitude(&mut self, v: f32) {
            self.latitude = ::std::option::Option::Some(v);
        }

        // optional float longitude = 2;

        pub fn longitude(&self) -> f32 {
            self.longitude.unwrap_or(0.)
        }

        pub fn clear_longitude(&mut self) {
            self.longitude = ::std::option::Option::None;
        }

        pub fn has_longitude(&self) -> bool {
            self.longitude.is_some()
        }

        // Param is passed by value, moved
        pub fn set_longitude(&mut self, v: f32) {
            self.longitude = ::std::option::Option::Some(v);
        }

        // optional string country = 3;

        pub fn country(&self) -> &str {
            match self.country.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country(&mut self) {
            self.country = ::std::option::Option::None;
        }

        pub fn has_country(&self) -> bool {
            self.country.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country(&mut self, v: ::std::string::String) {
            self.country = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country(&mut self) -> &mut ::std::string::String {
            if self.country.is_none() {
                self.country = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country.as_mut().unwrap()
        }

        // Take field
        pub fn take_country(&mut self) -> ::std::string::String {
            self.country.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "latitude",
                |m: &Location| { &m.latitude },
                |m: &mut Location| { &mut m.latitude },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "longitude",
                |m: &Location| { &m.longitude },
                |m: &mut Location| { &mut m.longitude },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "country",
                |m: &Location| { &m.country },
                |m: &mut Location| { &mut m.country },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
                "CMsgClientWelcome.Location",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.latitude = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.longitude = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.country = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.latitude {
                my_size += 1 + 4;
            }
            if let Some(v) = self.longitude {
                my_size += 1 + 4;
            }
            if let Some(v) = self.country.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.latitude {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.longitude {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.country.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.latitude = ::std::option::Option::None;
            self.longitude = ::std::option::Option::None;
            self.country = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                latitude: ::std::option::Option::None,
                longitude: ::std::option::Option::None,
                country: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Location {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgClientWelcome.Location").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Location {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Location {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgConnectionStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConnectionStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgConnectionStatus.status)
    pub status: ::std::option::Option<::protobuf::EnumOrUnknown<GCConnectionStatus>>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.client_session_need)
    pub client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.queue_position)
    pub queue_position: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.queue_size)
    pub queue_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.wait_seconds)
    pub wait_seconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.estimated_wait_seconds_remaining)
    pub estimated_wait_seconds_remaining: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConnectionStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConnectionStatus {
    fn default() -> &'a CMsgConnectionStatus {
        <CMsgConnectionStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgConnectionStatus {
    pub fn new() -> CMsgConnectionStatus {
        ::std::default::Default::default()
    }

    // optional .GCConnectionStatus status = 1;

    pub fn status(&self) -> GCConnectionStatus {
        match self.status {
            Some(e) => e.enum_value_or(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            None => GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: GCConnectionStatus) {
        self.status = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 client_session_need = 2;

    pub fn client_session_need(&self) -> u32 {
        self.client_session_need.unwrap_or(0)
    }

    pub fn clear_client_session_need(&mut self) {
        self.client_session_need = ::std::option::Option::None;
    }

    pub fn has_client_session_need(&self) -> bool {
        self.client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_need(&mut self, v: u32) {
        self.client_session_need = ::std::option::Option::Some(v);
    }

    // optional int32 queue_position = 3;

    pub fn queue_position(&self) -> i32 {
        self.queue_position.unwrap_or(0)
    }

    pub fn clear_queue_position(&mut self) {
        self.queue_position = ::std::option::Option::None;
    }

    pub fn has_queue_position(&self) -> bool {
        self.queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_position(&mut self, v: i32) {
        self.queue_position = ::std::option::Option::Some(v);
    }

    // optional int32 queue_size = 4;

    pub fn queue_size(&self) -> i32 {
        self.queue_size.unwrap_or(0)
    }

    pub fn clear_queue_size(&mut self) {
        self.queue_size = ::std::option::Option::None;
    }

    pub fn has_queue_size(&self) -> bool {
        self.queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_size(&mut self, v: i32) {
        self.queue_size = ::std::option::Option::Some(v);
    }

    // optional int32 wait_seconds = 5;

    pub fn wait_seconds(&self) -> i32 {
        self.wait_seconds.unwrap_or(0)
    }

    pub fn clear_wait_seconds(&mut self) {
        self.wait_seconds = ::std::option::Option::None;
    }

    pub fn has_wait_seconds(&self) -> bool {
        self.wait_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wait_seconds(&mut self, v: i32) {
        self.wait_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 estimated_wait_seconds_remaining = 6;

    pub fn estimated_wait_seconds_remaining(&self) -> i32 {
        self.estimated_wait_seconds_remaining.unwrap_or(0)
    }

    pub fn clear_estimated_wait_seconds_remaining(&mut self) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_estimated_wait_seconds_remaining(&self) -> bool {
        self.estimated_wait_seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimated_wait_seconds_remaining(&mut self, v: i32) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status",
            |m: &CMsgConnectionStatus| { &m.status },
            |m: &mut CMsgConnectionStatus| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_session_need",
            |m: &CMsgConnectionStatus| { &m.client_session_need },
            |m: &mut CMsgConnectionStatus| { &mut m.client_session_need },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_position",
            |m: &CMsgConnectionStatus| { &m.queue_position },
            |m: &mut CMsgConnectionStatus| { &mut m.queue_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "queue_size",
            |m: &CMsgConnectionStatus| { &m.queue_size },
            |m: &mut CMsgConnectionStatus| { &mut m.queue_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wait_seconds",
            |m: &CMsgConnectionStatus| { &m.wait_seconds },
            |m: &mut CMsgConnectionStatus| { &mut m.wait_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "estimated_wait_seconds_remaining",
            |m: &CMsgConnectionStatus| { &m.estimated_wait_seconds_remaining },
            |m: &mut CMsgConnectionStatus| { &mut m.estimated_wait_seconds_remaining },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgConnectionStatus>(
            "CMsgConnectionStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgConnectionStatus {
    const NAME: &'static str = "CMsgConnectionStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.queue_position = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.queue_size = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.wait_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.estimated_wait_seconds_remaining = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.client_session_need {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.queue_position {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.queue_size {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.wait_seconds {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.client_session_need {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.queue_position {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.queue_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.wait_seconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConnectionStatus {
        CMsgConnectionStatus::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.client_session_need = ::std::option::Option::None;
        self.queue_position = ::std::option::Option::None;
        self.queue_size = ::std::option::Option::None;
        self.wait_seconds = ::std::option::Option::None;
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConnectionStatus {
        static instance: CMsgConnectionStatus = CMsgConnectionStatus {
            status: ::std::option::Option::None,
            client_session_need: ::std::option::Option::None,
            queue_position: ::std::option::Option::None,
            queue_size: ::std::option::Option::None,
            wait_seconds: ::std::option::Option::None,
            estimated_wait_seconds_remaining: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgConnectionStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgConnectionStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgConnectionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgConnectionStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_PopulateItemDescriptions_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.languages)
    pub languages: ::std::vec::Vec<cworkshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_PopulateItemDescriptions_Request {
    fn default() -> &'a CWorkshop_PopulateItemDescriptions_Request {
        <CWorkshop_PopulateItemDescriptions_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_PopulateItemDescriptions_Request {
    pub fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_PopulateItemDescriptions_Request| { &m.appid },
            |m: &mut CWorkshop_PopulateItemDescriptions_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &CWorkshop_PopulateItemDescriptions_Request| { &m.languages },
            |m: &mut CWorkshop_PopulateItemDescriptions_Request| { &mut m.languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_PopulateItemDescriptions_Request>(
            "CWorkshop_PopulateItemDescriptions_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_PopulateItemDescriptions_Request {
    const NAME: &'static str = "CWorkshop_PopulateItemDescriptions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.languages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.languages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        CWorkshop_PopulateItemDescriptions_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_PopulateItemDescriptions_Request {
        static instance: CWorkshop_PopulateItemDescriptions_Request = CWorkshop_PopulateItemDescriptions_Request {
            appid: ::std::option::Option::None,
            languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_PopulateItemDescriptions_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_PopulateItemDescriptions_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_PopulateItemDescriptions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_PopulateItemDescriptions_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CWorkshop_PopulateItemDescriptions_Request`
pub mod cworkshop_populate_item_descriptions_request {
    // @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleItemDescription {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.gameitemid)
        pub gameitemid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.item_description)
        pub item_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.one_per_account)
        pub one_per_account: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleItemDescription {
        fn default() -> &'a SingleItemDescription {
            <SingleItemDescription as ::protobuf::Message>::default_instance()
        }
    }

    impl SingleItemDescription {
        pub fn new() -> SingleItemDescription {
            ::std::default::Default::default()
        }

        // optional uint32 gameitemid = 1;

        pub fn gameitemid(&self) -> u32 {
            self.gameitemid.unwrap_or(0)
        }

        pub fn clear_gameitemid(&mut self) {
            self.gameitemid = ::std::option::Option::None;
        }

        pub fn has_gameitemid(&self) -> bool {
            self.gameitemid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gameitemid(&mut self, v: u32) {
            self.gameitemid = ::std::option::Option::Some(v);
        }

        // optional string item_description = 2;

        pub fn item_description(&self) -> &str {
            match self.item_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_item_description(&mut self) {
            self.item_description = ::std::option::Option::None;
        }

        pub fn has_item_description(&self) -> bool {
            self.item_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_description(&mut self, v: ::std::string::String) {
            self.item_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_item_description(&mut self) -> &mut ::std::string::String {
            if self.item_description.is_none() {
                self.item_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.item_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_item_description(&mut self) -> ::std::string::String {
            self.item_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool one_per_account = 3;

        pub fn one_per_account(&self) -> bool {
            self.one_per_account.unwrap_or(false)
        }

        pub fn clear_one_per_account(&mut self) {
            self.one_per_account = ::std::option::Option::None;
        }

        pub fn has_one_per_account(&self) -> bool {
            self.one_per_account.is_some()
        }

        // Param is passed by value, moved
        pub fn set_one_per_account(&mut self, v: bool) {
            self.one_per_account = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gameitemid",
                |m: &SingleItemDescription| { &m.gameitemid },
                |m: &mut SingleItemDescription| { &mut m.gameitemid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "item_description",
                |m: &SingleItemDescription| { &m.item_description },
                |m: &mut SingleItemDescription| { &mut m.item_description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "one_per_account",
                |m: &SingleItemDescription| { &m.one_per_account },
                |m: &mut SingleItemDescription| { &mut m.one_per_account },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SingleItemDescription>(
                "CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SingleItemDescription {
        const NAME: &'static str = "SingleItemDescription";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.item_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.one_per_account = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.gameitemid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_description.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.one_per_account {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.gameitemid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_description.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.one_per_account {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleItemDescription {
            SingleItemDescription::new()
        }

        fn clear(&mut self) {
            self.gameitemid = ::std::option::Option::None;
            self.item_description = ::std::option::Option::None;
            self.one_per_account = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleItemDescription {
            static instance: SingleItemDescription = SingleItemDescription {
                gameitemid: ::std::option::Option::None,
                item_description: ::std::option::Option::None,
                one_per_account: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SingleItemDescription {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SingleItemDescription {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SingleItemDescription {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemDescriptionsLanguageBlock {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.language)
        pub language: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.descriptions)
        pub descriptions: ::std::vec::Vec<SingleItemDescription>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDescriptionsLanguageBlock {
        fn default() -> &'a ItemDescriptionsLanguageBlock {
            <ItemDescriptionsLanguageBlock as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemDescriptionsLanguageBlock {
        pub fn new() -> ItemDescriptionsLanguageBlock {
            ::std::default::Default::default()
        }

        // optional string language = 1;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "language",
                |m: &ItemDescriptionsLanguageBlock| { &m.language },
                |m: &mut ItemDescriptionsLanguageBlock| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "descriptions",
                |m: &ItemDescriptionsLanguageBlock| { &m.descriptions },
                |m: &mut ItemDescriptionsLanguageBlock| { &mut m.descriptions },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemDescriptionsLanguageBlock>(
                "CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemDescriptionsLanguageBlock {
        const NAME: &'static str = "ItemDescriptionsLanguageBlock";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.descriptions.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.language.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.descriptions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.language.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.descriptions {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDescriptionsLanguageBlock {
            ItemDescriptionsLanguageBlock::new()
        }

        fn clear(&mut self) {
            self.language = ::std::option::Option::None;
            self.descriptions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDescriptionsLanguageBlock {
            static instance: ItemDescriptionsLanguageBlock = ItemDescriptionsLanguageBlock {
                language: ::std::option::Option::None,
                descriptions: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemDescriptionsLanguageBlock {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemDescriptionsLanguageBlock {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemDescriptionsLanguageBlock {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetContributors_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetContributors_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetContributors_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Request {
    fn default() -> &'a CWorkshop_GetContributors_Request {
        <CWorkshop_GetContributors_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Request {
    pub fn new() -> CWorkshop_GetContributors_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_GetContributors_Request| { &m.appid },
            |m: &mut CWorkshop_GetContributors_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameitemid",
            |m: &CWorkshop_GetContributors_Request| { &m.gameitemid },
            |m: &mut CWorkshop_GetContributors_Request| { &mut m.gameitemid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_GetContributors_Request>(
            "CWorkshop_GetContributors_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_GetContributors_Request {
    const NAME: &'static str = "CWorkshop_GetContributors_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Request {
        CWorkshop_GetContributors_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Request {
        static instance: CWorkshop_GetContributors_Request = CWorkshop_GetContributors_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_GetContributors_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_GetContributors_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_GetContributors_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetContributors_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CWorkshop_GetContributors_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetContributors_Response {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Response.contributors)
    pub contributors: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetContributors_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Response {
    fn default() -> &'a CWorkshop_GetContributors_Response {
        <CWorkshop_GetContributors_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Response {
    pub fn new() -> CWorkshop_GetContributors_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "contributors",
            |m: &CWorkshop_GetContributors_Response| { &m.contributors },
            |m: &mut CWorkshop_GetContributors_Response| { &mut m.contributors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_GetContributors_Response>(
            "CWorkshop_GetContributors_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_GetContributors_Response {
    const NAME: &'static str = "CWorkshop_GetContributors_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.contributors)?;
                },
                9 => {
                    self.contributors.push(is.read_fixed64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.contributors.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.contributors {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Response {
        CWorkshop_GetContributors_Response::new()
    }

    fn clear(&mut self) {
        self.contributors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Response {
        static instance: CWorkshop_GetContributors_Response = CWorkshop_GetContributors_Response {
            contributors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_GetContributors_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_GetContributors_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_GetContributors_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_GetContributors_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_SetItemPaymentRules_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.associated_workshop_files)
    pub associated_workshop_files: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::WorkshopItemPaymentRule>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.partner_accounts)
    pub partner_accounts: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::PartnerItemPaymentRule>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.validate_only)
    pub validate_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.make_workshop_files_subscribable)
    pub make_workshop_files_subscribable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.associated_workshop_file_for_direct_payments)
    pub associated_workshop_file_for_direct_payments: ::protobuf::MessageField<cworkshop_set_item_payment_rules_request::WorkshopDirectPaymentRule>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Request {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Request {
        <CWorkshop_SetItemPaymentRules_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Request {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    // optional bool validate_only = 5;

    pub fn validate_only(&self) -> bool {
        self.validate_only.unwrap_or(false)
    }

    pub fn clear_validate_only(&mut self) {
        self.validate_only = ::std::option::Option::None;
    }

    pub fn has_validate_only(&self) -> bool {
        self.validate_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validate_only(&mut self, v: bool) {
        self.validate_only = ::std::option::Option::Some(v);
    }

    // optional bool make_workshop_files_subscribable = 6;

    pub fn make_workshop_files_subscribable(&self) -> bool {
        self.make_workshop_files_subscribable.unwrap_or(false)
    }

    pub fn clear_make_workshop_files_subscribable(&mut self) {
        self.make_workshop_files_subscribable = ::std::option::Option::None;
    }

    pub fn has_make_workshop_files_subscribable(&self) -> bool {
        self.make_workshop_files_subscribable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_make_workshop_files_subscribable(&mut self, v: bool) {
        self.make_workshop_files_subscribable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.appid },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameitemid",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.gameitemid },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.gameitemid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "associated_workshop_files",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.associated_workshop_files },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.associated_workshop_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "partner_accounts",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.partner_accounts },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.partner_accounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "validate_only",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.validate_only },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.validate_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "make_workshop_files_subscribable",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.make_workshop_files_subscribable },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.make_workshop_files_subscribable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cworkshop_set_item_payment_rules_request::WorkshopDirectPaymentRule>(
            "associated_workshop_file_for_direct_payments",
            |m: &CWorkshop_SetItemPaymentRules_Request| { &m.associated_workshop_file_for_direct_payments },
            |m: &mut CWorkshop_SetItemPaymentRules_Request| { &mut m.associated_workshop_file_for_direct_payments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_SetItemPaymentRules_Request>(
            "CWorkshop_SetItemPaymentRules_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_SetItemPaymentRules_Request {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.associated_workshop_files.push(is.read_message()?);
                },
                34 => {
                    self.partner_accounts.push(is.read_message()?);
                },
                40 => {
                    self.validate_only = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.make_workshop_files_subscribable = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.associated_workshop_file_for_direct_payments)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.associated_workshop_files {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.partner_accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.validate_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.make_workshop_files_subscribable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.associated_workshop_file_for_direct_payments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        for v in &self.associated_workshop_files {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.partner_accounts {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.validate_only {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.make_workshop_files_subscribable {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.associated_workshop_file_for_direct_payments.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Request {
        CWorkshop_SetItemPaymentRules_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.associated_workshop_files.clear();
        self.partner_accounts.clear();
        self.validate_only = ::std::option::Option::None;
        self.make_workshop_files_subscribable = ::std::option::Option::None;
        self.associated_workshop_file_for_direct_payments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Request {
        static instance: CWorkshop_SetItemPaymentRules_Request = CWorkshop_SetItemPaymentRules_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            associated_workshop_files: ::std::vec::Vec::new(),
            partner_accounts: ::std::vec::Vec::new(),
            validate_only: ::std::option::Option::None,
            make_workshop_files_subscribable: ::std::option::Option::None,
            associated_workshop_file_for_direct_payments: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_SetItemPaymentRules_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_SetItemPaymentRules_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_SetItemPaymentRules_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CWorkshop_SetItemPaymentRules_Request`
pub mod cworkshop_set_item_payment_rules_request {
    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.workshop_file_id)
        pub workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_type)
        pub rule_type: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemPaymentRule {
        fn default() -> &'a WorkshopItemPaymentRule {
            <WorkshopItemPaymentRule as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemPaymentRule {
        pub fn new() -> WorkshopItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint64 workshop_file_id = 1;

        pub fn workshop_file_id(&self) -> u64 {
            self.workshop_file_id.unwrap_or(0)
        }

        pub fn clear_workshop_file_id(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_workshop_file_id(&self) -> bool {
            self.workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_file_id(&mut self, v: u64) {
            self.workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 rule_type = 4;

        pub fn rule_type(&self) -> u32 {
            self.rule_type.unwrap_or(1u32)
        }

        pub fn clear_rule_type(&mut self) {
            self.rule_type = ::std::option::Option::None;
        }

        pub fn has_rule_type(&self) -> bool {
            self.rule_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_type(&mut self, v: u32) {
            self.rule_type = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "workshop_file_id",
                |m: &WorkshopItemPaymentRule| { &m.workshop_file_id },
                |m: &mut WorkshopItemPaymentRule| { &mut m.workshop_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "revenue_percentage",
                |m: &WorkshopItemPaymentRule| { &m.revenue_percentage },
                |m: &mut WorkshopItemPaymentRule| { &mut m.revenue_percentage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rule_description",
                |m: &WorkshopItemPaymentRule| { &m.rule_description },
                |m: &mut WorkshopItemPaymentRule| { &mut m.rule_description },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rule_type",
                |m: &WorkshopItemPaymentRule| { &m.rule_type },
                |m: &mut WorkshopItemPaymentRule| { &mut m.rule_type },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkshopItemPaymentRule>(
                "CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WorkshopItemPaymentRule {
        const NAME: &'static str = "WorkshopItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.rule_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.workshop_file_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.rule_type {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.workshop_file_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.rule_type {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItemPaymentRule {
            WorkshopItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.rule_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItemPaymentRule {
            static instance: WorkshopItemPaymentRule = WorkshopItemPaymentRule {
                workshop_file_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                rule_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WorkshopItemPaymentRule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkshopItemPaymentRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopItemPaymentRule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopDirectPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.workshop_file_id)
        pub workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopDirectPaymentRule {
        fn default() -> &'a WorkshopDirectPaymentRule {
            <WorkshopDirectPaymentRule as ::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopDirectPaymentRule {
        pub fn new() -> WorkshopDirectPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint64 workshop_file_id = 1;

        pub fn workshop_file_id(&self) -> u64 {
            self.workshop_file_id.unwrap_or(0)
        }

        pub fn clear_workshop_file_id(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_workshop_file_id(&self) -> bool {
            self.workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_file_id(&mut self, v: u64) {
            self.workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 2;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "workshop_file_id",
                |m: &WorkshopDirectPaymentRule| { &m.workshop_file_id },
                |m: &mut WorkshopDirectPaymentRule| { &mut m.workshop_file_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rule_description",
                |m: &WorkshopDirectPaymentRule| { &m.rule_description },
                |m: &mut WorkshopDirectPaymentRule| { &mut m.rule_description },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WorkshopDirectPaymentRule>(
                "CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for WorkshopDirectPaymentRule {
        const NAME: &'static str = "WorkshopDirectPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.workshop_file_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.workshop_file_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopDirectPaymentRule {
            WorkshopDirectPaymentRule::new()
        }

        fn clear(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopDirectPaymentRule {
            static instance: WorkshopDirectPaymentRule = WorkshopDirectPaymentRule {
                workshop_file_id: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for WorkshopDirectPaymentRule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WorkshopDirectPaymentRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for WorkshopDirectPaymentRule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PartnerItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartnerItemPaymentRule {
        fn default() -> &'a PartnerItemPaymentRule {
            <PartnerItemPaymentRule as ::protobuf::Message>::default_instance()
        }
    }

    impl PartnerItemPaymentRule {
        pub fn new() -> PartnerItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &PartnerItemPaymentRule| { &m.account_id },
                |m: &mut PartnerItemPaymentRule| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "revenue_percentage",
                |m: &PartnerItemPaymentRule| { &m.revenue_percentage },
                |m: &mut PartnerItemPaymentRule| { &mut m.revenue_percentage },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rule_description",
                |m: &PartnerItemPaymentRule| { &m.rule_description },
                |m: &mut PartnerItemPaymentRule| { &mut m.rule_description },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PartnerItemPaymentRule>(
                "CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PartnerItemPaymentRule {
        const NAME: &'static str = "PartnerItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartnerItemPaymentRule {
            PartnerItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartnerItemPaymentRule {
            static instance: PartnerItemPaymentRule = PartnerItemPaymentRule {
                account_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PartnerItemPaymentRule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PartnerItemPaymentRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PartnerItemPaymentRule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_SetItemPaymentRules_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Response {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Response {
        <CWorkshop_SetItemPaymentRules_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Response {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_SetItemPaymentRules_Response>(
            "CWorkshop_SetItemPaymentRules_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_SetItemPaymentRules_Response {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Response {
        CWorkshop_SetItemPaymentRules_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Response {
        static instance: CWorkshop_SetItemPaymentRules_Response = CWorkshop_SetItemPaymentRules_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_SetItemPaymentRules_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_SetItemPaymentRules_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_SetItemPaymentRules_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_SetItemPaymentRules_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGameServers_AggregationQuery_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameServers_AggregationQuery_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Request.filter)
    pub filter: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Request.group_fields)
    pub group_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameServers_AggregationQuery_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameServers_AggregationQuery_Request {
    fn default() -> &'a CGameServers_AggregationQuery_Request {
        <CGameServers_AggregationQuery_Request as ::protobuf::Message>::default_instance()
    }
}

impl CGameServers_AggregationQuery_Request {
    pub fn new() -> CGameServers_AggregationQuery_Request {
        ::std::default::Default::default()
    }

    // optional string filter = 1;

    pub fn filter(&self) -> &str {
        match self.filter.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        if self.filter.is_none() {
            self.filter = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        self.filter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filter",
            |m: &CGameServers_AggregationQuery_Request| { &m.filter },
            |m: &mut CGameServers_AggregationQuery_Request| { &mut m.filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "group_fields",
            |m: &CGameServers_AggregationQuery_Request| { &m.group_fields },
            |m: &mut CGameServers_AggregationQuery_Request| { &mut m.group_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameServers_AggregationQuery_Request>(
            "CGameServers_AggregationQuery_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameServers_AggregationQuery_Request {
    const NAME: &'static str = "CGameServers_AggregationQuery_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filter = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.group_fields.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filter.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.group_fields {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.filter.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.group_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameServers_AggregationQuery_Request {
        CGameServers_AggregationQuery_Request::new()
    }

    fn clear(&mut self) {
        self.filter = ::std::option::Option::None;
        self.group_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameServers_AggregationQuery_Request {
        static instance: CGameServers_AggregationQuery_Request = CGameServers_AggregationQuery_Request {
            filter: ::std::option::Option::None,
            group_fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameServers_AggregationQuery_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameServers_AggregationQuery_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameServers_AggregationQuery_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameServers_AggregationQuery_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGameServers_AggregationQuery_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameServers_AggregationQuery_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.groups)
    pub groups: ::std::vec::Vec<cgame_servers_aggregation_query_response::Group>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameServers_AggregationQuery_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameServers_AggregationQuery_Response {
    fn default() -> &'a CGameServers_AggregationQuery_Response {
        <CGameServers_AggregationQuery_Response as ::protobuf::Message>::default_instance()
    }
}

impl CGameServers_AggregationQuery_Response {
    pub fn new() -> CGameServers_AggregationQuery_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groups",
            |m: &CGameServers_AggregationQuery_Response| { &m.groups },
            |m: &mut CGameServers_AggregationQuery_Response| { &mut m.groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameServers_AggregationQuery_Response>(
            "CGameServers_AggregationQuery_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameServers_AggregationQuery_Response {
    const NAME: &'static str = "CGameServers_AggregationQuery_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.groups {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameServers_AggregationQuery_Response {
        CGameServers_AggregationQuery_Response::new()
    }

    fn clear(&mut self) {
        self.groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameServers_AggregationQuery_Response {
        static instance: CGameServers_AggregationQuery_Response = CGameServers_AggregationQuery_Response {
            groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameServers_AggregationQuery_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameServers_AggregationQuery_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameServers_AggregationQuery_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameServers_AggregationQuery_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CGameServers_AggregationQuery_Response`
pub mod cgame_servers_aggregation_query_response {
    // @@protoc_insertion_point(message:CGameServers_AggregationQuery_Response.Group)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Group {
        // message fields
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.group_values)
        pub group_values: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.servers_empty)
        pub servers_empty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.servers_full)
        pub servers_full: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.servers_total)
        pub servers_total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.players_humans)
        pub players_humans: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.players_bots)
        pub players_bots: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.player_capacity)
        pub player_capacity: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CGameServers_AggregationQuery_Response.Group.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Group {
        fn default() -> &'a Group {
            <Group as ::protobuf::Message>::default_instance()
        }
    }

    impl Group {
        pub fn new() -> Group {
            ::std::default::Default::default()
        }

        // optional uint32 servers_empty = 2;

        pub fn servers_empty(&self) -> u32 {
            self.servers_empty.unwrap_or(0)
        }

        pub fn clear_servers_empty(&mut self) {
            self.servers_empty = ::std::option::Option::None;
        }

        pub fn has_servers_empty(&self) -> bool {
            self.servers_empty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_servers_empty(&mut self, v: u32) {
            self.servers_empty = ::std::option::Option::Some(v);
        }

        // optional uint32 servers_full = 3;

        pub fn servers_full(&self) -> u32 {
            self.servers_full.unwrap_or(0)
        }

        pub fn clear_servers_full(&mut self) {
            self.servers_full = ::std::option::Option::None;
        }

        pub fn has_servers_full(&self) -> bool {
            self.servers_full.is_some()
        }

        // Param is passed by value, moved
        pub fn set_servers_full(&mut self, v: u32) {
            self.servers_full = ::std::option::Option::Some(v);
        }

        // optional uint32 servers_total = 4;

        pub fn servers_total(&self) -> u32 {
            self.servers_total.unwrap_or(0)
        }

        pub fn clear_servers_total(&mut self) {
            self.servers_total = ::std::option::Option::None;
        }

        pub fn has_servers_total(&self) -> bool {
            self.servers_total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_servers_total(&mut self, v: u32) {
            self.servers_total = ::std::option::Option::Some(v);
        }

        // optional uint32 players_humans = 5;

        pub fn players_humans(&self) -> u32 {
            self.players_humans.unwrap_or(0)
        }

        pub fn clear_players_humans(&mut self) {
            self.players_humans = ::std::option::Option::None;
        }

        pub fn has_players_humans(&self) -> bool {
            self.players_humans.is_some()
        }

        // Param is passed by value, moved
        pub fn set_players_humans(&mut self, v: u32) {
            self.players_humans = ::std::option::Option::Some(v);
        }

        // optional uint32 players_bots = 6;

        pub fn players_bots(&self) -> u32 {
            self.players_bots.unwrap_or(0)
        }

        pub fn clear_players_bots(&mut self) {
            self.players_bots = ::std::option::Option::None;
        }

        pub fn has_players_bots(&self) -> bool {
            self.players_bots.is_some()
        }

        // Param is passed by value, moved
        pub fn set_players_bots(&mut self, v: u32) {
            self.players_bots = ::std::option::Option::Some(v);
        }

        // optional uint32 player_capacity = 7;

        pub fn player_capacity(&self) -> u32 {
            self.player_capacity.unwrap_or(0)
        }

        pub fn clear_player_capacity(&mut self) {
            self.player_capacity = ::std::option::Option::None;
        }

        pub fn has_player_capacity(&self) -> bool {
            self.player_capacity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_capacity(&mut self, v: u32) {
            self.player_capacity = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "group_values",
                |m: &Group| { &m.group_values },
                |m: &mut Group| { &mut m.group_values },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "servers_empty",
                |m: &Group| { &m.servers_empty },
                |m: &mut Group| { &mut m.servers_empty },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "servers_full",
                |m: &Group| { &m.servers_full },
                |m: &mut Group| { &mut m.servers_full },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "servers_total",
                |m: &Group| { &m.servers_total },
                |m: &mut Group| { &mut m.servers_total },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "players_humans",
                |m: &Group| { &m.players_humans },
                |m: &mut Group| { &mut m.players_humans },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "players_bots",
                |m: &Group| { &m.players_bots },
                |m: &mut Group| { &mut m.players_bots },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_capacity",
                |m: &Group| { &m.player_capacity },
                |m: &mut Group| { &mut m.player_capacity },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Group>(
                "CGameServers_AggregationQuery_Response.Group",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Group {
        const NAME: &'static str = "Group";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.group_values.push(is.read_string()?);
                    },
                    16 => {
                        self.servers_empty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.servers_full = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.servers_total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.players_humans = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.players_bots = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.player_capacity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.group_values {
                my_size += ::protobuf::rt::string_size(1, &value);
            };
            if let Some(v) = self.servers_empty {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.servers_full {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.servers_total {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.players_humans {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.players_bots {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.player_capacity {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.group_values {
                os.write_string(1, &v)?;
            };
            if let Some(v) = self.servers_empty {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.servers_full {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.servers_total {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.players_humans {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.players_bots {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.player_capacity {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Group {
            Group::new()
        }

        fn clear(&mut self) {
            self.group_values.clear();
            self.servers_empty = ::std::option::Option::None;
            self.servers_full = ::std::option::Option::None;
            self.servers_total = ::std::option::Option::None;
            self.players_humans = ::std::option::Option::None;
            self.players_bots = ::std::option::Option::None;
            self.player_capacity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Group {
            static instance: Group = Group {
                group_values: ::std::vec::Vec::new(),
                servers_empty: ::std::option::Option::None,
                servers_full: ::std::option::Option::None,
                servers_total: ::std::option::Option::None,
                players_humans: ::std::option::Option::None,
                players_bots: ::std::option::Option::None,
                player_capacity: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Group {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CGameServers_AggregationQuery_Response.Group").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Group {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Group {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CWorkshop_AddSpecialPayment_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_AddSpecialPayment_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_AddSpecialPayment_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_AddSpecialPayment_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_AddSpecialPayment_Request.date)
    pub date: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CWorkshop_AddSpecialPayment_Request.payment_us_usd)
    pub payment_us_usd: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CWorkshop_AddSpecialPayment_Request.payment_row_usd)
    pub payment_row_usd: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_AddSpecialPayment_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_AddSpecialPayment_Request {
    fn default() -> &'a CWorkshop_AddSpecialPayment_Request {
        <CWorkshop_AddSpecialPayment_Request as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_AddSpecialPayment_Request {
    pub fn new() -> CWorkshop_AddSpecialPayment_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    // optional string date = 3;

    pub fn date(&self) -> &str {
        match self.date.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_date(&mut self) {
        self.date = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: ::std::string::String) {
        self.date = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date(&mut self) -> &mut ::std::string::String {
        if self.date.is_none() {
            self.date = ::std::option::Option::Some(::std::string::String::new());
        }
        self.date.as_mut().unwrap()
    }

    // Take field
    pub fn take_date(&mut self) -> ::std::string::String {
        self.date.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 payment_us_usd = 4;

    pub fn payment_us_usd(&self) -> u64 {
        self.payment_us_usd.unwrap_or(0)
    }

    pub fn clear_payment_us_usd(&mut self) {
        self.payment_us_usd = ::std::option::Option::None;
    }

    pub fn has_payment_us_usd(&self) -> bool {
        self.payment_us_usd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_us_usd(&mut self, v: u64) {
        self.payment_us_usd = ::std::option::Option::Some(v);
    }

    // optional uint64 payment_row_usd = 5;

    pub fn payment_row_usd(&self) -> u64 {
        self.payment_row_usd.unwrap_or(0)
    }

    pub fn clear_payment_row_usd(&mut self) {
        self.payment_row_usd = ::std::option::Option::None;
    }

    pub fn has_payment_row_usd(&self) -> bool {
        self.payment_row_usd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_row_usd(&mut self, v: u64) {
        self.payment_row_usd = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CWorkshop_AddSpecialPayment_Request| { &m.appid },
            |m: &mut CWorkshop_AddSpecialPayment_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameitemid",
            |m: &CWorkshop_AddSpecialPayment_Request| { &m.gameitemid },
            |m: &mut CWorkshop_AddSpecialPayment_Request| { &mut m.gameitemid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "date",
            |m: &CWorkshop_AddSpecialPayment_Request| { &m.date },
            |m: &mut CWorkshop_AddSpecialPayment_Request| { &mut m.date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payment_us_usd",
            |m: &CWorkshop_AddSpecialPayment_Request| { &m.payment_us_usd },
            |m: &mut CWorkshop_AddSpecialPayment_Request| { &mut m.payment_us_usd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payment_row_usd",
            |m: &CWorkshop_AddSpecialPayment_Request| { &m.payment_row_usd },
            |m: &mut CWorkshop_AddSpecialPayment_Request| { &mut m.payment_row_usd },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_AddSpecialPayment_Request>(
            "CWorkshop_AddSpecialPayment_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_AddSpecialPayment_Request {
    const NAME: &'static str = "CWorkshop_AddSpecialPayment_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.date = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.payment_us_usd = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.payment_row_usd = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.date.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.payment_us_usd {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.payment_row_usd {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.date.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.payment_us_usd {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.payment_row_usd {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_AddSpecialPayment_Request {
        CWorkshop_AddSpecialPayment_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.date = ::std::option::Option::None;
        self.payment_us_usd = ::std::option::Option::None;
        self.payment_row_usd = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_AddSpecialPayment_Request {
        static instance: CWorkshop_AddSpecialPayment_Request = CWorkshop_AddSpecialPayment_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            date: ::std::option::Option::None,
            payment_us_usd: ::std::option::Option::None,
            payment_row_usd: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_AddSpecialPayment_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_AddSpecialPayment_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_AddSpecialPayment_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_AddSpecialPayment_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CWorkshop_AddSpecialPayment_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_AddSpecialPayment_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_AddSpecialPayment_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_AddSpecialPayment_Response {
    fn default() -> &'a CWorkshop_AddSpecialPayment_Response {
        <CWorkshop_AddSpecialPayment_Response as ::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_AddSpecialPayment_Response {
    pub fn new() -> CWorkshop_AddSpecialPayment_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CWorkshop_AddSpecialPayment_Response>(
            "CWorkshop_AddSpecialPayment_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CWorkshop_AddSpecialPayment_Response {
    const NAME: &'static str = "CWorkshop_AddSpecialPayment_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_AddSpecialPayment_Response {
        CWorkshop_AddSpecialPayment_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_AddSpecialPayment_Response {
        static instance: CWorkshop_AddSpecialPayment_Response = CWorkshop_AddSpecialPayment_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CWorkshop_AddSpecialPayment_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CWorkshop_AddSpecialPayment_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CWorkshop_AddSpecialPayment_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CWorkshop_AddSpecialPayment_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CProductInfo_SetRichPresenceLocalization_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProductInfo_SetRichPresenceLocalization_Request {
    // message fields
    // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.languages)
    pub languages: ::std::vec::Vec<cproduct_info_set_rich_presence_localization_request::LanguageSection>,
    // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CProductInfo_SetRichPresenceLocalization_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProductInfo_SetRichPresenceLocalization_Request {
    fn default() -> &'a CProductInfo_SetRichPresenceLocalization_Request {
        <CProductInfo_SetRichPresenceLocalization_Request as ::protobuf::Message>::default_instance()
    }
}

impl CProductInfo_SetRichPresenceLocalization_Request {
    pub fn new() -> CProductInfo_SetRichPresenceLocalization_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CProductInfo_SetRichPresenceLocalization_Request| { &m.appid },
            |m: &mut CProductInfo_SetRichPresenceLocalization_Request| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "languages",
            |m: &CProductInfo_SetRichPresenceLocalization_Request| { &m.languages },
            |m: &mut CProductInfo_SetRichPresenceLocalization_Request| { &mut m.languages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CProductInfo_SetRichPresenceLocalization_Request| { &m.steamid },
            |m: &mut CProductInfo_SetRichPresenceLocalization_Request| { &mut m.steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProductInfo_SetRichPresenceLocalization_Request>(
            "CProductInfo_SetRichPresenceLocalization_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProductInfo_SetRichPresenceLocalization_Request {
    const NAME: &'static str = "CProductInfo_SetRichPresenceLocalization_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.languages.push(is.read_message()?);
                },
                24 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.languages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.steamid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.languages {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.steamid {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProductInfo_SetRichPresenceLocalization_Request {
        CProductInfo_SetRichPresenceLocalization_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.languages.clear();
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProductInfo_SetRichPresenceLocalization_Request {
        static instance: CProductInfo_SetRichPresenceLocalization_Request = CProductInfo_SetRichPresenceLocalization_Request {
            appid: ::std::option::Option::None,
            languages: ::std::vec::Vec::new(),
            steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProductInfo_SetRichPresenceLocalization_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProductInfo_SetRichPresenceLocalization_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProductInfo_SetRichPresenceLocalization_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProductInfo_SetRichPresenceLocalization_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CProductInfo_SetRichPresenceLocalization_Request`
pub mod cproduct_info_set_rich_presence_localization_request {
    // @@protoc_insertion_point(message:CProductInfo_SetRichPresenceLocalization_Request.Token)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Token {
        // message fields
        // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.Token.token)
        pub token: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.Token.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CProductInfo_SetRichPresenceLocalization_Request.Token.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Token {
        fn default() -> &'a Token {
            <Token as ::protobuf::Message>::default_instance()
        }
    }

    impl Token {
        pub fn new() -> Token {
            ::std::default::Default::default()
        }

        // optional string token = 1;

        pub fn token(&self) -> &str {
            match self.token.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_token(&mut self) {
            self.token = ::std::option::Option::None;
        }

        pub fn has_token(&self) -> bool {
            self.token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token(&mut self, v: ::std::string::String) {
            self.token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_token(&mut self) -> &mut ::std::string::String {
            if self.token.is_none() {
                self.token = ::std::option::Option::Some(::std::string::String::new());
            }
            self.token.as_mut().unwrap()
        }

        // Take field
        pub fn take_token(&mut self) -> ::std::string::String {
            self.token.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "token",
                |m: &Token| { &m.token },
                |m: &mut Token| { &mut m.token },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Token| { &m.value },
                |m: &mut Token| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Token>(
                "CProductInfo_SetRichPresenceLocalization_Request.Token",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Token {
        const NAME: &'static str = "Token";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.token = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.token.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.token.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Token {
            Token::new()
        }

        fn clear(&mut self) {
            self.token = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Token {
            static instance: Token = Token {
                token: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Token {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CProductInfo_SetRichPresenceLocalization_Request.Token").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Token {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Token {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LanguageSection {
        // message fields
        // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection.language)
        pub language: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection.tokens)
        pub tokens: ::std::vec::Vec<Token>,
        // special fields
        // @@protoc_insertion_point(special_field:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LanguageSection {
        fn default() -> &'a LanguageSection {
            <LanguageSection as ::protobuf::Message>::default_instance()
        }
    }

    impl LanguageSection {
        pub fn new() -> LanguageSection {
            ::std::default::Default::default()
        }

        // optional string language = 1;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "language",
                |m: &LanguageSection| { &m.language },
                |m: &mut LanguageSection| { &mut m.language },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "tokens",
                |m: &LanguageSection| { &m.tokens },
                |m: &mut LanguageSection| { &mut m.tokens },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LanguageSection>(
                "CProductInfo_SetRichPresenceLocalization_Request.LanguageSection",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for LanguageSection {
        const NAME: &'static str = "LanguageSection";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.tokens.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.language.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.tokens {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.language.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.tokens {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LanguageSection {
            LanguageSection::new()
        }

        fn clear(&mut self) {
            self.language = ::std::option::Option::None;
            self.tokens.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LanguageSection {
            static instance: LanguageSection = LanguageSection {
                language: ::std::option::Option::None,
                tokens: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for LanguageSection {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CProductInfo_SetRichPresenceLocalization_Request.LanguageSection").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LanguageSection {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for LanguageSection {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CProductInfo_SetRichPresenceLocalization_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProductInfo_SetRichPresenceLocalization_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CProductInfo_SetRichPresenceLocalization_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProductInfo_SetRichPresenceLocalization_Response {
    fn default() -> &'a CProductInfo_SetRichPresenceLocalization_Response {
        <CProductInfo_SetRichPresenceLocalization_Response as ::protobuf::Message>::default_instance()
    }
}

impl CProductInfo_SetRichPresenceLocalization_Response {
    pub fn new() -> CProductInfo_SetRichPresenceLocalization_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CProductInfo_SetRichPresenceLocalization_Response>(
            "CProductInfo_SetRichPresenceLocalization_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CProductInfo_SetRichPresenceLocalization_Response {
    const NAME: &'static str = "CProductInfo_SetRichPresenceLocalization_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProductInfo_SetRichPresenceLocalization_Response {
        CProductInfo_SetRichPresenceLocalization_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProductInfo_SetRichPresenceLocalization_Response {
        static instance: CProductInfo_SetRichPresenceLocalization_Response = CProductInfo_SetRichPresenceLocalization_Response {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CProductInfo_SetRichPresenceLocalization_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CProductInfo_SetRichPresenceLocalization_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CProductInfo_SetRichPresenceLocalization_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CProductInfo_SetRichPresenceLocalization_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSerializedSOCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSerializedSOCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgSerializedSOCache.file_version)
    pub file_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSerializedSOCache.caches)
    pub caches: ::std::vec::Vec<cmsg_serialized_socache::Cache>,
    // @@protoc_insertion_point(field:CMsgSerializedSOCache.gc_socache_file_version)
    pub gc_socache_file_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSerializedSOCache {
    fn default() -> &'a CMsgSerializedSOCache {
        <CMsgSerializedSOCache as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSerializedSOCache {
    pub fn new() -> CMsgSerializedSOCache {
        ::std::default::Default::default()
    }

    // optional uint32 file_version = 1;

    pub fn file_version(&self) -> u32 {
        self.file_version.unwrap_or(0)
    }

    pub fn clear_file_version(&mut self) {
        self.file_version = ::std::option::Option::None;
    }

    pub fn has_file_version(&self) -> bool {
        self.file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_version(&mut self, v: u32) {
        self.file_version = ::std::option::Option::Some(v);
    }

    // optional uint32 gc_socache_file_version = 3;

    pub fn gc_socache_file_version(&self) -> u32 {
        self.gc_socache_file_version.unwrap_or(0)
    }

    pub fn clear_gc_socache_file_version(&mut self) {
        self.gc_socache_file_version = ::std::option::Option::None;
    }

    pub fn has_gc_socache_file_version(&self) -> bool {
        self.gc_socache_file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_socache_file_version(&mut self, v: u32) {
        self.gc_socache_file_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_version",
            |m: &CMsgSerializedSOCache| { &m.file_version },
            |m: &mut CMsgSerializedSOCache| { &mut m.file_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "caches",
            |m: &CMsgSerializedSOCache| { &m.caches },
            |m: &mut CMsgSerializedSOCache| { &mut m.caches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gc_socache_file_version",
            |m: &CMsgSerializedSOCache| { &m.gc_socache_file_version },
            |m: &mut CMsgSerializedSOCache| { &mut m.gc_socache_file_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSerializedSOCache>(
            "CMsgSerializedSOCache",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSerializedSOCache {
    const NAME: &'static str = "CMsgSerializedSOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.caches.push(is.read_message()?);
                },
                24 => {
                    self.gc_socache_file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.caches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gc_socache_file_version {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.file_version {
            os.write_uint32(1, v)?;
        }
        for v in &self.caches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.gc_socache_file_version {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSerializedSOCache {
        CMsgSerializedSOCache::new()
    }

    fn clear(&mut self) {
        self.file_version = ::std::option::Option::None;
        self.caches.clear();
        self.gc_socache_file_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSerializedSOCache {
        static instance: CMsgSerializedSOCache = CMsgSerializedSOCache {
            file_version: ::std::option::Option::None,
            caches: ::std::vec::Vec::new(),
            gc_socache_file_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSerializedSOCache {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSerializedSOCache").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSerializedSOCache {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSerializedSOCache {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSerializedSOCache`
pub mod cmsg_serialized_socache {
    // @@protoc_insertion_point(message:CMsgSerializedSOCache.TypeCache)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TypeCache {
        // message fields
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.TypeCache.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.TypeCache.objects)
        pub objects: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.TypeCache.service_id)
        pub service_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.TypeCache.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TypeCache {
        fn default() -> &'a TypeCache {
            <TypeCache as ::protobuf::Message>::default_instance()
        }
    }

    impl TypeCache {
        pub fn new() -> TypeCache {
            ::std::default::Default::default()
        }

        // optional uint32 type = 1;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional uint32 service_id = 3;

        pub fn service_id(&self) -> u32 {
            self.service_id.unwrap_or(0)
        }

        pub fn clear_service_id(&mut self) {
            self.service_id = ::std::option::Option::None;
        }

        pub fn has_service_id(&self) -> bool {
            self.service_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_service_id(&mut self, v: u32) {
            self.service_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &TypeCache| { &m.type_ },
                |m: &mut TypeCache| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "objects",
                |m: &TypeCache| { &m.objects },
                |m: &mut TypeCache| { &mut m.objects },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "service_id",
                |m: &TypeCache| { &m.service_id },
                |m: &mut TypeCache| { &mut m.service_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TypeCache>(
                "CMsgSerializedSOCache.TypeCache",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TypeCache {
        const NAME: &'static str = "TypeCache";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.objects.push(is.read_bytes()?);
                    },
                    24 => {
                        self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.objects {
                my_size += ::protobuf::rt::bytes_size(2, &value);
            };
            if let Some(v) = self.service_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_uint32(1, v)?;
            }
            for v in &self.objects {
                os.write_bytes(2, &v)?;
            };
            if let Some(v) = self.service_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TypeCache {
            TypeCache::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.objects.clear();
            self.service_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TypeCache {
            static instance: TypeCache = TypeCache {
                type_: ::std::option::Option::None,
                objects: ::std::vec::Vec::new(),
                service_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TypeCache {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSerializedSOCache.TypeCache").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TypeCache {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TypeCache {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSerializedSOCache.Cache)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Cache {
        // message fields
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.id)
        pub id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.versions)
        pub versions: ::std::vec::Vec<cache::Version>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.type_caches)
        pub type_caches: ::std::vec::Vec<TypeCache>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.Cache.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Cache {
        fn default() -> &'a Cache {
            <Cache as ::protobuf::Message>::default_instance()
        }
    }

    impl Cache {
        pub fn new() -> Cache {
            ::std::default::Default::default()
        }

        // optional uint32 type = 1;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional uint64 id = 2;

        pub fn id(&self) -> u64 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u64) {
            self.id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Cache| { &m.type_ },
                |m: &mut Cache| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &Cache| { &m.id },
                |m: &mut Cache| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "versions",
                |m: &Cache| { &m.versions },
                |m: &mut Cache| { &mut m.versions },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "type_caches",
                |m: &Cache| { &m.type_caches },
                |m: &mut Cache| { &mut m.type_caches },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Cache>(
                "CMsgSerializedSOCache.Cache",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Cache {
        const NAME: &'static str = "Cache";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.versions.push(is.read_message()?);
                    },
                    34 => {
                        self.type_caches.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            for value in &self.versions {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.type_caches {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.id {
                os.write_uint64(2, v)?;
            }
            for v in &self.versions {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.type_caches {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Cache {
            Cache::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.id = ::std::option::Option::None;
            self.versions.clear();
            self.type_caches.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Cache {
            static instance: Cache = Cache {
                type_: ::std::option::Option::None,
                id: ::std::option::Option::None,
                versions: ::std::vec::Vec::new(),
                type_caches: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Cache {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSerializedSOCache.Cache").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Cache {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Cache {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Cache`
    pub mod cache {
        // @@protoc_insertion_point(message:CMsgSerializedSOCache.Cache.Version)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Version {
            // message fields
            // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.Version.service)
            pub service: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.Version.version)
            pub version: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.Cache.Version.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Version {
            fn default() -> &'a Version {
                <Version as ::protobuf::Message>::default_instance()
            }
        }

        impl Version {
            pub fn new() -> Version {
                ::std::default::Default::default()
            }

            // optional uint32 service = 1;

            pub fn service(&self) -> u32 {
                self.service.unwrap_or(0)
            }

            pub fn clear_service(&mut self) {
                self.service = ::std::option::Option::None;
            }

            pub fn has_service(&self) -> bool {
                self.service.is_some()
            }

            // Param is passed by value, moved
            pub fn set_service(&mut self, v: u32) {
                self.service = ::std::option::Option::Some(v);
            }

            // optional uint64 version = 2;

            pub fn version(&self) -> u64 {
                self.version.unwrap_or(0)
            }

            pub fn clear_version(&mut self) {
                self.version = ::std::option::Option::None;
            }

            pub fn has_version(&self) -> bool {
                self.version.is_some()
            }

            // Param is passed by value, moved
            pub fn set_version(&mut self, v: u64) {
                self.version = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "service",
                    |m: &Version| { &m.service },
                    |m: &mut Version| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "version",
                    |m: &Version| { &m.version },
                    |m: &mut Version| { &mut m.version },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Version>(
                    "CMsgSerializedSOCache.Cache.Version",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Version {
            const NAME: &'static str = "Version";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.service = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.version = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.service {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.version {
                    my_size += ::protobuf::rt::uint64_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.service {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.version {
                    os.write_uint64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Version {
                Version::new()
            }

            fn clear(&mut self) {
                self.service = ::std::option::Option::None;
                self.version = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Version {
                static instance: Version = Version {
                    service: ::std::option::Option::None,
                    version: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Version {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CMsgSerializedSOCache.Cache.Version").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Version {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Version {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GCClientLauncherType)
pub enum GCClientLauncherType {
    // @@protoc_insertion_point(enum_value:GCClientLauncherType.GCClientLauncherType_DEFAULT)
    GCClientLauncherType_DEFAULT = 0,
    // @@protoc_insertion_point(enum_value:GCClientLauncherType.GCClientLauncherType_PERFECTWORLD)
    GCClientLauncherType_PERFECTWORLD = 1,
    // @@protoc_insertion_point(enum_value:GCClientLauncherType.GCClientLauncherType_STEAMCHINA)
    GCClientLauncherType_STEAMCHINA = 2,
}

impl ::protobuf::Enum for GCClientLauncherType {
    const NAME: &'static str = "GCClientLauncherType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCClientLauncherType> {
        match value {
            0 => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_DEFAULT),
            1 => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_PERFECTWORLD),
            2 => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_STEAMCHINA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GCClientLauncherType> {
        match str {
            "GCClientLauncherType_DEFAULT" => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_DEFAULT),
            "GCClientLauncherType_PERFECTWORLD" => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_PERFECTWORLD),
            "GCClientLauncherType_STEAMCHINA" => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_STEAMCHINA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GCClientLauncherType] = &[
        GCClientLauncherType::GCClientLauncherType_DEFAULT,
        GCClientLauncherType::GCClientLauncherType_PERFECTWORLD,
        GCClientLauncherType::GCClientLauncherType_STEAMCHINA,
    ];
}

impl ::protobuf::EnumFull for GCClientLauncherType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GCClientLauncherType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for GCClientLauncherType {
    fn default() -> Self {
        GCClientLauncherType::GCClientLauncherType_DEFAULT
    }
}

impl GCClientLauncherType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GCClientLauncherType>("GCClientLauncherType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GCConnectionStatus)
pub enum GCConnectionStatus {
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_HAVE_SESSION)
    GCConnectionStatus_HAVE_SESSION = 0,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_GC_GOING_DOWN)
    GCConnectionStatus_GC_GOING_DOWN = 1,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_SESSION)
    GCConnectionStatus_NO_SESSION = 2,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE)
    GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_STEAM)
    GCConnectionStatus_NO_STEAM = 4,
}

impl ::protobuf::Enum for GCConnectionStatus {
    const NAME: &'static str = "GCConnectionStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCConnectionStatus> {
        match value {
            0 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            1 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            2 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            3 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            4 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GCConnectionStatus> {
        match str {
            "GCConnectionStatus_HAVE_SESSION" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            "GCConnectionStatus_GC_GOING_DOWN" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            "GCConnectionStatus_NO_SESSION" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            "GCConnectionStatus_NO_STEAM" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GCConnectionStatus] = &[
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
        GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN,
        GCConnectionStatus::GCConnectionStatus_NO_SESSION,
        GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE,
        GCConnectionStatus::GCConnectionStatus_NO_STEAM,
    ];
}

impl ::protobuf::EnumFull for GCConnectionStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("GCConnectionStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for GCConnectionStatus {
    fn default() -> Self {
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION
    }
}

impl GCConnectionStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<GCConnectionStatus>("GCConnectionStatus")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16gcsdk_gcmessages.proto\x1a\x13steammessages.proto\"3\n\rCMsgSOIDOw\
    ner\x12\x12\n\x04type\x18\x01\x20\x01(\rR\x04type\x12\x0e\n\x02id\x18\
    \x02\x20\x01(\x04R\x02id\"\x97\x01\n\x12CMsgSOSingleObject\x12\x17\n\x07\
    type_id\x18\x02\x20\x01(\x05R\x06typeId\x12\x1f\n\x0bobject_data\x18\x03\
    \x20\x01(\x0cR\nobjectData\x12\x18\n\x07version\x18\x04\x20\x01(\x06R\
    \x07version\x12-\n\nowner_soid\x18\x05\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\
    \townerSoid\"\x86\x02\n\x15CMsgSOMultipleObjects\x12N\n\x10objects_modif\
    ied\x18\x02\x20\x03(\x0b2#.CMsgSOMultipleObjects.SingleObjectR\x0fobject\
    sModified\x12\x18\n\x07version\x18\x03\x20\x01(\x06R\x07version\x12-\n\n\
    owner_soid\x18\x06\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\x1aT\n\
    \x0cSingleObject\x12\x17\n\x07type_id\x18\x01\x20\x01(\x05R\x06typeId\
    \x12\x1f\n\x0bobject_data\x18\x02\x20\x01(\x0cR\nobjectData:\n\x80\xa6\
    \x1d\x80\x02\x88\xa6\x1d\x80\x08\"\xed\x01\n\x15CMsgSOCacheSubscribed\
    \x12?\n\x07objects\x18\x02\x20\x03(\x0b2%.CMsgSOCacheSubscribed.Subscrib\
    edTypeR\x07objects\x12\x18\n\x07version\x18\x03\x20\x01(\x06R\x07version\
    \x12-\n\nowner_soid\x18\x04\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\
    \x1aJ\n\x0eSubscribedType\x12\x17\n\x07type_id\x18\x01\x20\x01(\x05R\x06\
    typeId\x12\x1f\n\x0bobject_data\x18\x02\x20\x03(\x0cR\nobjectData\"H\n\
    \x17CMsgSOCacheUnsubscribed\x12-\n\nowner_soid\x18\x02\x20\x01(\x0b2\x0e\
    .CMsgSOIDOwnerR\townerSoid\"g\n\x1cCMsgSOCacheSubscriptionCheck\x12\x18\
    \n\x07version\x18\x02\x20\x01(\x06R\x07version\x12-\n\nowner_soid\x18\
    \x03\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\townerSoid\"O\n\x1eCMsgSOCacheSubs\
    criptionRefresh\x12-\n\nowner_soid\x18\x02\x20\x01(\x0b2\x0e.CMsgSOIDOwn\
    erR\townerSoid\".\n\x12CMsgSOCacheVersion\x12\x18\n\x07version\x18\x01\
    \x20\x01(\x06R\x07version\"\x9c\x05\n\x12CMsgAccountDetails\x12\x14\n\
    \x05valid\x18\x01\x20\x01(\x08R\x05valid\x12!\n\x0caccount_name\x18\x02\
    \x20\x01(\tR\x0baccountName\x12%\n\x0epublic_profile\x18\x04\x20\x01(\
    \x08R\rpublicProfile\x12)\n\x10public_inventory\x18\x05\x20\x01(\x08R\
    \x0fpublicInventory\x12\x1d\n\nvac_banned\x18\x06\x20\x01(\x08R\tvacBann\
    ed\x12\x1d\n\ncyber_cafe\x18\x07\x20\x01(\x08R\tcyberCafe\x12%\n\x0escho\
    ol_account\x18\x08\x20\x01(\x08R\rschoolAccount\x12,\n\x12free_trial_acc\
    ount\x18\t\x20\x01(\x08R\x10freeTrialAccount\x12\x1e\n\nsubscribed\x18\n\
    \x20\x01(\x08R\nsubscribed\x12!\n\x0clow_violence\x18\x0b\x20\x01(\x08R\
    \x0blowViolence\x12\x18\n\x07limited\x18\x0c\x20\x01(\x08R\x07limited\
    \x12\x18\n\x07trusted\x18\r\x20\x01(\x08R\x07trusted\x12\x18\n\x07packag\
    e\x18\x0e\x20\x01(\rR\x07package\x12\x1f\n\x0btime_cached\x18\x0f\x20\
    \x01(\x07R\ntimeCached\x12%\n\x0eaccount_locked\x18\x10\x20\x01(\x08R\ra\
    ccountLocked\x12)\n\x10community_banned\x18\x11\x20\x01(\x08R\x0fcommuni\
    tyBanned\x12!\n\x0ctrade_banned\x18\x12\x20\x01(\x08R\x0btradeBanned\x12\
    A\n\x1deligible_for_community_market\x18\x13\x20\x01(\x08R\x1aeligibleFo\
    rCommunityMarket\"\x86\x01\n\x16CMsgGCMultiplexMessage\x12\x18\n\x07msgt\
    ype\x18\x01\x20\x01(\rR\x07msgtype\x12\x18\n\x07payload\x18\x02\x20\x01(\
    \x0cR\x07payload\x12\x1a\n\x08steamids\x18\x03\x20\x03(\x06R\x08steamids\
    \x12\x1c\n\treplytogc\x18\x04\x20\x01(\x08R\treplytogc\";\n\x1fCMsgGCMul\
    tiplexMessage_Response\x12\x18\n\x07msgtype\x18\x01\x20\x01(\rR\x07msgty\
    pe\"K\n\x13CGCToGCMsgMasterAck\x12\x1b\n\tdir_index\x18\x01\x20\x01(\rR\
    \x08dirIndex\x12\x17\n\x07gc_type\x18\x02\x20\x01(\rR\x06gcType\";\n\x1c\
    CGCToGCMsgMasterAck_Response\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\
    \x012R\x07eresult\"!\n\x1fCGCToGCMsgMasterStartupComplete\"{\n\x10CGCToG\
    CMsgRouted\x12\x19\n\x08msg_type\x18\x01\x20\x01(\rR\x07msgType\x12\x1b\
    \n\tsender_id\x18\x02\x20\x01(\x06R\x08senderId\x12\x1f\n\x0bnet_message\
    \x18\x03\x20\x01(\x0cR\nnetMessage\x12\x0e\n\x02ip\x18\x04\x20\x01(\rR\
    \x02ip\"S\n\x15CGCToGCMsgRoutedReply\x12\x19\n\x08msg_type\x18\x01\x20\
    \x01(\rR\x07msgType\x12\x1f\n\x0bnet_message\x18\x02\x20\x01(\x0cR\nnetM\
    essage\"A\n\x15CMsgGCUpdateSessionIP\x12\x18\n\x07steamid\x18\x01\x20\
    \x01(\x06R\x07steamid\x12\x0e\n\x02ip\x18\x02\x20\x01(\x07R\x02ip\"2\n\
    \x16CMsgGCRequestSessionIP\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\
    \x07steamid\"0\n\x1eCMsgGCRequestSessionIPResponse\x12\x0e\n\x02ip\x18\
    \x01\x20\x01(\x07R\x02ip\"V\n\x16CMsgSOCacheHaveVersion\x12\"\n\x04soid\
    \x18\x01\x20\x01(\x0b2\x0e.CMsgSOIDOwnerR\x04soid\x12\x18\n\x07version\
    \x18\x02\x20\x01(\x06R\x07version\"\xb4\x03\n\x0fCMsgClientHello\x12\x18\
    \n\x07version\x18\x01\x20\x01(\rR\x07version\x12K\n\x15socache_have_vers\
    ions\x18\x02\x20\x03(\x0b2\x17.CMsgSOCacheHaveVersionR\x13socacheHaveVer\
    sions\x12.\n\x13client_session_need\x18\x03\x20\x01(\rR\x11clientSession\
    Need\x12'\n\x0fclient_launcher\x18\x04\x20\x01(\rR\x0eclientLauncher\x12\
    #\n\rpartner_srcid\x18\x05\x20\x01(\rR\x0cpartnerSrcid\x12+\n\x11partner\
    _accountid\x18\x06\x20\x01(\rR\x10partnerAccountid\x121\n\x14partner_acc\
    ountflags\x18\x07\x20\x01(\rR\x13partnerAccountflags\x125\n\x16partner_a\
    ccountbalance\x18\x08\x20\x01(\rR\x15partnerAccountbalance\x12%\n\x0este\
    am_launcher\x18\t\x20\x01(\rR\rsteamLauncher\"\x87\x03\n\x0fCMsgServerHe\
    llo\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12K\n\x15socach\
    e_have_versions\x18\x02\x20\x03(\x0b2\x17.CMsgSOCacheHaveVersionR\x13soc\
    acheHaveVersions\x12;\n\x1alegacy_client_session_need\x18\x03\x20\x01(\r\
    R\x17legacyClientSessionNeed\x12'\n\x0fclient_launcher\x18\x04\x20\x01(\
    \rR\x0eclientLauncher\x12@\n\x1clegacy_steamdatagram_routing\x18\x06\x20\
    \x01(\x0cR\x1alegacySteamdatagramRouting\x124\n\x16required_internal_add\
    r\x18\x07\x20\x01(\rR\x14requiredInternalAddr\x12/\n\x13steamdatagram_lo\
    gin\x18\x08\x20\x01(\x0cR\x12steamdatagramLogin\"\xf9\x04\n\x11CMsgClien\
    tWelcome\x12\x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x1b\n\t\
    game_data\x18\x02\x20\x01(\x0cR\x08gameData\x12V\n\x1boutofdate_subscrib\
    ed_caches\x18\x03\x20\x03(\x0b2\x16.CMsgSOCacheSubscribedR\x19outofdateS\
    ubscribedCaches\x12[\n\x1auptodate_subscribed_caches\x18\x04\x20\x03(\
    \x0b2\x1d.CMsgSOCacheSubscriptionCheckR\x18uptodateSubscribedCaches\x127\
    \n\x08location\x18\x05\x20\x01(\x0b2\x1b.CMsgClientWelcome.LocationR\x08\
    location\x12\x1d\n\ngame_data2\x18\x06\x20\x01(\x0cR\tgameData2\x12?\n\
    \x1crtime32_gc_welcome_timestamp\x18\x07\x20\x01(\rR\x19rtime32GcWelcome\
    Timestamp\x12\x1a\n\x08currency\x18\x08\x20\x01(\rR\x08currency\x12\x18\
    \n\x07balance\x18\t\x20\x01(\rR\x07balance\x12\x1f\n\x0bbalance_url\x18\
    \n\x20\x01(\tR\nbalanceUrl\x12(\n\x10txn_country_code\x18\x0b\x20\x01(\t\
    R\x0etxnCountryCode\x1a^\n\x08Location\x12\x1a\n\x08latitude\x18\x01\x20\
    \x01(\x02R\x08latitude\x12\x1c\n\tlongitude\x18\x02\x20\x01(\x02R\tlongi\
    tude\x12\x18\n\x07country\x18\x03\x20\x01(\tR\x07country\"\xc6\x02\n\x14\
    CMsgConnectionStatus\x12L\n\x06status\x18\x01\x20\x01(\x0e2\x13.GCConnec\
    tionStatus:\x1fGCConnectionStatus_HAVE_SESSIONR\x06status\x12.\n\x13clie\
    nt_session_need\x18\x02\x20\x01(\rR\x11clientSessionNeed\x12%\n\x0equeue\
    _position\x18\x03\x20\x01(\x05R\rqueuePosition\x12\x1d\n\nqueue_size\x18\
    \x04\x20\x01(\x05R\tqueueSize\x12!\n\x0cwait_seconds\x18\x05\x20\x01(\
    \x05R\x0bwaitSeconds\x12G\n\x20estimated_wait_seconds_remaining\x18\x06\
    \x20\x01(\x05R\x1destimatedWaitSecondsRemaining\"\xdd\x03\n*CWorkshop_Po\
    pulateItemDescriptions_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\
    \x05appid\x12g\n\tlanguages\x18\x02\x20\x03(\x0b2I.CWorkshop_PopulateIte\
    mDescriptions_Request.ItemDescriptionsLanguageBlockR\tlanguages\x1a\x8a\
    \x01\n\x15SingleItemDescription\x12\x1e\n\ngameitemid\x18\x01\x20\x01(\r\
    R\ngameitemid\x12)\n\x10item_description\x18\x02\x20\x01(\tR\x0fitemDesc\
    ription\x12&\n\x0fone_per_account\x18\x03\x20\x01(\x08R\ronePerAccount\
    \x1a\xa2\x01\n\x1dItemDescriptionsLanguageBlock\x12\x1a\n\x08language\
    \x18\x01\x20\x01(\tR\x08language\x12e\n\x0cdescriptions\x18\x02\x20\x03(\
    \x0b2A.CWorkshop_PopulateItemDescriptions_Request.SingleItemDescriptionR\
    \x0cdescriptions\"Y\n!CWorkshop_GetContributors_Request\x12\x14\n\x05app\
    id\x18\x01\x20\x01(\rR\x05appid\x12\x1e\n\ngameitemid\x18\x02\x20\x01(\r\
    R\ngameitemid\"H\n\"CWorkshop_GetContributors_Response\x12\"\n\x0ccontri\
    butors\x18\x01\x20\x03(\x06R\x0ccontributors\"\x99\x08\n%CWorkshop_SetIt\
    emPaymentRules_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\
    \x12\x1e\n\ngameitemid\x18\x02\x20\x01(\rR\ngameitemid\x12z\n\x19associa\
    ted_workshop_files\x18\x03\x20\x03(\x0b2>.CWorkshop_SetItemPaymentRules_\
    Request.WorkshopItemPaymentRuleR\x17associatedWorkshopFiles\x12h\n\x10pa\
    rtner_accounts\x18\x04\x20\x03(\x0b2=.CWorkshop_SetItemPaymentRules_Requ\
    est.PartnerItemPaymentRuleR\x0fpartnerAccounts\x12#\n\rvalidate_only\x18\
    \x05\x20\x01(\x08R\x0cvalidateOnly\x12G\n\x20make_workshop_files_subscri\
    bable\x18\x06\x20\x01(\x08R\x1dmakeWorkshopFilesSubscribable\x12\x9f\x01\
    \n,associated_workshop_file_for_direct_payments\x18\x07\x20\x01(\x0b2@.C\
    Workshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRuleR'associat\
    edWorkshopFileForDirectPayments\x1a\xbd\x01\n\x17WorkshopItemPaymentRule\
    \x12(\n\x10workshop_file_id\x18\x01\x20\x01(\x04R\x0eworkshopFileId\x12-\
    \n\x12revenue_percentage\x18\x02\x20\x01(\x02R\x11revenuePercentage\x12)\
    \n\x10rule_description\x18\x03\x20\x01(\tR\x0fruleDescription\x12\x1e\n\
    \trule_type\x18\x04\x20\x01(\r:\x011R\x08ruleType\x1ap\n\x19WorkshopDire\
    ctPaymentRule\x12(\n\x10workshop_file_id\x18\x01\x20\x01(\x04R\x0eworksh\
    opFileId\x12)\n\x10rule_description\x18\x02\x20\x01(\tR\x0fruleDescripti\
    on\x1a\x91\x01\n\x16PartnerItemPaymentRule\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12-\n\x12revenue_percentage\x18\x02\x20\x01(\
    \x02R\x11revenuePercentage\x12)\n\x10rule_description\x18\x03\x20\x01(\t\
    R\x0fruleDescription\"(\n&CWorkshop_SetItemPaymentRules_Response\"b\n%CG\
    ameServers_AggregationQuery_Request\x12\x16\n\x06filter\x18\x01\x20\x01(\
    \tR\x06filter\x12!\n\x0cgroup_fields\x18\x03\x20\x03(\tR\x0bgroupFields\
    \"\xfc\x02\n&CGameServers_AggregationQuery_Response\x12E\n\x06groups\x18\
    \x01\x20\x03(\x0b2-.CGameServers_AggregationQuery_Response.GroupR\x06gro\
    ups\x1a\x8a\x02\n\x05Group\x12!\n\x0cgroup_values\x18\x01\x20\x03(\tR\
    \x0bgroupValues\x12#\n\rservers_empty\x18\x02\x20\x01(\rR\x0cserversEmpt\
    y\x12!\n\x0cservers_full\x18\x03\x20\x01(\rR\x0bserversFull\x12#\n\rserv\
    ers_total\x18\x04\x20\x01(\rR\x0cserversTotal\x12%\n\x0eplayers_humans\
    \x18\x05\x20\x01(\rR\rplayersHumans\x12!\n\x0cplayers_bots\x18\x06\x20\
    \x01(\rR\x0bplayersBots\x12'\n\x0fplayer_capacity\x18\x07\x20\x01(\rR\
    \x0eplayerCapacity\"\xbd\x01\n#CWorkshop_AddSpecialPayment_Request\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1e\n\ngameitemid\x18\
    \x02\x20\x01(\rR\ngameitemid\x12\x12\n\x04date\x18\x03\x20\x01(\tR\x04da\
    te\x12$\n\x0epayment_us_usd\x18\x04\x20\x01(\x04R\x0cpaymentUsUsd\x12&\n\
    \x0fpayment_row_usd\x18\x05\x20\x01(\x04R\rpaymentRowUsd\"&\n$CWorkshop_\
    AddSpecialPayment_Response\"\xf8\x02\n0CProductInfo_SetRichPresenceLocal\
    ization_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12_\n\t\
    languages\x18\x02\x20\x03(\x0b2A.CProductInfo_SetRichPresenceLocalizatio\
    n_Request.LanguageSectionR\tlanguages\x12\x18\n\x07steamid\x18\x03\x20\
    \x01(\x04R\x07steamid\x1a3\n\x05Token\x12\x14\n\x05token\x18\x01\x20\x01\
    (\tR\x05token\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x1a~\n\x0f\
    LanguageSection\x12\x1a\n\x08language\x18\x01\x20\x01(\tR\x08language\
    \x12O\n\x06tokens\x18\x02\x20\x03(\x0b27.CProductInfo_SetRichPresenceLoc\
    alization_Request.TokenR\x06tokens\"3\n1CProductInfo_SetRichPresenceLoca\
    lization_Response\"\xf3\x03\n\x15CMsgSerializedSOCache\x12!\n\x0cfile_ve\
    rsion\x18\x01\x20\x01(\rR\x0bfileVersion\x124\n\x06caches\x18\x02\x20\
    \x03(\x0b2\x1c.CMsgSerializedSOCache.CacheR\x06caches\x125\n\x17gc_socac\
    he_file_version\x18\x03\x20\x01(\rR\x14gcSocacheFileVersion\x1aX\n\tType\
    Cache\x12\x12\n\x04type\x18\x01\x20\x01(\rR\x04type\x12\x18\n\x07objects\
    \x18\x02\x20\x03(\x0cR\x07objects\x12\x1d\n\nservice_id\x18\x03\x20\x01(\
    \rR\tserviceId\x1a\xef\x01\n\x05Cache\x12\x12\n\x04type\x18\x01\x20\x01(\
    \rR\x04type\x12\x0e\n\x02id\x18\x02\x20\x01(\x04R\x02id\x12@\n\x08versio\
    ns\x18\x03\x20\x03(\x0b2$.CMsgSerializedSOCache.Cache.VersionR\x08versio\
    ns\x12A\n\x0btype_caches\x18\x04\x20\x03(\x0b2\x20.CMsgSerializedSOCache\
    .TypeCacheR\ntypeCaches\x1a=\n\x07Version\x12\x18\n\x07service\x18\x01\
    \x20\x01(\rR\x07service\x12\x18\n\x07version\x18\x02\x20\x01(\x04R\x07ve\
    rsion*\x84\x01\n\x14GCClientLauncherType\x12\x20\n\x1cGCClientLauncherTy\
    pe_DEFAULT\x10\0\x12%\n!GCClientLauncherType_PERFECTWORLD\x10\x01\x12#\n\
    \x1fGCClientLauncherType_STEAMCHINA\x10\x02*\xd5\x01\n\x12GCConnectionSt\
    atus\x12#\n\x1fGCConnectionStatus_HAVE_SESSION\x10\0\x12$\n\x20GCConnect\
    ionStatus_GC_GOING_DOWN\x10\x01\x12!\n\x1dGCConnectionStatus_NO_SESSION\
    \x10\x02\x120\n,GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE\x10\x03\x12\
    \x1f\n\x1bGCConnectionStatus_NO_STEAM\x10\x04\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(50);
            messages.push(CMsgSOIDOwner::generated_message_descriptor_data());
            messages.push(CMsgSOSingleObject::generated_message_descriptor_data());
            messages.push(CMsgSOMultipleObjects::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscribed::generated_message_descriptor_data());
            messages.push(CMsgSOCacheUnsubscribed::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscriptionCheck::generated_message_descriptor_data());
            messages.push(CMsgSOCacheSubscriptionRefresh::generated_message_descriptor_data());
            messages.push(CMsgSOCacheVersion::generated_message_descriptor_data());
            messages.push(CMsgAccountDetails::generated_message_descriptor_data());
            messages.push(CMsgGCMultiplexMessage::generated_message_descriptor_data());
            messages.push(CMsgGCMultiplexMessage_Response::generated_message_descriptor_data());
            messages.push(CGCToGCMsgMasterAck::generated_message_descriptor_data());
            messages.push(CGCToGCMsgMasterAck_Response::generated_message_descriptor_data());
            messages.push(CGCToGCMsgMasterStartupComplete::generated_message_descriptor_data());
            messages.push(CGCToGCMsgRouted::generated_message_descriptor_data());
            messages.push(CGCToGCMsgRoutedReply::generated_message_descriptor_data());
            messages.push(CMsgGCUpdateSessionIP::generated_message_descriptor_data());
            messages.push(CMsgGCRequestSessionIP::generated_message_descriptor_data());
            messages.push(CMsgGCRequestSessionIPResponse::generated_message_descriptor_data());
            messages.push(CMsgSOCacheHaveVersion::generated_message_descriptor_data());
            messages.push(CMsgClientHello::generated_message_descriptor_data());
            messages.push(CMsgServerHello::generated_message_descriptor_data());
            messages.push(CMsgClientWelcome::generated_message_descriptor_data());
            messages.push(CMsgConnectionStatus::generated_message_descriptor_data());
            messages.push(CWorkshop_PopulateItemDescriptions_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_GetContributors_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_GetContributors_Response::generated_message_descriptor_data());
            messages.push(CWorkshop_SetItemPaymentRules_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_SetItemPaymentRules_Response::generated_message_descriptor_data());
            messages.push(CGameServers_AggregationQuery_Request::generated_message_descriptor_data());
            messages.push(CGameServers_AggregationQuery_Response::generated_message_descriptor_data());
            messages.push(CWorkshop_AddSpecialPayment_Request::generated_message_descriptor_data());
            messages.push(CWorkshop_AddSpecialPayment_Response::generated_message_descriptor_data());
            messages.push(CProductInfo_SetRichPresenceLocalization_Request::generated_message_descriptor_data());
            messages.push(CProductInfo_SetRichPresenceLocalization_Response::generated_message_descriptor_data());
            messages.push(CMsgSerializedSOCache::generated_message_descriptor_data());
            messages.push(cmsg_somultiple_objects::SingleObject::generated_message_descriptor_data());
            messages.push(cmsg_socache_subscribed::SubscribedType::generated_message_descriptor_data());
            messages.push(cmsg_client_welcome::Location::generated_message_descriptor_data());
            messages.push(cworkshop_populate_item_descriptions_request::SingleItemDescription::generated_message_descriptor_data());
            messages.push(cworkshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock::generated_message_descriptor_data());
            messages.push(cworkshop_set_item_payment_rules_request::WorkshopItemPaymentRule::generated_message_descriptor_data());
            messages.push(cworkshop_set_item_payment_rules_request::WorkshopDirectPaymentRule::generated_message_descriptor_data());
            messages.push(cworkshop_set_item_payment_rules_request::PartnerItemPaymentRule::generated_message_descriptor_data());
            messages.push(cgame_servers_aggregation_query_response::Group::generated_message_descriptor_data());
            messages.push(cproduct_info_set_rich_presence_localization_request::Token::generated_message_descriptor_data());
            messages.push(cproduct_info_set_rich_presence_localization_request::LanguageSection::generated_message_descriptor_data());
            messages.push(cmsg_serialized_socache::TypeCache::generated_message_descriptor_data());
            messages.push(cmsg_serialized_socache::Cache::generated_message_descriptor_data());
            messages.push(cmsg_serialized_socache::cache::Version::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(GCClientLauncherType::generated_enum_descriptor_data());
            enums.push(GCConnectionStatus::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
