use csgoproto::{EBaseGameEvents, EBaseUserMessages, ECstrike15UserMessages, NetMessages, SvcMessages};
use parser::JsonValue::{self, *};
use parser::{GameItems, Translation};
use std::collections::{BTreeMap, HashMap};
use std::fs::File;
use std::io::{Result, Write};
use strum::IntoEnumIterator;

mod parser;

fn main() -> Result<()> {
    create_net_message_enum()?;
    create_data_maps()
}

const AUTOGENERATED_COMMENT: &str = "// Autogenerated by main.rs\n// DO NOT UPDATE MANUALLY\n";

const ENUM_TEMPLATE: &str = "
#[derive(Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum NetMessageType {
    Unknown,
    __$$__,
}
";

const CONVERT_TEMPLATE: &str = "
impl From<i32> for NetMessageType {
    fn from(msg_type: i32) -> Self {
        use NetMessageType::*;

        match msg_type {
            __$$__,
            _ => Unknown,
        }
    }
}";

fn create_net_message_enum() -> Result<()> {
    let mut file = File::create("src/message_type.rs")?;
    file.write_all(AUTOGENERATED_COMMENT.as_bytes())?;

    let mut merged_enum = BTreeMap::new();
    merged_enum.extend(NetMessages::iter().map(|e| (e as i32, e.as_str_name())));
    merged_enum.extend(SvcMessages::iter().map(|e| (e as i32, e.as_str_name())));
    merged_enum.extend(EBaseUserMessages::iter().map(|e| (e as i32, e.as_str_name())));
    merged_enum.extend(EBaseGameEvents::iter().map(|e| (e as i32, e.as_str_name())));
    merged_enum.extend(ECstrike15UserMessages::iter().map(|e| (e as i32, e.as_str_name())));

    let enum_values = merged_enum.values().fold(String::new(), |output, value| append_line(output, 4, value));
    file.write_all(ENUM_TEMPLATE.replace("__$$__", &enum_values).as_bytes())?;

    let enum_mapping = merged_enum.into_iter().fold(String::new(), |output, (msg_type, msg_name)| {
        append_line(output, 12, &format!("{msg_type} => {msg_name}"))
    });
    file.write_all(CONVERT_TEMPLATE.replace("__$$__", &enum_mapping).as_bytes())
}

fn append_line(mut output: String, tab_size: usize, value: &str) -> String {
    if !output.is_empty() {
        output += &format!(",\n{}", " ".repeat(tab_size));
    }
    output += value;
    output
}

fn create_data_maps() -> Result<()> {
    let items = GameItems::try_from("GameTracking-CS2/game/csgo/pak01_dir/scripts/items/items_game.txt")?;
    let translation = Translation::try_from("GameTracking-CS2/game/csgo/pak01_dir/resource/csgo_english.txt")?;

    let mut file = File::create("src/maps.rs")?;
    file.write_all(AUTOGENERATED_COMMENT.as_bytes())?;
    file.write_all("\nuse phf::phf_map;\n".as_bytes())?;
    file.write_all(create_paint_kits_map(&items, &translation).as_bytes())?;
    file.write_all(create_agents_map(&items).as_bytes())?;
    file.write_all(create_stickers_map(&items).as_bytes())?;
    file.write_all(create_weapons_map(&items, &translation).as_bytes())
}

const MAP_TEMPLATE: &str = "
pub static __MAP_NAME__: phf::Map<u32, &'static str> = phf_map! {
    __$$__,
};
";

fn create_map(name: &str, value: String) -> String {
    MAP_TEMPLATE.replace("__MAP_NAME__", name).replace("__$$__", &value)
}

fn create_map_data(mut data: Vec<(i32, String)>) -> String {
    data.sort_by(|(key_a, _), (key_b, _)| key_a.cmp(key_b));

    data.into_iter()
        .fold(String::new(), |output, (id, name)| append_line(output, 4, &format!("{id}_u32 => \"{name}\"")))
}

fn get_item_data<'a>(item: (&'a String, &'a JsonValue)) -> Option<(i32, &'a HashMap<String, JsonValue>)> {
    let Object(item_data) = item.1 else {
        return None;
    };
    let Ok(item_id) = item.0.parse::<i32>() else {
        return None;
    };
    Some((item_id, item_data))
}

fn get_item_name(data: &HashMap<String, JsonValue>) -> Option<String> {
    if let Some(Str(item_name)) = data.get("name") {
        Some(item_name.to_owned())
    } else {
        None
    }
}

fn get_item_field(key: &str, data: &HashMap<String, JsonValue>, translation: &Translation) -> Option<String> {
    if let Some(Str(tag)) = data.get(key) {
        translation.get(tag)
    } else {
        None
    }
}

fn create_paint_kits_map(items: &GameItems, translation: &Translation) -> String {
    let Some(items) = items.get("paint_kits") else {
        return String::new();
    };

    let mut paint_kits: Vec<(i32, String)> = vec![];
    for item in items {
        let Some((id, data)) = get_item_data(item) else {
            continue;
        };
        let Some(name) = get_item_field("description_tag", data, translation).or_else(|| get_item_name(data)) else {
            continue;
        };
        if id == 0 {
            continue;
        }

        paint_kits.push((id, name));
    }

    create_map("PAINTKITS", create_map_data(paint_kits))
}

fn create_agents_map(items: &GameItems) -> String {
    let Some(items) = items.get("items") else {
        return String::new();
    };

    let mut agents: Vec<(i32, String)> = vec![];
    for item in items {
        let Some((id, data)) = get_item_data(item) else {
            continue;
        };
        let Some(name) = get_item_name(data) else {
            continue;
        };

        let is_agent_item = data
            .get("prefab")
            .is_some_and(|value| matches!(value, Str(prefab) if prefab.starts_with("customplayer")));

        if is_agent_item {
            agents.push((id, name));
        }
    }

    create_map("AGENTSMAP", create_map_data(agents))
}

fn create_stickers_map(items: &GameItems) -> String {
    let Some(items) = items.get("sticker_kits") else {
        return String::new();
    };

    let mut sticker_kits: Vec<(i32, String)> = vec![];
    for item in items {
        let Some((id, data)) = get_item_data(item) else {
            continue;
        };
        let Some(name) = get_item_name(data) else {
            continue;
        };

        sticker_kits.push((id, name));
    }

    create_map("STICKER_ID_TO_NAME", create_map_data(sticker_kits))
}

fn create_weapons_map(items: &GameItems, translation: &Translation) -> String {
    let Some(prefabs) = items.get("prefabs") else {
        return String::new();
    };
    let Some(items) = items.get("items") else {
        return String::new();
    };

    let mut weapons_or_equipment: Vec<(i32, String)> = vec![(42, "knife".to_string()), (59, "knife_t".to_string())];
    for item in items {
        let Some((id, data)) = get_item_data(item) else {
            continue;
        };

        // Skip translating default CT&T knives
        if id == 42 || id == 59 {
            continue;
        }
        let Some(Str(prefab)) = data.get("prefab") else {
            continue;
        };
        let Some(name) = get_item_field("item_name", data, translation).or_else(|| {
            if let Some(Object(prefab_data)) = prefabs.get(prefab) {
                get_item_field("item_name", prefab_data, translation).or_else(|| get_item_name(data))
            } else {
                None
            }
        }) else {
            continue;
        };

        let force_collect = matches!(prefab.as_str(), "melee" | "melee_unusual" | "c4" | "equipment" | "recipe");
        if (prefab.starts_with("weapon_") && !prefab.starts_with("weapon_case")) || force_collect {
            weapons_or_equipment.push((id, name));
        }
    }

    create_map("WEAPINDICIES", create_map_data(weapons_or_equipment))
}
