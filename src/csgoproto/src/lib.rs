// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgProtoBufHeader {
    #[prost(fixed64, optional, tag="1")]
    pub client_steam_id: ::core::option::Option<u64>,
    #[prost(int32, optional, tag="2")]
    pub client_session_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="3")]
    pub source_app_id: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag="10", default="18446744073709551615")]
    pub job_id_source: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag="11", default="18446744073709551615")]
    pub job_id_target: ::core::option::Option<u64>,
    #[prost(string, optional, tag="12")]
    pub target_job_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="13", default="2")]
    pub eresult: ::core::option::Option<i32>,
    #[prost(string, optional, tag="14")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="15")]
    pub ip: ::core::option::Option<u32>,
    #[prost(enumeration="GcProtoBufMsgSrc", optional, tag="200", default="Unspecified")]
    pub gc_msg_src: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="201")]
    pub gc_dir_index_source: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CChinaAgreementSessionsStartAgreementSessionInGameRequest {
    #[prost(uint32, optional, tag="1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag="2")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(string, optional, tag="3")]
    pub client_ipaddress: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CChinaAgreementSessionsStartAgreementSessionInGameResponse {
    #[prost(string, optional, tag="1")]
    pub agreement_url: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcProtoBufMsgSrc {
    Unspecified = 0,
    FromSystem = 1,
    FromSteamId = 2,
    FromGc = 3,
    ReplySystem = 4,
}
impl GcProtoBufMsgSrc {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "GCProtoBufMsgSrc_Unspecified",
            Self::FromSystem => "GCProtoBufMsgSrc_FromSystem",
            Self::FromSteamId => "GCProtoBufMsgSrc_FromSteamID",
            Self::FromGc => "GCProtoBufMsgSrc_FromGC",
            Self::ReplySystem => "GCProtoBufMsgSrc_ReplySystem",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCProtoBufMsgSrc_Unspecified" => Some(Self::Unspecified),
            "GCProtoBufMsgSrc_FromSystem" => Some(Self::FromSystem),
            "GCProtoBufMsgSrc_FromSteamID" => Some(Self::FromSteamId),
            "GCProtoBufMsgSrc_FromGC" => Some(Self::FromGc),
            "GCProtoBufMsgSrc_ReplySystem" => Some(Self::ReplySystem),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoidOwner {
    #[prost(uint32, optional, tag="1")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="2")]
    pub id: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSoSingleObject {
    #[prost(int32, optional, tag="2")]
    pub type_id: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="3")]
    pub object_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(fixed64, optional, tag="4")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag="5")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSoMultipleObjects {
    #[prost(message, repeated, tag="2")]
    pub objects_modified: ::prost::alloc::vec::Vec<c_msg_so_multiple_objects::SingleObject>,
    #[prost(fixed64, optional, tag="3")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag="6")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
}
/// Nested message and enum types in `CMsgSOMultipleObjects`.
pub mod c_msg_so_multiple_objects {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SingleObject {
        #[prost(int32, optional, tag="1")]
        pub type_id: ::core::option::Option<i32>,
        #[prost(bytes="bytes", optional, tag="2")]
        pub object_data: ::core::option::Option<::prost::bytes::Bytes>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheSubscribed {
    #[prost(message, repeated, tag="2")]
    pub objects: ::prost::alloc::vec::Vec<c_msg_so_cache_subscribed::SubscribedType>,
    #[prost(fixed64, optional, tag="3")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag="4")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
}
/// Nested message and enum types in `CMsgSOCacheSubscribed`.
pub mod c_msg_so_cache_subscribed {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubscribedType {
        #[prost(int32, optional, tag="1")]
        pub type_id: ::core::option::Option<i32>,
        #[prost(bytes="bytes", repeated, tag="2")]
        pub object_data: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheUnsubscribed {
    #[prost(message, optional, tag="2")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheSubscriptionCheck {
    #[prost(fixed64, optional, tag="2")]
    pub version: ::core::option::Option<u64>,
    #[prost(message, optional, tag="3")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheSubscriptionRefresh {
    #[prost(message, optional, tag="2")]
    pub owner_soid: ::core::option::Option<CMsgSoidOwner>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheVersion {
    #[prost(fixed64, optional, tag="1")]
    pub version: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgAccountDetails {
    #[prost(bool, optional, tag="1")]
    pub valid: ::core::option::Option<bool>,
    #[prost(string, optional, tag="2")]
    pub account_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="4")]
    pub public_profile: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="5")]
    pub public_inventory: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="6")]
    pub vac_banned: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="7")]
    pub cyber_cafe: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="8")]
    pub school_account: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="9")]
    pub free_trial_account: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="10")]
    pub subscribed: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="11")]
    pub low_violence: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="12")]
    pub limited: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="13")]
    pub trusted: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag="14")]
    pub package: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag="15")]
    pub time_cached: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="16")]
    pub account_locked: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="17")]
    pub community_banned: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="18")]
    pub trade_banned: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="19")]
    pub eligible_for_community_market: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcMultiplexMessage {
    #[prost(uint32, optional, tag="1")]
    pub msgtype: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub payload: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(fixed64, repeated, packed="false", tag="3")]
    pub steamids: ::prost::alloc::vec::Vec<u64>,
    #[prost(bool, optional, tag="4")]
    pub replytogc: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcMultiplexMessageResponse {
    #[prost(uint32, optional, tag="1")]
    pub msgtype: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CgcToGcMsgMasterAck {
    #[prost(uint32, optional, tag="1")]
    pub dir_index: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub gc_type: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CgcToGcMsgMasterAckResponse {
    #[prost(int32, optional, tag="1", default="2")]
    pub eresult: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CgcToGcMsgMasterStartupComplete {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgcToGcMsgRouted {
    #[prost(uint32, optional, tag="1")]
    pub msg_type: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag="2")]
    pub sender_id: ::core::option::Option<u64>,
    #[prost(bytes="bytes", optional, tag="3")]
    pub net_message: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag="4")]
    pub ip: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgcToGcMsgRoutedReply {
    #[prost(uint32, optional, tag="1")]
    pub msg_type: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub net_message: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcUpdateSessionIp {
    #[prost(fixed64, optional, tag="1")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(fixed32, optional, tag="2")]
    pub ip: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcRequestSessionIp {
    #[prost(fixed64, optional, tag="1")]
    pub steamid: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcRequestSessionIpResponse {
    #[prost(fixed32, optional, tag="1")]
    pub ip: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSoCacheHaveVersion {
    #[prost(message, optional, tag="1")]
    pub soid: ::core::option::Option<CMsgSoidOwner>,
    #[prost(fixed64, optional, tag="2")]
    pub version: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgClientHello {
    #[prost(uint32, optional, tag="1")]
    pub version: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="2")]
    pub socache_have_versions: ::prost::alloc::vec::Vec<CMsgSoCacheHaveVersion>,
    #[prost(uint32, optional, tag="3")]
    pub client_session_need: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub client_launcher: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub partner_srcid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub partner_accountid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub partner_accountflags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub partner_accountbalance: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="9")]
    pub steam_launcher: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgServerHello {
    #[prost(uint32, optional, tag="1")]
    pub version: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="2")]
    pub socache_have_versions: ::prost::alloc::vec::Vec<CMsgSoCacheHaveVersion>,
    #[prost(uint32, optional, tag="3")]
    pub legacy_client_session_need: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub client_launcher: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="6")]
    pub legacy_steamdatagram_routing: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag="7")]
    pub required_internal_addr: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="8")]
    pub steamdatagram_login: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag="9")]
    pub socache_control: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgClientWelcome {
    #[prost(uint32, optional, tag="1")]
    pub version: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub game_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(message, repeated, tag="3")]
    pub outofdate_subscribed_caches: ::prost::alloc::vec::Vec<CMsgSoCacheSubscribed>,
    #[prost(message, repeated, tag="4")]
    pub uptodate_subscribed_caches: ::prost::alloc::vec::Vec<CMsgSoCacheSubscriptionCheck>,
    #[prost(message, optional, tag="5")]
    pub location: ::core::option::Option<c_msg_client_welcome::Location>,
    #[prost(bytes="bytes", optional, tag="6")]
    pub game_data2: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag="7")]
    pub rtime32_gc_welcome_timestamp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub currency: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="9")]
    pub balance: ::core::option::Option<u32>,
    #[prost(string, optional, tag="10")]
    pub balance_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="11")]
    pub txn_country_code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CMsgClientWelcome`.
pub mod c_msg_client_welcome {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Location {
        #[prost(float, optional, tag="1")]
        pub latitude: ::core::option::Option<f32>,
        #[prost(float, optional, tag="2")]
        pub longitude: ::core::option::Option<f32>,
        #[prost(string, optional, tag="3")]
        pub country: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgConnectionStatus {
    #[prost(enumeration="GcConnectionStatus", optional, tag="1", default="HaveSession")]
    pub status: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="2")]
    pub client_session_need: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="3")]
    pub queue_position: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub queue_size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub wait_seconds: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub estimated_wait_seconds_remaining: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CWorkshopPopulateItemDescriptionsRequest {
    #[prost(uint32, optional, tag="1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="2")]
    pub languages: ::prost::alloc::vec::Vec<c_workshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock>,
}
/// Nested message and enum types in `CWorkshop_PopulateItemDescriptions_Request`.
pub mod c_workshop_populate_item_descriptions_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SingleItemDescription {
        #[prost(uint32, optional, tag="1")]
        pub gameitemid: ::core::option::Option<u32>,
        #[prost(string, optional, tag="2")]
        pub item_description: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="3")]
        pub one_per_account: ::core::option::Option<bool>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ItemDescriptionsLanguageBlock {
        #[prost(string, optional, tag="1")]
        pub language: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="2")]
        pub descriptions: ::prost::alloc::vec::Vec<SingleItemDescription>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CWorkshopGetContributorsRequest {
    #[prost(uint32, optional, tag="1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub gameitemid: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CWorkshopGetContributorsResponse {
    #[prost(fixed64, repeated, packed="false", tag="1")]
    pub contributors: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CWorkshopSetItemPaymentRulesRequest {
    #[prost(uint32, optional, tag="1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub gameitemid: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="3")]
    pub associated_workshop_files: ::prost::alloc::vec::Vec<c_workshop_set_item_payment_rules_request::WorkshopItemPaymentRule>,
    #[prost(message, repeated, tag="4")]
    pub partner_accounts: ::prost::alloc::vec::Vec<c_workshop_set_item_payment_rules_request::PartnerItemPaymentRule>,
    #[prost(bool, optional, tag="5")]
    pub validate_only: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="6")]
    pub make_workshop_files_subscribable: ::core::option::Option<bool>,
    #[prost(message, optional, tag="7")]
    pub associated_workshop_file_for_direct_payments: ::core::option::Option<c_workshop_set_item_payment_rules_request::WorkshopDirectPaymentRule>,
}
/// Nested message and enum types in `CWorkshop_SetItemPaymentRules_Request`.
pub mod c_workshop_set_item_payment_rules_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WorkshopItemPaymentRule {
        #[prost(uint64, optional, tag="1")]
        pub workshop_file_id: ::core::option::Option<u64>,
        #[prost(float, optional, tag="2")]
        pub revenue_percentage: ::core::option::Option<f32>,
        #[prost(string, optional, tag="3")]
        pub rule_description: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag="4", default="1")]
        pub rule_type: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WorkshopDirectPaymentRule {
        #[prost(uint64, optional, tag="1")]
        pub workshop_file_id: ::core::option::Option<u64>,
        #[prost(string, optional, tag="2")]
        pub rule_description: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PartnerItemPaymentRule {
        #[prost(uint32, optional, tag="1")]
        pub account_id: ::core::option::Option<u32>,
        #[prost(float, optional, tag="2")]
        pub revenue_percentage: ::core::option::Option<f32>,
        #[prost(string, optional, tag="3")]
        pub rule_description: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CWorkshopSetItemPaymentRulesResponse {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CGameServersAggregationQueryRequest {
    #[prost(string, optional, tag="1")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="3")]
    pub group_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CGameServersAggregationQueryResponse {
    #[prost(message, repeated, tag="1")]
    pub groups: ::prost::alloc::vec::Vec<c_game_servers_aggregation_query_response::Group>,
}
/// Nested message and enum types in `CGameServers_AggregationQuery_Response`.
pub mod c_game_servers_aggregation_query_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Group {
        #[prost(string, repeated, tag="1")]
        pub group_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag="2")]
        pub servers_empty: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="3")]
        pub servers_full: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="4")]
        pub servers_total: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="5")]
        pub players_humans: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="6")]
        pub players_bots: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="7")]
        pub player_capacity: ::core::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CWorkshopAddSpecialPaymentRequest {
    #[prost(uint32, optional, tag="1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub gameitemid: ::core::option::Option<u32>,
    #[prost(string, optional, tag="3")]
    pub date: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="4")]
    pub payment_us_usd: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="5")]
    pub payment_row_usd: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CWorkshopAddSpecialPaymentResponse {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CProductInfoSetRichPresenceLocalizationRequest {
    #[prost(uint32, optional, tag="1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="2")]
    pub languages: ::prost::alloc::vec::Vec<c_product_info_set_rich_presence_localization_request::LanguageSection>,
    #[prost(uint64, optional, tag="3")]
    pub steamid: ::core::option::Option<u64>,
}
/// Nested message and enum types in `CProductInfo_SetRichPresenceLocalization_Request`.
pub mod c_product_info_set_rich_presence_localization_request {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Token {
        #[prost(string, optional, tag="1")]
        pub token: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LanguageSection {
        #[prost(string, optional, tag="1")]
        pub language: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="2")]
        pub tokens: ::prost::alloc::vec::Vec<Token>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CProductInfoSetRichPresenceLocalizationResponse {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSerializedSoCache {
    #[prost(uint32, optional, tag="1")]
    pub file_version: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="2")]
    pub caches: ::prost::alloc::vec::Vec<c_msg_serialized_so_cache::Cache>,
    #[prost(uint32, optional, tag="3")]
    pub gc_socache_file_version: ::core::option::Option<u32>,
}
/// Nested message and enum types in `CMsgSerializedSOCache`.
pub mod c_msg_serialized_so_cache {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TypeCache {
        #[prost(uint32, optional, tag="1")]
        pub r#type: ::core::option::Option<u32>,
        #[prost(bytes="bytes", repeated, tag="2")]
        pub objects: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
        #[prost(uint32, optional, tag="3")]
        pub service_id: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Cache {
        #[prost(uint32, optional, tag="1")]
        pub r#type: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag="2")]
        pub id: ::core::option::Option<u64>,
        #[prost(message, repeated, tag="3")]
        pub versions: ::prost::alloc::vec::Vec<cache::Version>,
        #[prost(message, repeated, tag="4")]
        pub type_caches: ::prost::alloc::vec::Vec<TypeCache>,
    }
    /// Nested message and enum types in `Cache`.
    pub mod cache {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Version {
            #[prost(uint32, optional, tag="1")]
            pub service: ::core::option::Option<u32>,
            #[prost(uint64, optional, tag="2")]
            pub version: ::core::option::Option<u64>,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcClientLauncherType {
    Default = 0,
    Perfectworld = 1,
    Steamchina = 2,
    Source2 = 3,
}
impl GcClientLauncherType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Default => "GCClientLauncherType_DEFAULT",
            Self::Perfectworld => "GCClientLauncherType_PERFECTWORLD",
            Self::Steamchina => "GCClientLauncherType_STEAMCHINA",
            Self::Source2 => "GCClientLauncherType_SOURCE2",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCClientLauncherType_DEFAULT" => Some(Self::Default),
            "GCClientLauncherType_PERFECTWORLD" => Some(Self::Perfectworld),
            "GCClientLauncherType_STEAMCHINA" => Some(Self::Steamchina),
            "GCClientLauncherType_SOURCE2" => Some(Self::Source2),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GcConnectionStatus {
    HaveSession = 0,
    GcGoingDown = 1,
    NoSession = 2,
    NoSessionInLogonQueue = 3,
    NoSteam = 4,
}
impl GcConnectionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::HaveSession => "GCConnectionStatus_HAVE_SESSION",
            Self::GcGoingDown => "GCConnectionStatus_GC_GOING_DOWN",
            Self::NoSession => "GCConnectionStatus_NO_SESSION",
            Self::NoSessionInLogonQueue => "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE",
            Self::NoSteam => "GCConnectionStatus_NO_STEAM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GCConnectionStatus_HAVE_SESSION" => Some(Self::HaveSession),
            "GCConnectionStatus_GC_GOING_DOWN" => Some(Self::GcGoingDown),
            "GCConnectionStatus_NO_SESSION" => Some(Self::NoSession),
            "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE" => Some(Self::NoSessionInLogonQueue),
            "GCConnectionStatus_NO_STEAM" => Some(Self::NoSteam),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoFileHeader {
    #[prost(string, required, tag="1")]
    pub demo_file_stamp: ::prost::alloc::string::String,
    #[prost(int32, optional, tag="2")]
    pub network_protocol: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub server_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub client_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="6")]
    pub game_directory: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="7")]
    pub fullpackets_version: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="8")]
    pub allow_clientside_entities: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="9")]
    pub allow_clientside_particles: ::core::option::Option<bool>,
    #[prost(string, optional, tag="10")]
    pub addons: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="11")]
    pub demo_version_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="12")]
    pub demo_version_guid: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="13")]
    pub build_num: ::core::option::Option<i32>,
    #[prost(string, optional, tag="14")]
    pub game: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="15")]
    pub server_start_tick: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CGameInfo {
    #[prost(message, optional, tag="4")]
    pub dota: ::core::option::Option<c_game_info::CDotaGameInfo>,
    #[prost(message, optional, tag="5")]
    pub cs: ::core::option::Option<c_game_info::CcsGameInfo>,
}
/// Nested message and enum types in `CGameInfo`.
pub mod c_game_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CDotaGameInfo {
        #[prost(uint64, optional, tag="1")]
        pub match_id: ::core::option::Option<u64>,
        #[prost(int32, optional, tag="2")]
        pub game_mode: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub game_winner: ::core::option::Option<i32>,
        #[prost(message, repeated, tag="4")]
        pub player_info: ::prost::alloc::vec::Vec<c_dota_game_info::CPlayerInfo>,
        #[prost(uint32, optional, tag="5")]
        pub leagueid: ::core::option::Option<u32>,
        #[prost(message, repeated, tag="6")]
        pub picks_bans: ::prost::alloc::vec::Vec<c_dota_game_info::CHeroSelectEvent>,
        #[prost(uint32, optional, tag="7")]
        pub radiant_team_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="8")]
        pub dire_team_id: ::core::option::Option<u32>,
        #[prost(string, optional, tag="9")]
        pub radiant_team_tag: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="10")]
        pub dire_team_tag: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag="11")]
        pub end_time: ::core::option::Option<u32>,
    }
    /// Nested message and enum types in `CDotaGameInfo`.
    pub mod c_dota_game_info {
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CPlayerInfo {
            #[prost(string, optional, tag="1")]
            pub hero_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(string, optional, tag="2")]
            pub player_name: ::core::option::Option<::prost::alloc::string::String>,
            #[prost(bool, optional, tag="3")]
            pub is_fake_client: ::core::option::Option<bool>,
            #[prost(uint64, optional, tag="4")]
            pub steamid: ::core::option::Option<u64>,
            #[prost(int32, optional, tag="5")]
            pub game_team: ::core::option::Option<i32>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct CHeroSelectEvent {
            #[prost(bool, optional, tag="1")]
            pub is_pick: ::core::option::Option<bool>,
            #[prost(uint32, optional, tag="2")]
            pub team: ::core::option::Option<u32>,
            #[prost(int32, optional, tag="3")]
            pub hero_id: ::core::option::Option<i32>,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CcsGameInfo {
        #[prost(int32, repeated, packed="false", tag="1")]
        pub round_start_ticks: ::prost::alloc::vec::Vec<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoFileInfo {
    #[prost(float, optional, tag="1")]
    pub playback_time: ::core::option::Option<f32>,
    #[prost(int32, optional, tag="2")]
    pub playback_ticks: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub playback_frames: ::core::option::Option<i32>,
    #[prost(message, optional, tag="4")]
    pub game_info: ::core::option::Option<CGameInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoPacket {
    #[prost(bytes="bytes", optional, tag="3")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoFullPacket {
    #[prost(message, optional, tag="1")]
    pub string_table: ::core::option::Option<CDemoStringTables>,
    #[prost(message, optional, tag="2")]
    pub packet: ::core::option::Option<CDemoPacket>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoSaveGame {
    #[prost(bytes="bytes", optional, tag="1")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(fixed64, optional, tag="2")]
    pub steam_id: ::core::option::Option<u64>,
    #[prost(fixed64, optional, tag="3")]
    pub signature: ::core::option::Option<u64>,
    #[prost(int32, optional, tag="4")]
    pub version: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDemoSyncTick {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoConsoleCmd {
    #[prost(string, optional, tag="1")]
    pub cmdstring: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoSendTables {
    #[prost(bytes="bytes", optional, tag="1")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoClassInfo {
    #[prost(message, repeated, tag="1")]
    pub classes: ::prost::alloc::vec::Vec<c_demo_class_info::ClassT>,
}
/// Nested message and enum types in `CDemoClassInfo`.
pub mod c_demo_class_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClassT {
        #[prost(int32, optional, tag="1")]
        pub class_id: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub network_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="3")]
        pub table_name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoCustomData {
    #[prost(int32, optional, tag="1")]
    pub callback_index: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoCustomDataCallbacks {
    #[prost(string, repeated, tag="1")]
    pub save_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoAnimationHeader {
    #[prost(sint32, optional, tag="1")]
    pub entity_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub tick: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="3")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoAnimationData {
    #[prost(sint32, optional, tag="1")]
    pub entity_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub start_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub end_tick: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="4")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(int64, optional, tag="5")]
    pub data_checksum: ::core::option::Option<i64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoStringTables {
    #[prost(message, repeated, tag="1")]
    pub tables: ::prost::alloc::vec::Vec<c_demo_string_tables::TableT>,
}
/// Nested message and enum types in `CDemoStringTables`.
pub mod c_demo_string_tables {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ItemsT {
        #[prost(string, optional, tag="1")]
        pub str: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="bytes", optional, tag="2")]
        pub data: ::core::option::Option<::prost::bytes::Bytes>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TableT {
        #[prost(string, optional, tag="1")]
        pub table_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="2")]
        pub items: ::prost::alloc::vec::Vec<ItemsT>,
        #[prost(message, repeated, tag="3")]
        pub items_clientside: ::prost::alloc::vec::Vec<ItemsT>,
        #[prost(int32, optional, tag="4")]
        pub table_flags: ::core::option::Option<i32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDemoStop {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoUserCmd {
    #[prost(int32, optional, tag="1")]
    pub cmd_number: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoSpawnGroups {
    #[prost(bytes="bytes", repeated, tag="3")]
    pub msgs: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDemoRecovery {
    #[prost(message, optional, tag="1")]
    pub initial_spawn_group: ::core::option::Option<c_demo_recovery::DemoInitialSpawnGroupEntry>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub spawn_group_message: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Nested message and enum types in `CDemoRecovery`.
pub mod c_demo_recovery {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DemoInitialSpawnGroupEntry {
        #[prost(uint32, optional, tag="1")]
        pub spawngrouphandle: ::core::option::Option<u32>,
        #[prost(bool, optional, tag="2")]
        pub was_created: ::core::option::Option<bool>,
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EDemoCommands {
    DemError = -1,
    DemStop = 0,
    DemFileHeader = 1,
    DemFileInfo = 2,
    DemSyncTick = 3,
    DemSendTables = 4,
    DemClassInfo = 5,
    DemStringTables = 6,
    DemPacket = 7,
    DemSignonPacket = 8,
    DemConsoleCmd = 9,
    DemCustomData = 10,
    DemCustomDataCallbacks = 11,
    DemUserCmd = 12,
    DemFullPacket = 13,
    DemSaveGame = 14,
    DemSpawnGroups = 15,
    DemAnimationData = 16,
    DemAnimationHeader = 17,
    DemRecovery = 18,
    DemMax = 19,
    DemIsCompressed = 64,
}
impl EDemoCommands {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DemError => "DEM_Error",
            Self::DemStop => "DEM_Stop",
            Self::DemFileHeader => "DEM_FileHeader",
            Self::DemFileInfo => "DEM_FileInfo",
            Self::DemSyncTick => "DEM_SyncTick",
            Self::DemSendTables => "DEM_SendTables",
            Self::DemClassInfo => "DEM_ClassInfo",
            Self::DemStringTables => "DEM_StringTables",
            Self::DemPacket => "DEM_Packet",
            Self::DemSignonPacket => "DEM_SignonPacket",
            Self::DemConsoleCmd => "DEM_ConsoleCmd",
            Self::DemCustomData => "DEM_CustomData",
            Self::DemCustomDataCallbacks => "DEM_CustomDataCallbacks",
            Self::DemUserCmd => "DEM_UserCmd",
            Self::DemFullPacket => "DEM_FullPacket",
            Self::DemSaveGame => "DEM_SaveGame",
            Self::DemSpawnGroups => "DEM_SpawnGroups",
            Self::DemAnimationData => "DEM_AnimationData",
            Self::DemAnimationHeader => "DEM_AnimationHeader",
            Self::DemRecovery => "DEM_Recovery",
            Self::DemMax => "DEM_Max",
            Self::DemIsCompressed => "DEM_IsCompressed",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEM_Error" => Some(Self::DemError),
            "DEM_Stop" => Some(Self::DemStop),
            "DEM_FileHeader" => Some(Self::DemFileHeader),
            "DEM_FileInfo" => Some(Self::DemFileInfo),
            "DEM_SyncTick" => Some(Self::DemSyncTick),
            "DEM_SendTables" => Some(Self::DemSendTables),
            "DEM_ClassInfo" => Some(Self::DemClassInfo),
            "DEM_StringTables" => Some(Self::DemStringTables),
            "DEM_Packet" => Some(Self::DemPacket),
            "DEM_SignonPacket" => Some(Self::DemSignonPacket),
            "DEM_ConsoleCmd" => Some(Self::DemConsoleCmd),
            "DEM_CustomData" => Some(Self::DemCustomData),
            "DEM_CustomDataCallbacks" => Some(Self::DemCustomDataCallbacks),
            "DEM_UserCmd" => Some(Self::DemUserCmd),
            "DEM_FullPacket" => Some(Self::DemFullPacket),
            "DEM_SaveGame" => Some(Self::DemSaveGame),
            "DEM_SpawnGroups" => Some(Self::DemSpawnGroups),
            "DEM_AnimationData" => Some(Self::DemAnimationData),
            "DEM_AnimationHeader" => Some(Self::DemAnimationHeader),
            "DEM_Recovery" => Some(Self::DemRecovery),
            "DEM_Max" => Some(Self::DemMax),
            "DEM_IsCompressed" => Some(Self::DemIsCompressed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEngineGotvSyncPacket {
    #[prost(uint64, optional, tag="1")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="2")]
    pub instance_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub signupfragment: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub currentfragment: ::core::option::Option<u32>,
    #[prost(float, optional, tag="5")]
    pub tickrate: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag="6")]
    pub tick: ::core::option::Option<u32>,
    #[prost(float, optional, tag="8")]
    pub rtdelay: ::core::option::Option<f32>,
    #[prost(float, optional, tag="9")]
    pub rcvage: ::core::option::Option<f32>,
    #[prost(float, optional, tag="10")]
    pub keyframe_interval: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag="11")]
    pub cdndelay: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GameServerPing {
    #[prost(int32, optional, tag="2")]
    pub ping: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="3")]
    pub ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub instances: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataCenterPing {
    #[prost(fixed32, optional, tag="1")]
    pub data_center_id: ::core::option::Option<u32>,
    #[prost(sint32, optional, tag="2")]
    pub ping: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DetailedSearchStatistic {
    #[prost(uint32, optional, tag="1")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub search_time_avg: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub players_searching: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TournamentPlayer {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub player_nick: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub player_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="4")]
    pub player_dob: ::core::option::Option<u32>,
    #[prost(string, optional, tag="5")]
    pub player_flag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="6")]
    pub player_location: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="7")]
    pub player_desc: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TournamentTeam {
    #[prost(int32, optional, tag="1")]
    pub team_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub team_tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub team_flag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub team_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="5")]
    pub players: ::prost::alloc::vec::Vec<TournamentPlayer>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TournamentEvent {
    #[prost(int32, optional, tag="1")]
    pub event_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub event_tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="4")]
    pub event_time_start: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub event_time_end: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="6")]
    pub event_public: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="7")]
    pub event_stage_id: ::core::option::Option<i32>,
    #[prost(string, optional, tag="8")]
    pub event_stage_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="9")]
    pub active_section_id: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalStatistics {
    #[prost(uint32, optional, tag="1")]
    pub players_online: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub servers_online: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub players_searching: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub servers_available: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub ongoing_matches: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub search_time_avg: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="7")]
    pub search_statistics: ::prost::alloc::vec::Vec<DetailedSearchStatistic>,
    #[prost(string, optional, tag="8")]
    pub main_post_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="9")]
    pub required_appid_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="10")]
    pub pricesheet_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="11")]
    pub twitch_streams_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="12")]
    pub active_tournament_eventid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="13")]
    pub active_survey_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="14")]
    pub rtime32_cur: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="15")]
    pub rtime32_event_start: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="16")]
    pub required_appid_version2: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationalStatisticDescription {
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="2")]
    pub idkey: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationalStatisticElement {
    #[prost(uint32, optional, tag="1")]
    pub idkey: ::core::option::Option<u32>,
    #[prost(int32, repeated, packed="false", tag="2")]
    pub values: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationalStatisticsPacket {
    #[prost(int32, optional, tag="1")]
    pub packetid: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub mstimestamp: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="3")]
    pub values: ::prost::alloc::vec::Vec<OperationalStatisticElement>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationalVarValue {
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="2")]
    pub ivalue: ::core::option::Option<i32>,
    #[prost(float, optional, tag="3")]
    pub fvalue: ::core::option::Option<f32>,
    #[prost(bytes="bytes", optional, tag="4")]
    pub svalue: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerRankingInfo {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub rank_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub wins: ::core::option::Option<u32>,
    #[prost(float, optional, tag="4")]
    pub rank_change: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag="6")]
    pub rank_type_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub tv_control: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="8")]
    pub rank_window_stats: ::core::option::Option<u64>,
    #[prost(string, optional, tag="9")]
    pub leaderboard_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="10")]
    pub rank_if_win: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="11")]
    pub rank_if_lose: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="12")]
    pub rank_if_tie: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="13")]
    pub per_map_rank: ::prost::alloc::vec::Vec<player_ranking_info::PerMapRank>,
    #[prost(uint32, optional, tag="14")]
    pub leaderboard_name_status: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="15")]
    pub highest_rank: ::core::option::Option<u32>,
}
/// Nested message and enum types in `PlayerRankingInfo`.
pub mod player_ranking_info {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PerMapRank {
        #[prost(uint32, optional, tag="1")]
        pub map_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub rank_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="3")]
        pub wins: ::core::option::Option<u32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlayerCommendationInfo {
    #[prost(uint32, optional, tag="1")]
    pub cmd_friendly: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub cmd_teaching: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub cmd_leader: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerMedalsInfo {
    #[prost(uint32, repeated, packed="false", tag="7")]
    pub display_items_defidx: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag="8")]
    pub featured_display_item_defidx: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountActivity {
    #[prost(uint32, optional, tag="1")]
    pub activity: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub mode: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub map: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="4")]
    pub matchid: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TournamentMatchSetup {
    #[prost(int32, optional, tag="1")]
    pub event_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub team_id_ct: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub team_id_t: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub event_stage_id: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerHltvInfo {
    #[prost(uint32, optional, tag="1")]
    pub tv_udp_port: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="2")]
    pub tv_watch_key: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub tv_slots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub tv_clients: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub tv_proxies: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub tv_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(string, optional, tag="9")]
    pub game_mapgroup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="10")]
    pub game_map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="11")]
    pub tv_master_steamid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="12")]
    pub tv_local_slots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="13")]
    pub tv_local_clients: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="14")]
    pub tv_local_proxies: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="15")]
    pub tv_relay_slots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="16")]
    pub tv_relay_clients: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="17")]
    pub tv_relay_proxies: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="18")]
    pub tv_relay_address: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="19")]
    pub tv_relay_port: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="20")]
    pub tv_relay_steamid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="21")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IpAddressMask {
    #[prost(uint32, optional, tag="1")]
    pub a: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub b: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub c: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub d: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub bits: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub token: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgCsgoSteamUserStatChange {
    #[prost(int32, optional, tag="1")]
    pub ecsgosteamuserstat: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub delta: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="3")]
    pub absolute: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct XpProgressData {
    #[prost(uint32, optional, tag="1")]
    pub xp_points: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="2")]
    pub xp_category: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MatchEndItemUpdates {
    #[prost(uint64, optional, tag="1")]
    pub item_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="2")]
    pub item_attr_defidx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub item_attr_delta_value: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScoreLeaderboardData {
    #[prost(uint64, optional, tag="1")]
    pub quest_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="2")]
    pub score: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="3")]
    pub accountentries: ::prost::alloc::vec::Vec<score_leaderboard_data::AccountEntries>,
    #[prost(message, repeated, tag="5")]
    pub matchentries: ::prost::alloc::vec::Vec<score_leaderboard_data::Entry>,
    #[prost(string, optional, tag="6")]
    pub leaderboard_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ScoreLeaderboardData`.
pub mod score_leaderboard_data {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(uint32, optional, tag="1")]
        pub tag: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub val: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AccountEntries {
        #[prost(uint32, optional, tag="1")]
        pub accountid: ::core::option::Option<u32>,
        #[prost(message, repeated, tag="2")]
        pub entries: ::prost::alloc::vec::Vec<Entry>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerQuestData {
    #[prost(uint32, optional, tag="1")]
    pub quester_account_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="2")]
    pub quest_item_data: ::prost::alloc::vec::Vec<player_quest_data::QuestItemData>,
    #[prost(message, repeated, tag="3")]
    pub xp_progress_data: ::prost::alloc::vec::Vec<XpProgressData>,
    #[prost(uint32, optional, tag="4")]
    pub time_played: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub mm_game_mode: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="6")]
    pub item_updates: ::prost::alloc::vec::Vec<MatchEndItemUpdates>,
    #[prost(bool, optional, tag="7")]
    pub operation_points_eligible: ::core::option::Option<bool>,
    #[prost(message, repeated, tag="8")]
    pub userstatchanges: ::prost::alloc::vec::Vec<CMsgCsgoSteamUserStatChange>,
}
/// Nested message and enum types in `PlayerQuestData`.
pub mod player_quest_data {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct QuestItemData {
        #[prost(uint64, optional, tag="1")]
        pub quest_id: ::core::option::Option<u64>,
        #[prost(int32, optional, tag="2")]
        pub quest_normal_points_earned: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub quest_bonus_points_earned: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeepPlayerStatsEntry {
    #[prost(uint32, optional, tag="1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="2")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub mm_game_mode: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub mapid: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="5")]
    pub b_starting_ct: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag="6")]
    pub match_outcome: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub rounds_won: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub rounds_lost: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="9")]
    pub stat_score: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="12")]
    pub stat_deaths: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="13")]
    pub stat_mvps: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="14")]
    pub enemy_kills: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="15")]
    pub enemy_headshots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="16")]
    pub enemy_2ks: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="17")]
    pub enemy_3ks: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="18")]
    pub enemy_4ks: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="19")]
    pub total_damage: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="23")]
    pub engagements_entry_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="24")]
    pub engagements_entry_wins: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="25")]
    pub engagements_1v1_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="26")]
    pub engagements_1v1_wins: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="27")]
    pub engagements_1v2_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="28")]
    pub engagements_1v2_wins: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="29")]
    pub utility_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="30")]
    pub utility_success: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="32")]
    pub flash_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="33")]
    pub flash_success: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed="false", tag="34")]
    pub mates: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeepPlayerMatchEvent {
    #[prost(uint32, optional, tag="1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="2")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub event_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub event_type: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="5")]
    pub b_playing_ct: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="6")]
    pub user_pos_x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="7")]
    pub user_pos_y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="12")]
    pub user_pos_z: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="8")]
    pub user_defidx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="9")]
    pub other_pos_x: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="10")]
    pub other_pos_y: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="13")]
    pub other_pos_z: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="11")]
    pub other_defidx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="14")]
    pub event_data: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcServerQuestUpdateData {
    #[prost(message, repeated, tag="1")]
    pub player_quest_data: ::prost::alloc::vec::Vec<PlayerQuestData>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub binary_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag="3")]
    pub mm_game_mode: ::core::option::Option<u32>,
    #[prost(message, optional, tag="4")]
    pub missionlbsdata: ::core::option::Option<ScoreLeaderboardData>,
    #[prost(uint32, optional, tag="5")]
    pub flags: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ServerConfirm {
    #[prost(uint32, optional, tag="1")]
    pub token: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub stamp: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="3")]
    pub exchange: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="4")]
    pub retry: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ServerReservationUpdate {
    #[prost(uint32, optional, tag="1")]
    pub viewers_external_total: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub viewers_external_steam: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingStart {
    #[prost(uint32, repeated, packed="false", tag="1")]
    pub account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag="2")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(string, optional, tag="3")]
    pub ticket_data: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="4")]
    pub client_version: ::core::option::Option<u32>,
    #[prost(message, optional, tag="5")]
    pub tournament_match: ::core::option::Option<TournamentMatchSetup>,
    #[prost(bool, optional, tag="6")]
    pub prime_only: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag="7")]
    pub tv_control: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="8")]
    pub lobby_id: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingStop {
    #[prost(int32, optional, tag="1")]
    pub abandon: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ClientUpdateNote {
    #[prost(int32, optional, tag="1")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub region_id: ::core::option::Option<i32>,
    #[prost(float, optional, tag="3")]
    pub region_r: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub distance: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingClient2ServerPing {
    #[prost(message, repeated, tag="1")]
    pub gameserverpings: ::prost::alloc::vec::Vec<GameServerPing>,
    #[prost(int32, optional, tag="2")]
    pub offset_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub final_batch: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="4")]
    pub data_center_pings: ::prost::alloc::vec::Vec<DataCenterPing>,
    #[prost(uint32, optional, tag="5")]
    pub max_ping: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag="6")]
    pub test_token: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="7")]
    pub search_key: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(message, repeated, tag="8")]
    pub notes: ::prost::alloc::vec::Vec<CMsgGccStrike15V2MatchmakingGc2ClientUpdateNote>,
    #[prost(string, optional, tag="9")]
    pub debug_message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ClientUpdate {
    #[prost(int32, optional, tag="1")]
    pub matchmaking: ::core::option::Option<i32>,
    #[prost(uint32, repeated, packed="false", tag="2")]
    pub waiting_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, optional, tag="3")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, repeated, packed="false", tag="6")]
    pub ongoingmatch_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag="7")]
    pub global_stats: ::core::option::Option<GlobalStatistics>,
    #[prost(uint32, repeated, packed="false", tag="8")]
    pub failping_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="9")]
    pub penalty_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="10")]
    pub failready_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="11")]
    pub vacbanned_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, optional, tag="12")]
    pub server_ipaddress_mask: ::core::option::Option<IpAddressMask>,
    #[prost(message, repeated, tag="13")]
    pub notes: ::prost::alloc::vec::Vec<CMsgGccStrike15V2MatchmakingGc2ClientUpdateNote>,
    #[prost(uint32, repeated, packed="false", tag="14")]
    pub penalty_account_id_sessions_green: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="15")]
    pub insufficientlevel_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="16")]
    pub vsncheck_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="17")]
    pub launcher_mismatch_sessions: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="18")]
    pub insecure_account_id_sessions: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2TournamentMatchDraft {
    #[prost(int32, optional, tag="1")]
    pub event_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub event_stage_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub team_id_0: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub team_id_1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub maps_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub maps_current: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="7")]
    pub team_id_start: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="8")]
    pub team_id_veto1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="9")]
    pub team_id_pickn: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="10")]
    pub drafts: ::prost::alloc::vec::Vec<c_data_gcc_strike15_v2_tournament_match_draft::Entry>,
    #[prost(int32, repeated, packed="false", tag="11")]
    pub vote_mapid_0: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="12")]
    pub vote_mapid_1: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="13")]
    pub vote_mapid_2: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="14")]
    pub vote_mapid_3: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="15")]
    pub vote_mapid_4: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="16")]
    pub vote_mapid_5: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="17")]
    pub vote_starting_side: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag="18")]
    pub vote_phase: ::core::option::Option<i32>,
    #[prost(float, optional, tag="19")]
    pub vote_phase_start: ::core::option::Option<f32>,
    #[prost(float, optional, tag="20")]
    pub vote_phase_length: ::core::option::Option<f32>,
}
/// Nested message and enum types in `CDataGCCStrike15_v2_TournamentMatchDraft`.
pub mod c_data_gcc_strike15_v2_tournament_match_draft {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(int32, optional, tag="1")]
        pub mapid: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub team_id_ct: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CPreMatchInfoData {
    #[prost(int32, optional, tag="1")]
    pub predictions_pct: ::core::option::Option<i32>,
    #[prost(message, optional, tag="4")]
    pub draft: ::core::option::Option<CDataGccStrike15V2TournamentMatchDraft>,
    #[prost(message, repeated, tag="5")]
    pub stats: ::prost::alloc::vec::Vec<c_pre_match_info_data::TeamStats>,
    #[prost(int32, repeated, packed="false", tag="6")]
    pub wins: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `CPreMatchInfoData`.
pub mod c_pre_match_info_data {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TeamStats {
        #[prost(int32, optional, tag="1")]
        pub match_info_idxtxt: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub match_info_txt: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, repeated, tag="3")]
        pub match_info_teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ServerReserve {
    #[prost(uint32, repeated, packed="false", tag="1")]
    pub account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag="2")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="3")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="4")]
    pub server_version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="18")]
    pub flags: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="5")]
    pub rankings: ::prost::alloc::vec::Vec<PlayerRankingInfo>,
    #[prost(uint64, optional, tag="6")]
    pub encryption_key: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="7")]
    pub encryption_key_pub: ::core::option::Option<u64>,
    #[prost(uint32, repeated, packed="false", tag="8")]
    pub party_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag="9")]
    pub whitelist: ::prost::alloc::vec::Vec<IpAddressMask>,
    #[prost(uint64, optional, tag="10")]
    pub tv_master_steamid: ::core::option::Option<u64>,
    #[prost(message, optional, tag="11")]
    pub tournament_event: ::core::option::Option<TournamentEvent>,
    #[prost(message, repeated, tag="12")]
    pub tournament_teams: ::prost::alloc::vec::Vec<TournamentTeam>,
    #[prost(uint32, repeated, packed="false", tag="13")]
    pub tournament_casters_account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, optional, tag="14")]
    pub tv_relay_steamid: ::core::option::Option<u64>,
    #[prost(message, optional, tag="15")]
    pub pre_match_data: ::core::option::Option<CPreMatchInfoData>,
    #[prost(uint32, optional, tag="16")]
    pub rtime32_event_start: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="17")]
    pub tv_control: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="19")]
    pub op_var_values: ::prost::alloc::vec::Vec<OperationalVarValue>,
    #[prost(uint32, optional, tag="20")]
    pub socache_control: ::core::option::Option<u32>,
    #[prost(int32, repeated, packed="false", tag="21")]
    pub teammate_colors: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingServerReservationResponse {
    #[prost(uint64, optional, tag="1")]
    pub reservationid: ::core::option::Option<u64>,
    #[prost(message, optional, tag="2")]
    pub reservation: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ServerReserve>,
    #[prost(string, optional, tag="3")]
    pub map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="4")]
    pub gc_reservation_sent: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="5")]
    pub server_version: ::core::option::Option<u32>,
    #[prost(message, optional, tag="6")]
    pub tv_info: ::core::option::Option<ServerHltvInfo>,
    #[prost(uint32, repeated, packed="false", tag="7")]
    pub reward_player_accounts: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="8")]
    pub idle_player_accounts: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag="9")]
    pub reward_item_attr_def_idx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="10")]
    pub reward_item_attr_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="11")]
    pub reward_item_attr_reward_idx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="12")]
    pub reward_drop_list: ::core::option::Option<u32>,
    #[prost(string, optional, tag="13")]
    pub tournament_tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="14")]
    pub legacy_steamdatagram_port: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="17")]
    pub steamdatagram_routing: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag="15")]
    pub test_token: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="16")]
    pub flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="18")]
    pub system_load: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="19")]
    pub cpus_online: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ClientReserve {
    #[prost(uint64, optional, tag="1")]
    pub serverid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="2")]
    pub direct_udp_ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub direct_udp_port: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="4")]
    pub reservationid: ::core::option::Option<u64>,
    #[prost(message, optional, tag="5")]
    pub reservation: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ServerReserve>,
    #[prost(string, optional, tag="6")]
    pub map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="7")]
    pub server_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="8")]
    pub gs_ping: ::core::option::Option<DataCenterPing>,
    #[prost(uint32, optional, tag="9")]
    pub gs_location_id: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingServerRoundStats {
    #[prost(uint64, optional, tag="1")]
    pub reservationid: ::core::option::Option<u64>,
    #[prost(message, optional, tag="2")]
    pub reservation: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ServerReserve>,
    #[prost(string, optional, tag="3")]
    pub map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="4")]
    pub round: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed="false", tag="5")]
    pub kills: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="6")]
    pub assists: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="7")]
    pub deaths: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="8")]
    pub scores: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="9")]
    pub pings: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag="10")]
    pub round_result: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="11")]
    pub match_result: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed="false", tag="12")]
    pub team_scores: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag="13")]
    pub confirm: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ServerConfirm>,
    #[prost(int32, optional, tag="14")]
    pub reservation_stage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="15")]
    pub match_duration: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed="false", tag="16")]
    pub enemy_kills: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="17")]
    pub enemy_headshots: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="18")]
    pub enemy_3ks: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="19")]
    pub enemy_4ks: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="20")]
    pub enemy_5ks: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="21")]
    pub mvps: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, optional, tag="22")]
    pub spectators_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="23")]
    pub spectators_count_tv: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="24")]
    pub spectators_count_lnk: ::core::option::Option<u32>,
    #[prost(int32, repeated, packed="false", tag="25")]
    pub enemy_kills_agg: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag="26")]
    pub drop_info: ::core::option::Option<c_msg_gcc_strike15_v2_matchmaking_server_round_stats::DropInfo>,
    #[prost(bool, optional, tag="27")]
    pub b_switched_teams: ::core::option::Option<bool>,
    #[prost(int32, repeated, packed="false", tag="28")]
    pub enemy_2ks: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="29")]
    pub player_spawned: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="30")]
    pub team_spawn_count: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, optional, tag="31")]
    pub max_rounds: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="32")]
    pub map_id: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_MatchmakingServerRoundStats`.
pub mod c_msg_gcc_strike15_v2_matchmaking_server_round_stats {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DropInfo {
        #[prost(uint32, optional, tag="1")]
        pub account_mvp: ::core::option::Option<u32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingClient2GcHello {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ClientHello {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag="2")]
    pub ongoingmatch: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ClientReserve>,
    #[prost(message, optional, tag="3")]
    pub global_stats: ::core::option::Option<GlobalStatistics>,
    #[prost(uint32, optional, tag="4")]
    pub penalty_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub penalty_reason: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="6")]
    pub vac_banned: ::core::option::Option<i32>,
    #[prost(message, optional, tag="7")]
    pub ranking: ::core::option::Option<PlayerRankingInfo>,
    #[prost(message, optional, tag="8")]
    pub commendation: ::core::option::Option<PlayerCommendationInfo>,
    #[prost(message, optional, tag="9")]
    pub medals: ::core::option::Option<PlayerMedalsInfo>,
    #[prost(message, optional, tag="10")]
    pub my_current_event: ::core::option::Option<TournamentEvent>,
    #[prost(message, repeated, tag="11")]
    pub my_current_event_teams: ::prost::alloc::vec::Vec<TournamentTeam>,
    #[prost(message, optional, tag="12")]
    pub my_current_team: ::core::option::Option<TournamentTeam>,
    #[prost(message, repeated, tag="13")]
    pub my_current_event_stages: ::prost::alloc::vec::Vec<TournamentEvent>,
    #[prost(uint32, optional, tag="14")]
    pub survey_vote: ::core::option::Option<u32>,
    #[prost(message, optional, tag="15")]
    pub activity: ::core::option::Option<AccountActivity>,
    #[prost(int32, optional, tag="17")]
    pub player_level: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="18")]
    pub player_cur_xp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="19")]
    pub player_xp_bonus_flags: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="20")]
    pub rankings: ::prost::alloc::vec::Vec<PlayerRankingInfo>,
    #[prost(uint64, optional, tag="21")]
    pub owcaseid: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2AccountPrivacySettings {
    #[prost(message, repeated, tag="1")]
    pub settings: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_account_privacy_settings::Setting>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_AccountPrivacySettings`.
pub mod c_msg_gcc_strike15_v2_account_privacy_settings {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Setting {
        #[prost(uint32, optional, tag="1")]
        pub setting_type: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub setting_value: ::core::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ClientAbandon {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag="2")]
    pub abandoned_match: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ClientReserve>,
    #[prost(uint32, optional, tag="3")]
    pub penalty_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub penalty_reason: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientGcRankUpdate {
    #[prost(message, repeated, tag="1")]
    pub rankings: ::prost::alloc::vec::Vec<PlayerRankingInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingOperator2GcBlogUpdate {
    #[prost(string, optional, tag="1")]
    pub main_post_url: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ServerNotificationForUserPenalty {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub reason: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub seconds: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="4")]
    pub communication_cooldown: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientReportPlayer {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub rpt_aimbot: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub rpt_wallhack: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub rpt_speedhack: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub rpt_teamharm: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub rpt_textabuse: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub rpt_voiceabuse: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="8")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(bool, optional, tag="9")]
    pub report_from_demo: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientCommendPlayer {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="8")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(message, optional, tag="9")]
    pub commendation: ::core::option::Option<PlayerCommendationInfo>,
    #[prost(uint32, optional, tag="10")]
    pub tokens: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientReportServer {
    #[prost(uint32, optional, tag="1")]
    pub rpt_poorperf: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub rpt_abusivemodels: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub rpt_badmotd: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub rpt_listingabuse: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub rpt_inventoryabuse: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="8")]
    pub match_id: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientReportResponse {
    #[prost(uint64, optional, tag="1")]
    pub confirmation_id: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="2")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub server_ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub response_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub response_result: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub tokens: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestWatchInfoFriends {
    #[prost(uint32, optional, tag="1")]
    pub request_id: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed="false", tag="2")]
    pub account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint64, optional, tag="3")]
    pub serverid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="4")]
    pub matchid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="5")]
    pub client_launcher: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="6")]
    pub data_center_pings: ::prost::alloc::vec::Vec<DataCenterPing>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WatchableMatchInfo {
    #[prost(uint32, optional, tag="1")]
    pub server_ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub tv_port: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub tv_spectators: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub tv_time: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="5")]
    pub tv_watch_password: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint64, optional, tag="6")]
    pub cl_decryptdata_key: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="7")]
    pub cl_decryptdata_key_pub: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="8")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(string, optional, tag="9")]
    pub game_mapgroup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="10")]
    pub game_map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag="11")]
    pub server_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="12")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="13")]
    pub reservation_id: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestJoinFriendData {
    #[prost(uint32, optional, tag="1")]
    pub version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub join_token: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub join_ipp: ::core::option::Option<u32>,
    #[prost(message, optional, tag="5")]
    pub res: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ClientReserve>,
    #[prost(string, optional, tag="6")]
    pub errormsg: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestJoinServerData {
    #[prost(uint32, optional, tag="1")]
    pub version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="3")]
    pub serverid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="4")]
    pub server_ip: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub server_port: ::core::option::Option<u32>,
    #[prost(message, optional, tag="6")]
    pub res: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ClientReserve>,
    #[prost(string, optional, tag="7")]
    pub errormsg: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcCstrike15V2ClientRequestNewMission {
    #[prost(uint32, optional, tag="2")]
    pub mission_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub campaign_id: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcCstrike15V2ClientRedeemMissionReward {
    #[prost(uint32, optional, tag="1")]
    pub campaign_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub redeem_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub redeemable_balance: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub expected_cost: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcCstrike15V2ClientRedeemFreeReward {
    #[prost(uint32, optional, tag="1")]
    pub generation_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub redeemable_balance: ::core::option::Option<u32>,
    #[prost(uint64, repeated, packed="false", tag="3")]
    pub items: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcCstrike15V2Gc2ServerNotifyXpRewarded {
    #[prost(message, repeated, tag="1")]
    pub xp_progress_data: ::prost::alloc::vec::Vec<XpProgressData>,
    #[prost(uint32, optional, tag="2")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub current_xp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub current_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub upgraded_defidx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub operation_points_awarded: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub free_rewards: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub xp_trail_remaining: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="9")]
    pub xp_trail_xp_needed: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="10")]
    pub xp_trail_level: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientNetworkConfig {
    #[prost(bytes="bytes", optional, tag="1")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15ClientDeepStats {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag="2")]
    pub range: ::core::option::Option<c_msg_gcc_strike15_client_deep_stats::DeepStatsRange>,
    #[prost(message, repeated, tag="3")]
    pub matches: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_client_deep_stats::DeepStatsMatch>,
}
/// Nested message and enum types in `CMsgGCCStrike15_ClientDeepStats`.
pub mod c_msg_gcc_strike15_client_deep_stats {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DeepStatsRange {
        #[prost(uint32, optional, tag="1")]
        pub begin: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub end: ::core::option::Option<u32>,
        #[prost(bool, optional, tag="3")]
        pub frozen: ::core::option::Option<bool>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DeepStatsMatch {
        #[prost(message, optional, tag="1")]
        pub player: ::core::option::Option<super::DeepPlayerStatsEntry>,
        #[prost(message, repeated, tag="2")]
        pub events: ::prost::alloc::vec::Vec<super::DeepPlayerMatchEvent>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2WatchInfoUsers {
    #[prost(uint32, optional, tag="1")]
    pub request_id: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed="false", tag="2")]
    pub account_ids: ::prost::alloc::vec::Vec<u32>,
    #[prost(message, repeated, tag="3")]
    pub watchable_match_infos: ::prost::alloc::vec::Vec<WatchableMatchInfo>,
    #[prost(uint32, optional, tag="5")]
    pub extended_timeout: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestPlayersProfile {
    #[prost(uint32, optional, tag="1")]
    pub request_id_deprecated: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed="false", tag="2")]
    pub account_ids_deprecated: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag="3")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub request_level: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PlayersProfile {
    #[prost(uint32, optional, tag="1")]
    pub request_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="2")]
    pub account_profiles: ::prost::alloc::vec::Vec<CMsgGccStrike15V2MatchmakingGc2ClientHello>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PremierSeasonSummary {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub season_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="3")]
    pub data_per_week: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_premier_season_summary::DataPerWeek>,
    #[prost(message, repeated, tag="4")]
    pub data_per_map: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_premier_season_summary::DataPerMap>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_PremierSeasonSummary`.
pub mod c_msg_gcc_strike15_v2_premier_season_summary {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataPerWeek {
        #[prost(uint64, optional, tag="1")]
        pub week_id: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag="2")]
        pub rank_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="3")]
        pub matches_played: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DataPerMap {
        #[prost(uint32, optional, tag="1")]
        pub map_id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub wins: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="3")]
        pub ties: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="4")]
        pub losses: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="5")]
        pub rounds: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="6")]
        pub kills: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="7")]
        pub headshots: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="8")]
        pub assists: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="9")]
        pub deaths: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="10")]
        pub mvps: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="11")]
        pub rounds_3k: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="12")]
        pub rounds_4k: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="13")]
        pub rounds_5k: ::core::option::Option<u32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PlayerOverwatchCaseUpdate {
    #[prost(uint64, optional, tag="1")]
    pub caseid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub suspectid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub fractionid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub rpt_aimbot: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub rpt_wallhack: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub rpt_speedhack: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub rpt_teamharm: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="9")]
    pub reason: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PlayerOverwatchCaseAssignment {
    #[prost(uint64, optional, tag="1")]
    pub caseid: ::core::option::Option<u64>,
    #[prost(string, optional, tag="2")]
    pub caseurl: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="3")]
    pub verdict: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub timestamp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub throttleseconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub suspectid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub fractionid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub numrounds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="9")]
    pub fractionrounds: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="10")]
    pub streakconvictions: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="11")]
    pub reason: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PlayerOverwatchCaseStatus {
    #[prost(uint64, optional, tag="1")]
    pub caseid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="2")]
    pub statusid: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CClientHeaderOverwatchEvidence {
    #[prost(uint32, optional, tag="1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="2")]
    pub caseid: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientTextMsg {
    #[prost(uint32, optional, tag="1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="3")]
    pub payload: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcTextMsg {
    #[prost(uint32, optional, tag="1")]
    pub id: ::core::option::Option<u32>,
    #[prost(bytes="bytes", repeated, tag="2")]
    pub args: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchEndRunRewardDrops {
    #[prost(message, optional, tag="3")]
    pub serverinfo: ::core::option::Option<CMsgGccStrike15V2MatchmakingServerReservationResponse>,
    #[prost(message, optional, tag="4")]
    pub match_end_quest_data: ::core::option::Option<CMsgGcServerQuestUpdateData>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CEconItemPreviewDataBlock {
    #[prost(uint32, optional, tag="1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="2")]
    pub itemid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub defindex: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub paintindex: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub rarity: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub quality: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub paintwear: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub paintseed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="9")]
    pub killeaterscoretype: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="10")]
    pub killeatervalue: ::core::option::Option<u32>,
    #[prost(string, optional, tag="11")]
    pub customname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="12")]
    pub stickers: ::prost::alloc::vec::Vec<c_econ_item_preview_data_block::Sticker>,
    #[prost(uint32, optional, tag="13")]
    pub inventory: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="14")]
    pub origin: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="15")]
    pub questid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="16")]
    pub dropreason: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="17")]
    pub musicindex: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="18")]
    pub entindex: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="19")]
    pub petindex: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="20")]
    pub keychains: ::prost::alloc::vec::Vec<c_econ_item_preview_data_block::Sticker>,
}
/// Nested message and enum types in `CEconItemPreviewDataBlock`.
pub mod c_econ_item_preview_data_block {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Sticker {
        #[prost(uint32, optional, tag="1")]
        pub slot: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub sticker_id: ::core::option::Option<u32>,
        #[prost(float, optional, tag="3")]
        pub wear: ::core::option::Option<f32>,
        #[prost(float, optional, tag="4")]
        pub scale: ::core::option::Option<f32>,
        #[prost(float, optional, tag="5")]
        pub rotation: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag="6")]
        pub tint_id: ::core::option::Option<u32>,
        #[prost(float, optional, tag="7")]
        pub offset_x: ::core::option::Option<f32>,
        #[prost(float, optional, tag="8")]
        pub offset_y: ::core::option::Option<f32>,
        #[prost(float, optional, tag="9")]
        pub offset_z: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag="10")]
        pub pattern: ::core::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchEndRewardDropsNotification {
    #[prost(message, optional, tag="6")]
    pub iteminfo: ::core::option::Option<CEconItemPreviewDataBlock>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgItemAcknowledged {
    #[prost(message, optional, tag="1")]
    pub iteminfo: ::core::option::Option<CEconItemPreviewDataBlock>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcEconPreviewDataBlockRequest {
    #[prost(uint64, optional, tag="1")]
    pub param_s: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="2")]
    pub param_a: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="3")]
    pub param_d: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="4")]
    pub param_m: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcEconPreviewDataBlockResponse {
    #[prost(message, optional, tag="1")]
    pub iteminfo: ::core::option::Option<CEconItemPreviewDataBlock>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListRequestCurrentLiveGames {
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListRequestLiveGameForUser {
    #[prost(uint32, optional, tag="1")]
    pub accountid: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListRequestRecentUserGames {
    #[prost(uint32, optional, tag="1")]
    pub accountid: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListRequestTournamentGames {
    #[prost(int32, optional, tag="1")]
    pub eventid: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListRequestFullGameInfo {
    #[prost(uint64, optional, tag="1")]
    pub matchid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="2")]
    pub outcomeid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub token: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2MatchInfo {
    #[prost(uint64, optional, tag="1")]
    pub matchid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="2")]
    pub matchtime: ::core::option::Option<u32>,
    #[prost(message, optional, tag="3")]
    pub watchablematchinfo: ::core::option::Option<WatchableMatchInfo>,
    #[prost(message, optional, tag="4")]
    pub roundstats_legacy: ::core::option::Option<CMsgGccStrike15V2MatchmakingServerRoundStats>,
    #[prost(message, repeated, tag="5")]
    pub roundstatsall: ::prost::alloc::vec::Vec<CMsgGccStrike15V2MatchmakingServerRoundStats>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2TournamentGroupTeam {
    #[prost(int32, optional, tag="1")]
    pub team_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub score: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="3")]
    pub correctpick: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2TournamentGroup {
    #[prost(uint32, optional, tag="1")]
    pub groupid: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub desc: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="4")]
    pub picks_deprecated: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="5")]
    pub teams: ::prost::alloc::vec::Vec<CDataGccStrike15V2TournamentGroupTeam>,
    #[prost(int32, repeated, packed="false", tag="6")]
    pub stage_ids: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, optional, tag="7")]
    pub picklockuntiltime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub pickableteams: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="9")]
    pub points_per_pick: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="10")]
    pub picks: ::prost::alloc::vec::Vec<c_data_gcc_strike15_v2_tournament_group::Picks>,
}
/// Nested message and enum types in `CDataGCCStrike15_v2_TournamentGroup`.
pub mod c_data_gcc_strike15_v2_tournament_group {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Picks {
        #[prost(int32, repeated, packed="false", tag="1")]
        pub pickids: ::prost::alloc::vec::Vec<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2TournamentSection {
    #[prost(uint32, optional, tag="1")]
    pub sectionid: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub desc: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="4")]
    pub groups: ::prost::alloc::vec::Vec<CDataGccStrike15V2TournamentGroup>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CDataGccStrike15V2TournamentInfo {
    #[prost(message, repeated, tag="1")]
    pub sections: ::prost::alloc::vec::Vec<CDataGccStrike15V2TournamentSection>,
    #[prost(message, optional, tag="2")]
    pub tournament_event: ::core::option::Option<TournamentEvent>,
    #[prost(message, repeated, tag="3")]
    pub tournament_teams: ::prost::alloc::vec::Vec<TournamentTeam>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchList {
    #[prost(uint32, optional, tag="1")]
    pub msgrequestid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub servertime: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="4")]
    pub matches: ::prost::alloc::vec::Vec<CDataGccStrike15V2MatchInfo>,
    #[prost(message, repeated, tag="5")]
    pub streams: ::prost::alloc::vec::Vec<TournamentTeam>,
    #[prost(message, optional, tag="6")]
    pub tournamentinfo: ::core::option::Option<CDataGccStrike15V2TournamentInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchListTournamentOperatorMgmt {
    #[prost(int32, optional, tag="1")]
    pub eventid: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="2")]
    pub matches: ::prost::alloc::vec::Vec<CDataGccStrike15V2MatchInfo>,
    #[prost(uint32, optional, tag="3")]
    pub accountid: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Predictions {
    #[prost(uint32, optional, tag="1")]
    pub event_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="2")]
    pub group_match_team_picks: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_predictions::GroupMatchTeamPick>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_Predictions`.
pub mod c_msg_gcc_strike15_v2_predictions {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GroupMatchTeamPick {
        #[prost(int32, optional, tag="1")]
        pub sectionid: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub groupid: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="4")]
        pub teamid: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag="5")]
        pub itemid: ::core::option::Option<u64>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Fantasy {
    #[prost(uint32, optional, tag="1")]
    pub event_id: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="2")]
    pub teams: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_fantasy::FantasyTeam>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_Fantasy`.
pub mod c_msg_gcc_strike15_v2_fantasy {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FantasySlot {
        #[prost(int32, optional, tag="1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub pick: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag="3")]
        pub itemid: ::core::option::Option<u64>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FantasyTeam {
        #[prost(int32, optional, tag="1")]
        pub sectionid: ::core::option::Option<i32>,
        #[prost(message, repeated, tag="2")]
        pub slots: ::prost::alloc::vec::Vec<FantasySlot>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CAttributeString {
    #[prost(string, optional, tag="1")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgLegacySource1ClientWelcome {
    #[prost(uint32, optional, tag="1")]
    pub version: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub game_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(message, repeated, tag="3")]
    pub outofdate_subscribed_caches: ::prost::alloc::vec::Vec<CMsgSoCacheSubscribed>,
    #[prost(message, repeated, tag="4")]
    pub uptodate_subscribed_caches: ::prost::alloc::vec::Vec<CMsgSoCacheSubscriptionCheck>,
    #[prost(message, optional, tag="5")]
    pub location: ::core::option::Option<c_msg_legacy_source1_client_welcome::Location>,
    #[prost(bytes="bytes", optional, tag="6")]
    pub game_data2: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag="7")]
    pub rtime32_gc_welcome_timestamp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub currency: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="9")]
    pub balance: ::core::option::Option<u32>,
    #[prost(string, optional, tag="10")]
    pub balance_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="11")]
    pub txn_country_code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CMsgLegacySource1ClientWelcome`.
pub mod c_msg_legacy_source1_client_welcome {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Location {
        #[prost(float, optional, tag="1")]
        pub latitude: ::core::option::Option<f32>,
        #[prost(float, optional, tag="2")]
        pub longitude: ::core::option::Option<f32>,
        #[prost(string, optional, tag="3")]
        pub country: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgCStrike15Welcome {
    #[prost(uint32, optional, tag="5")]
    pub store_item_hash: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub timeplayedconsecutively: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="10")]
    pub time_first_played: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="12")]
    pub last_time_played: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="13")]
    pub last_ip_address: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="18")]
    pub gscookieid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="19")]
    pub uniqueid: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientVarValueNotificationInfo {
    #[prost(string, optional, tag="1")]
    pub value_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="2")]
    pub value_int: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="3")]
    pub server_addr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub server_port: ::core::option::Option<u32>,
    #[prost(string, repeated, tag="5")]
    pub choked_blocks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ServerVarValueNotificationInfo {
    #[prost(uint32, optional, tag="1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed="false", tag="2")]
    pub viewangles: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag="3")]
    pub r#type: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed="false", tag="4")]
    pub userdata: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2GiftsLeaderboardRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2GiftsLeaderboardResponse {
    #[prost(uint32, optional, tag="1")]
    pub servertime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub time_period_seconds: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub total_gifts_given: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub total_givers: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="5")]
    pub entries: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_gifts_leaderboard_response::GiftLeaderboardEntry>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_GiftsLeaderboardResponse`.
pub mod c_msg_gcc_strike15_v2_gifts_leaderboard_response {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct GiftLeaderboardEntry {
        #[prost(uint32, optional, tag="1")]
        pub accountid: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub gifts: ::core::option::Option<u32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientSubmitSurveyVote {
    #[prost(uint32, optional, tag="1")]
    pub survey_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub vote: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Server2GcClientValidate {
    #[prost(uint32, optional, tag="1")]
    pub accountid: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientTournamentInfo {
    #[prost(uint32, optional, tag="1")]
    pub eventid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub stageid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub game_type: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed="false", tag="4")]
    pub teamids: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsoEconCoupon {
    #[prost(uint32, optional, tag="1")]
    pub entryid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub defidx: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag="3")]
    pub expiration_date: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsoAccountItemPersonalStore {
    #[prost(uint32, optional, tag="1")]
    pub generation_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub redeemable_balance: ::core::option::Option<u32>,
    #[prost(uint64, repeated, packed="false", tag="3")]
    pub items: ::prost::alloc::vec::Vec<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsoAccountXpShop {
    #[prost(uint32, optional, tag="1")]
    pub generation_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub redeemable_balance: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed="false", tag="3")]
    pub xp_tracks: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsoAccountKeychainRemoveToolCharges {
    #[prost(uint32, optional, tag="1")]
    pub charges: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsoQuestProgress {
    #[prost(uint32, optional, tag="1")]
    pub questid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub points_remaining: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub bonus_points: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsoAccountSeasonalOperation {
    #[prost(uint32, optional, tag="1")]
    pub season_value: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub tier_unlocked: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub premium_tiers: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub mission_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub missions_completed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub redeemable_balance: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub season_pass_time: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsoAccountRecurringSubscription {
    #[prost(uint32, optional, tag="1")]
    pub time_next_cycle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub time_initiated: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsoPersonaDataPublic {
    #[prost(int32, optional, tag="1")]
    pub player_level: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub commendation: ::core::option::Option<PlayerCommendationInfo>,
    #[prost(bool, optional, tag="3")]
    pub elevated_state: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag="4")]
    pub xp_trail_timestamp_refresh: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub xp_trail_level: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientNotifyXpShop {
    #[prost(message, optional, tag="1")]
    pub prematch: ::core::option::Option<CsoAccountXpShop>,
    #[prost(message, optional, tag="2")]
    pub postmatch: ::core::option::Option<CsoAccountXpShop>,
    #[prost(uint32, optional, tag="3")]
    pub current_xp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub current_level: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcAckXpShopTracks {
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2MatchmakingGc2ClientSearchStats {
    #[prost(uint32, optional, tag="1")]
    pub gs_location_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub data_center_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub num_locked_in: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub num_found_nearby: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub note_level: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcGlobalGameSubscribe {
    #[prost(uint64, optional, tag="1")]
    pub ticket: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcGlobalGameUnsubscribe {
    #[prost(int32, optional, tag="1")]
    pub timeleft: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGcGlobalGamePlay {
    #[prost(uint64, optional, tag="1")]
    pub ticket: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="2")]
    pub gametimems: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub msperpoint: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2AcknowledgePenalty {
    #[prost(int32, optional, tag="1")]
    pub acknowledged: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcRequestPrestigeCoin {
    #[prost(uint32, optional, tag="1")]
    pub defindex: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="2")]
    pub upgradeid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub hours: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub prestigetime: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Client2GcStreamUnlock {
    #[prost(uint64, optional, tag="1")]
    pub ticket: ::core::option::Option<u64>,
    #[prost(int32, optional, tag="2")]
    pub os: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientToGcRequestElevate {
    #[prost(uint32, optional, tag="1")]
    pub stage: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientToGcChat {
    #[prost(uint64, optional, tag="1")]
    pub match_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag="2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2GcToClientChat {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientAuthKeyCode {
    #[prost(uint32, optional, tag="1")]
    pub eventid: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15GotvSyncPacket {
    #[prost(message, optional, tag="1")]
    pub data: ::core::option::Option<CEngineGotvSyncPacket>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlayerDecalDigitalSignature {
    #[prost(bytes="bytes", optional, tag="1")]
    pub signature: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag="2")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub rtime: ::core::option::Option<u32>,
    #[prost(float, repeated, packed="false", tag="4")]
    pub endpos: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, packed="false", tag="5")]
    pub startpos: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, packed="false", tag="6")]
    pub left: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, optional, tag="7")]
    pub tx_defidx: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="8")]
    pub entindex: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="9")]
    pub hitbox: ::core::option::Option<u32>,
    #[prost(float, optional, tag="10")]
    pub creationtime: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag="11")]
    pub equipslot: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="12")]
    pub trace_id: ::core::option::Option<u32>,
    #[prost(float, repeated, packed="false", tag="13")]
    pub normal: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, optional, tag="14")]
    pub tint_id: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientPlayerDecalSign {
    #[prost(message, optional, tag="1")]
    pub data: ::core::option::Option<PlayerDecalDigitalSignature>,
    #[prost(uint64, optional, tag="2")]
    pub itemid: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2BetaEnrollment {
    #[prost(uint32, optional, tag="1")]
    pub eresult: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientLogonFatalError {
    #[prost(uint32, optional, tag="1")]
    pub errorcode: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub country: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientPollState {
    #[prost(uint32, optional, tag="1")]
    pub pollid: ::core::option::Option<u32>,
    #[prost(string, repeated, tag="2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, repeated, packed="false", tag="3")]
    pub values: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PartyRegister {
    #[prost(uint32, optional, tag="1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub ver: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub apr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub ark: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub nby: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub grp: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub slots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub launcher: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="9")]
    pub game_type: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PartySearch {
    #[prost(uint32, optional, tag="1")]
    pub ver: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub apr: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub ark: ::core::option::Option<u32>,
    #[prost(uint32, repeated, packed="false", tag="4")]
    pub grps: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag="5")]
    pub launcher: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub game_type: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PartySearchResults {
    #[prost(message, repeated, tag="1")]
    pub entries: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_party_search_results::Entry>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_Party_SearchResults`.
pub mod c_msg_gcc_strike15_v2_party_search_results {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(uint32, optional, tag="1")]
        pub id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub grp: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="3")]
        pub game_type: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="4")]
        pub apr: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="5")]
        pub ark: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="6")]
        pub loc: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="7")]
        pub accountid: ::core::option::Option<u32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2PartyInvite {
    #[prost(uint32, optional, tag="1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub lobbyid: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2AccountRequestCoPlays {
    #[prost(message, repeated, tag="1")]
    pub players: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_account_request_co_plays::Player>,
    #[prost(uint32, optional, tag="2")]
    pub servertime: ::core::option::Option<u32>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_Account_RequestCoPlays`.
pub mod c_msg_gcc_strike15_v2_account_request_co_plays {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Player {
        #[prost(uint32, optional, tag="1")]
        pub accountid: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub rtcoplay: ::core::option::Option<u32>,
        #[prost(bool, optional, tag="3")]
        pub online: ::core::option::Option<bool>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientToGcRequestTicket {
    #[prost(fixed64, optional, tag="1")]
    pub authorized_steam_id: ::core::option::Option<u64>,
    #[prost(fixed32, optional, tag="2")]
    pub authorized_public_ip: ::core::option::Option<u32>,
    #[prost(fixed64, optional, tag="3")]
    pub gameserver_steam_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag="5")]
    pub gameserver_sdr_routing: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGcToClientSteamDatagramTicket {
    #[prost(bytes="bytes", optional, tag="16")]
    pub serialized_ticket: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestOffers {
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientRequestSouvenir {
    #[prost(uint64, optional, tag="1")]
    pub itemid: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="2")]
    pub matchid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag="3")]
    pub eventid: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientAccountBalance {
    #[prost(uint64, optional, tag="1")]
    pub amount: ::core::option::Option<u64>,
    #[prost(string, optional, tag="2")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientPartyJoinRelay {
    #[prost(uint32, optional, tag="1")]
    pub accountid: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="2")]
    pub lobbyid: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientPartyWarning {
    #[prost(message, repeated, tag="1")]
    pub entries: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_client_party_warning::Entry>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_ClientPartyWarning`.
pub mod c_msg_gcc_strike15_v2_client_party_warning {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(uint32, optional, tag="1")]
        pub accountid: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub warntype: ::core::option::Option<u32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2SetEventFavorite {
    #[prost(uint64, optional, tag="1")]
    pub eventid: ::core::option::Option<u64>,
    #[prost(bool, optional, tag="2")]
    pub is_favorite: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2GetEventFavoritesRequest {
    #[prost(bool, optional, tag="1")]
    pub all_events: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2GetEventFavoritesResponse {
    #[prost(bool, optional, tag="1")]
    pub all_events: ::core::option::Option<bool>,
    #[prost(string, optional, tag="2")]
    pub json_favorites: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub json_featured: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientPerfReport {
    #[prost(message, repeated, tag="1")]
    pub entries: ::prost::alloc::vec::Vec<c_msg_gcc_strike15_v2_client_perf_report::Entry>,
}
/// Nested message and enum types in `CMsgGCCStrike15_v2_ClientPerfReport`.
pub mod c_msg_gcc_strike15_v2_client_perf_report {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(uint32, optional, tag="1")]
        pub perfcounter: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub length: ::core::option::Option<u32>,
        #[prost(bytes="bytes", optional, tag="3")]
        pub reference: ::core::option::Option<::prost::bytes::Bytes>,
        #[prost(bytes="bytes", optional, tag="4")]
        pub actual: ::core::option::Option<::prost::bytes::Bytes>,
        #[prost(uint32, optional, tag="5")]
        pub sourceid: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="6")]
        pub status: ::core::option::Option<u32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CvDiagnostic {
    #[prost(uint32, optional, tag="1")]
    pub id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub extended: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="3")]
    pub value: ::core::option::Option<u64>,
    #[prost(string, optional, tag="4")]
    pub string_value: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2ClientReportValidation {
    #[prost(string, optional, tag="1")]
    pub file_report: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub command_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="3")]
    pub total_files: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub internal_error: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub trust_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub count_pending: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub count_completed: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub process_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="9")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="10")]
    pub clientreportversion: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="11")]
    pub status_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="12")]
    pub diagnostic1: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="13")]
    pub diagnostic2: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="14")]
    pub diagnostic3: ::core::option::Option<u64>,
    #[prost(string, optional, tag="15")]
    pub last_launch_data: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="16")]
    pub report_count: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="17")]
    pub client_time: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="18")]
    pub diagnostic4: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="19")]
    pub diagnostic5: ::core::option::Option<u64>,
    #[prost(message, repeated, tag="20")]
    pub diagnostics: ::prost::alloc::vec::Vec<CvDiagnostic>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientRefuseSecureMode {
    #[prost(string, optional, tag="1")]
    pub file_report: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="2")]
    pub offer_insecure_mode: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="3")]
    pub offer_secure_mode: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="4")]
    pub show_unsigned_ui: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="5")]
    pub kick_user: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="6")]
    pub show_trusted_ui: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="7")]
    pub show_warning_not_trusted: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="8")]
    pub show_warning_not_trusted_2: ::core::option::Option<bool>,
    #[prost(string, optional, tag="9")]
    pub files_prevented_trusted: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientRequestValidation {
    #[prost(bool, optional, tag="1")]
    pub full_report: ::core::option::Option<bool>,
    #[prost(string, optional, tag="2")]
    pub module: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientInitSystem {
    #[prost(bool, optional, tag="1")]
    pub load: ::core::option::Option<bool>,
    #[prost(string, optional, tag="2")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub outputname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="bytes", optional, tag="4")]
    pub key_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bytes="bytes", optional, tag="5")]
    pub sha_hash: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(int32, optional, tag="6")]
    pub cookie: ::core::option::Option<i32>,
    #[prost(string, optional, tag="7")]
    pub manifest: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="bytes", optional, tag="8")]
    pub system_package: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bool, optional, tag="9")]
    pub load_system: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2Gc2ClientInitSystemResponse {
    #[prost(bool, optional, tag="1")]
    pub success: ::core::option::Option<bool>,
    #[prost(string, optional, tag="2")]
    pub diagnostic: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="bytes", optional, tag="3")]
    pub sha_hash: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(int32, optional, tag="4")]
    pub response: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub error_code1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub error_code2: ::core::option::Option<i32>,
    #[prost(int64, optional, tag="7")]
    pub handle: ::core::option::Option<i64>,
    #[prost(enumeration="EInitSystemResult", optional, tag="8", default="KEInitSystemResultInvalid")]
    pub einit_result: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="9")]
    pub aux_system1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="10")]
    pub aux_system2: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgGccStrike15V2SetPlayerLeaderboardSafeName {
    #[prost(string, optional, tag="1")]
    pub leaderboard_safe_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ECsgoGcMsg {
    KEMsgGccStrike15V2Base = 9100,
    KEMsgGccStrike15V2MatchmakingStart = 9101,
    KEMsgGccStrike15V2MatchmakingStop = 9102,
    KEMsgGccStrike15V2MatchmakingClient2ServerPing = 9103,
    KEMsgGccStrike15V2MatchmakingGc2ClientUpdate = 9104,
    KEMsgGccStrike15V2MatchmakingServerReservationResponse = 9106,
    KEMsgGccStrike15V2MatchmakingGc2ClientReserve = 9107,
    KEMsgGccStrike15V2MatchmakingClient2GcHello = 9109,
    KEMsgGccStrike15V2MatchmakingGc2ClientHello = 9110,
    KEMsgGccStrike15V2MatchmakingGc2ClientAbandon = 9112,
    KEMsgGccStrike15V2MatchmakingOperator2GcBlogUpdate = 9117,
    KEMsgGccStrike15V2ServerNotificationForUserPenalty = 9118,
    KEMsgGccStrike15V2ClientReportPlayer = 9119,
    KEMsgGccStrike15V2ClientReportServer = 9120,
    KEMsgGccStrike15V2ClientCommendPlayer = 9121,
    KEMsgGccStrike15V2ClientReportResponse = 9122,
    KEMsgGccStrike15V2ClientCommendPlayerQuery = 9123,
    KEMsgGccStrike15V2ClientCommendPlayerQueryResponse = 9124,
    KEMsgGccStrike15V2WatchInfoUsers = 9126,
    KEMsgGccStrike15V2ClientRequestPlayersProfile = 9127,
    KEMsgGccStrike15V2PlayersProfile = 9128,
    KEMsgGccStrike15V2PlayerOverwatchCaseUpdate = 9131,
    KEMsgGccStrike15V2PlayerOverwatchCaseAssignment = 9132,
    KEMsgGccStrike15V2PlayerOverwatchCaseStatus = 9133,
    KEMsgGccStrike15V2Gc2ClientTextMsg = 9134,
    KEMsgGccStrike15V2Client2GcTextMsg = 9135,
    KEMsgGccStrike15V2MatchEndRunRewardDrops = 9136,
    KEMsgGccStrike15V2MatchEndRewardDropsNotification = 9137,
    KEMsgGccStrike15V2ClientRequestWatchInfoFriends2 = 9138,
    KEMsgGccStrike15V2MatchList = 9139,
    KEMsgGccStrike15V2MatchListRequestCurrentLiveGames = 9140,
    KEMsgGccStrike15V2MatchListRequestRecentUserGames = 9141,
    KEMsgGccStrike15V2Gc2ServerReservationUpdate = 9142,
    KEMsgGccStrike15V2ClientVarValueNotificationInfo = 9144,
    KEMsgGccStrike15V2MatchListRequestTournamentGames = 9146,
    KEMsgGccStrike15V2MatchListRequestFullGameInfo = 9147,
    KEMsgGccStrike15V2GiftsLeaderboardRequest = 9148,
    KEMsgGccStrike15V2GiftsLeaderboardResponse = 9149,
    KEMsgGccStrike15V2ServerVarValueNotificationInfo = 9150,
    KEMsgGccStrike15V2ClientSubmitSurveyVote = 9152,
    KEMsgGccStrike15V2Server2GcClientValidate = 9153,
    KEMsgGccStrike15V2MatchListRequestLiveGameForUser = 9154,
    KEMsgGccStrike15V2Client2GcEconPreviewDataBlockRequest = 9156,
    KEMsgGccStrike15V2Client2GcEconPreviewDataBlockResponse = 9157,
    KEMsgGccStrike15V2AccountPrivacySettings = 9158,
    KEMsgGccStrike15V2SetMyActivityInfo = 9159,
    KEMsgGccStrike15V2MatchListRequestTournamentPredictions = 9160,
    KEMsgGccStrike15V2MatchListUploadTournamentPredictions = 9161,
    KEMsgGccStrike15V2DraftSummary = 9162,
    KEMsgGccStrike15V2ClientRequestJoinFriendData = 9163,
    KEMsgGccStrike15V2ClientRequestJoinServerData = 9164,
    KEMsgGccStrike15V2ClientRequestNewMission = 9165,
    KEMsgGccStrike15V2Gc2ClientTournamentInfo = 9167,
    KEMsgGcGlobalGameSubscribe = 9168,
    KEMsgGcGlobalGameUnsubscribe = 9169,
    KEMsgGcGlobalGamePlay = 9170,
    KEMsgGccStrike15V2AcknowledgePenalty = 9171,
    KEMsgGccStrike15V2Client2GcRequestPrestigeCoin = 9172,
    KEMsgGccStrike15V2Gc2ClientGlobalStats = 9173,
    KEMsgGccStrike15V2Client2GcStreamUnlock = 9174,
    KEMsgGccStrike15V2FantasyRequestClientData = 9175,
    KEMsgGccStrike15V2FantasyUpdateClientData = 9176,
    KEMsgGccStrike15V2GcToClientSteamdatagramTicket = 9177,
    KEMsgGccStrike15V2ClientToGcRequestTicket = 9178,
    KEMsgGccStrike15V2ClientToGcRequestElevate = 9179,
    KEMsgGccStrike15V2GlobalChat = 9180,
    KEMsgGccStrike15V2GlobalChatSubscribe = 9181,
    KEMsgGccStrike15V2GlobalChatUnsubscribe = 9182,
    KEMsgGccStrike15V2ClientAuthKeyCode = 9183,
    KEMsgGccStrike15V2GotvSyncPacket = 9184,
    KEMsgGccStrike15V2ClientPlayerDecalSign = 9185,
    KEMsgGccStrike15V2ClientLogonFatalError = 9187,
    KEMsgGccStrike15V2ClientPollState = 9188,
    KEMsgGccStrike15V2PartyRegister = 9189,
    KEMsgGccStrike15V2PartyUnregister = 9190,
    KEMsgGccStrike15V2PartySearch = 9191,
    KEMsgGccStrike15V2PartyInvite = 9192,
    KEMsgGccStrike15V2AccountRequestCoPlays = 9193,
    KEMsgGccStrike15V2ClientGcRankUpdate = 9194,
    KEMsgGccStrike15V2ClientRequestOffers = 9195,
    KEMsgGccStrike15V2ClientAccountBalance = 9196,
    KEMsgGccStrike15V2ClientPartyJoinRelay = 9197,
    KEMsgGccStrike15V2ClientPartyWarning = 9198,
    KEMsgGccStrike15V2SetEventFavorite = 9200,
    KEMsgGccStrike15V2GetEventFavoritesRequest = 9201,
    KEMsgGccStrike15V2ClientPerfReport = 9202,
    KEMsgGccStrike15V2GetEventFavoritesResponse = 9203,
    KEMsgGccStrike15V2ClientRequestSouvenir = 9204,
    KEMsgGccStrike15V2ClientReportValidation = 9205,
    KEMsgGccStrike15V2Gc2ClientRefuseSecureMode = 9206,
    KEMsgGccStrike15V2Gc2ClientRequestValidation = 9207,
    KEMsgGccStrike15V2ClientRedeemMissionReward = 9209,
    KEMsgGccStrike15ClientDeepStats = 9210,
    KEMsgGccStrike15StartAgreementSessionInGame = 9211,
    KEMsgGccStrike15V2Gc2ClientInitSystem = 9212,
    KEMsgGccStrike15V2Gc2ClientInitSystemResponse = 9213,
    KEMsgGccStrike15V2PrivateQueues = 9214,
    KEMsgGccStrike15V2MatchListTournamentOperatorMgmt = 9215,
    KEMsgGccStrike15V2BetaEnrollment = 9217,
    KEMsgGccStrike15V2SetPlayerLeaderboardSafeName = 9218,
    KEMsgGccStrike15V2ClientRedeemFreeReward = 9219,
    KEMsgGccStrike15V2ClientNetworkConfig = 9220,
    KEMsgGccStrike15V2Gc2ClientNotifyXpShop = 9221,
    KEMsgGccStrike15V2Client2GcAckXpShopTracks = 9222,
    KEMsgGccStrike15V2MatchmakingGc2ClientSearchStats = 9223,
    KEMsgGccStrike15V2PremierSeasonSummary = 9224,
}
impl ECsgoGcMsg {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::KEMsgGccStrike15V2Base => "k_EMsgGCCStrike15_v2_Base",
            Self::KEMsgGccStrike15V2MatchmakingStart => "k_EMsgGCCStrike15_v2_MatchmakingStart",
            Self::KEMsgGccStrike15V2MatchmakingStop => "k_EMsgGCCStrike15_v2_MatchmakingStop",
            Self::KEMsgGccStrike15V2MatchmakingClient2ServerPing => "k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing",
            Self::KEMsgGccStrike15V2MatchmakingGc2ClientUpdate => "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate",
            Self::KEMsgGccStrike15V2MatchmakingServerReservationResponse => "k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse",
            Self::KEMsgGccStrike15V2MatchmakingGc2ClientReserve => "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve",
            Self::KEMsgGccStrike15V2MatchmakingClient2GcHello => "k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello",
            Self::KEMsgGccStrike15V2MatchmakingGc2ClientHello => "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello",
            Self::KEMsgGccStrike15V2MatchmakingGc2ClientAbandon => "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon",
            Self::KEMsgGccStrike15V2MatchmakingOperator2GcBlogUpdate => "k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate",
            Self::KEMsgGccStrike15V2ServerNotificationForUserPenalty => "k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty",
            Self::KEMsgGccStrike15V2ClientReportPlayer => "k_EMsgGCCStrike15_v2_ClientReportPlayer",
            Self::KEMsgGccStrike15V2ClientReportServer => "k_EMsgGCCStrike15_v2_ClientReportServer",
            Self::KEMsgGccStrike15V2ClientCommendPlayer => "k_EMsgGCCStrike15_v2_ClientCommendPlayer",
            Self::KEMsgGccStrike15V2ClientReportResponse => "k_EMsgGCCStrike15_v2_ClientReportResponse",
            Self::KEMsgGccStrike15V2ClientCommendPlayerQuery => "k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery",
            Self::KEMsgGccStrike15V2ClientCommendPlayerQueryResponse => "k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse",
            Self::KEMsgGccStrike15V2WatchInfoUsers => "k_EMsgGCCStrike15_v2_WatchInfoUsers",
            Self::KEMsgGccStrike15V2ClientRequestPlayersProfile => "k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile",
            Self::KEMsgGccStrike15V2PlayersProfile => "k_EMsgGCCStrike15_v2_PlayersProfile",
            Self::KEMsgGccStrike15V2PlayerOverwatchCaseUpdate => "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate",
            Self::KEMsgGccStrike15V2PlayerOverwatchCaseAssignment => "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment",
            Self::KEMsgGccStrike15V2PlayerOverwatchCaseStatus => "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus",
            Self::KEMsgGccStrike15V2Gc2ClientTextMsg => "k_EMsgGCCStrike15_v2_GC2ClientTextMsg",
            Self::KEMsgGccStrike15V2Client2GcTextMsg => "k_EMsgGCCStrike15_v2_Client2GCTextMsg",
            Self::KEMsgGccStrike15V2MatchEndRunRewardDrops => "k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops",
            Self::KEMsgGccStrike15V2MatchEndRewardDropsNotification => "k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification",
            Self::KEMsgGccStrike15V2ClientRequestWatchInfoFriends2 => "k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2",
            Self::KEMsgGccStrike15V2MatchList => "k_EMsgGCCStrike15_v2_MatchList",
            Self::KEMsgGccStrike15V2MatchListRequestCurrentLiveGames => "k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames",
            Self::KEMsgGccStrike15V2MatchListRequestRecentUserGames => "k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames",
            Self::KEMsgGccStrike15V2Gc2ServerReservationUpdate => "k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate",
            Self::KEMsgGccStrike15V2ClientVarValueNotificationInfo => "k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo",
            Self::KEMsgGccStrike15V2MatchListRequestTournamentGames => "k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames",
            Self::KEMsgGccStrike15V2MatchListRequestFullGameInfo => "k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo",
            Self::KEMsgGccStrike15V2GiftsLeaderboardRequest => "k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest",
            Self::KEMsgGccStrike15V2GiftsLeaderboardResponse => "k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse",
            Self::KEMsgGccStrike15V2ServerVarValueNotificationInfo => "k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo",
            Self::KEMsgGccStrike15V2ClientSubmitSurveyVote => "k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote",
            Self::KEMsgGccStrike15V2Server2GcClientValidate => "k_EMsgGCCStrike15_v2_Server2GCClientValidate",
            Self::KEMsgGccStrike15V2MatchListRequestLiveGameForUser => "k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser",
            Self::KEMsgGccStrike15V2Client2GcEconPreviewDataBlockRequest => "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest",
            Self::KEMsgGccStrike15V2Client2GcEconPreviewDataBlockResponse => "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse",
            Self::KEMsgGccStrike15V2AccountPrivacySettings => "k_EMsgGCCStrike15_v2_AccountPrivacySettings",
            Self::KEMsgGccStrike15V2SetMyActivityInfo => "k_EMsgGCCStrike15_v2_SetMyActivityInfo",
            Self::KEMsgGccStrike15V2MatchListRequestTournamentPredictions => "k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions",
            Self::KEMsgGccStrike15V2MatchListUploadTournamentPredictions => "k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions",
            Self::KEMsgGccStrike15V2DraftSummary => "k_EMsgGCCStrike15_v2_DraftSummary",
            Self::KEMsgGccStrike15V2ClientRequestJoinFriendData => "k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData",
            Self::KEMsgGccStrike15V2ClientRequestJoinServerData => "k_EMsgGCCStrike15_v2_ClientRequestJoinServerData",
            Self::KEMsgGccStrike15V2ClientRequestNewMission => "k_EMsgGCCStrike15_v2_ClientRequestNewMission",
            Self::KEMsgGccStrike15V2Gc2ClientTournamentInfo => "k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo",
            Self::KEMsgGcGlobalGameSubscribe => "k_EMsgGC_GlobalGame_Subscribe",
            Self::KEMsgGcGlobalGameUnsubscribe => "k_EMsgGC_GlobalGame_Unsubscribe",
            Self::KEMsgGcGlobalGamePlay => "k_EMsgGC_GlobalGame_Play",
            Self::KEMsgGccStrike15V2AcknowledgePenalty => "k_EMsgGCCStrike15_v2_AcknowledgePenalty",
            Self::KEMsgGccStrike15V2Client2GcRequestPrestigeCoin => "k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin",
            Self::KEMsgGccStrike15V2Gc2ClientGlobalStats => "k_EMsgGCCStrike15_v2_GC2ClientGlobalStats",
            Self::KEMsgGccStrike15V2Client2GcStreamUnlock => "k_EMsgGCCStrike15_v2_Client2GCStreamUnlock",
            Self::KEMsgGccStrike15V2FantasyRequestClientData => "k_EMsgGCCStrike15_v2_FantasyRequestClientData",
            Self::KEMsgGccStrike15V2FantasyUpdateClientData => "k_EMsgGCCStrike15_v2_FantasyUpdateClientData",
            Self::KEMsgGccStrike15V2GcToClientSteamdatagramTicket => "k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket",
            Self::KEMsgGccStrike15V2ClientToGcRequestTicket => "k_EMsgGCCStrike15_v2_ClientToGCRequestTicket",
            Self::KEMsgGccStrike15V2ClientToGcRequestElevate => "k_EMsgGCCStrike15_v2_ClientToGCRequestElevate",
            Self::KEMsgGccStrike15V2GlobalChat => "k_EMsgGCCStrike15_v2_GlobalChat",
            Self::KEMsgGccStrike15V2GlobalChatSubscribe => "k_EMsgGCCStrike15_v2_GlobalChat_Subscribe",
            Self::KEMsgGccStrike15V2GlobalChatUnsubscribe => "k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe",
            Self::KEMsgGccStrike15V2ClientAuthKeyCode => "k_EMsgGCCStrike15_v2_ClientAuthKeyCode",
            Self::KEMsgGccStrike15V2GotvSyncPacket => "k_EMsgGCCStrike15_v2_GotvSyncPacket",
            Self::KEMsgGccStrike15V2ClientPlayerDecalSign => "k_EMsgGCCStrike15_v2_ClientPlayerDecalSign",
            Self::KEMsgGccStrike15V2ClientLogonFatalError => "k_EMsgGCCStrike15_v2_ClientLogonFatalError",
            Self::KEMsgGccStrike15V2ClientPollState => "k_EMsgGCCStrike15_v2_ClientPollState",
            Self::KEMsgGccStrike15V2PartyRegister => "k_EMsgGCCStrike15_v2_Party_Register",
            Self::KEMsgGccStrike15V2PartyUnregister => "k_EMsgGCCStrike15_v2_Party_Unregister",
            Self::KEMsgGccStrike15V2PartySearch => "k_EMsgGCCStrike15_v2_Party_Search",
            Self::KEMsgGccStrike15V2PartyInvite => "k_EMsgGCCStrike15_v2_Party_Invite",
            Self::KEMsgGccStrike15V2AccountRequestCoPlays => "k_EMsgGCCStrike15_v2_Account_RequestCoPlays",
            Self::KEMsgGccStrike15V2ClientGcRankUpdate => "k_EMsgGCCStrike15_v2_ClientGCRankUpdate",
            Self::KEMsgGccStrike15V2ClientRequestOffers => "k_EMsgGCCStrike15_v2_ClientRequestOffers",
            Self::KEMsgGccStrike15V2ClientAccountBalance => "k_EMsgGCCStrike15_v2_ClientAccountBalance",
            Self::KEMsgGccStrike15V2ClientPartyJoinRelay => "k_EMsgGCCStrike15_v2_ClientPartyJoinRelay",
            Self::KEMsgGccStrike15V2ClientPartyWarning => "k_EMsgGCCStrike15_v2_ClientPartyWarning",
            Self::KEMsgGccStrike15V2SetEventFavorite => "k_EMsgGCCStrike15_v2_SetEventFavorite",
            Self::KEMsgGccStrike15V2GetEventFavoritesRequest => "k_EMsgGCCStrike15_v2_GetEventFavorites_Request",
            Self::KEMsgGccStrike15V2ClientPerfReport => "k_EMsgGCCStrike15_v2_ClientPerfReport",
            Self::KEMsgGccStrike15V2GetEventFavoritesResponse => "k_EMsgGCCStrike15_v2_GetEventFavorites_Response",
            Self::KEMsgGccStrike15V2ClientRequestSouvenir => "k_EMsgGCCStrike15_v2_ClientRequestSouvenir",
            Self::KEMsgGccStrike15V2ClientReportValidation => "k_EMsgGCCStrike15_v2_ClientReportValidation",
            Self::KEMsgGccStrike15V2Gc2ClientRefuseSecureMode => "k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode",
            Self::KEMsgGccStrike15V2Gc2ClientRequestValidation => "k_EMsgGCCStrike15_v2_GC2ClientRequestValidation",
            Self::KEMsgGccStrike15V2ClientRedeemMissionReward => "k_EMsgGCCStrike15_v2_ClientRedeemMissionReward",
            Self::KEMsgGccStrike15ClientDeepStats => "k_EMsgGCCStrike15_ClientDeepStats",
            Self::KEMsgGccStrike15StartAgreementSessionInGame => "k_EMsgGCCStrike15_StartAgreementSessionInGame",
            Self::KEMsgGccStrike15V2Gc2ClientInitSystem => "k_EMsgGCCStrike15_v2_GC2ClientInitSystem",
            Self::KEMsgGccStrike15V2Gc2ClientInitSystemResponse => "k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response",
            Self::KEMsgGccStrike15V2PrivateQueues => "k_EMsgGCCStrike15_v2_PrivateQueues",
            Self::KEMsgGccStrike15V2MatchListTournamentOperatorMgmt => "k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt",
            Self::KEMsgGccStrike15V2BetaEnrollment => "k_EMsgGCCStrike15_v2_BetaEnrollment",
            Self::KEMsgGccStrike15V2SetPlayerLeaderboardSafeName => "k_EMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName",
            Self::KEMsgGccStrike15V2ClientRedeemFreeReward => "k_EMsgGCCStrike15_v2_ClientRedeemFreeReward",
            Self::KEMsgGccStrike15V2ClientNetworkConfig => "k_EMsgGCCStrike15_v2_ClientNetworkConfig",
            Self::KEMsgGccStrike15V2Gc2ClientNotifyXpShop => "k_EMsgGCCStrike15_v2_GC2ClientNotifyXPShop",
            Self::KEMsgGccStrike15V2Client2GcAckXpShopTracks => "k_EMsgGCCStrike15_v2_Client2GcAckXPShopTracks",
            Self::KEMsgGccStrike15V2MatchmakingGc2ClientSearchStats => "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientSearchStats",
            Self::KEMsgGccStrike15V2PremierSeasonSummary => "k_EMsgGCCStrike15_v2_PremierSeasonSummary",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EMsgGCCStrike15_v2_Base" => Some(Self::KEMsgGccStrike15V2Base),
            "k_EMsgGCCStrike15_v2_MatchmakingStart" => Some(Self::KEMsgGccStrike15V2MatchmakingStart),
            "k_EMsgGCCStrike15_v2_MatchmakingStop" => Some(Self::KEMsgGccStrike15V2MatchmakingStop),
            "k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing" => Some(Self::KEMsgGccStrike15V2MatchmakingClient2ServerPing),
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate" => Some(Self::KEMsgGccStrike15V2MatchmakingGc2ClientUpdate),
            "k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse" => Some(Self::KEMsgGccStrike15V2MatchmakingServerReservationResponse),
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve" => Some(Self::KEMsgGccStrike15V2MatchmakingGc2ClientReserve),
            "k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello" => Some(Self::KEMsgGccStrike15V2MatchmakingClient2GcHello),
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello" => Some(Self::KEMsgGccStrike15V2MatchmakingGc2ClientHello),
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon" => Some(Self::KEMsgGccStrike15V2MatchmakingGc2ClientAbandon),
            "k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate" => Some(Self::KEMsgGccStrike15V2MatchmakingOperator2GcBlogUpdate),
            "k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty" => Some(Self::KEMsgGccStrike15V2ServerNotificationForUserPenalty),
            "k_EMsgGCCStrike15_v2_ClientReportPlayer" => Some(Self::KEMsgGccStrike15V2ClientReportPlayer),
            "k_EMsgGCCStrike15_v2_ClientReportServer" => Some(Self::KEMsgGccStrike15V2ClientReportServer),
            "k_EMsgGCCStrike15_v2_ClientCommendPlayer" => Some(Self::KEMsgGccStrike15V2ClientCommendPlayer),
            "k_EMsgGCCStrike15_v2_ClientReportResponse" => Some(Self::KEMsgGccStrike15V2ClientReportResponse),
            "k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery" => Some(Self::KEMsgGccStrike15V2ClientCommendPlayerQuery),
            "k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse" => Some(Self::KEMsgGccStrike15V2ClientCommendPlayerQueryResponse),
            "k_EMsgGCCStrike15_v2_WatchInfoUsers" => Some(Self::KEMsgGccStrike15V2WatchInfoUsers),
            "k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile" => Some(Self::KEMsgGccStrike15V2ClientRequestPlayersProfile),
            "k_EMsgGCCStrike15_v2_PlayersProfile" => Some(Self::KEMsgGccStrike15V2PlayersProfile),
            "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate" => Some(Self::KEMsgGccStrike15V2PlayerOverwatchCaseUpdate),
            "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment" => Some(Self::KEMsgGccStrike15V2PlayerOverwatchCaseAssignment),
            "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus" => Some(Self::KEMsgGccStrike15V2PlayerOverwatchCaseStatus),
            "k_EMsgGCCStrike15_v2_GC2ClientTextMsg" => Some(Self::KEMsgGccStrike15V2Gc2ClientTextMsg),
            "k_EMsgGCCStrike15_v2_Client2GCTextMsg" => Some(Self::KEMsgGccStrike15V2Client2GcTextMsg),
            "k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops" => Some(Self::KEMsgGccStrike15V2MatchEndRunRewardDrops),
            "k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification" => Some(Self::KEMsgGccStrike15V2MatchEndRewardDropsNotification),
            "k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2" => Some(Self::KEMsgGccStrike15V2ClientRequestWatchInfoFriends2),
            "k_EMsgGCCStrike15_v2_MatchList" => Some(Self::KEMsgGccStrike15V2MatchList),
            "k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames" => Some(Self::KEMsgGccStrike15V2MatchListRequestCurrentLiveGames),
            "k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames" => Some(Self::KEMsgGccStrike15V2MatchListRequestRecentUserGames),
            "k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate" => Some(Self::KEMsgGccStrike15V2Gc2ServerReservationUpdate),
            "k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo" => Some(Self::KEMsgGccStrike15V2ClientVarValueNotificationInfo),
            "k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames" => Some(Self::KEMsgGccStrike15V2MatchListRequestTournamentGames),
            "k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo" => Some(Self::KEMsgGccStrike15V2MatchListRequestFullGameInfo),
            "k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest" => Some(Self::KEMsgGccStrike15V2GiftsLeaderboardRequest),
            "k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse" => Some(Self::KEMsgGccStrike15V2GiftsLeaderboardResponse),
            "k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo" => Some(Self::KEMsgGccStrike15V2ServerVarValueNotificationInfo),
            "k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote" => Some(Self::KEMsgGccStrike15V2ClientSubmitSurveyVote),
            "k_EMsgGCCStrike15_v2_Server2GCClientValidate" => Some(Self::KEMsgGccStrike15V2Server2GcClientValidate),
            "k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser" => Some(Self::KEMsgGccStrike15V2MatchListRequestLiveGameForUser),
            "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest" => Some(Self::KEMsgGccStrike15V2Client2GcEconPreviewDataBlockRequest),
            "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse" => Some(Self::KEMsgGccStrike15V2Client2GcEconPreviewDataBlockResponse),
            "k_EMsgGCCStrike15_v2_AccountPrivacySettings" => Some(Self::KEMsgGccStrike15V2AccountPrivacySettings),
            "k_EMsgGCCStrike15_v2_SetMyActivityInfo" => Some(Self::KEMsgGccStrike15V2SetMyActivityInfo),
            "k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions" => Some(Self::KEMsgGccStrike15V2MatchListRequestTournamentPredictions),
            "k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions" => Some(Self::KEMsgGccStrike15V2MatchListUploadTournamentPredictions),
            "k_EMsgGCCStrike15_v2_DraftSummary" => Some(Self::KEMsgGccStrike15V2DraftSummary),
            "k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData" => Some(Self::KEMsgGccStrike15V2ClientRequestJoinFriendData),
            "k_EMsgGCCStrike15_v2_ClientRequestJoinServerData" => Some(Self::KEMsgGccStrike15V2ClientRequestJoinServerData),
            "k_EMsgGCCStrike15_v2_ClientRequestNewMission" => Some(Self::KEMsgGccStrike15V2ClientRequestNewMission),
            "k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo" => Some(Self::KEMsgGccStrike15V2Gc2ClientTournamentInfo),
            "k_EMsgGC_GlobalGame_Subscribe" => Some(Self::KEMsgGcGlobalGameSubscribe),
            "k_EMsgGC_GlobalGame_Unsubscribe" => Some(Self::KEMsgGcGlobalGameUnsubscribe),
            "k_EMsgGC_GlobalGame_Play" => Some(Self::KEMsgGcGlobalGamePlay),
            "k_EMsgGCCStrike15_v2_AcknowledgePenalty" => Some(Self::KEMsgGccStrike15V2AcknowledgePenalty),
            "k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin" => Some(Self::KEMsgGccStrike15V2Client2GcRequestPrestigeCoin),
            "k_EMsgGCCStrike15_v2_GC2ClientGlobalStats" => Some(Self::KEMsgGccStrike15V2Gc2ClientGlobalStats),
            "k_EMsgGCCStrike15_v2_Client2GCStreamUnlock" => Some(Self::KEMsgGccStrike15V2Client2GcStreamUnlock),
            "k_EMsgGCCStrike15_v2_FantasyRequestClientData" => Some(Self::KEMsgGccStrike15V2FantasyRequestClientData),
            "k_EMsgGCCStrike15_v2_FantasyUpdateClientData" => Some(Self::KEMsgGccStrike15V2FantasyUpdateClientData),
            "k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket" => Some(Self::KEMsgGccStrike15V2GcToClientSteamdatagramTicket),
            "k_EMsgGCCStrike15_v2_ClientToGCRequestTicket" => Some(Self::KEMsgGccStrike15V2ClientToGcRequestTicket),
            "k_EMsgGCCStrike15_v2_ClientToGCRequestElevate" => Some(Self::KEMsgGccStrike15V2ClientToGcRequestElevate),
            "k_EMsgGCCStrike15_v2_GlobalChat" => Some(Self::KEMsgGccStrike15V2GlobalChat),
            "k_EMsgGCCStrike15_v2_GlobalChat_Subscribe" => Some(Self::KEMsgGccStrike15V2GlobalChatSubscribe),
            "k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe" => Some(Self::KEMsgGccStrike15V2GlobalChatUnsubscribe),
            "k_EMsgGCCStrike15_v2_ClientAuthKeyCode" => Some(Self::KEMsgGccStrike15V2ClientAuthKeyCode),
            "k_EMsgGCCStrike15_v2_GotvSyncPacket" => Some(Self::KEMsgGccStrike15V2GotvSyncPacket),
            "k_EMsgGCCStrike15_v2_ClientPlayerDecalSign" => Some(Self::KEMsgGccStrike15V2ClientPlayerDecalSign),
            "k_EMsgGCCStrike15_v2_ClientLogonFatalError" => Some(Self::KEMsgGccStrike15V2ClientLogonFatalError),
            "k_EMsgGCCStrike15_v2_ClientPollState" => Some(Self::KEMsgGccStrike15V2ClientPollState),
            "k_EMsgGCCStrike15_v2_Party_Register" => Some(Self::KEMsgGccStrike15V2PartyRegister),
            "k_EMsgGCCStrike15_v2_Party_Unregister" => Some(Self::KEMsgGccStrike15V2PartyUnregister),
            "k_EMsgGCCStrike15_v2_Party_Search" => Some(Self::KEMsgGccStrike15V2PartySearch),
            "k_EMsgGCCStrike15_v2_Party_Invite" => Some(Self::KEMsgGccStrike15V2PartyInvite),
            "k_EMsgGCCStrike15_v2_Account_RequestCoPlays" => Some(Self::KEMsgGccStrike15V2AccountRequestCoPlays),
            "k_EMsgGCCStrike15_v2_ClientGCRankUpdate" => Some(Self::KEMsgGccStrike15V2ClientGcRankUpdate),
            "k_EMsgGCCStrike15_v2_ClientRequestOffers" => Some(Self::KEMsgGccStrike15V2ClientRequestOffers),
            "k_EMsgGCCStrike15_v2_ClientAccountBalance" => Some(Self::KEMsgGccStrike15V2ClientAccountBalance),
            "k_EMsgGCCStrike15_v2_ClientPartyJoinRelay" => Some(Self::KEMsgGccStrike15V2ClientPartyJoinRelay),
            "k_EMsgGCCStrike15_v2_ClientPartyWarning" => Some(Self::KEMsgGccStrike15V2ClientPartyWarning),
            "k_EMsgGCCStrike15_v2_SetEventFavorite" => Some(Self::KEMsgGccStrike15V2SetEventFavorite),
            "k_EMsgGCCStrike15_v2_GetEventFavorites_Request" => Some(Self::KEMsgGccStrike15V2GetEventFavoritesRequest),
            "k_EMsgGCCStrike15_v2_ClientPerfReport" => Some(Self::KEMsgGccStrike15V2ClientPerfReport),
            "k_EMsgGCCStrike15_v2_GetEventFavorites_Response" => Some(Self::KEMsgGccStrike15V2GetEventFavoritesResponse),
            "k_EMsgGCCStrike15_v2_ClientRequestSouvenir" => Some(Self::KEMsgGccStrike15V2ClientRequestSouvenir),
            "k_EMsgGCCStrike15_v2_ClientReportValidation" => Some(Self::KEMsgGccStrike15V2ClientReportValidation),
            "k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode" => Some(Self::KEMsgGccStrike15V2Gc2ClientRefuseSecureMode),
            "k_EMsgGCCStrike15_v2_GC2ClientRequestValidation" => Some(Self::KEMsgGccStrike15V2Gc2ClientRequestValidation),
            "k_EMsgGCCStrike15_v2_ClientRedeemMissionReward" => Some(Self::KEMsgGccStrike15V2ClientRedeemMissionReward),
            "k_EMsgGCCStrike15_ClientDeepStats" => Some(Self::KEMsgGccStrike15ClientDeepStats),
            "k_EMsgGCCStrike15_StartAgreementSessionInGame" => Some(Self::KEMsgGccStrike15StartAgreementSessionInGame),
            "k_EMsgGCCStrike15_v2_GC2ClientInitSystem" => Some(Self::KEMsgGccStrike15V2Gc2ClientInitSystem),
            "k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response" => Some(Self::KEMsgGccStrike15V2Gc2ClientInitSystemResponse),
            "k_EMsgGCCStrike15_v2_PrivateQueues" => Some(Self::KEMsgGccStrike15V2PrivateQueues),
            "k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt" => Some(Self::KEMsgGccStrike15V2MatchListTournamentOperatorMgmt),
            "k_EMsgGCCStrike15_v2_BetaEnrollment" => Some(Self::KEMsgGccStrike15V2BetaEnrollment),
            "k_EMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName" => Some(Self::KEMsgGccStrike15V2SetPlayerLeaderboardSafeName),
            "k_EMsgGCCStrike15_v2_ClientRedeemFreeReward" => Some(Self::KEMsgGccStrike15V2ClientRedeemFreeReward),
            "k_EMsgGCCStrike15_v2_ClientNetworkConfig" => Some(Self::KEMsgGccStrike15V2ClientNetworkConfig),
            "k_EMsgGCCStrike15_v2_GC2ClientNotifyXPShop" => Some(Self::KEMsgGccStrike15V2Gc2ClientNotifyXpShop),
            "k_EMsgGCCStrike15_v2_Client2GcAckXPShopTracks" => Some(Self::KEMsgGccStrike15V2Client2GcAckXpShopTracks),
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientSearchStats" => Some(Self::KEMsgGccStrike15V2MatchmakingGc2ClientSearchStats),
            "k_EMsgGCCStrike15_v2_PremierSeasonSummary" => Some(Self::KEMsgGccStrike15V2PremierSeasonSummary),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ECsgoSteamUserStat {
    KECsgoSteamUserStatXpEarnedGames = 1,
    KECsgoSteamUserStatMatchWinsCompetitive = 2,
    KECsgoSteamUserStatSurvivedDangerZone = 3,
}
impl ECsgoSteamUserStat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::KECsgoSteamUserStatXpEarnedGames => "k_ECsgoSteamUserStat_XpEarnedGames",
            Self::KECsgoSteamUserStatMatchWinsCompetitive => "k_ECsgoSteamUserStat_MatchWinsCompetitive",
            Self::KECsgoSteamUserStatSurvivedDangerZone => "k_ECsgoSteamUserStat_SurvivedDangerZone",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ECsgoSteamUserStat_XpEarnedGames" => Some(Self::KECsgoSteamUserStatXpEarnedGames),
            "k_ECsgoSteamUserStat_MatchWinsCompetitive" => Some(Self::KECsgoSteamUserStatMatchWinsCompetitive),
            "k_ECsgoSteamUserStat_SurvivedDangerZone" => Some(Self::KECsgoSteamUserStatSurvivedDangerZone),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EClientReportingVersion {
    KEClientReportingVersionOldVersion = 0,
    KEClientReportingVersionBetaVersion = 1,
    KEClientReportingVersionSupportsTrustedMode = 2,
}
impl EClientReportingVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::KEClientReportingVersionOldVersion => "k_EClientReportingVersion_OldVersion",
            Self::KEClientReportingVersionBetaVersion => "k_EClientReportingVersion_BetaVersion",
            Self::KEClientReportingVersionSupportsTrustedMode => "k_EClientReportingVersion_SupportsTrustedMode",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EClientReportingVersion_OldVersion" => Some(Self::KEClientReportingVersionOldVersion),
            "k_EClientReportingVersion_BetaVersion" => Some(Self::KEClientReportingVersionBetaVersion),
            "k_EClientReportingVersion_SupportsTrustedMode" => Some(Self::KEClientReportingVersionSupportsTrustedMode),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EInitSystemResult {
    KEInitSystemResultInvalid = 0,
    KEInitSystemResultSuccess = 1,
    KEInitSystemResultNone = 2,
    KEInitSystemResultNotFound = 3,
    KEInitSystemResultExisting = 4,
    KEInitSystemResultFailedOpen = 5,
    KEInitSystemResultMismatch = 6,
    KEInitSystemResultFailedInit = 7,
    KEInitSystemResultMax = 8,
}
impl EInitSystemResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::KEInitSystemResultInvalid => "k_EInitSystemResult_Invalid",
            Self::KEInitSystemResultSuccess => "k_EInitSystemResult_Success",
            Self::KEInitSystemResultNone => "k_EInitSystemResult_None",
            Self::KEInitSystemResultNotFound => "k_EInitSystemResult_NotFound",
            Self::KEInitSystemResultExisting => "k_EInitSystemResult_Existing",
            Self::KEInitSystemResultFailedOpen => "k_EInitSystemResult_FailedOpen",
            Self::KEInitSystemResultMismatch => "k_EInitSystemResult_Mismatch",
            Self::KEInitSystemResultFailedInit => "k_EInitSystemResult_FailedInit",
            Self::KEInitSystemResultMax => "k_EInitSystemResult_Max",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_EInitSystemResult_Invalid" => Some(Self::KEInitSystemResultInvalid),
            "k_EInitSystemResult_Success" => Some(Self::KEInitSystemResultSuccess),
            "k_EInitSystemResult_None" => Some(Self::KEInitSystemResultNone),
            "k_EInitSystemResult_NotFound" => Some(Self::KEInitSystemResultNotFound),
            "k_EInitSystemResult_Existing" => Some(Self::KEInitSystemResultExisting),
            "k_EInitSystemResult_FailedOpen" => Some(Self::KEInitSystemResultFailedOpen),
            "k_EInitSystemResult_Mismatch" => Some(Self::KEInitSystemResultMismatch),
            "k_EInitSystemResult_FailedInit" => Some(Self::KEInitSystemResultFailedInit),
            "k_EInitSystemResult_Max" => Some(Self::KEInitSystemResultMax),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ENetworkDisconnectionReason {
    NetworkDisconnectInvalid = 0,
    NetworkDisconnectShutdown = 1,
    NetworkDisconnectDisconnectByUser = 2,
    NetworkDisconnectDisconnectByServer = 3,
    NetworkDisconnectLost = 4,
    NetworkDisconnectOverflow = 5,
    NetworkDisconnectSteamBanned = 6,
    NetworkDisconnectSteamInuse = 7,
    NetworkDisconnectSteamTicket = 8,
    NetworkDisconnectSteamLogon = 9,
    NetworkDisconnectSteamAuthcancelled = 10,
    NetworkDisconnectSteamAuthalreadyused = 11,
    NetworkDisconnectSteamAuthinvalid = 12,
    NetworkDisconnectSteamVacbanstate = 13,
    NetworkDisconnectSteamLoggedInElsewhere = 14,
    NetworkDisconnectSteamVacCheckTimedout = 15,
    NetworkDisconnectSteamDropped = 16,
    NetworkDisconnectSteamOwnership = 17,
    NetworkDisconnectServerinfoOverflow = 18,
    NetworkDisconnectTickmsgOverflow = 19,
    NetworkDisconnectStringtablemsgOverflow = 20,
    NetworkDisconnectDeltaentmsgOverflow = 21,
    NetworkDisconnectTempentmsgOverflow = 22,
    NetworkDisconnectSoundsmsgOverflow = 23,
    NetworkDisconnectSnapshotoverflow = 24,
    NetworkDisconnectSnapshoterror = 25,
    NetworkDisconnectReliableoverflow = 26,
    NetworkDisconnectBaddeltatick = 27,
    NetworkDisconnectNomoresplits = 28,
    NetworkDisconnectTimedout = 29,
    NetworkDisconnectDisconnected = 30,
    NetworkDisconnectLeavingsplit = 31,
    NetworkDisconnectDifferentclasstables = 32,
    NetworkDisconnectBadrelaypassword = 33,
    NetworkDisconnectBadspectatorpassword = 34,
    NetworkDisconnectHltvrestricted = 35,
    NetworkDisconnectNospectators = 36,
    NetworkDisconnectHltvunavailable = 37,
    NetworkDisconnectHltvstop = 38,
    NetworkDisconnectKicked = 39,
    NetworkDisconnectBanadded = 40,
    NetworkDisconnectKickbanadded = 41,
    NetworkDisconnectHltvdirect = 42,
    NetworkDisconnectPureserverClientextra = 43,
    NetworkDisconnectPureserverMismatch = 44,
    NetworkDisconnectUsercmd = 45,
    NetworkDisconnectRejectedByGame = 46,
    NetworkDisconnectMessageParseError = 47,
    NetworkDisconnectInvalidMessageError = 48,
    NetworkDisconnectBadServerPassword = 49,
    NetworkDisconnectDirectConnectReservation = 50,
    NetworkDisconnectConnectionFailure = 51,
    NetworkDisconnectNoPeerGroupHandlers = 52,
    NetworkDisconnectReconnection = 53,
    NetworkDisconnectLoopshutdown = 54,
    NetworkDisconnectLoopdeactivate = 55,
    NetworkDisconnectHostEndgame = 56,
    NetworkDisconnectLoopLevelloadActivate = 57,
    NetworkDisconnectCreateServerFailed = 58,
    NetworkDisconnectExiting = 59,
    NetworkDisconnectRequestHoststateIdle = 60,
    NetworkDisconnectRequestHoststateHltvrelay = 61,
    NetworkDisconnectClientConsistencyFail = 62,
    NetworkDisconnectClientUnableToCrcMap = 63,
    NetworkDisconnectClientNoMap = 64,
    NetworkDisconnectClientDifferentMap = 65,
    NetworkDisconnectServerRequiresSteam = 66,
    NetworkDisconnectSteamDenyMisc = 67,
    NetworkDisconnectSteamDenyBadAntiCheat = 68,
    NetworkDisconnectServerShutdown = 69,
    NetworkDisconnectReplayIncompatible = 71,
    NetworkDisconnectConnectRequestTimedout = 72,
    NetworkDisconnectServerIncompatible = 73,
    NetworkDisconnectLocalproblemManyrelays = 74,
    NetworkDisconnectLocalproblemHostedserverprimaryrelay = 75,
    NetworkDisconnectLocalproblemNetworkconfig = 76,
    NetworkDisconnectLocalproblemOther = 77,
    NetworkDisconnectRemoteTimeout = 79,
    NetworkDisconnectRemoteTimeoutConnecting = 80,
    NetworkDisconnectRemoteOther = 81,
    NetworkDisconnectRemoteBadcrypt = 82,
    NetworkDisconnectRemoteCertnottrusted = 83,
    NetworkDisconnectUnusual = 84,
    NetworkDisconnectInternalError = 85,
    NetworkDisconnectRejectBadchallenge = 128,
    NetworkDisconnectRejectNolobby = 129,
    NetworkDisconnectRejectBackgroundMap = 130,
    NetworkDisconnectRejectSinglePlayer = 131,
    NetworkDisconnectRejectHiddenGame = 132,
    NetworkDisconnectRejectLanrestrict = 133,
    NetworkDisconnectRejectBadpassword = 134,
    NetworkDisconnectRejectServerfull = 135,
    NetworkDisconnectRejectInvalidreservation = 136,
    NetworkDisconnectRejectFailedchannel = 137,
    NetworkDisconnectRejectConnectFromLobby = 138,
    NetworkDisconnectRejectReservedForLobby = 139,
    NetworkDisconnectRejectInvalidkeylength = 140,
    NetworkDisconnectRejectOldprotocol = 141,
    NetworkDisconnectRejectNewprotocol = 142,
    NetworkDisconnectRejectInvalidconnection = 143,
    NetworkDisconnectRejectInvalidcertlen = 144,
    NetworkDisconnectRejectInvalidsteamcertlen = 145,
    NetworkDisconnectRejectSteam = 146,
    NetworkDisconnectRejectServerauthdisabled = 147,
    NetworkDisconnectRejectServercdkeyauthinvalid = 148,
    NetworkDisconnectRejectBanned = 149,
    NetworkDisconnectKickedTeamkilling = 150,
    NetworkDisconnectKickedTkStart = 151,
    NetworkDisconnectKickedUntrustedaccount = 152,
    NetworkDisconnectKickedConvictedaccount = 153,
    NetworkDisconnectKickedCompetitivecooldown = 154,
    NetworkDisconnectKickedTeamhurting = 155,
    NetworkDisconnectKickedHostagekilling = 156,
    NetworkDisconnectKickedVotedoff = 157,
    NetworkDisconnectKickedIdle = 158,
    NetworkDisconnectKickedSuicide = 159,
    NetworkDisconnectKickedNosteamlogin = 160,
    NetworkDisconnectKickedNosteamticket = 161,
    NetworkDisconnectKickedInputautomation = 162,
    NetworkDisconnectKickedVacnetabnormalbehavior = 163,
    NetworkDisconnectKickedInsecureclient = 164,
}
impl ENetworkDisconnectionReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NetworkDisconnectInvalid => "NETWORK_DISCONNECT_INVALID",
            Self::NetworkDisconnectShutdown => "NETWORK_DISCONNECT_SHUTDOWN",
            Self::NetworkDisconnectDisconnectByUser => "NETWORK_DISCONNECT_DISCONNECT_BY_USER",
            Self::NetworkDisconnectDisconnectByServer => "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER",
            Self::NetworkDisconnectLost => "NETWORK_DISCONNECT_LOST",
            Self::NetworkDisconnectOverflow => "NETWORK_DISCONNECT_OVERFLOW",
            Self::NetworkDisconnectSteamBanned => "NETWORK_DISCONNECT_STEAM_BANNED",
            Self::NetworkDisconnectSteamInuse => "NETWORK_DISCONNECT_STEAM_INUSE",
            Self::NetworkDisconnectSteamTicket => "NETWORK_DISCONNECT_STEAM_TICKET",
            Self::NetworkDisconnectSteamLogon => "NETWORK_DISCONNECT_STEAM_LOGON",
            Self::NetworkDisconnectSteamAuthcancelled => "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED",
            Self::NetworkDisconnectSteamAuthalreadyused => "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED",
            Self::NetworkDisconnectSteamAuthinvalid => "NETWORK_DISCONNECT_STEAM_AUTHINVALID",
            Self::NetworkDisconnectSteamVacbanstate => "NETWORK_DISCONNECT_STEAM_VACBANSTATE",
            Self::NetworkDisconnectSteamLoggedInElsewhere => "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE",
            Self::NetworkDisconnectSteamVacCheckTimedout => "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT",
            Self::NetworkDisconnectSteamDropped => "NETWORK_DISCONNECT_STEAM_DROPPED",
            Self::NetworkDisconnectSteamOwnership => "NETWORK_DISCONNECT_STEAM_OWNERSHIP",
            Self::NetworkDisconnectServerinfoOverflow => "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW",
            Self::NetworkDisconnectTickmsgOverflow => "NETWORK_DISCONNECT_TICKMSG_OVERFLOW",
            Self::NetworkDisconnectStringtablemsgOverflow => "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW",
            Self::NetworkDisconnectDeltaentmsgOverflow => "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW",
            Self::NetworkDisconnectTempentmsgOverflow => "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW",
            Self::NetworkDisconnectSoundsmsgOverflow => "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW",
            Self::NetworkDisconnectSnapshotoverflow => "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW",
            Self::NetworkDisconnectSnapshoterror => "NETWORK_DISCONNECT_SNAPSHOTERROR",
            Self::NetworkDisconnectReliableoverflow => "NETWORK_DISCONNECT_RELIABLEOVERFLOW",
            Self::NetworkDisconnectBaddeltatick => "NETWORK_DISCONNECT_BADDELTATICK",
            Self::NetworkDisconnectNomoresplits => "NETWORK_DISCONNECT_NOMORESPLITS",
            Self::NetworkDisconnectTimedout => "NETWORK_DISCONNECT_TIMEDOUT",
            Self::NetworkDisconnectDisconnected => "NETWORK_DISCONNECT_DISCONNECTED",
            Self::NetworkDisconnectLeavingsplit => "NETWORK_DISCONNECT_LEAVINGSPLIT",
            Self::NetworkDisconnectDifferentclasstables => "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES",
            Self::NetworkDisconnectBadrelaypassword => "NETWORK_DISCONNECT_BADRELAYPASSWORD",
            Self::NetworkDisconnectBadspectatorpassword => "NETWORK_DISCONNECT_BADSPECTATORPASSWORD",
            Self::NetworkDisconnectHltvrestricted => "NETWORK_DISCONNECT_HLTVRESTRICTED",
            Self::NetworkDisconnectNospectators => "NETWORK_DISCONNECT_NOSPECTATORS",
            Self::NetworkDisconnectHltvunavailable => "NETWORK_DISCONNECT_HLTVUNAVAILABLE",
            Self::NetworkDisconnectHltvstop => "NETWORK_DISCONNECT_HLTVSTOP",
            Self::NetworkDisconnectKicked => "NETWORK_DISCONNECT_KICKED",
            Self::NetworkDisconnectBanadded => "NETWORK_DISCONNECT_BANADDED",
            Self::NetworkDisconnectKickbanadded => "NETWORK_DISCONNECT_KICKBANADDED",
            Self::NetworkDisconnectHltvdirect => "NETWORK_DISCONNECT_HLTVDIRECT",
            Self::NetworkDisconnectPureserverClientextra => "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA",
            Self::NetworkDisconnectPureserverMismatch => "NETWORK_DISCONNECT_PURESERVER_MISMATCH",
            Self::NetworkDisconnectUsercmd => "NETWORK_DISCONNECT_USERCMD",
            Self::NetworkDisconnectRejectedByGame => "NETWORK_DISCONNECT_REJECTED_BY_GAME",
            Self::NetworkDisconnectMessageParseError => "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR",
            Self::NetworkDisconnectInvalidMessageError => "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR",
            Self::NetworkDisconnectBadServerPassword => "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD",
            Self::NetworkDisconnectDirectConnectReservation => "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION",
            Self::NetworkDisconnectConnectionFailure => "NETWORK_DISCONNECT_CONNECTION_FAILURE",
            Self::NetworkDisconnectNoPeerGroupHandlers => "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS",
            Self::NetworkDisconnectReconnection => "NETWORK_DISCONNECT_RECONNECTION",
            Self::NetworkDisconnectLoopshutdown => "NETWORK_DISCONNECT_LOOPSHUTDOWN",
            Self::NetworkDisconnectLoopdeactivate => "NETWORK_DISCONNECT_LOOPDEACTIVATE",
            Self::NetworkDisconnectHostEndgame => "NETWORK_DISCONNECT_HOST_ENDGAME",
            Self::NetworkDisconnectLoopLevelloadActivate => "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE",
            Self::NetworkDisconnectCreateServerFailed => "NETWORK_DISCONNECT_CREATE_SERVER_FAILED",
            Self::NetworkDisconnectExiting => "NETWORK_DISCONNECT_EXITING",
            Self::NetworkDisconnectRequestHoststateIdle => "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE",
            Self::NetworkDisconnectRequestHoststateHltvrelay => "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY",
            Self::NetworkDisconnectClientConsistencyFail => "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL",
            Self::NetworkDisconnectClientUnableToCrcMap => "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP",
            Self::NetworkDisconnectClientNoMap => "NETWORK_DISCONNECT_CLIENT_NO_MAP",
            Self::NetworkDisconnectClientDifferentMap => "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP",
            Self::NetworkDisconnectServerRequiresSteam => "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM",
            Self::NetworkDisconnectSteamDenyMisc => "NETWORK_DISCONNECT_STEAM_DENY_MISC",
            Self::NetworkDisconnectSteamDenyBadAntiCheat => "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT",
            Self::NetworkDisconnectServerShutdown => "NETWORK_DISCONNECT_SERVER_SHUTDOWN",
            Self::NetworkDisconnectReplayIncompatible => "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE",
            Self::NetworkDisconnectConnectRequestTimedout => "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT",
            Self::NetworkDisconnectServerIncompatible => "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE",
            Self::NetworkDisconnectLocalproblemManyrelays => "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS",
            Self::NetworkDisconnectLocalproblemHostedserverprimaryrelay => "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY",
            Self::NetworkDisconnectLocalproblemNetworkconfig => "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG",
            Self::NetworkDisconnectLocalproblemOther => "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER",
            Self::NetworkDisconnectRemoteTimeout => "NETWORK_DISCONNECT_REMOTE_TIMEOUT",
            Self::NetworkDisconnectRemoteTimeoutConnecting => "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING",
            Self::NetworkDisconnectRemoteOther => "NETWORK_DISCONNECT_REMOTE_OTHER",
            Self::NetworkDisconnectRemoteBadcrypt => "NETWORK_DISCONNECT_REMOTE_BADCRYPT",
            Self::NetworkDisconnectRemoteCertnottrusted => "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED",
            Self::NetworkDisconnectUnusual => "NETWORK_DISCONNECT_UNUSUAL",
            Self::NetworkDisconnectInternalError => "NETWORK_DISCONNECT_INTERNAL_ERROR",
            Self::NetworkDisconnectRejectBadchallenge => "NETWORK_DISCONNECT_REJECT_BADCHALLENGE",
            Self::NetworkDisconnectRejectNolobby => "NETWORK_DISCONNECT_REJECT_NOLOBBY",
            Self::NetworkDisconnectRejectBackgroundMap => "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP",
            Self::NetworkDisconnectRejectSinglePlayer => "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER",
            Self::NetworkDisconnectRejectHiddenGame => "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME",
            Self::NetworkDisconnectRejectLanrestrict => "NETWORK_DISCONNECT_REJECT_LANRESTRICT",
            Self::NetworkDisconnectRejectBadpassword => "NETWORK_DISCONNECT_REJECT_BADPASSWORD",
            Self::NetworkDisconnectRejectServerfull => "NETWORK_DISCONNECT_REJECT_SERVERFULL",
            Self::NetworkDisconnectRejectInvalidreservation => "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION",
            Self::NetworkDisconnectRejectFailedchannel => "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL",
            Self::NetworkDisconnectRejectConnectFromLobby => "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY",
            Self::NetworkDisconnectRejectReservedForLobby => "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY",
            Self::NetworkDisconnectRejectInvalidkeylength => "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH",
            Self::NetworkDisconnectRejectOldprotocol => "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL",
            Self::NetworkDisconnectRejectNewprotocol => "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL",
            Self::NetworkDisconnectRejectInvalidconnection => "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION",
            Self::NetworkDisconnectRejectInvalidcertlen => "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN",
            Self::NetworkDisconnectRejectInvalidsteamcertlen => "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN",
            Self::NetworkDisconnectRejectSteam => "NETWORK_DISCONNECT_REJECT_STEAM",
            Self::NetworkDisconnectRejectServerauthdisabled => "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED",
            Self::NetworkDisconnectRejectServercdkeyauthinvalid => "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID",
            Self::NetworkDisconnectRejectBanned => "NETWORK_DISCONNECT_REJECT_BANNED",
            Self::NetworkDisconnectKickedTeamkilling => "NETWORK_DISCONNECT_KICKED_TEAMKILLING",
            Self::NetworkDisconnectKickedTkStart => "NETWORK_DISCONNECT_KICKED_TK_START",
            Self::NetworkDisconnectKickedUntrustedaccount => "NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT",
            Self::NetworkDisconnectKickedConvictedaccount => "NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT",
            Self::NetworkDisconnectKickedCompetitivecooldown => "NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN",
            Self::NetworkDisconnectKickedTeamhurting => "NETWORK_DISCONNECT_KICKED_TEAMHURTING",
            Self::NetworkDisconnectKickedHostagekilling => "NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING",
            Self::NetworkDisconnectKickedVotedoff => "NETWORK_DISCONNECT_KICKED_VOTEDOFF",
            Self::NetworkDisconnectKickedIdle => "NETWORK_DISCONNECT_KICKED_IDLE",
            Self::NetworkDisconnectKickedSuicide => "NETWORK_DISCONNECT_KICKED_SUICIDE",
            Self::NetworkDisconnectKickedNosteamlogin => "NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN",
            Self::NetworkDisconnectKickedNosteamticket => "NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET",
            Self::NetworkDisconnectKickedInputautomation => "NETWORK_DISCONNECT_KICKED_INPUTAUTOMATION",
            Self::NetworkDisconnectKickedVacnetabnormalbehavior => "NETWORK_DISCONNECT_KICKED_VACNETABNORMALBEHAVIOR",
            Self::NetworkDisconnectKickedInsecureclient => "NETWORK_DISCONNECT_KICKED_INSECURECLIENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NETWORK_DISCONNECT_INVALID" => Some(Self::NetworkDisconnectInvalid),
            "NETWORK_DISCONNECT_SHUTDOWN" => Some(Self::NetworkDisconnectShutdown),
            "NETWORK_DISCONNECT_DISCONNECT_BY_USER" => Some(Self::NetworkDisconnectDisconnectByUser),
            "NETWORK_DISCONNECT_DISCONNECT_BY_SERVER" => Some(Self::NetworkDisconnectDisconnectByServer),
            "NETWORK_DISCONNECT_LOST" => Some(Self::NetworkDisconnectLost),
            "NETWORK_DISCONNECT_OVERFLOW" => Some(Self::NetworkDisconnectOverflow),
            "NETWORK_DISCONNECT_STEAM_BANNED" => Some(Self::NetworkDisconnectSteamBanned),
            "NETWORK_DISCONNECT_STEAM_INUSE" => Some(Self::NetworkDisconnectSteamInuse),
            "NETWORK_DISCONNECT_STEAM_TICKET" => Some(Self::NetworkDisconnectSteamTicket),
            "NETWORK_DISCONNECT_STEAM_LOGON" => Some(Self::NetworkDisconnectSteamLogon),
            "NETWORK_DISCONNECT_STEAM_AUTHCANCELLED" => Some(Self::NetworkDisconnectSteamAuthcancelled),
            "NETWORK_DISCONNECT_STEAM_AUTHALREADYUSED" => Some(Self::NetworkDisconnectSteamAuthalreadyused),
            "NETWORK_DISCONNECT_STEAM_AUTHINVALID" => Some(Self::NetworkDisconnectSteamAuthinvalid),
            "NETWORK_DISCONNECT_STEAM_VACBANSTATE" => Some(Self::NetworkDisconnectSteamVacbanstate),
            "NETWORK_DISCONNECT_STEAM_LOGGED_IN_ELSEWHERE" => Some(Self::NetworkDisconnectSteamLoggedInElsewhere),
            "NETWORK_DISCONNECT_STEAM_VAC_CHECK_TIMEDOUT" => Some(Self::NetworkDisconnectSteamVacCheckTimedout),
            "NETWORK_DISCONNECT_STEAM_DROPPED" => Some(Self::NetworkDisconnectSteamDropped),
            "NETWORK_DISCONNECT_STEAM_OWNERSHIP" => Some(Self::NetworkDisconnectSteamOwnership),
            "NETWORK_DISCONNECT_SERVERINFO_OVERFLOW" => Some(Self::NetworkDisconnectServerinfoOverflow),
            "NETWORK_DISCONNECT_TICKMSG_OVERFLOW" => Some(Self::NetworkDisconnectTickmsgOverflow),
            "NETWORK_DISCONNECT_STRINGTABLEMSG_OVERFLOW" => Some(Self::NetworkDisconnectStringtablemsgOverflow),
            "NETWORK_DISCONNECT_DELTAENTMSG_OVERFLOW" => Some(Self::NetworkDisconnectDeltaentmsgOverflow),
            "NETWORK_DISCONNECT_TEMPENTMSG_OVERFLOW" => Some(Self::NetworkDisconnectTempentmsgOverflow),
            "NETWORK_DISCONNECT_SOUNDSMSG_OVERFLOW" => Some(Self::NetworkDisconnectSoundsmsgOverflow),
            "NETWORK_DISCONNECT_SNAPSHOTOVERFLOW" => Some(Self::NetworkDisconnectSnapshotoverflow),
            "NETWORK_DISCONNECT_SNAPSHOTERROR" => Some(Self::NetworkDisconnectSnapshoterror),
            "NETWORK_DISCONNECT_RELIABLEOVERFLOW" => Some(Self::NetworkDisconnectReliableoverflow),
            "NETWORK_DISCONNECT_BADDELTATICK" => Some(Self::NetworkDisconnectBaddeltatick),
            "NETWORK_DISCONNECT_NOMORESPLITS" => Some(Self::NetworkDisconnectNomoresplits),
            "NETWORK_DISCONNECT_TIMEDOUT" => Some(Self::NetworkDisconnectTimedout),
            "NETWORK_DISCONNECT_DISCONNECTED" => Some(Self::NetworkDisconnectDisconnected),
            "NETWORK_DISCONNECT_LEAVINGSPLIT" => Some(Self::NetworkDisconnectLeavingsplit),
            "NETWORK_DISCONNECT_DIFFERENTCLASSTABLES" => Some(Self::NetworkDisconnectDifferentclasstables),
            "NETWORK_DISCONNECT_BADRELAYPASSWORD" => Some(Self::NetworkDisconnectBadrelaypassword),
            "NETWORK_DISCONNECT_BADSPECTATORPASSWORD" => Some(Self::NetworkDisconnectBadspectatorpassword),
            "NETWORK_DISCONNECT_HLTVRESTRICTED" => Some(Self::NetworkDisconnectHltvrestricted),
            "NETWORK_DISCONNECT_NOSPECTATORS" => Some(Self::NetworkDisconnectNospectators),
            "NETWORK_DISCONNECT_HLTVUNAVAILABLE" => Some(Self::NetworkDisconnectHltvunavailable),
            "NETWORK_DISCONNECT_HLTVSTOP" => Some(Self::NetworkDisconnectHltvstop),
            "NETWORK_DISCONNECT_KICKED" => Some(Self::NetworkDisconnectKicked),
            "NETWORK_DISCONNECT_BANADDED" => Some(Self::NetworkDisconnectBanadded),
            "NETWORK_DISCONNECT_KICKBANADDED" => Some(Self::NetworkDisconnectKickbanadded),
            "NETWORK_DISCONNECT_HLTVDIRECT" => Some(Self::NetworkDisconnectHltvdirect),
            "NETWORK_DISCONNECT_PURESERVER_CLIENTEXTRA" => Some(Self::NetworkDisconnectPureserverClientextra),
            "NETWORK_DISCONNECT_PURESERVER_MISMATCH" => Some(Self::NetworkDisconnectPureserverMismatch),
            "NETWORK_DISCONNECT_USERCMD" => Some(Self::NetworkDisconnectUsercmd),
            "NETWORK_DISCONNECT_REJECTED_BY_GAME" => Some(Self::NetworkDisconnectRejectedByGame),
            "NETWORK_DISCONNECT_MESSAGE_PARSE_ERROR" => Some(Self::NetworkDisconnectMessageParseError),
            "NETWORK_DISCONNECT_INVALID_MESSAGE_ERROR" => Some(Self::NetworkDisconnectInvalidMessageError),
            "NETWORK_DISCONNECT_BAD_SERVER_PASSWORD" => Some(Self::NetworkDisconnectBadServerPassword),
            "NETWORK_DISCONNECT_DIRECT_CONNECT_RESERVATION" => Some(Self::NetworkDisconnectDirectConnectReservation),
            "NETWORK_DISCONNECT_CONNECTION_FAILURE" => Some(Self::NetworkDisconnectConnectionFailure),
            "NETWORK_DISCONNECT_NO_PEER_GROUP_HANDLERS" => Some(Self::NetworkDisconnectNoPeerGroupHandlers),
            "NETWORK_DISCONNECT_RECONNECTION" => Some(Self::NetworkDisconnectReconnection),
            "NETWORK_DISCONNECT_LOOPSHUTDOWN" => Some(Self::NetworkDisconnectLoopshutdown),
            "NETWORK_DISCONNECT_LOOPDEACTIVATE" => Some(Self::NetworkDisconnectLoopdeactivate),
            "NETWORK_DISCONNECT_HOST_ENDGAME" => Some(Self::NetworkDisconnectHostEndgame),
            "NETWORK_DISCONNECT_LOOP_LEVELLOAD_ACTIVATE" => Some(Self::NetworkDisconnectLoopLevelloadActivate),
            "NETWORK_DISCONNECT_CREATE_SERVER_FAILED" => Some(Self::NetworkDisconnectCreateServerFailed),
            "NETWORK_DISCONNECT_EXITING" => Some(Self::NetworkDisconnectExiting),
            "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_IDLE" => Some(Self::NetworkDisconnectRequestHoststateIdle),
            "NETWORK_DISCONNECT_REQUEST_HOSTSTATE_HLTVRELAY" => Some(Self::NetworkDisconnectRequestHoststateHltvrelay),
            "NETWORK_DISCONNECT_CLIENT_CONSISTENCY_FAIL" => Some(Self::NetworkDisconnectClientConsistencyFail),
            "NETWORK_DISCONNECT_CLIENT_UNABLE_TO_CRC_MAP" => Some(Self::NetworkDisconnectClientUnableToCrcMap),
            "NETWORK_DISCONNECT_CLIENT_NO_MAP" => Some(Self::NetworkDisconnectClientNoMap),
            "NETWORK_DISCONNECT_CLIENT_DIFFERENT_MAP" => Some(Self::NetworkDisconnectClientDifferentMap),
            "NETWORK_DISCONNECT_SERVER_REQUIRES_STEAM" => Some(Self::NetworkDisconnectServerRequiresSteam),
            "NETWORK_DISCONNECT_STEAM_DENY_MISC" => Some(Self::NetworkDisconnectSteamDenyMisc),
            "NETWORK_DISCONNECT_STEAM_DENY_BAD_ANTI_CHEAT" => Some(Self::NetworkDisconnectSteamDenyBadAntiCheat),
            "NETWORK_DISCONNECT_SERVER_SHUTDOWN" => Some(Self::NetworkDisconnectServerShutdown),
            "NETWORK_DISCONNECT_REPLAY_INCOMPATIBLE" => Some(Self::NetworkDisconnectReplayIncompatible),
            "NETWORK_DISCONNECT_CONNECT_REQUEST_TIMEDOUT" => Some(Self::NetworkDisconnectConnectRequestTimedout),
            "NETWORK_DISCONNECT_SERVER_INCOMPATIBLE" => Some(Self::NetworkDisconnectServerIncompatible),
            "NETWORK_DISCONNECT_LOCALPROBLEM_MANYRELAYS" => Some(Self::NetworkDisconnectLocalproblemManyrelays),
            "NETWORK_DISCONNECT_LOCALPROBLEM_HOSTEDSERVERPRIMARYRELAY" => Some(Self::NetworkDisconnectLocalproblemHostedserverprimaryrelay),
            "NETWORK_DISCONNECT_LOCALPROBLEM_NETWORKCONFIG" => Some(Self::NetworkDisconnectLocalproblemNetworkconfig),
            "NETWORK_DISCONNECT_LOCALPROBLEM_OTHER" => Some(Self::NetworkDisconnectLocalproblemOther),
            "NETWORK_DISCONNECT_REMOTE_TIMEOUT" => Some(Self::NetworkDisconnectRemoteTimeout),
            "NETWORK_DISCONNECT_REMOTE_TIMEOUT_CONNECTING" => Some(Self::NetworkDisconnectRemoteTimeoutConnecting),
            "NETWORK_DISCONNECT_REMOTE_OTHER" => Some(Self::NetworkDisconnectRemoteOther),
            "NETWORK_DISCONNECT_REMOTE_BADCRYPT" => Some(Self::NetworkDisconnectRemoteBadcrypt),
            "NETWORK_DISCONNECT_REMOTE_CERTNOTTRUSTED" => Some(Self::NetworkDisconnectRemoteCertnottrusted),
            "NETWORK_DISCONNECT_UNUSUAL" => Some(Self::NetworkDisconnectUnusual),
            "NETWORK_DISCONNECT_INTERNAL_ERROR" => Some(Self::NetworkDisconnectInternalError),
            "NETWORK_DISCONNECT_REJECT_BADCHALLENGE" => Some(Self::NetworkDisconnectRejectBadchallenge),
            "NETWORK_DISCONNECT_REJECT_NOLOBBY" => Some(Self::NetworkDisconnectRejectNolobby),
            "NETWORK_DISCONNECT_REJECT_BACKGROUND_MAP" => Some(Self::NetworkDisconnectRejectBackgroundMap),
            "NETWORK_DISCONNECT_REJECT_SINGLE_PLAYER" => Some(Self::NetworkDisconnectRejectSinglePlayer),
            "NETWORK_DISCONNECT_REJECT_HIDDEN_GAME" => Some(Self::NetworkDisconnectRejectHiddenGame),
            "NETWORK_DISCONNECT_REJECT_LANRESTRICT" => Some(Self::NetworkDisconnectRejectLanrestrict),
            "NETWORK_DISCONNECT_REJECT_BADPASSWORD" => Some(Self::NetworkDisconnectRejectBadpassword),
            "NETWORK_DISCONNECT_REJECT_SERVERFULL" => Some(Self::NetworkDisconnectRejectServerfull),
            "NETWORK_DISCONNECT_REJECT_INVALIDRESERVATION" => Some(Self::NetworkDisconnectRejectInvalidreservation),
            "NETWORK_DISCONNECT_REJECT_FAILEDCHANNEL" => Some(Self::NetworkDisconnectRejectFailedchannel),
            "NETWORK_DISCONNECT_REJECT_CONNECT_FROM_LOBBY" => Some(Self::NetworkDisconnectRejectConnectFromLobby),
            "NETWORK_DISCONNECT_REJECT_RESERVED_FOR_LOBBY" => Some(Self::NetworkDisconnectRejectReservedForLobby),
            "NETWORK_DISCONNECT_REJECT_INVALIDKEYLENGTH" => Some(Self::NetworkDisconnectRejectInvalidkeylength),
            "NETWORK_DISCONNECT_REJECT_OLDPROTOCOL" => Some(Self::NetworkDisconnectRejectOldprotocol),
            "NETWORK_DISCONNECT_REJECT_NEWPROTOCOL" => Some(Self::NetworkDisconnectRejectNewprotocol),
            "NETWORK_DISCONNECT_REJECT_INVALIDCONNECTION" => Some(Self::NetworkDisconnectRejectInvalidconnection),
            "NETWORK_DISCONNECT_REJECT_INVALIDCERTLEN" => Some(Self::NetworkDisconnectRejectInvalidcertlen),
            "NETWORK_DISCONNECT_REJECT_INVALIDSTEAMCERTLEN" => Some(Self::NetworkDisconnectRejectInvalidsteamcertlen),
            "NETWORK_DISCONNECT_REJECT_STEAM" => Some(Self::NetworkDisconnectRejectSteam),
            "NETWORK_DISCONNECT_REJECT_SERVERAUTHDISABLED" => Some(Self::NetworkDisconnectRejectServerauthdisabled),
            "NETWORK_DISCONNECT_REJECT_SERVERCDKEYAUTHINVALID" => Some(Self::NetworkDisconnectRejectServercdkeyauthinvalid),
            "NETWORK_DISCONNECT_REJECT_BANNED" => Some(Self::NetworkDisconnectRejectBanned),
            "NETWORK_DISCONNECT_KICKED_TEAMKILLING" => Some(Self::NetworkDisconnectKickedTeamkilling),
            "NETWORK_DISCONNECT_KICKED_TK_START" => Some(Self::NetworkDisconnectKickedTkStart),
            "NETWORK_DISCONNECT_KICKED_UNTRUSTEDACCOUNT" => Some(Self::NetworkDisconnectKickedUntrustedaccount),
            "NETWORK_DISCONNECT_KICKED_CONVICTEDACCOUNT" => Some(Self::NetworkDisconnectKickedConvictedaccount),
            "NETWORK_DISCONNECT_KICKED_COMPETITIVECOOLDOWN" => Some(Self::NetworkDisconnectKickedCompetitivecooldown),
            "NETWORK_DISCONNECT_KICKED_TEAMHURTING" => Some(Self::NetworkDisconnectKickedTeamhurting),
            "NETWORK_DISCONNECT_KICKED_HOSTAGEKILLING" => Some(Self::NetworkDisconnectKickedHostagekilling),
            "NETWORK_DISCONNECT_KICKED_VOTEDOFF" => Some(Self::NetworkDisconnectKickedVotedoff),
            "NETWORK_DISCONNECT_KICKED_IDLE" => Some(Self::NetworkDisconnectKickedIdle),
            "NETWORK_DISCONNECT_KICKED_SUICIDE" => Some(Self::NetworkDisconnectKickedSuicide),
            "NETWORK_DISCONNECT_KICKED_NOSTEAMLOGIN" => Some(Self::NetworkDisconnectKickedNosteamlogin),
            "NETWORK_DISCONNECT_KICKED_NOSTEAMTICKET" => Some(Self::NetworkDisconnectKickedNosteamticket),
            "NETWORK_DISCONNECT_KICKED_INPUTAUTOMATION" => Some(Self::NetworkDisconnectKickedInputautomation),
            "NETWORK_DISCONNECT_KICKED_VACNETABNORMALBEHAVIOR" => Some(Self::NetworkDisconnectKickedVacnetabnormalbehavior),
            "NETWORK_DISCONNECT_KICKED_INSECURECLIENT" => Some(Self::NetworkDisconnectKickedInsecureclient),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgVector {
    #[prost(float, optional, tag="1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag="2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub z: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub w: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgVector2D {
    #[prost(float, optional, tag="1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag="2")]
    pub y: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgQAngle {
    #[prost(float, optional, tag="1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag="2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub z: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgQuaternion {
    #[prost(float, optional, tag="1")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag="2")]
    pub y: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub z: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub w: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgTransform {
    #[prost(message, optional, tag="1")]
    pub position: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag="2")]
    pub scale: ::core::option::Option<f32>,
    #[prost(message, optional, tag="3")]
    pub orientation: ::core::option::Option<CMsgQuaternion>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgRgba {
    #[prost(int32, optional, tag="1")]
    pub r: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub g: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub b: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub a: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgPlayerInfo {
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(fixed64, optional, tag="2")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag="3")]
    pub userid: ::core::option::Option<i32>,
    #[prost(fixed64, optional, tag="4")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(bool, optional, tag="5")]
    pub fakeplayer: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="6")]
    pub ishltv: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMsg {
    #[prost(uint32, optional, tag="1", default="16777215")]
    pub target_entity: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgCVars {
    #[prost(message, repeated, tag="1")]
    pub cvars: ::prost::alloc::vec::Vec<c_msg_c_vars::CVar>,
}
/// Nested message and enum types in `CMsg_CVars`.
pub mod c_msg_c_vars {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CVar {
        #[prost(string, optional, tag="1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CnetMsgNop {
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CnetMsgSplitScreenUser {
    #[prost(int32, optional, tag="1")]
    pub slot: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgTick {
    #[prost(uint32, optional, tag="1")]
    pub tick: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub host_computationtime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub host_computationtime_std_deviation: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub legacy_host_loss: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="8")]
    pub host_unfiltered_frametime: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="9")]
    pub hltv_replay_flags: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="10")]
    pub expected_long_tick: ::core::option::Option<u32>,
    #[prost(string, optional, tag="11")]
    pub expected_long_tick_reason: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="12")]
    pub host_frame_dropped_pct_x10: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="13")]
    pub host_frame_irregular_arrival_pct_x10: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgStringCmd {
    #[prost(string, optional, tag="1")]
    pub command: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="2")]
    pub prediction_sync: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgSetConVar {
    #[prost(message, optional, tag="1")]
    pub convars: ::core::option::Option<CMsgCVars>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgSignonState {
    #[prost(enumeration="SignonStateT", optional, tag="1", default="SignonstateNone")]
    pub signon_state: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="2")]
    pub spawn_count: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub num_server_players: ::core::option::Option<u32>,
    #[prost(string, repeated, tag="4")]
    pub players_networkids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="6")]
    pub addons: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgGameEvent {
    #[prost(string, optional, tag="1")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="2")]
    pub eventid: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="3")]
    pub keys: ::prost::alloc::vec::Vec<csvc_msg_game_event::KeyT>,
}
/// Nested message and enum types in `CSVCMsg_GameEvent`.
pub mod csvc_msg_game_event {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag="1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub val_string: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag="3")]
        pub val_float: ::core::option::Option<f32>,
        #[prost(int32, optional, tag="4")]
        pub val_long: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="5")]
        pub val_short: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="6")]
        pub val_byte: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="7")]
        pub val_bool: ::core::option::Option<bool>,
        #[prost(uint64, optional, tag="8")]
        pub val_uint64: ::core::option::Option<u64>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgListGameEvents {
    #[prost(message, repeated, tag="1")]
    pub events: ::prost::alloc::vec::Vec<csvc_msg_list_game_events::EventT>,
}
/// Nested message and enum types in `CSVCMsgList_GameEvents`.
pub mod csvc_msg_list_game_events {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EventT {
        #[prost(int32, optional, tag="1")]
        pub tick: ::core::option::Option<i32>,
        #[prost(message, optional, tag="2")]
        pub event: ::core::option::Option<super::CsvcMsgGameEvent>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgSpawnGroupLoad {
    #[prost(string, optional, tag="1")]
    pub worldname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub entitylumpname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub entityfiltername: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="4")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub spawngroupownerhandle: ::core::option::Option<u32>,
    #[prost(message, optional, tag="6")]
    pub world_offset_pos: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag="7")]
    pub world_offset_angle: ::core::option::Option<CMsgQAngle>,
    #[prost(bytes="bytes", optional, tag="8")]
    pub spawngroupmanifest: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag="9")]
    pub flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="10")]
    pub tickcount: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="11")]
    pub manifestincomplete: ::core::option::Option<bool>,
    #[prost(string, optional, tag="12")]
    pub localnamefixup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="13")]
    pub parentnamefixup: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="14")]
    pub manifestloadpriority: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="15")]
    pub worldgroupid: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="16")]
    pub creationsequence: ::core::option::Option<u32>,
    #[prost(string, optional, tag="17")]
    pub savegamefilename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="18")]
    pub spawngroupparenthandle: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="19")]
    pub leveltransition: ::core::option::Option<bool>,
    #[prost(string, optional, tag="20")]
    pub worldgroupname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgSpawnGroupManifestUpdate {
    #[prost(uint32, optional, tag="1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub spawngroupmanifest: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bool, optional, tag="3")]
    pub manifestincomplete: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CnetMsgSpawnGroupSetCreationTick {
    #[prost(uint32, optional, tag="1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="2")]
    pub tickcount: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="3")]
    pub creationsequence: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CnetMsgSpawnGroupUnload {
    #[prost(uint32, optional, tag="1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub flags: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="3")]
    pub tickcount: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CnetMsgSpawnGroupLoadCompleted {
    #[prost(uint32, optional, tag="1")]
    pub spawngrouphandle: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgGameSessionConfiguration {
    #[prost(bool, optional, tag="1")]
    pub is_multiplayer: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="2")]
    pub is_loadsavegame: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="3")]
    pub is_background_map: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="4")]
    pub is_headless: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag="5")]
    pub min_client_limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub max_client_limit: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub max_clients: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag="8")]
    pub tick_interval: ::core::option::Option<u32>,
    #[prost(string, optional, tag="9")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="10")]
    pub savegamename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="11")]
    pub s1_mapname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="12")]
    pub gamemode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="13")]
    pub server_ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="bytes", optional, tag="14")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bool, optional, tag="15")]
    pub is_localonly: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="19")]
    pub no_steam_server: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="16")]
    pub is_transition: ::core::option::Option<bool>,
    #[prost(string, optional, tag="17")]
    pub previouslevel: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="18")]
    pub landmarkname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CnetMsgDebugOverlay {
    #[prost(int32, optional, tag="1")]
    pub etype: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="2")]
    pub vectors: ::prost::alloc::vec::Vec<CMsgVector>,
    #[prost(message, repeated, tag="3")]
    pub colors: ::prost::alloc::vec::Vec<CMsgRgba>,
    #[prost(float, repeated, packed="false", tag="4")]
    pub dimensions: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, packed="false", tag="5")]
    pub times: ::prost::alloc::vec::Vec<f32>,
    #[prost(bool, repeated, packed="false", tag="6")]
    pub bools: ::prost::alloc::vec::Vec<bool>,
    #[prost(uint64, repeated, packed="false", tag="7")]
    pub uint64s: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, repeated, tag="8")]
    pub strings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignonStateT {
    SignonstateNone = 0,
    SignonstateChallenge = 1,
    SignonstateConnected = 2,
    SignonstateNew = 3,
    SignonstatePrespawn = 4,
    SignonstateSpawn = 5,
    SignonstateFull = 6,
    SignonstateChangelevel = 7,
}
impl SignonStateT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SignonstateNone => "SIGNONSTATE_NONE",
            Self::SignonstateChallenge => "SIGNONSTATE_CHALLENGE",
            Self::SignonstateConnected => "SIGNONSTATE_CONNECTED",
            Self::SignonstateNew => "SIGNONSTATE_NEW",
            Self::SignonstatePrespawn => "SIGNONSTATE_PRESPAWN",
            Self::SignonstateSpawn => "SIGNONSTATE_SPAWN",
            Self::SignonstateFull => "SIGNONSTATE_FULL",
            Self::SignonstateChangelevel => "SIGNONSTATE_CHANGELEVEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNONSTATE_NONE" => Some(Self::SignonstateNone),
            "SIGNONSTATE_CHALLENGE" => Some(Self::SignonstateChallenge),
            "SIGNONSTATE_CONNECTED" => Some(Self::SignonstateConnected),
            "SIGNONSTATE_NEW" => Some(Self::SignonstateNew),
            "SIGNONSTATE_PRESPAWN" => Some(Self::SignonstatePrespawn),
            "SIGNONSTATE_SPAWN" => Some(Self::SignonstateSpawn),
            "SIGNONSTATE_FULL" => Some(Self::SignonstateFull),
            "SIGNONSTATE_CHANGELEVEL" => Some(Self::SignonstateChangelevel),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NetMessages {
    NetNop = 0,
    NetDisconnectLegacy = 1,
    NetSplitScreenUser = 3,
    NetTick = 4,
    NetStringCmd = 5,
    NetSetConVar = 6,
    NetSignonState = 7,
    NetSpawnGroupLoad = 8,
    NetSpawnGroupManifestUpdate = 9,
    NetSpawnGroupSetCreationTick = 11,
    NetSpawnGroupUnload = 12,
    NetSpawnGroupLoadCompleted = 13,
    NetDebugOverlay = 15,
}
impl NetMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NetNop => "net_NOP",
            Self::NetDisconnectLegacy => "net_Disconnect_Legacy",
            Self::NetSplitScreenUser => "net_SplitScreenUser",
            Self::NetTick => "net_Tick",
            Self::NetStringCmd => "net_StringCmd",
            Self::NetSetConVar => "net_SetConVar",
            Self::NetSignonState => "net_SignonState",
            Self::NetSpawnGroupLoad => "net_SpawnGroup_Load",
            Self::NetSpawnGroupManifestUpdate => "net_SpawnGroup_ManifestUpdate",
            Self::NetSpawnGroupSetCreationTick => "net_SpawnGroup_SetCreationTick",
            Self::NetSpawnGroupUnload => "net_SpawnGroup_Unload",
            Self::NetSpawnGroupLoadCompleted => "net_SpawnGroup_LoadCompleted",
            Self::NetDebugOverlay => "net_DebugOverlay",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "net_NOP" => Some(Self::NetNop),
            "net_Disconnect_Legacy" => Some(Self::NetDisconnectLegacy),
            "net_SplitScreenUser" => Some(Self::NetSplitScreenUser),
            "net_Tick" => Some(Self::NetTick),
            "net_StringCmd" => Some(Self::NetStringCmd),
            "net_SetConVar" => Some(Self::NetSetConVar),
            "net_SignonState" => Some(Self::NetSignonState),
            "net_SpawnGroup_Load" => Some(Self::NetSpawnGroupLoad),
            "net_SpawnGroup_ManifestUpdate" => Some(Self::NetSpawnGroupManifestUpdate),
            "net_SpawnGroup_SetCreationTick" => Some(Self::NetSpawnGroupSetCreationTick),
            "net_SpawnGroup_Unload" => Some(Self::NetSpawnGroupUnload),
            "net_SpawnGroup_LoadCompleted" => Some(Self::NetSpawnGroupLoadCompleted),
            "net_DebugOverlay" => Some(Self::NetDebugOverlay),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpawnGroupFlagsT {
    SpawnGroupLoadEntitiesFromSave = 1,
    SpawnGroupDontSpawnEntities = 2,
    SpawnGroupSynchronousSpawn = 4,
    SpawnGroupIsInitialSpawnGroup = 8,
    SpawnGroupCreateClientOnlyEntities = 16,
    SpawnGroupBlockUntilLoaded = 64,
    SpawnGroupLoadStreamingData = 128,
    SpawnGroupCreateNewSceneWorld = 256,
}
impl SpawnGroupFlagsT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SpawnGroupLoadEntitiesFromSave => "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE",
            Self::SpawnGroupDontSpawnEntities => "SPAWN_GROUP_DONT_SPAWN_ENTITIES",
            Self::SpawnGroupSynchronousSpawn => "SPAWN_GROUP_SYNCHRONOUS_SPAWN",
            Self::SpawnGroupIsInitialSpawnGroup => "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP",
            Self::SpawnGroupCreateClientOnlyEntities => "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES",
            Self::SpawnGroupBlockUntilLoaded => "SPAWN_GROUP_BLOCK_UNTIL_LOADED",
            Self::SpawnGroupLoadStreamingData => "SPAWN_GROUP_LOAD_STREAMING_DATA",
            Self::SpawnGroupCreateNewSceneWorld => "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE" => Some(Self::SpawnGroupLoadEntitiesFromSave),
            "SPAWN_GROUP_DONT_SPAWN_ENTITIES" => Some(Self::SpawnGroupDontSpawnEntities),
            "SPAWN_GROUP_SYNCHRONOUS_SPAWN" => Some(Self::SpawnGroupSynchronousSpawn),
            "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP" => Some(Self::SpawnGroupIsInitialSpawnGroup),
            "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES" => Some(Self::SpawnGroupCreateClientOnlyEntities),
            "SPAWN_GROUP_BLOCK_UNTIL_LOADED" => Some(Self::SpawnGroupBlockUntilLoaded),
            "SPAWN_GROUP_LOAD_STREAMING_DATA" => Some(Self::SpawnGroupLoadStreamingData),
            "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD" => Some(Self::SpawnGroupCreateNewSceneWorld),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVguiMenu {
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="2")]
    pub show: ::core::option::Option<bool>,
    #[prost(message, repeated, tag="3")]
    pub keys: ::prost::alloc::vec::Vec<ccs_usr_msg_vgui_menu::Keys>,
}
/// Nested message and enum types in `CCSUsrMsg_VGUIMenu`.
pub mod ccs_usr_msg_vgui_menu {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Keys {
        #[prost(string, optional, tag="1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgGeiger {
    #[prost(int32, optional, tag="1")]
    pub range: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgTrain {
    #[prost(int32, optional, tag="1")]
    pub train: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgHudText {
    #[prost(string, optional, tag="1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgHudMsg {
    #[prost(int32, optional, tag="1")]
    pub channel: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub pos: ::core::option::Option<CMsgVector2D>,
    #[prost(message, optional, tag="3")]
    pub clr1: ::core::option::Option<CMsgRgba>,
    #[prost(message, optional, tag="4")]
    pub clr2: ::core::option::Option<CMsgRgba>,
    #[prost(int32, optional, tag="5")]
    pub effect: ::core::option::Option<i32>,
    #[prost(float, optional, tag="6")]
    pub fade_in_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag="7")]
    pub fade_out_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag="9")]
    pub hold_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag="10")]
    pub fx_time: ::core::option::Option<f32>,
    #[prost(string, optional, tag="11")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgShake {
    #[prost(int32, optional, tag="1")]
    pub command: ::core::option::Option<i32>,
    #[prost(float, optional, tag="2")]
    pub local_amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub duration: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgFade {
    #[prost(int32, optional, tag="1")]
    pub duration: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub hold_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub flags: ::core::option::Option<i32>,
    #[prost(message, optional, tag="4")]
    pub clr: ::core::option::Option<CMsgRgba>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRumble {
    #[prost(int32, optional, tag="1")]
    pub index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub data: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub flags: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCloseCaption {
    #[prost(uint32, optional, tag="1")]
    pub hash: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="2")]
    pub duration: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(string, optional, tag="4")]
    pub cctoken: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCloseCaptionDirect {
    #[prost(uint32, optional, tag="1")]
    pub hash: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="2")]
    pub duration: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="3")]
    pub from_player: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSendAudio {
    #[prost(string, optional, tag="1")]
    pub radio_sound: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRawAudio {
    #[prost(int32, optional, tag="1")]
    pub pitch: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2", default="-1")]
    pub entidx: ::core::option::Option<i32>,
    #[prost(float, optional, tag="3")]
    pub duration: ::core::option::Option<f32>,
    #[prost(string, optional, tag="4")]
    pub voice_filename: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVoiceMask {
    #[prost(message, repeated, tag="1")]
    pub player_masks: ::prost::alloc::vec::Vec<ccs_usr_msg_voice_mask::PlayerMask>,
    #[prost(bool, optional, tag="2")]
    pub player_mod_enable: ::core::option::Option<bool>,
}
/// Nested message and enum types in `CCSUsrMsg_VoiceMask`.
pub mod ccs_usr_msg_voice_mask {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PlayerMask {
        #[prost(int32, optional, tag="1")]
        pub game_rules_mask: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub ban_masks: ::core::option::Option<i32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgDamage {
    #[prost(int32, optional, tag="1")]
    pub amount: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub inflictor_world_pos: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag="3", default="-1")]
    pub victim_entindex: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRadioText {
    #[prost(int32, optional, tag="1")]
    pub msg_dst: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2", default="-1")]
    pub client: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub msg_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag="4")]
    pub params: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgHintText {
    #[prost(string, optional, tag="1")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgKeyHintText {
    #[prost(string, repeated, tag="1")]
    pub messages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgProcessSpottedEntityUpdate {
    #[prost(bool, optional, tag="1")]
    pub new_update: ::core::option::Option<bool>,
    #[prost(message, repeated, tag="2")]
    pub entity_updates: ::prost::alloc::vec::Vec<ccs_usr_msg_process_spotted_entity_update::SpottedEntityUpdate>,
}
/// Nested message and enum types in `CCSUsrMsg_ProcessSpottedEntityUpdate`.
pub mod ccs_usr_msg_process_spotted_entity_update {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SpottedEntityUpdate {
        #[prost(int32, optional, tag="1", default="-1")]
        pub entity_idx: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub class_id: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub origin_x: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="4")]
        pub origin_y: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="5")]
        pub origin_z: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="6")]
        pub angle_y: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="7")]
        pub defuser: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="8")]
        pub player_has_defuser: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="9")]
        pub player_has_c4: ::core::option::Option<bool>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSendPlayerItemDrops {
    #[prost(message, repeated, tag="1")]
    pub entity_updates: ::prost::alloc::vec::Vec<CEconItemPreviewDataBlock>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSendPlayerItemFound {
    #[prost(message, optional, tag="1")]
    pub iteminfo: ::core::option::Option<CEconItemPreviewDataBlock>,
    #[prost(int32, optional, tag="2", default="-1")]
    pub playerslot: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgReloadEffect {
    #[prost(int32, optional, tag="1", default="-1")]
    pub entidx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub actanim: ::core::option::Option<i32>,
    #[prost(float, optional, tag="3")]
    pub origin_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub origin_y: ::core::option::Option<f32>,
    #[prost(float, optional, tag="5")]
    pub origin_z: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgWeaponSound {
    #[prost(int32, optional, tag="1", default="-1")]
    pub entidx: ::core::option::Option<i32>,
    #[prost(float, optional, tag="2")]
    pub origin_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub origin_y: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub origin_z: ::core::option::Option<f32>,
    #[prost(string, optional, tag="5")]
    pub sound: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag="6")]
    pub game_timestamp: ::core::option::Option<f32>,
    #[prost(fixed32, optional, tag="7")]
    pub source_soundscapeid: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgUpdateScreenHealthBar {
    #[prost(int32, optional, tag="1", default="-1")]
    pub entidx: ::core::option::Option<i32>,
    #[prost(float, optional, tag="2")]
    pub healthratio_old: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub healthratio_new: ::core::option::Option<f32>,
    #[prost(int32, optional, tag="4")]
    pub style: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgEntityOutlineHighlight {
    #[prost(int32, optional, tag="1", default="-1")]
    pub entidx: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="2")]
    pub removehighlight: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgAdjustMoney {
    #[prost(int32, optional, tag="1")]
    pub amount: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgReportHit {
    #[prost(float, optional, tag="1")]
    pub pos_x: ::core::option::Option<f32>,
    #[prost(float, optional, tag="2")]
    pub pos_y: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub timestamp: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub pos_z: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgKillCam {
    #[prost(int32, optional, tag="1")]
    pub obs_mode: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2", default="-1")]
    pub first_target: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3", default="-1")]
    pub second_target: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgDesiredTimescale {
    #[prost(float, optional, tag="1")]
    pub desired_timescale: ::core::option::Option<f32>,
    #[prost(float, optional, tag="2")]
    pub duration_realtime_sec: ::core::option::Option<f32>,
    #[prost(int32, optional, tag="3")]
    pub interpolator_type: ::core::option::Option<i32>,
    #[prost(float, optional, tag="4")]
    pub start_blend_time: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCurrentTimescale {
    #[prost(float, optional, tag="1")]
    pub cur_timescale: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgAchievementEvent {
    #[prost(int32, optional, tag="1")]
    pub achievement: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub user_id: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgMatchEndConditions {
    #[prost(int32, optional, tag="1")]
    pub fraglimit: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub mp_maxrounds: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub mp_winlimit: ::core::option::Option<i32>,
    #[prost(float, optional, tag="4")]
    pub mp_timelimit: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgPlayerStatsUpdate {
    #[prost(int32, optional, tag="1")]
    pub version: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="4")]
    pub stats: ::prost::alloc::vec::Vec<ccs_usr_msg_player_stats_update::Stat>,
    #[prost(uint32, optional, tag="5")]
    pub ehandle: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="6")]
    pub crc: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CCSUsrMsg_PlayerStatsUpdate`.
pub mod ccs_usr_msg_player_stats_update {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Stat {
        #[prost(int32, optional, tag="1")]
        pub idx: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub delta: ::core::option::Option<i32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgQuestProgress {
    #[prost(uint32, optional, tag="1")]
    pub quest_id: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub normal_points: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub bonus_points: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="4")]
    pub is_event_quest: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgScoreLeaderboardData {
    #[prost(message, optional, tag="1")]
    pub data: ::core::option::Option<ScoreLeaderboardData>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgPlayerDecalDigitalSignature {
    #[prost(message, optional, tag="1")]
    pub data: ::core::option::Option<PlayerDecalDigitalSignature>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgXRankGet {
    #[prost(int32, optional, tag="1")]
    pub mode_idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub controller: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgXRankUpd {
    #[prost(int32, optional, tag="1")]
    pub mode_idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub controller: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub ranking: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCallVoteFailed {
    #[prost(int32, optional, tag="1")]
    pub reason: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub time: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVoteStart {
    #[prost(int32, optional, tag="1")]
    pub team: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2", default="-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub vote_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag="4")]
    pub disp_str: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub details_str: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="6")]
    pub other_team_str: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="7")]
    pub is_yes_no_vote: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="8", default="-1")]
    pub player_slot_target: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVotePass {
    #[prost(int32, optional, tag="1")]
    pub team: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub vote_type: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub disp_str: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub details_str: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVoteFailed {
    #[prost(int32, optional, tag="1")]
    pub team: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub reason: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgVoteSetup {
    #[prost(string, repeated, tag="1")]
    pub potential_issues: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSendLastKillerDamageToClient {
    #[prost(int32, optional, tag="1")]
    pub num_hits_given: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub damage_given: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub num_hits_taken: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub damage_taken: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub actual_damage_given: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub actual_damage_taken: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgServerRankUpdate {
    #[prost(message, repeated, tag="1")]
    pub rank_update: ::prost::alloc::vec::Vec<ccs_usr_msg_server_rank_update::RankUpdate>,
}
/// Nested message and enum types in `CCSUsrMsg_ServerRankUpdate`.
pub mod ccs_usr_msg_server_rank_update {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RankUpdate {
        #[prost(int32, optional, tag="1")]
        pub account_id: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub rank_old: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub rank_new: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="4")]
        pub num_wins: ::core::option::Option<i32>,
        #[prost(float, optional, tag="5")]
        pub rank_change: ::core::option::Option<f32>,
        #[prost(int32, optional, tag="6")]
        pub rank_type_id: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgXpUpdate {
    #[prost(message, optional, tag="1")]
    pub data: ::core::option::Option<CMsgGcCstrike15V2Gc2ServerNotifyXpRewarded>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgItemPickup {
    #[prost(string, optional, tag="1")]
    pub item: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgShowMenu {
    #[prost(int32, optional, tag="1")]
    pub bits_valid_slots: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub display_time: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub menu_string: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgBarTime {
    #[prost(string, optional, tag="1")]
    pub time: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgAmmoDenied {
    #[prost(int32, optional, tag="1")]
    pub ammoidx: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgMarkAchievement {
    #[prost(string, optional, tag="1")]
    pub achievement: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgMatchStatsUpdate {
    #[prost(string, optional, tag="1")]
    pub update: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgItemDrop {
    #[prost(int64, optional, tag="1")]
    pub itemid: ::core::option::Option<i64>,
    #[prost(bool, optional, tag="2")]
    pub death: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgGlowPropTurnOff {
    #[prost(int32, optional, tag="1", default="-1")]
    pub entidx: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRoundBackupFilenames {
    #[prost(int32, optional, tag="1")]
    pub count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub index: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub nicename: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSsui {
    #[prost(bool, optional, tag="1")]
    pub show: ::core::option::Option<bool>,
    #[prost(float, optional, tag="2")]
    pub start_time: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub end_time: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgSurvivalStats {
    #[prost(uint64, optional, tag="1")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(message, repeated, tag="2")]
    pub facts: ::prost::alloc::vec::Vec<ccs_usr_msg_survival_stats::Fact>,
    #[prost(message, repeated, tag="3")]
    pub users: ::prost::alloc::vec::Vec<ccs_usr_msg_survival_stats::Placement>,
    #[prost(message, repeated, tag="5")]
    pub damages: ::prost::alloc::vec::Vec<ccs_usr_msg_survival_stats::Damage>,
    #[prost(int32, optional, tag="4")]
    pub ticknumber: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CCSUsrMsg_SurvivalStats`.
pub mod ccs_usr_msg_survival_stats {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Fact {
        #[prost(int32, optional, tag="1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub display: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub value: ::core::option::Option<i32>,
        #[prost(float, optional, tag="4")]
        pub interestingness: ::core::option::Option<f32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Placement {
        #[prost(uint64, optional, tag="1")]
        pub xuid: ::core::option::Option<u64>,
        #[prost(int32, optional, tag="2")]
        pub teamnumber: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub placement: ::core::option::Option<i32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Damage {
        #[prost(uint64, optional, tag="1")]
        pub xuid: ::core::option::Option<u64>,
        #[prost(int32, optional, tag="2")]
        pub to: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub to_hits: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="4")]
        pub from: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="5")]
        pub from_hits: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgEndOfMatchAllPlayersData {
    #[prost(message, repeated, tag="1")]
    pub allplayerdata: ::prost::alloc::vec::Vec<ccs_usr_msg_end_of_match_all_players_data::PlayerData>,
    #[prost(int32, optional, tag="2")]
    pub scene: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CCSUsrMsg_EndOfMatchAllPlayersData`.
pub mod ccs_usr_msg_end_of_match_all_players_data {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Accolade {
        #[prost(int32, optional, tag="1")]
        pub eaccolade: ::core::option::Option<i32>,
        #[prost(float, optional, tag="2")]
        pub value: ::core::option::Option<f32>,
        #[prost(int32, optional, tag="3")]
        pub position: ::core::option::Option<i32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PlayerData {
        #[prost(int32, optional, tag="1", default="-1")]
        pub slot: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag="2")]
        pub xuid: ::core::option::Option<u64>,
        #[prost(string, optional, tag="3")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="4")]
        pub teamnumber: ::core::option::Option<i32>,
        #[prost(message, optional, tag="5")]
        pub nomination: ::core::option::Option<Accolade>,
        #[prost(message, repeated, tag="6")]
        pub items: ::prost::alloc::vec::Vec<super::CEconItemPreviewDataBlock>,
        #[prost(int32, optional, tag="7")]
        pub playercolor: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="8")]
        pub isbot: ::core::option::Option<bool>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRoundEndReportData {
    #[prost(message, optional, tag="1")]
    pub init_conditions: ::core::option::Option<ccs_usr_msg_round_end_report_data::InitialConditions>,
    #[prost(message, repeated, tag="2")]
    pub all_rer_event_data: ::prost::alloc::vec::Vec<ccs_usr_msg_round_end_report_data::RerEvent>,
}
/// Nested message and enum types in `CCSUsrMsg_RoundEndReportData`.
pub mod ccs_usr_msg_round_end_report_data {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RerEvent {
        #[prost(float, optional, tag="1")]
        pub timestamp: ::core::option::Option<f32>,
        #[prost(int32, optional, tag="2")]
        pub terrorist_odds: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub ct_alive: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="4")]
        pub t_alive: ::core::option::Option<i32>,
        #[prost(message, optional, tag="5")]
        pub victim_data: ::core::option::Option<rer_event::Victim>,
        #[prost(message, optional, tag="6")]
        pub objective_data: ::core::option::Option<rer_event::Objective>,
        #[prost(message, repeated, tag="7")]
        pub all_damage_data: ::prost::alloc::vec::Vec<rer_event::Damage>,
    }
    /// Nested message and enum types in `RerEvent`.
    pub mod rer_event {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Victim {
            #[prost(int32, optional, tag="1")]
            pub team_number: ::core::option::Option<i32>,
            #[prost(int32, optional, tag="2", default="-1")]
            pub playerslot: ::core::option::Option<i32>,
            #[prost(uint64, optional, tag="3")]
            pub xuid: ::core::option::Option<u64>,
            #[prost(int32, optional, tag="4")]
            pub color: ::core::option::Option<i32>,
            #[prost(bool, optional, tag="5")]
            pub is_bot: ::core::option::Option<bool>,
            #[prost(bool, optional, tag="6")]
            pub is_dead: ::core::option::Option<bool>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Objective {
            #[prost(int32, optional, tag="1")]
            pub r#type: ::core::option::Option<i32>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct Damage {
            #[prost(int32, optional, tag="1", default="-1")]
            pub other_playerslot: ::core::option::Option<i32>,
            #[prost(uint64, optional, tag="2")]
            pub other_xuid: ::core::option::Option<u64>,
            #[prost(int32, optional, tag="3")]
            pub health_removed: ::core::option::Option<i32>,
            #[prost(int32, optional, tag="4")]
            pub num_hits: ::core::option::Option<i32>,
            #[prost(int32, optional, tag="5")]
            pub return_health_removed: ::core::option::Option<i32>,
            #[prost(int32, optional, tag="6")]
            pub return_num_hits: ::core::option::Option<i32>,
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct InitialConditions {
        #[prost(int32, optional, tag="1")]
        pub ct_equip_value: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub t_equip_value: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub terrorist_odds: ::core::option::Option<i32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgPostRoundDamageReport {
    #[prost(uint64, optional, tag="1")]
    pub other_xuid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag="2")]
    pub given_kill_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub given_health_removed: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub given_num_hits: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub taken_kill_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub taken_health_removed: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="7")]
    pub taken_num_hits: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCurrentRoundOdds {
    #[prost(int32, optional, tag="1")]
    pub odds: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgDeepStats {
    #[prost(message, optional, tag="1")]
    pub stats: ::core::option::Option<CMsgGccStrike15ClientDeepStats>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgShootInfo {
    #[prost(int32, optional, tag="1")]
    pub frame_number: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="2")]
    pub hitbox_transforms: ::prost::alloc::vec::Vec<CMsgTransform>,
    #[prost(message, optional, tag="3")]
    pub shoot_pos: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag="4")]
    pub shoot_dir: ::core::option::Option<CMsgQAngle>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgResetHud {
    #[prost(bool, optional, tag="1")]
    pub reset: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgGameTitle {
    #[prost(int32, optional, tag="1")]
    pub dummy: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgRequestState {
    #[prost(int32, optional, tag="1")]
    pub dummy: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgStopSpectatorMode {
    #[prost(int32, optional, tag="1")]
    pub dummy: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgDisconnectToLobby {
    #[prost(int32, optional, tag="1")]
    pub dummy: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgWarmupHasEnded {
    #[prost(int32, optional, tag="1")]
    pub dummy: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgClientInfo {
    #[prost(int32, optional, tag="1")]
    pub dummy: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgServerRankRevealAll {
    #[prost(int32, optional, tag="1")]
    pub seconds_till_shutdown: ::core::option::Option<i32>,
    #[prost(message, optional, tag="2")]
    pub reservation: ::core::option::Option<CMsgGccStrike15V2MatchmakingGc2ServerReserve>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgPreMatchSayText {
    #[prost(uint32, optional, tag="1")]
    pub account_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="3")]
    pub all_chat: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgCounterStrafe {
    #[prost(int32, optional, tag="1")]
    pub press_to_release_ns: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub total_keys_down: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CcsUsrMsgDamagePrediction {
    #[prost(int32, optional, tag="1")]
    pub command_num: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub pellet_idx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub victim_slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub victim_starting_health: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub victim_damage: ::core::option::Option<i32>,
    #[prost(message, optional, tag="6")]
    pub shoot_pos: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag="7")]
    pub shoot_dir: ::core::option::Option<CMsgQAngle>,
    #[prost(message, optional, tag="8")]
    pub aim_punch: ::core::option::Option<CMsgQAngle>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ECstrike15UserMessages {
    CsUmVguiMenu = 301,
    CsUmGeiger = 302,
    CsUmTrain = 303,
    CsUmHudText = 304,
    CsUmSayText = 305,
    CsUmSayText2 = 306,
    CsUmTextMsg = 307,
    CsUmHudMsg = 308,
    CsUmResetHud = 309,
    CsUmGameTitle = 310,
    CsUmShake = 312,
    CsUmFade = 313,
    CsUmRumble = 314,
    CsUmCloseCaption = 315,
    CsUmCloseCaptionDirect = 316,
    CsUmSendAudio = 317,
    CsUmRawAudio = 318,
    CsUmVoiceMask = 319,
    CsUmRequestState = 320,
    CsUmDamage = 321,
    CsUmRadioText = 322,
    CsUmHintText = 323,
    CsUmKeyHintText = 324,
    CsUmProcessSpottedEntityUpdate = 325,
    CsUmReloadEffect = 326,
    CsUmAdjustMoney = 327,
    CsUmUpdateTeamMoney = 328,
    CsUmStopSpectatorMode = 329,
    CsUmKillCam = 330,
    CsUmDesiredTimescale = 331,
    CsUmCurrentTimescale = 332,
    CsUmAchievementEvent = 333,
    CsUmMatchEndConditions = 334,
    CsUmDisconnectToLobby = 335,
    CsUmPlayerStatsUpdate = 336,
    CsUmWarmupHasEnded = 338,
    CsUmClientInfo = 339,
    CsUmXRankGet = 340,
    CsUmXRankUpd = 341,
    CsUmCallVoteFailed = 345,
    CsUmVoteStart = 346,
    CsUmVotePass = 347,
    CsUmVoteFailed = 348,
    CsUmVoteSetup = 349,
    CsUmServerRankRevealAll = 350,
    CsUmSendLastKillerDamageToClient = 351,
    CsUmServerRankUpdate = 352,
    CsUmItemPickup = 353,
    CsUmShowMenu = 354,
    CsUmBarTime = 355,
    CsUmAmmoDenied = 356,
    CsUmMarkAchievement = 357,
    CsUmMatchStatsUpdate = 358,
    CsUmItemDrop = 359,
    CsUmGlowPropTurnOff = 360,
    CsUmSendPlayerItemDrops = 361,
    CsUmRoundBackupFilenames = 362,
    CsUmSendPlayerItemFound = 363,
    CsUmReportHit = 364,
    CsUmXpUpdate = 365,
    CsUmQuestProgress = 366,
    CsUmScoreLeaderboardData = 367,
    CsUmPlayerDecalDigitalSignature = 368,
    CsUmWeaponSound = 369,
    CsUmUpdateScreenHealthBar = 370,
    CsUmEntityOutlineHighlight = 371,
    CsUmSsui = 372,
    CsUmSurvivalStats = 373,
    CsUmDisconnectToLobby2 = 374,
    CsUmEndOfMatchAllPlayersData = 375,
    CsUmPostRoundDamageReport = 376,
    CsUmRoundEndReportData = 379,
    CsUmCurrentRoundOdds = 380,
    CsUmDeepStats = 381,
    CsUmShootInfo = 383,
    CsUmCounterStrafe = 385,
    CsUmDamagePrediction = 386,
}
impl ECstrike15UserMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::CsUmVguiMenu => "CS_UM_VGUIMenu",
            Self::CsUmGeiger => "CS_UM_Geiger",
            Self::CsUmTrain => "CS_UM_Train",
            Self::CsUmHudText => "CS_UM_HudText",
            Self::CsUmSayText => "CS_UM_SayText",
            Self::CsUmSayText2 => "CS_UM_SayText2",
            Self::CsUmTextMsg => "CS_UM_TextMsg",
            Self::CsUmHudMsg => "CS_UM_HudMsg",
            Self::CsUmResetHud => "CS_UM_ResetHud",
            Self::CsUmGameTitle => "CS_UM_GameTitle",
            Self::CsUmShake => "CS_UM_Shake",
            Self::CsUmFade => "CS_UM_Fade",
            Self::CsUmRumble => "CS_UM_Rumble",
            Self::CsUmCloseCaption => "CS_UM_CloseCaption",
            Self::CsUmCloseCaptionDirect => "CS_UM_CloseCaptionDirect",
            Self::CsUmSendAudio => "CS_UM_SendAudio",
            Self::CsUmRawAudio => "CS_UM_RawAudio",
            Self::CsUmVoiceMask => "CS_UM_VoiceMask",
            Self::CsUmRequestState => "CS_UM_RequestState",
            Self::CsUmDamage => "CS_UM_Damage",
            Self::CsUmRadioText => "CS_UM_RadioText",
            Self::CsUmHintText => "CS_UM_HintText",
            Self::CsUmKeyHintText => "CS_UM_KeyHintText",
            Self::CsUmProcessSpottedEntityUpdate => "CS_UM_ProcessSpottedEntityUpdate",
            Self::CsUmReloadEffect => "CS_UM_ReloadEffect",
            Self::CsUmAdjustMoney => "CS_UM_AdjustMoney",
            Self::CsUmUpdateTeamMoney => "CS_UM_UpdateTeamMoney",
            Self::CsUmStopSpectatorMode => "CS_UM_StopSpectatorMode",
            Self::CsUmKillCam => "CS_UM_KillCam",
            Self::CsUmDesiredTimescale => "CS_UM_DesiredTimescale",
            Self::CsUmCurrentTimescale => "CS_UM_CurrentTimescale",
            Self::CsUmAchievementEvent => "CS_UM_AchievementEvent",
            Self::CsUmMatchEndConditions => "CS_UM_MatchEndConditions",
            Self::CsUmDisconnectToLobby => "CS_UM_DisconnectToLobby",
            Self::CsUmPlayerStatsUpdate => "CS_UM_PlayerStatsUpdate",
            Self::CsUmWarmupHasEnded => "CS_UM_WarmupHasEnded",
            Self::CsUmClientInfo => "CS_UM_ClientInfo",
            Self::CsUmXRankGet => "CS_UM_XRankGet",
            Self::CsUmXRankUpd => "CS_UM_XRankUpd",
            Self::CsUmCallVoteFailed => "CS_UM_CallVoteFailed",
            Self::CsUmVoteStart => "CS_UM_VoteStart",
            Self::CsUmVotePass => "CS_UM_VotePass",
            Self::CsUmVoteFailed => "CS_UM_VoteFailed",
            Self::CsUmVoteSetup => "CS_UM_VoteSetup",
            Self::CsUmServerRankRevealAll => "CS_UM_ServerRankRevealAll",
            Self::CsUmSendLastKillerDamageToClient => "CS_UM_SendLastKillerDamageToClient",
            Self::CsUmServerRankUpdate => "CS_UM_ServerRankUpdate",
            Self::CsUmItemPickup => "CS_UM_ItemPickup",
            Self::CsUmShowMenu => "CS_UM_ShowMenu",
            Self::CsUmBarTime => "CS_UM_BarTime",
            Self::CsUmAmmoDenied => "CS_UM_AmmoDenied",
            Self::CsUmMarkAchievement => "CS_UM_MarkAchievement",
            Self::CsUmMatchStatsUpdate => "CS_UM_MatchStatsUpdate",
            Self::CsUmItemDrop => "CS_UM_ItemDrop",
            Self::CsUmGlowPropTurnOff => "CS_UM_GlowPropTurnOff",
            Self::CsUmSendPlayerItemDrops => "CS_UM_SendPlayerItemDrops",
            Self::CsUmRoundBackupFilenames => "CS_UM_RoundBackupFilenames",
            Self::CsUmSendPlayerItemFound => "CS_UM_SendPlayerItemFound",
            Self::CsUmReportHit => "CS_UM_ReportHit",
            Self::CsUmXpUpdate => "CS_UM_XpUpdate",
            Self::CsUmQuestProgress => "CS_UM_QuestProgress",
            Self::CsUmScoreLeaderboardData => "CS_UM_ScoreLeaderboardData",
            Self::CsUmPlayerDecalDigitalSignature => "CS_UM_PlayerDecalDigitalSignature",
            Self::CsUmWeaponSound => "CS_UM_WeaponSound",
            Self::CsUmUpdateScreenHealthBar => "CS_UM_UpdateScreenHealthBar",
            Self::CsUmEntityOutlineHighlight => "CS_UM_EntityOutlineHighlight",
            Self::CsUmSsui => "CS_UM_SSUI",
            Self::CsUmSurvivalStats => "CS_UM_SurvivalStats",
            Self::CsUmDisconnectToLobby2 => "CS_UM_DisconnectToLobby2",
            Self::CsUmEndOfMatchAllPlayersData => "CS_UM_EndOfMatchAllPlayersData",
            Self::CsUmPostRoundDamageReport => "CS_UM_PostRoundDamageReport",
            Self::CsUmRoundEndReportData => "CS_UM_RoundEndReportData",
            Self::CsUmCurrentRoundOdds => "CS_UM_CurrentRoundOdds",
            Self::CsUmDeepStats => "CS_UM_DeepStats",
            Self::CsUmShootInfo => "CS_UM_ShootInfo",
            Self::CsUmCounterStrafe => "CS_UM_CounterStrafe",
            Self::CsUmDamagePrediction => "CS_UM_DamagePrediction",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CS_UM_VGUIMenu" => Some(Self::CsUmVguiMenu),
            "CS_UM_Geiger" => Some(Self::CsUmGeiger),
            "CS_UM_Train" => Some(Self::CsUmTrain),
            "CS_UM_HudText" => Some(Self::CsUmHudText),
            "CS_UM_SayText" => Some(Self::CsUmSayText),
            "CS_UM_SayText2" => Some(Self::CsUmSayText2),
            "CS_UM_TextMsg" => Some(Self::CsUmTextMsg),
            "CS_UM_HudMsg" => Some(Self::CsUmHudMsg),
            "CS_UM_ResetHud" => Some(Self::CsUmResetHud),
            "CS_UM_GameTitle" => Some(Self::CsUmGameTitle),
            "CS_UM_Shake" => Some(Self::CsUmShake),
            "CS_UM_Fade" => Some(Self::CsUmFade),
            "CS_UM_Rumble" => Some(Self::CsUmRumble),
            "CS_UM_CloseCaption" => Some(Self::CsUmCloseCaption),
            "CS_UM_CloseCaptionDirect" => Some(Self::CsUmCloseCaptionDirect),
            "CS_UM_SendAudio" => Some(Self::CsUmSendAudio),
            "CS_UM_RawAudio" => Some(Self::CsUmRawAudio),
            "CS_UM_VoiceMask" => Some(Self::CsUmVoiceMask),
            "CS_UM_RequestState" => Some(Self::CsUmRequestState),
            "CS_UM_Damage" => Some(Self::CsUmDamage),
            "CS_UM_RadioText" => Some(Self::CsUmRadioText),
            "CS_UM_HintText" => Some(Self::CsUmHintText),
            "CS_UM_KeyHintText" => Some(Self::CsUmKeyHintText),
            "CS_UM_ProcessSpottedEntityUpdate" => Some(Self::CsUmProcessSpottedEntityUpdate),
            "CS_UM_ReloadEffect" => Some(Self::CsUmReloadEffect),
            "CS_UM_AdjustMoney" => Some(Self::CsUmAdjustMoney),
            "CS_UM_UpdateTeamMoney" => Some(Self::CsUmUpdateTeamMoney),
            "CS_UM_StopSpectatorMode" => Some(Self::CsUmStopSpectatorMode),
            "CS_UM_KillCam" => Some(Self::CsUmKillCam),
            "CS_UM_DesiredTimescale" => Some(Self::CsUmDesiredTimescale),
            "CS_UM_CurrentTimescale" => Some(Self::CsUmCurrentTimescale),
            "CS_UM_AchievementEvent" => Some(Self::CsUmAchievementEvent),
            "CS_UM_MatchEndConditions" => Some(Self::CsUmMatchEndConditions),
            "CS_UM_DisconnectToLobby" => Some(Self::CsUmDisconnectToLobby),
            "CS_UM_PlayerStatsUpdate" => Some(Self::CsUmPlayerStatsUpdate),
            "CS_UM_WarmupHasEnded" => Some(Self::CsUmWarmupHasEnded),
            "CS_UM_ClientInfo" => Some(Self::CsUmClientInfo),
            "CS_UM_XRankGet" => Some(Self::CsUmXRankGet),
            "CS_UM_XRankUpd" => Some(Self::CsUmXRankUpd),
            "CS_UM_CallVoteFailed" => Some(Self::CsUmCallVoteFailed),
            "CS_UM_VoteStart" => Some(Self::CsUmVoteStart),
            "CS_UM_VotePass" => Some(Self::CsUmVotePass),
            "CS_UM_VoteFailed" => Some(Self::CsUmVoteFailed),
            "CS_UM_VoteSetup" => Some(Self::CsUmVoteSetup),
            "CS_UM_ServerRankRevealAll" => Some(Self::CsUmServerRankRevealAll),
            "CS_UM_SendLastKillerDamageToClient" => Some(Self::CsUmSendLastKillerDamageToClient),
            "CS_UM_ServerRankUpdate" => Some(Self::CsUmServerRankUpdate),
            "CS_UM_ItemPickup" => Some(Self::CsUmItemPickup),
            "CS_UM_ShowMenu" => Some(Self::CsUmShowMenu),
            "CS_UM_BarTime" => Some(Self::CsUmBarTime),
            "CS_UM_AmmoDenied" => Some(Self::CsUmAmmoDenied),
            "CS_UM_MarkAchievement" => Some(Self::CsUmMarkAchievement),
            "CS_UM_MatchStatsUpdate" => Some(Self::CsUmMatchStatsUpdate),
            "CS_UM_ItemDrop" => Some(Self::CsUmItemDrop),
            "CS_UM_GlowPropTurnOff" => Some(Self::CsUmGlowPropTurnOff),
            "CS_UM_SendPlayerItemDrops" => Some(Self::CsUmSendPlayerItemDrops),
            "CS_UM_RoundBackupFilenames" => Some(Self::CsUmRoundBackupFilenames),
            "CS_UM_SendPlayerItemFound" => Some(Self::CsUmSendPlayerItemFound),
            "CS_UM_ReportHit" => Some(Self::CsUmReportHit),
            "CS_UM_XpUpdate" => Some(Self::CsUmXpUpdate),
            "CS_UM_QuestProgress" => Some(Self::CsUmQuestProgress),
            "CS_UM_ScoreLeaderboardData" => Some(Self::CsUmScoreLeaderboardData),
            "CS_UM_PlayerDecalDigitalSignature" => Some(Self::CsUmPlayerDecalDigitalSignature),
            "CS_UM_WeaponSound" => Some(Self::CsUmWeaponSound),
            "CS_UM_UpdateScreenHealthBar" => Some(Self::CsUmUpdateScreenHealthBar),
            "CS_UM_EntityOutlineHighlight" => Some(Self::CsUmEntityOutlineHighlight),
            "CS_UM_SSUI" => Some(Self::CsUmSsui),
            "CS_UM_SurvivalStats" => Some(Self::CsUmSurvivalStats),
            "CS_UM_DisconnectToLobby2" => Some(Self::CsUmDisconnectToLobby2),
            "CS_UM_EndOfMatchAllPlayersData" => Some(Self::CsUmEndOfMatchAllPlayersData),
            "CS_UM_PostRoundDamageReport" => Some(Self::CsUmPostRoundDamageReport),
            "CS_UM_RoundEndReportData" => Some(Self::CsUmRoundEndReportData),
            "CS_UM_CurrentRoundOdds" => Some(Self::CsUmCurrentRoundOdds),
            "CS_UM_DeepStats" => Some(Self::CsUmDeepStats),
            "CS_UM_ShootInfo" => Some(Self::CsUmShootInfo),
            "CS_UM_CounterStrafe" => Some(Self::CsUmCounterStrafe),
            "CS_UM_DamagePrediction" => Some(Self::CsUmDamagePrediction),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EcsUsrMsgDisconnectToLobbyAction {
    KEcsUsrMsgDisconnectToLobbyActionDefault = 0,
    KEcsUsrMsgDisconnectToLobbyActionGoQueue = 1,
}
impl EcsUsrMsgDisconnectToLobbyAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::KEcsUsrMsgDisconnectToLobbyActionDefault => "k_ECSUsrMsg_DisconnectToLobby_Action_Default",
            Self::KEcsUsrMsgDisconnectToLobbyActionGoQueue => "k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "k_ECSUsrMsg_DisconnectToLobby_Action_Default" => Some(Self::KEcsUsrMsgDisconnectToLobbyActionDefault),
            "k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue" => Some(Self::KEcsUsrMsgDisconnectToLobbyActionGoQueue),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageAchievementEvent {
    #[prost(uint32, optional, tag="1")]
    pub achievement: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCloseCaption {
    #[prost(fixed32, optional, tag="1")]
    pub hash: ::core::option::Option<u32>,
    #[prost(float, optional, tag="2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag="3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="4", default="-1")]
    pub ent_index: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCloseCaptionDirect {
    #[prost(fixed32, optional, tag="1")]
    pub hash: ::core::option::Option<u32>,
    #[prost(float, optional, tag="2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag="3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="4", default="-1")]
    pub ent_index: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageCloseCaptionPlaceholder {
    #[prost(string, optional, tag="1")]
    pub string: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag="2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(bool, optional, tag="3")]
    pub from_player: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="4", default="-1")]
    pub ent_index: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCurrentTimescale {
    #[prost(float, optional, tag="1")]
    pub current: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageDesiredTimescale {
    #[prost(float, optional, tag="1")]
    pub desired: ::core::option::Option<f32>,
    #[prost(float, optional, tag="2")]
    pub acceleration: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub minblendrate: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub blenddeltamultiplier: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageFade {
    #[prost(uint32, optional, tag="1")]
    pub duration: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub hold_time: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub flags: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag="4")]
    pub color: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageShake {
    #[prost(uint32, optional, tag="1")]
    pub command: ::core::option::Option<u32>,
    #[prost(float, optional, tag="2")]
    pub amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub duration: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageShakeDir {
    #[prost(message, optional, tag="1")]
    pub shake: ::core::option::Option<CUserMessageShake>,
    #[prost(message, optional, tag="2")]
    pub direction: ::core::option::Option<CMsgVector>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageWaterShake {
    #[prost(uint32, optional, tag="1")]
    pub command: ::core::option::Option<u32>,
    #[prost(float, optional, tag="2")]
    pub amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub duration: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageScreenTilt {
    #[prost(uint32, optional, tag="1")]
    pub command: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="2")]
    pub ease_in_out: ::core::option::Option<bool>,
    #[prost(message, optional, tag="3")]
    pub angle: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag="4")]
    pub duration: ::core::option::Option<f32>,
    #[prost(float, optional, tag="5")]
    pub time: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSayText {
    #[prost(int32, optional, tag="1", default="-1")]
    pub playerindex: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="3")]
    pub chat: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSayText2 {
    #[prost(int32, optional, tag="1", default="-1")]
    pub entityindex: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="2")]
    pub chat: ::core::option::Option<bool>,
    #[prost(string, optional, tag="3")]
    pub messagename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub param1: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="5")]
    pub param2: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="6")]
    pub param3: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="7")]
    pub param4: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageHudMsg {
    #[prost(uint32, optional, tag="1")]
    pub channel: ::core::option::Option<u32>,
    #[prost(float, optional, tag="2")]
    pub x: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub y: ::core::option::Option<f32>,
    #[prost(fixed32, optional, tag="4")]
    pub color1: ::core::option::Option<u32>,
    #[prost(fixed32, optional, tag="5")]
    pub color2: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub effect: ::core::option::Option<u32>,
    #[prost(string, optional, tag="11")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageHudText {
    #[prost(string, optional, tag="1")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageTextMsg {
    #[prost(uint32, optional, tag="1")]
    pub dest: ::core::option::Option<u32>,
    #[prost(string, repeated, tag="2")]
    pub param: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageGameTitle {
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageResetHud {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSendAudio {
    #[prost(string, optional, tag="1")]
    pub soundname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="2")]
    pub stop: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageAudioParameter {
    #[prost(uint32, optional, tag="1")]
    pub parameter_type: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub name_hash_code: ::core::option::Option<u32>,
    #[prost(float, optional, tag="3")]
    pub value: ::core::option::Option<f32>,
    #[prost(uint32, optional, tag="4")]
    pub int_value: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageVoiceMask {
    #[prost(uint32, repeated, packed="false", tag="1")]
    pub gamerules_masks: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, packed="false", tag="2")]
    pub ban_masks: ::prost::alloc::vec::Vec<u32>,
    #[prost(bool, optional, tag="3")]
    pub mod_enable: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestState {
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRumble {
    #[prost(int32, optional, tag="1")]
    pub index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub data: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub flags: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageSayTextChannel {
    #[prost(int32, optional, tag="1")]
    pub player: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub channel: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageColoredText {
    #[prost(uint32, optional, tag="1")]
    pub color: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="3")]
    pub reset: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="4", default="-1")]
    pub context_player_slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub context_value: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub context_team_id: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageItemPickup {
    #[prost(string, optional, tag="1")]
    pub itemname: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageAmmoDenied {
    #[prost(uint32, optional, tag="1")]
    pub ammo_id: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageShowMenu {
    #[prost(uint32, optional, tag="1")]
    pub validslots: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub displaytime: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="3")]
    pub needmore: ::core::option::Option<bool>,
    #[prost(string, optional, tag="4")]
    pub menustring: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageCreditsMsg {
    #[prost(enumeration="ERollType", optional, tag="1", default="RollNone")]
    pub rolltype: ::core::option::Option<i32>,
    #[prost(float, optional, tag="2")]
    pub logo_length: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessagePlayJingle {
    #[prost(message, optional, tag="1")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageScreenOverlay {
    #[prost(bool, optional, tag="1")]
    pub start_effect: ::core::option::Option<bool>,
    #[prost(message, optional, tag="2")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageRemoveAllDecals {
    #[prost(bool, optional, tag="1")]
    pub remove_decals: ::core::option::Option<bool>,
    #[prost(message, optional, tag="2")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessagePropagateForce {
    #[prost(message, optional, tag="1")]
    pub impulse: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag="2")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageDoSpark {
    #[prost(message, optional, tag="1")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag="2", default="-1")]
    pub entityindex: ::core::option::Option<i32>,
    #[prost(float, optional, tag="3")]
    pub radius: ::core::option::Option<f32>,
    #[prost(fixed32, optional, tag="4")]
    pub color: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub beams: ::core::option::Option<u32>,
    #[prost(float, optional, tag="6")]
    pub thick: ::core::option::Option<f32>,
    #[prost(float, optional, tag="7")]
    pub duration: ::core::option::Option<f32>,
    #[prost(message, optional, tag="8")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CEntityMessageFixAngle {
    #[prost(bool, optional, tag="1")]
    pub relative: ::core::option::Option<bool>,
    #[prost(message, optional, tag="2")]
    pub angle: ::core::option::Option<CMsgQAngle>,
    #[prost(message, optional, tag="3")]
    pub entity_msg: ::core::option::Option<CEntityMsg>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageCameraTransition {
    #[prost(uint32, optional, tag="1")]
    pub camera_type: ::core::option::Option<u32>,
    #[prost(float, optional, tag="2")]
    pub duration: ::core::option::Option<f32>,
    #[prost(message, optional, tag="3")]
    pub params_data_driven: ::core::option::Option<c_user_message_camera_transition::TransitionDataDriven>,
}
/// Nested message and enum types in `CUserMessageCameraTransition`.
pub mod c_user_message_camera_transition {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransitionDataDriven {
        #[prost(string, optional, tag="1")]
        pub filename: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="2", default="-1")]
        pub attach_ent_index: ::core::option::Option<i32>,
        #[prost(float, optional, tag="3")]
        pub duration: ::core::option::Option<f32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMsgParticleManager {
    #[prost(enumeration="ParticleMessage", required, tag="1", default="GameParticleManagerEventCreate")]
    pub r#type: i32,
    #[prost(uint32, required, tag="2")]
    pub index: u32,
    #[prost(message, optional, tag="3")]
    pub release_particle_index: ::core::option::Option<c_user_msg_particle_manager::ReleaseParticleIndex>,
    #[prost(message, optional, tag="4")]
    pub create_particle: ::core::option::Option<c_user_msg_particle_manager::CreateParticle>,
    #[prost(message, optional, tag="5")]
    pub destroy_particle: ::core::option::Option<c_user_msg_particle_manager::DestroyParticle>,
    #[prost(message, optional, tag="6")]
    pub destroy_particle_involving: ::core::option::Option<c_user_msg_particle_manager::DestroyParticleInvolving>,
    #[prost(message, optional, tag="7")]
    pub update_particle: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleObsolete>,
    #[prost(message, optional, tag="8")]
    pub update_particle_fwd: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleFwdObsolete>,
    #[prost(message, optional, tag="9")]
    pub update_particle_orient: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleOrientObsolete>,
    #[prost(message, optional, tag="10")]
    pub update_particle_fallback: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleFallback>,
    #[prost(message, optional, tag="11")]
    pub update_particle_offset: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleOffset>,
    #[prost(message, optional, tag="12")]
    pub update_particle_ent: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleEnt>,
    #[prost(message, optional, tag="14")]
    pub update_particle_should_draw: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleShouldDraw>,
    #[prost(message, optional, tag="15")]
    pub update_particle_set_frozen: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleSetFrozen>,
    #[prost(message, optional, tag="16")]
    pub change_control_point_attachment: ::core::option::Option<c_user_msg_particle_manager::ChangeControlPointAttachment>,
    #[prost(message, optional, tag="17")]
    pub update_entity_position: ::core::option::Option<c_user_msg_particle_manager::UpdateEntityPosition>,
    #[prost(message, optional, tag="18")]
    pub set_particle_fow_properties: ::core::option::Option<c_user_msg_particle_manager::SetParticleFoWProperties>,
    #[prost(message, optional, tag="19")]
    pub set_particle_text: ::core::option::Option<c_user_msg_particle_manager::SetParticleText>,
    #[prost(message, optional, tag="20")]
    pub set_particle_should_check_fow: ::core::option::Option<c_user_msg_particle_manager::SetParticleShouldCheckFoW>,
    #[prost(message, optional, tag="21")]
    pub set_control_point_model: ::core::option::Option<c_user_msg_particle_manager::SetControlPointModel>,
    #[prost(message, optional, tag="22")]
    pub set_control_point_snapshot: ::core::option::Option<c_user_msg_particle_manager::SetControlPointSnapshot>,
    #[prost(message, optional, tag="23")]
    pub set_texture_attribute: ::core::option::Option<c_user_msg_particle_manager::SetTextureAttribute>,
    #[prost(message, optional, tag="24")]
    pub set_scene_object_generic_flag: ::core::option::Option<c_user_msg_particle_manager::SetSceneObjectGenericFlag>,
    #[prost(message, optional, tag="25")]
    pub set_scene_object_tint_and_desat: ::core::option::Option<c_user_msg_particle_manager::SetSceneObjectTintAndDesat>,
    #[prost(message, optional, tag="26")]
    pub destroy_particle_named: ::core::option::Option<c_user_msg_particle_manager::DestroyParticleNamed>,
    #[prost(message, optional, tag="27")]
    pub particle_skip_to_time: ::core::option::Option<c_user_msg_particle_manager::ParticleSkipToTime>,
    #[prost(message, optional, tag="28")]
    pub particle_can_freeze: ::core::option::Option<c_user_msg_particle_manager::ParticleCanFreeze>,
    #[prost(message, optional, tag="29")]
    pub set_named_value_context: ::core::option::Option<c_user_msg_particle_manager::SetParticleNamedValueContext>,
    #[prost(message, optional, tag="30")]
    pub update_particle_transform: ::core::option::Option<c_user_msg_particle_manager::UpdateParticleTransform>,
    #[prost(message, optional, tag="31")]
    pub particle_freeze_transition_override: ::core::option::Option<c_user_msg_particle_manager::ParticleFreezeTransitionOverride>,
    #[prost(message, optional, tag="32")]
    pub freeze_particle_involving: ::core::option::Option<c_user_msg_particle_manager::FreezeParticleInvolving>,
    #[prost(message, optional, tag="33")]
    pub add_modellist_override_element: ::core::option::Option<c_user_msg_particle_manager::AddModellistOverrideElement>,
    #[prost(message, optional, tag="34")]
    pub clear_modellist_override: ::core::option::Option<c_user_msg_particle_manager::ClearModellistOverride>,
    #[prost(message, optional, tag="35")]
    pub create_physics_sim: ::core::option::Option<c_user_msg_particle_manager::CreatePhysicsSim>,
    #[prost(message, optional, tag="36")]
    pub destroy_physics_sim: ::core::option::Option<c_user_msg_particle_manager::DestroyPhysicsSim>,
    #[prost(message, optional, tag="37")]
    pub set_vdata: ::core::option::Option<c_user_msg_particle_manager::SetVData>,
    #[prost(message, optional, tag="38")]
    pub set_material_override: ::core::option::Option<c_user_msg_particle_manager::SetMaterialOverride>,
}
/// Nested message and enum types in `CUserMsg_ParticleManager`.
pub mod c_user_msg_particle_manager {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ReleaseParticleIndex {
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateParticle {
        #[prost(fixed64, optional, tag="1")]
        pub particle_name_index: ::core::option::Option<u64>,
        #[prost(int32, optional, tag="2")]
        pub attach_type: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag="3", default="16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="4", default="16777215")]
        pub entity_handle_for_modifiers: ::core::option::Option<u32>,
        #[prost(bool, optional, tag="5")]
        pub apply_voice_ban_rules: ::core::option::Option<bool>,
        #[prost(int32, optional, tag="6")]
        pub team_behavior: ::core::option::Option<i32>,
        #[prost(string, optional, tag="7")]
        pub control_point_configuration: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="8")]
        pub cluster: ::core::option::Option<bool>,
        #[prost(float, optional, tag="9")]
        pub endcap_time: ::core::option::Option<f32>,
        #[prost(message, optional, tag="10")]
        pub aggregation_position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticle {
        #[prost(bool, optional, tag="1")]
        pub destroy_immediately: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticleInvolving {
        #[prost(bool, optional, tag="1")]
        pub destroy_immediately: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag="3", default="16777215")]
        pub entity_handle: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyParticleNamed {
        #[prost(fixed64, optional, tag="1")]
        pub particle_name_index: ::core::option::Option<u64>,
        #[prost(uint32, optional, tag="2", default="16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(bool, optional, tag="3")]
        pub destroy_immediately: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="4")]
        pub play_endcap: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleObsolete {
        #[prost(int32, optional, tag="1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag="2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleFwdObsolete {
        #[prost(int32, optional, tag="1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag="2")]
        pub forward: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleOrientObsolete {
        #[prost(int32, optional, tag="1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag="2")]
        pub forward: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag="3")]
        pub deprecated_right: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag="4")]
        pub up: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag="5")]
        pub left: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleTransform {
        #[prost(int32, optional, tag="1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag="2")]
        pub position: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag="3")]
        pub orientation: ::core::option::Option<super::CMsgQuaternion>,
        #[prost(float, optional, tag="4")]
        pub interpolation_interval: ::core::option::Option<f32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleFallback {
        #[prost(int32, optional, tag="1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag="2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleOffset {
        #[prost(int32, optional, tag="1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(message, optional, tag="2")]
        pub origin_offset: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag="3")]
        pub angle_offset: ::core::option::Option<super::CMsgQAngle>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleEnt {
        #[prost(int32, optional, tag="1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag="2", default="16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(int32, optional, tag="3")]
        pub attach_type: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="4")]
        pub attachment: ::core::option::Option<i32>,
        #[prost(message, optional, tag="5")]
        pub fallback_position: ::core::option::Option<super::CMsgVector>,
        #[prost(bool, optional, tag="6")]
        pub include_wearables: ::core::option::Option<bool>,
        #[prost(message, optional, tag="7")]
        pub offset_position: ::core::option::Option<super::CMsgVector>,
        #[prost(message, optional, tag="8")]
        pub offset_angles: ::core::option::Option<super::CMsgQAngle>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleSetFrozen {
        #[prost(bool, optional, tag="1")]
        pub set_frozen: ::core::option::Option<bool>,
        #[prost(float, optional, tag="2")]
        pub transition_duration: ::core::option::Option<f32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateParticleShouldDraw {
        #[prost(bool, optional, tag="1")]
        pub should_draw: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ChangeControlPointAttachment {
        #[prost(int32, optional, tag="1")]
        pub attachment_old: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub attachment_new: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag="3", default="16777215")]
        pub entity_handle: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct UpdateEntityPosition {
        #[prost(uint32, optional, tag="1", default="16777215")]
        pub entity_handle: ::core::option::Option<u32>,
        #[prost(message, optional, tag="2")]
        pub position: ::core::option::Option<super::CMsgVector>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetParticleFoWProperties {
        #[prost(int32, optional, tag="1")]
        pub fow_control_point: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub fow_control_point2: ::core::option::Option<i32>,
        #[prost(float, optional, tag="3")]
        pub fow_radius: ::core::option::Option<f32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetParticleShouldCheckFoW {
        #[prost(bool, optional, tag="1")]
        pub check_fow: ::core::option::Option<bool>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetControlPointModel {
        #[prost(int32, optional, tag="1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub model_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetControlPointSnapshot {
        #[prost(int32, optional, tag="1")]
        pub control_point: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub snapshot_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetParticleText {
        #[prost(string, optional, tag="1")]
        pub text: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetTextureAttribute {
        #[prost(string, optional, tag="1")]
        pub attribute_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="2")]
        pub texture_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetSceneObjectGenericFlag {
        #[prost(bool, optional, tag="1")]
        pub flag_value: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SetSceneObjectTintAndDesat {
        #[prost(fixed32, optional, tag="1")]
        pub tint: ::core::option::Option<u32>,
        #[prost(float, optional, tag="2")]
        pub desat: ::core::option::Option<f32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ParticleSkipToTime {
        #[prost(float, optional, tag="1")]
        pub skip_to_time: ::core::option::Option<f32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ParticleCanFreeze {
        #[prost(bool, optional, tag="1")]
        pub can_freeze: ::core::option::Option<bool>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ParticleFreezeTransitionOverride {
        #[prost(float, optional, tag="1")]
        pub freeze_transition_override: ::core::option::Option<f32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct FreezeParticleInvolving {
        #[prost(bool, optional, tag="1")]
        pub set_frozen: ::core::option::Option<bool>,
        #[prost(float, optional, tag="2")]
        pub transition_duration: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag="3", default="16777215")]
        pub entity_handle: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddModellistOverrideElement {
        #[prost(string, optional, tag="1")]
        pub model_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(float, optional, tag="2")]
        pub spawn_probability: ::core::option::Option<f32>,
        #[prost(uint32, optional, tag="3")]
        pub groupid: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ClearModellistOverride {
        #[prost(uint32, optional, tag="1")]
        pub groupid: ::core::option::Option<u32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetParticleNamedValueContext {
        #[prost(message, repeated, tag="1")]
        pub float_values: ::prost::alloc::vec::Vec<set_particle_named_value_context::FloatContextValue>,
        #[prost(message, repeated, tag="2")]
        pub vector_values: ::prost::alloc::vec::Vec<set_particle_named_value_context::VectorContextValue>,
        #[prost(message, repeated, tag="3")]
        pub transform_values: ::prost::alloc::vec::Vec<set_particle_named_value_context::TransformContextValue>,
        #[prost(message, repeated, tag="4")]
        pub ehandle_values: ::prost::alloc::vec::Vec<set_particle_named_value_context::EHandleContext>,
    }
    /// Nested message and enum types in `SetParticleNamedValueContext`.
    pub mod set_particle_named_value_context {
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct FloatContextValue {
            #[prost(uint32, optional, tag="1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(float, optional, tag="2")]
            pub value: ::core::option::Option<f32>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct VectorContextValue {
            #[prost(uint32, optional, tag="1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(message, optional, tag="2")]
            pub value: ::core::option::Option<super::super::CMsgVector>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct TransformContextValue {
            #[prost(uint32, optional, tag="1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(message, optional, tag="2")]
            pub angles: ::core::option::Option<super::super::CMsgQAngle>,
            #[prost(message, optional, tag="3")]
            pub translation: ::core::option::Option<super::super::CMsgVector>,
        }
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct EHandleContext {
            #[prost(uint32, optional, tag="1")]
            pub value_name_hash: ::core::option::Option<u32>,
            #[prost(uint32, optional, tag="2", default="16777215")]
            pub ent_index: ::core::option::Option<u32>,
        }
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreatePhysicsSim {
        #[prost(string, optional, tag="1")]
        pub prop_group_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="2")]
        pub use_high_quality_simulation: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag="3")]
        pub max_particle_count: ::core::option::Option<u32>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DestroyPhysicsSim {
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetVData {
        #[prost(string, optional, tag="1")]
        pub vdata_name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SetMaterialOverride {
        #[prost(string, optional, tag="1")]
        pub material_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag="2")]
        pub include_children: ::core::option::Option<bool>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMsgHudError {
    #[prost(int32, optional, tag="1")]
    pub order_id: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMsgCustomGameEvent {
    #[prost(string, optional, tag="1")]
    pub event_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageHapticsManagerPulse {
    #[prost(int32, optional, tag="1")]
    pub hand_id: ::core::option::Option<i32>,
    #[prost(float, optional, tag="2")]
    pub effect_amplitude: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub effect_frequency: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub effect_duration: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageHapticsManagerEffect {
    #[prost(int32, optional, tag="1")]
    pub hand_id: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="2")]
    pub effect_name_hash_code: ::core::option::Option<u32>,
    #[prost(float, optional, tag="3")]
    pub effect_scale: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageAnimStateGraphState {
    #[prost(int32, optional, tag="1")]
    pub entity_index: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageUpdateCssClasses {
    #[prost(int32, optional, tag="1")]
    pub target_world_panel: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub css_classes: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="3")]
    pub is_add: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageServerFrameTime {
    #[prost(float, optional, tag="1")]
    pub frame_time: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageLagCompensationError {
    #[prost(float, optional, tag="1")]
    pub distance: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestDllStatus {
    #[prost(string, optional, tag="1")]
    pub dll_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="2")]
    pub full_report: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestUtilAction {
    #[prost(int32, optional, tag="2")]
    pub util1: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub util2: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub util3: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub util4: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub util5: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageUtilMsgResponse {
    #[prost(fixed32, optional, tag="1")]
    pub crc: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="2")]
    pub item_count: ::core::option::Option<i32>,
    #[prost(fixed32, optional, tag="3")]
    pub crc2: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="4")]
    pub item_count2: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed="false", tag="5")]
    pub crc_part: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed="false", tag="6")]
    pub crc_part2: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, optional, tag="7")]
    pub client_timestamp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="8")]
    pub platform: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="9")]
    pub itemdetails: ::prost::alloc::vec::Vec<c_user_message_util_msg_response::ItemDetail>,
    #[prost(int32, optional, tag="10")]
    pub itemgroup: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="11")]
    pub total_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="12")]
    pub total_count2: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CUserMessage_UtilMsg_Response`.
pub mod c_user_message_util_msg_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ItemDetail {
        #[prost(int32, optional, tag="1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub hash: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="3")]
        pub crc: ::core::option::Option<i32>,
        #[prost(string, optional, tag="4")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageDllStatus {
    #[prost(string, optional, tag="1")]
    pub file_report: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub command_line: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="3")]
    pub total_files: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub process_id: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="5")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag="6")]
    pub client_time: ::core::option::Option<u64>,
    #[prost(message, repeated, tag="7")]
    pub diagnostics: ::prost::alloc::vec::Vec<c_user_message_dll_status::CvDiagnostic>,
    #[prost(message, repeated, tag="8")]
    pub modules: ::prost::alloc::vec::Vec<c_user_message_dll_status::CModule>,
}
/// Nested message and enum types in `CUserMessage_DllStatus`.
pub mod c_user_message_dll_status {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CvDiagnostic {
        #[prost(uint32, optional, tag="1")]
        pub id: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="2")]
        pub extended: ::core::option::Option<u32>,
        #[prost(uint64, optional, tag="3")]
        pub value: ::core::option::Option<u64>,
        #[prost(string, optional, tag="4")]
        pub string_value: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CModule {
        #[prost(uint64, optional, tag="1")]
        pub base_addr: ::core::option::Option<u64>,
        #[prost(string, optional, tag="2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(uint32, optional, tag="3")]
        pub size: ::core::option::Option<u32>,
        #[prost(uint32, optional, tag="4")]
        pub timestamp: ::core::option::Option<u32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestInventory {
    #[prost(int32, optional, tag="1")]
    pub inventory: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub offset: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub options: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageInventoryResponse {
    #[prost(fixed32, optional, tag="1")]
    pub crc: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="2")]
    pub item_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub perf_time: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="7")]
    pub client_timestamp: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="8")]
    pub platform: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="9")]
    pub inventories: ::prost::alloc::vec::Vec<c_user_message_inventory_response::InventoryDetail>,
    #[prost(message, repeated, tag="10")]
    pub inventories2: ::prost::alloc::vec::Vec<c_user_message_inventory_response::InventoryDetail>,
    #[prost(message, repeated, tag="14")]
    pub inventories3: ::prost::alloc::vec::Vec<c_user_message_inventory_response::InventoryDetail>,
    #[prost(int32, optional, tag="11")]
    pub inv_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="12")]
    pub build_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="13")]
    pub instance: ::core::option::Option<i32>,
    #[prost(int64, optional, tag="15")]
    pub start_time: ::core::option::Option<i64>,
}
/// Nested message and enum types in `CUserMessage_Inventory_Response`.
pub mod c_user_message_inventory_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InventoryDetail {
        #[prost(int32, optional, tag="1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="2")]
        pub primary: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="3")]
        pub offset: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="4")]
        pub first: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="5")]
        pub base: ::core::option::Option<i64>,
        #[prost(string, optional, tag="6")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="7")]
        pub base_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="8")]
        pub base_detail: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="9")]
        pub base_time: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="10")]
        pub base_hash: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageRequestDiagnostic {
    #[prost(message, repeated, tag="1")]
    pub diagnostics: ::prost::alloc::vec::Vec<c_user_message_request_diagnostic::Diagnostic>,
}
/// Nested message and enum types in `CUserMessageRequestDiagnostic`.
pub mod c_user_message_request_diagnostic {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Diagnostic {
        #[prost(int32, optional, tag="1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="2")]
        pub offset: ::core::option::Option<i64>,
        #[prost(int32, optional, tag="3")]
        pub param: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="4")]
        pub length: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="5")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="6")]
        pub base: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="7")]
        pub range: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="8")]
        pub extent: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="9")]
        pub detail: ::core::option::Option<i64>,
        #[prost(string, optional, tag="10")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="11")]
        pub alias: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="bytes", optional, tag="12")]
        pub vardetail: ::core::option::Option<::prost::bytes::Bytes>,
        #[prost(int32, optional, tag="13")]
        pub context: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageDiagnosticResponse {
    #[prost(message, repeated, tag="1")]
    pub diagnostics: ::prost::alloc::vec::Vec<c_user_message_diagnostic_response::Diagnostic>,
    #[prost(int32, optional, tag="2")]
    pub build_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub instance: ::core::option::Option<i32>,
    #[prost(int64, optional, tag="4")]
    pub start_time: ::core::option::Option<i64>,
    #[prost(int32, optional, tag="5")]
    pub osversion: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub platform: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CUserMessage_Diagnostic_Response`.
pub mod c_user_message_diagnostic_response {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Diagnostic {
        #[prost(int32, optional, tag="1")]
        pub index: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="2")]
        pub offset: ::core::option::Option<i64>,
        #[prost(int32, optional, tag="3")]
        pub param: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="4")]
        pub length: ::core::option::Option<i32>,
        #[prost(bytes="bytes", optional, tag="5")]
        pub detail: ::core::option::Option<::prost::bytes::Bytes>,
        #[prost(int64, optional, tag="6")]
        pub base: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="7")]
        pub range: ::core::option::Option<i64>,
        #[prost(int32, optional, tag="8")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="10")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag="11")]
        pub alias: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bytes="bytes", optional, tag="12")]
        pub backup: ::core::option::Option<::prost::bytes::Bytes>,
        #[prost(int32, optional, tag="13")]
        pub context: ::core::option::Option<i32>,
        #[prost(int64, optional, tag="14")]
        pub control: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="15")]
        pub augment: ::core::option::Option<i64>,
        #[prost(int64, optional, tag="16")]
        pub placebo: ::core::option::Option<i64>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageExtraUserData {
    #[prost(int32, optional, tag="1")]
    pub item: ::core::option::Option<i32>,
    #[prost(int64, optional, tag="2")]
    pub value1: ::core::option::Option<i64>,
    #[prost(int64, optional, tag="3")]
    pub value2: ::core::option::Option<i64>,
    #[prost(bytes="bytes", repeated, tag="4")]
    pub detail1: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
    #[prost(bytes="bytes", repeated, tag="5")]
    pub detail2: ::prost::alloc::vec::Vec<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessageNotifyResponseFound {
    #[prost(int32, optional, tag="1", default="-1")]
    pub ent_index: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub rule_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="3")]
    pub response_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub response_concept: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="5")]
    pub criteria: ::prost::alloc::vec::Vec<c_user_message_notify_response_found::Criteria>,
    #[prost(uint32, repeated, tag="6")]
    pub int_criteria_names: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, repeated, tag="7")]
    pub int_criteria_values: ::prost::alloc::vec::Vec<i32>,
    #[prost(uint32, repeated, tag="8")]
    pub float_criteria_names: ::prost::alloc::vec::Vec<u32>,
    #[prost(float, repeated, packed="false", tag="9")]
    pub float_criteria_values: ::prost::alloc::vec::Vec<f32>,
    #[prost(uint32, repeated, tag="10")]
    pub symbol_criteria_names: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag="11")]
    pub symbol_criteria_values: ::prost::alloc::vec::Vec<u32>,
    #[prost(int32, optional, tag="12")]
    pub speak_result: ::core::option::Option<i32>,
}
/// Nested message and enum types in `CUserMessage_NotifyResponseFound`.
pub mod c_user_message_notify_response_found {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Criteria {
        #[prost(uint32, optional, tag="1")]
        pub name_symbol: ::core::option::Option<u32>,
        #[prost(string, optional, tag="2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserMessagePlayResponseConditional {
    #[prost(int32, optional, tag="1", default="-1")]
    pub ent_index: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed="false", tag="2")]
    pub player_slots: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, optional, tag="3")]
    pub response: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="4")]
    pub ent_origin: ::core::option::Option<CMsgVector>,
    #[prost(float, optional, tag="5")]
    pub pre_delay: ::core::option::Option<f32>,
    #[prost(int32, optional, tag="6")]
    pub mix_priority: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EBaseUserMessages {
    UmAchievementEvent = 101,
    UmCloseCaption = 102,
    UmCloseCaptionDirect = 103,
    UmCurrentTimescale = 104,
    UmDesiredTimescale = 105,
    UmFade = 106,
    UmGameTitle = 107,
    UmHudMsg = 110,
    UmHudText = 111,
    UmColoredText = 113,
    UmRequestState = 114,
    UmResetHud = 115,
    UmRumble = 116,
    UmSayText = 117,
    UmSayText2 = 118,
    UmSayTextChannel = 119,
    UmShake = 120,
    UmShakeDir = 121,
    UmWaterShake = 122,
    UmTextMsg = 124,
    UmScreenTilt = 125,
    UmVoiceMask = 128,
    UmSendAudio = 130,
    UmItemPickup = 131,
    UmAmmoDenied = 132,
    UmShowMenu = 134,
    UmCreditsMsg = 135,
    UmCloseCaptionPlaceholder = 142,
    UmCameraTransition = 143,
    UmAudioParameter = 144,
    UmParticleManager = 145,
    UmHudError = 146,
    UmCustomGameEvent = 148,
    UmAnimGraphUpdate = 149,
    UmHapticsManagerPulse = 150,
    UmHapticsManagerEffect = 151,
    UmCommandQueueState = 152,
    UmUpdateCssClasses = 153,
    UmServerFrameTime = 154,
    UmLagCompensationError = 155,
    UmRequestDllStatus = 156,
    UmRequestUtilAction = 157,
    UmUtilActionResponse = 158,
    UmDllStatusResponse = 159,
    UmRequestInventory = 160,
    UmInventoryResponse = 161,
    UmRequestDiagnostic = 162,
    UmDiagnosticResponse = 163,
    UmExtraUserData = 164,
    UmNotifyResponseFound = 165,
    UmPlayResponseConditional = 166,
    UmMaxBase = 200,
}
impl EBaseUserMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UmAchievementEvent => "UM_AchievementEvent",
            Self::UmCloseCaption => "UM_CloseCaption",
            Self::UmCloseCaptionDirect => "UM_CloseCaptionDirect",
            Self::UmCurrentTimescale => "UM_CurrentTimescale",
            Self::UmDesiredTimescale => "UM_DesiredTimescale",
            Self::UmFade => "UM_Fade",
            Self::UmGameTitle => "UM_GameTitle",
            Self::UmHudMsg => "UM_HudMsg",
            Self::UmHudText => "UM_HudText",
            Self::UmColoredText => "UM_ColoredText",
            Self::UmRequestState => "UM_RequestState",
            Self::UmResetHud => "UM_ResetHUD",
            Self::UmRumble => "UM_Rumble",
            Self::UmSayText => "UM_SayText",
            Self::UmSayText2 => "UM_SayText2",
            Self::UmSayTextChannel => "UM_SayTextChannel",
            Self::UmShake => "UM_Shake",
            Self::UmShakeDir => "UM_ShakeDir",
            Self::UmWaterShake => "UM_WaterShake",
            Self::UmTextMsg => "UM_TextMsg",
            Self::UmScreenTilt => "UM_ScreenTilt",
            Self::UmVoiceMask => "UM_VoiceMask",
            Self::UmSendAudio => "UM_SendAudio",
            Self::UmItemPickup => "UM_ItemPickup",
            Self::UmAmmoDenied => "UM_AmmoDenied",
            Self::UmShowMenu => "UM_ShowMenu",
            Self::UmCreditsMsg => "UM_CreditsMsg",
            Self::UmCloseCaptionPlaceholder => "UM_CloseCaptionPlaceholder",
            Self::UmCameraTransition => "UM_CameraTransition",
            Self::UmAudioParameter => "UM_AudioParameter",
            Self::UmParticleManager => "UM_ParticleManager",
            Self::UmHudError => "UM_HudError",
            Self::UmCustomGameEvent => "UM_CustomGameEvent",
            Self::UmAnimGraphUpdate => "UM_AnimGraphUpdate",
            Self::UmHapticsManagerPulse => "UM_HapticsManagerPulse",
            Self::UmHapticsManagerEffect => "UM_HapticsManagerEffect",
            Self::UmCommandQueueState => "UM_CommandQueueState",
            Self::UmUpdateCssClasses => "UM_UpdateCssClasses",
            Self::UmServerFrameTime => "UM_ServerFrameTime",
            Self::UmLagCompensationError => "UM_LagCompensationError",
            Self::UmRequestDllStatus => "UM_RequestDllStatus",
            Self::UmRequestUtilAction => "UM_RequestUtilAction",
            Self::UmUtilActionResponse => "UM_UtilActionResponse",
            Self::UmDllStatusResponse => "UM_DllStatusResponse",
            Self::UmRequestInventory => "UM_RequestInventory",
            Self::UmInventoryResponse => "UM_InventoryResponse",
            Self::UmRequestDiagnostic => "UM_RequestDiagnostic",
            Self::UmDiagnosticResponse => "UM_DiagnosticResponse",
            Self::UmExtraUserData => "UM_ExtraUserData",
            Self::UmNotifyResponseFound => "UM_NotifyResponseFound",
            Self::UmPlayResponseConditional => "UM_PlayResponseConditional",
            Self::UmMaxBase => "UM_MAX_BASE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UM_AchievementEvent" => Some(Self::UmAchievementEvent),
            "UM_CloseCaption" => Some(Self::UmCloseCaption),
            "UM_CloseCaptionDirect" => Some(Self::UmCloseCaptionDirect),
            "UM_CurrentTimescale" => Some(Self::UmCurrentTimescale),
            "UM_DesiredTimescale" => Some(Self::UmDesiredTimescale),
            "UM_Fade" => Some(Self::UmFade),
            "UM_GameTitle" => Some(Self::UmGameTitle),
            "UM_HudMsg" => Some(Self::UmHudMsg),
            "UM_HudText" => Some(Self::UmHudText),
            "UM_ColoredText" => Some(Self::UmColoredText),
            "UM_RequestState" => Some(Self::UmRequestState),
            "UM_ResetHUD" => Some(Self::UmResetHud),
            "UM_Rumble" => Some(Self::UmRumble),
            "UM_SayText" => Some(Self::UmSayText),
            "UM_SayText2" => Some(Self::UmSayText2),
            "UM_SayTextChannel" => Some(Self::UmSayTextChannel),
            "UM_Shake" => Some(Self::UmShake),
            "UM_ShakeDir" => Some(Self::UmShakeDir),
            "UM_WaterShake" => Some(Self::UmWaterShake),
            "UM_TextMsg" => Some(Self::UmTextMsg),
            "UM_ScreenTilt" => Some(Self::UmScreenTilt),
            "UM_VoiceMask" => Some(Self::UmVoiceMask),
            "UM_SendAudio" => Some(Self::UmSendAudio),
            "UM_ItemPickup" => Some(Self::UmItemPickup),
            "UM_AmmoDenied" => Some(Self::UmAmmoDenied),
            "UM_ShowMenu" => Some(Self::UmShowMenu),
            "UM_CreditsMsg" => Some(Self::UmCreditsMsg),
            "UM_CloseCaptionPlaceholder" => Some(Self::UmCloseCaptionPlaceholder),
            "UM_CameraTransition" => Some(Self::UmCameraTransition),
            "UM_AudioParameter" => Some(Self::UmAudioParameter),
            "UM_ParticleManager" => Some(Self::UmParticleManager),
            "UM_HudError" => Some(Self::UmHudError),
            "UM_CustomGameEvent" => Some(Self::UmCustomGameEvent),
            "UM_AnimGraphUpdate" => Some(Self::UmAnimGraphUpdate),
            "UM_HapticsManagerPulse" => Some(Self::UmHapticsManagerPulse),
            "UM_HapticsManagerEffect" => Some(Self::UmHapticsManagerEffect),
            "UM_CommandQueueState" => Some(Self::UmCommandQueueState),
            "UM_UpdateCssClasses" => Some(Self::UmUpdateCssClasses),
            "UM_ServerFrameTime" => Some(Self::UmServerFrameTime),
            "UM_LagCompensationError" => Some(Self::UmLagCompensationError),
            "UM_RequestDllStatus" => Some(Self::UmRequestDllStatus),
            "UM_RequestUtilAction" => Some(Self::UmRequestUtilAction),
            "UM_UtilActionResponse" => Some(Self::UmUtilActionResponse),
            "UM_DllStatusResponse" => Some(Self::UmDllStatusResponse),
            "UM_RequestInventory" => Some(Self::UmRequestInventory),
            "UM_InventoryResponse" => Some(Self::UmInventoryResponse),
            "UM_RequestDiagnostic" => Some(Self::UmRequestDiagnostic),
            "UM_DiagnosticResponse" => Some(Self::UmDiagnosticResponse),
            "UM_ExtraUserData" => Some(Self::UmExtraUserData),
            "UM_NotifyResponseFound" => Some(Self::UmNotifyResponseFound),
            "UM_PlayResponseConditional" => Some(Self::UmPlayResponseConditional),
            "UM_MAX_BASE" => Some(Self::UmMaxBase),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EBaseEntityMessages {
    EmPlayJingle = 136,
    EmScreenOverlay = 137,
    EmRemoveAllDecals = 138,
    EmPropagateForce = 139,
    EmDoSpark = 140,
    EmFixAngle = 141,
}
impl EBaseEntityMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::EmPlayJingle => "EM_PlayJingle",
            Self::EmScreenOverlay => "EM_ScreenOverlay",
            Self::EmRemoveAllDecals => "EM_RemoveAllDecals",
            Self::EmPropagateForce => "EM_PropagateForce",
            Self::EmDoSpark => "EM_DoSpark",
            Self::EmFixAngle => "EM_FixAngle",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EM_PlayJingle" => Some(Self::EmPlayJingle),
            "EM_ScreenOverlay" => Some(Self::EmScreenOverlay),
            "EM_RemoveAllDecals" => Some(Self::EmRemoveAllDecals),
            "EM_PropagateForce" => Some(Self::EmPropagateForce),
            "EM_DoSpark" => Some(Self::EmDoSpark),
            "EM_FixAngle" => Some(Self::EmFixAngle),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ERollType {
    RollNone = -1,
    RollStats = 0,
    RollCredits = 1,
    RollLateJoinLogo = 2,
    RollOuttro = 3,
}
impl ERollType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RollNone => "ROLL_NONE",
            Self::RollStats => "ROLL_STATS",
            Self::RollCredits => "ROLL_CREDITS",
            Self::RollLateJoinLogo => "ROLL_LATE_JOIN_LOGO",
            Self::RollOuttro => "ROLL_OUTTRO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROLL_NONE" => Some(Self::RollNone),
            "ROLL_STATS" => Some(Self::RollStats),
            "ROLL_CREDITS" => Some(Self::RollCredits),
            "ROLL_LATE_JOIN_LOGO" => Some(Self::RollLateJoinLogo),
            "ROLL_OUTTRO" => Some(Self::RollOuttro),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParticleMessage {
    GameParticleManagerEventCreate = 0,
    GameParticleManagerEventUpdate = 1,
    GameParticleManagerEventUpdateForward = 2,
    GameParticleManagerEventUpdateOrientation = 3,
    GameParticleManagerEventUpdateFallback = 4,
    GameParticleManagerEventUpdateEnt = 5,
    GameParticleManagerEventUpdateOffset = 6,
    GameParticleManagerEventDestroy = 7,
    GameParticleManagerEventDestroyInvolving = 8,
    GameParticleManagerEventRelease = 9,
    GameParticleManagerEventLatency = 10,
    GameParticleManagerEventShouldDraw = 11,
    GameParticleManagerEventFrozen = 12,
    GameParticleManagerEventChangeControlPointAttachment = 13,
    GameParticleManagerEventUpdateEntityPosition = 14,
    GameParticleManagerEventSetFowProperties = 15,
    GameParticleManagerEventSetText = 16,
    GameParticleManagerEventSetShouldCheckFow = 17,
    GameParticleManagerEventSetControlPointModel = 18,
    GameParticleManagerEventSetControlPointSnapshot = 19,
    GameParticleManagerEventSetTextureAttribute = 20,
    GameParticleManagerEventSetSceneObjectGenericFlag = 21,
    GameParticleManagerEventSetSceneObjectTintAndDesat = 22,
    GameParticleManagerEventDestroyNamed = 23,
    GameParticleManagerEventSkipToTime = 24,
    GameParticleManagerEventCanFreeze = 25,
    GameParticleManagerEventSetNamedValueContext = 26,
    GameParticleManagerEventUpdateTransform = 27,
    GameParticleManagerEventFreezeTransitionOverride = 28,
    GameParticleManagerEventFreezeInvolving = 29,
    GameParticleManagerEventAddModellistOverrideElement = 30,
    GameParticleManagerEventClearModellistOverride = 31,
    GameParticleManagerEventCreatePhysicsSim = 32,
    GameParticleManagerEventDestroyPhysicsSim = 33,
    GameParticleManagerEventSetVdata = 34,
    GameParticleManagerEventSetMaterialOverride = 35,
}
impl ParticleMessage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::GameParticleManagerEventCreate => "GAME_PARTICLE_MANAGER_EVENT_CREATE",
            Self::GameParticleManagerEventUpdate => "GAME_PARTICLE_MANAGER_EVENT_UPDATE",
            Self::GameParticleManagerEventUpdateForward => "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD",
            Self::GameParticleManagerEventUpdateOrientation => "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION",
            Self::GameParticleManagerEventUpdateFallback => "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK",
            Self::GameParticleManagerEventUpdateEnt => "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT",
            Self::GameParticleManagerEventUpdateOffset => "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET",
            Self::GameParticleManagerEventDestroy => "GAME_PARTICLE_MANAGER_EVENT_DESTROY",
            Self::GameParticleManagerEventDestroyInvolving => "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING",
            Self::GameParticleManagerEventRelease => "GAME_PARTICLE_MANAGER_EVENT_RELEASE",
            Self::GameParticleManagerEventLatency => "GAME_PARTICLE_MANAGER_EVENT_LATENCY",
            Self::GameParticleManagerEventShouldDraw => "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW",
            Self::GameParticleManagerEventFrozen => "GAME_PARTICLE_MANAGER_EVENT_FROZEN",
            Self::GameParticleManagerEventChangeControlPointAttachment => "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT",
            Self::GameParticleManagerEventUpdateEntityPosition => "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION",
            Self::GameParticleManagerEventSetFowProperties => "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES",
            Self::GameParticleManagerEventSetText => "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT",
            Self::GameParticleManagerEventSetShouldCheckFow => "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW",
            Self::GameParticleManagerEventSetControlPointModel => "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL",
            Self::GameParticleManagerEventSetControlPointSnapshot => "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT",
            Self::GameParticleManagerEventSetTextureAttribute => "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE",
            Self::GameParticleManagerEventSetSceneObjectGenericFlag => "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG",
            Self::GameParticleManagerEventSetSceneObjectTintAndDesat => "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT",
            Self::GameParticleManagerEventDestroyNamed => "GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED",
            Self::GameParticleManagerEventSkipToTime => "GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME",
            Self::GameParticleManagerEventCanFreeze => "GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE",
            Self::GameParticleManagerEventSetNamedValueContext => "GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT",
            Self::GameParticleManagerEventUpdateTransform => "GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM",
            Self::GameParticleManagerEventFreezeTransitionOverride => "GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE",
            Self::GameParticleManagerEventFreezeInvolving => "GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING",
            Self::GameParticleManagerEventAddModellistOverrideElement => "GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT",
            Self::GameParticleManagerEventClearModellistOverride => "GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE",
            Self::GameParticleManagerEventCreatePhysicsSim => "GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM",
            Self::GameParticleManagerEventDestroyPhysicsSim => "GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM",
            Self::GameParticleManagerEventSetVdata => "GAME_PARTICLE_MANAGER_EVENT_SET_VDATA",
            Self::GameParticleManagerEventSetMaterialOverride => "GAME_PARTICLE_MANAGER_EVENT_SET_MATERIAL_OVERRIDE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GAME_PARTICLE_MANAGER_EVENT_CREATE" => Some(Self::GameParticleManagerEventCreate),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE" => Some(Self::GameParticleManagerEventUpdate),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD" => Some(Self::GameParticleManagerEventUpdateForward),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION" => Some(Self::GameParticleManagerEventUpdateOrientation),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK" => Some(Self::GameParticleManagerEventUpdateFallback),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT" => Some(Self::GameParticleManagerEventUpdateEnt),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET" => Some(Self::GameParticleManagerEventUpdateOffset),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY" => Some(Self::GameParticleManagerEventDestroy),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING" => Some(Self::GameParticleManagerEventDestroyInvolving),
            "GAME_PARTICLE_MANAGER_EVENT_RELEASE" => Some(Self::GameParticleManagerEventRelease),
            "GAME_PARTICLE_MANAGER_EVENT_LATENCY" => Some(Self::GameParticleManagerEventLatency),
            "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW" => Some(Self::GameParticleManagerEventShouldDraw),
            "GAME_PARTICLE_MANAGER_EVENT_FROZEN" => Some(Self::GameParticleManagerEventFrozen),
            "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT" => Some(Self::GameParticleManagerEventChangeControlPointAttachment),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION" => Some(Self::GameParticleManagerEventUpdateEntityPosition),
            "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES" => Some(Self::GameParticleManagerEventSetFowProperties),
            "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT" => Some(Self::GameParticleManagerEventSetText),
            "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW" => Some(Self::GameParticleManagerEventSetShouldCheckFow),
            "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL" => Some(Self::GameParticleManagerEventSetControlPointModel),
            "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT" => Some(Self::GameParticleManagerEventSetControlPointSnapshot),
            "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE" => Some(Self::GameParticleManagerEventSetTextureAttribute),
            "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG" => Some(Self::GameParticleManagerEventSetSceneObjectGenericFlag),
            "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT" => Some(Self::GameParticleManagerEventSetSceneObjectTintAndDesat),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED" => Some(Self::GameParticleManagerEventDestroyNamed),
            "GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME" => Some(Self::GameParticleManagerEventSkipToTime),
            "GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE" => Some(Self::GameParticleManagerEventCanFreeze),
            "GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT" => Some(Self::GameParticleManagerEventSetNamedValueContext),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM" => Some(Self::GameParticleManagerEventUpdateTransform),
            "GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE" => Some(Self::GameParticleManagerEventFreezeTransitionOverride),
            "GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING" => Some(Self::GameParticleManagerEventFreezeInvolving),
            "GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT" => Some(Self::GameParticleManagerEventAddModellistOverrideElement),
            "GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE" => Some(Self::GameParticleManagerEventClearModellistOverride),
            "GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM" => Some(Self::GameParticleManagerEventCreatePhysicsSim),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM" => Some(Self::GameParticleManagerEventDestroyPhysicsSim),
            "GAME_PARTICLE_MANAGER_EVENT_SET_VDATA" => Some(Self::GameParticleManagerEventSetVdata),
            "GAME_PARTICLE_MANAGER_EVENT_SET_MATERIAL_OVERRIDE" => Some(Self::GameParticleManagerEventSetMaterialOverride),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EHapticPulseType {
    VrHandHapticPulseLight = 0,
    VrHandHapticPulseMedium = 1,
    VrHandHapticPulseStrong = 2,
}
impl EHapticPulseType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VrHandHapticPulseLight => "VR_HAND_HAPTIC_PULSE_LIGHT",
            Self::VrHandHapticPulseMedium => "VR_HAND_HAPTIC_PULSE_MEDIUM",
            Self::VrHandHapticPulseStrong => "VR_HAND_HAPTIC_PULSE_STRONG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VR_HAND_HAPTIC_PULSE_LIGHT" => Some(Self::VrHandHapticPulseLight),
            "VR_HAND_HAPTIC_PULSE_MEDIUM" => Some(Self::VrHandHapticPulseMedium),
            "VR_HAND_HAPTIC_PULSE_STRONG" => Some(Self::VrHandHapticPulseStrong),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgClientInfo {
    #[prost(fixed32, optional, tag="1")]
    pub send_table_crc: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="2")]
    pub server_count: ::core::option::Option<u32>,
    #[prost(bool, optional, tag="3")]
    pub is_hltv: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag="5")]
    pub friends_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag="6")]
    pub friends_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgMove {
    #[prost(bytes="bytes", optional, tag="3")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag="4")]
    pub last_command_number: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgVoiceAudio {
    #[prost(enumeration="VoiceDataFormatT", optional, tag="1", default="VoicedataFormatSteam")]
    pub format: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub voice_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(int32, optional, tag="3")]
    pub sequence_bytes: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="4")]
    pub section_number: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="5")]
    pub sample_rate: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="6")]
    pub uncompressed_sample_offset: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="7")]
    pub num_packets: ::core::option::Option<u32>,
    #[prost(uint32, repeated, tag="8")]
    pub packet_offsets: ::prost::alloc::vec::Vec<u32>,
    #[prost(float, optional, tag="9")]
    pub voice_level: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgVoiceData {
    #[prost(message, optional, tag="1")]
    pub audio: ::core::option::Option<CMsgVoiceAudio>,
    #[prost(fixed64, optional, tag="2")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="3")]
    pub tick: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgBaselineAck {
    #[prost(int32, optional, tag="1")]
    pub baseline_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub baseline_nr: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgListenEvents {
    #[prost(fixed32, repeated, packed="false", tag="1")]
    pub event_mask: ::prost::alloc::vec::Vec<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgRespondCvarValue {
    #[prost(int32, optional, tag="1")]
    pub cookie: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub status_code: ::core::option::Option<i32>,
    #[prost(string, optional, tag="3")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="4")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgFileCrcCheck {
    #[prost(int32, optional, tag="1")]
    pub code_path: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="3")]
    pub code_filename: ::core::option::Option<i32>,
    #[prost(string, optional, tag="4")]
    pub filename: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(fixed32, optional, tag="5")]
    pub crc: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgLoadingProgress {
    #[prost(int32, optional, tag="1")]
    pub progress: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgSplitPlayerConnect {
    #[prost(string, optional, tag="1")]
    pub playername: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgSplitPlayerDisconnect {
    #[prost(int32, optional, tag="1")]
    pub slot: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgServerStatus {
    #[prost(bool, optional, tag="1")]
    pub simplified: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgRequestPause {
    #[prost(enumeration="RequestPauseT", optional, tag="1", default="RpPause")]
    pub pause_type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub pause_group: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgCmdKeyValues {
    #[prost(bytes="bytes", optional, tag="1")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgRconServerDetails {
    #[prost(bytes="bytes", optional, tag="1")]
    pub token: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource2SystemSpecs {
    #[prost(string, optional, tag="1")]
    pub cpu_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="2")]
    pub cpu_brand: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="3")]
    pub cpu_model: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub cpu_num_physical: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="21")]
    pub ram_physical_total_mb: ::core::option::Option<u32>,
    #[prost(string, optional, tag="41")]
    pub gpu_rendersystem_dll_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="42")]
    pub gpu_vendor_id: ::core::option::Option<u32>,
    #[prost(string, optional, tag="43")]
    pub gpu_driver_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="44")]
    pub gpu_driver_version_high: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="45")]
    pub gpu_driver_version_low: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="46")]
    pub gpu_dx_support_level: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="47")]
    pub gpu_texture_memory_size_mb: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource2VProfLiteReportItem {
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="2")]
    pub active_samples: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="4")]
    pub active_samples_1secmax: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="3")]
    pub usec_max: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="11")]
    pub usec_avg_active: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="12")]
    pub usec_p50_active: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="13")]
    pub usec_p99_active: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="21")]
    pub usec_avg_all: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="22")]
    pub usec_p50_all: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="23")]
    pub usec_p99_all: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="31")]
    pub usec_1secmax_avg_active: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="32")]
    pub usec_1secmax_p50_active: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="33")]
    pub usec_1secmax_p95_active: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="34")]
    pub usec_1secmax_p99_active: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="41")]
    pub usec_1secmax_avg_all: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="42")]
    pub usec_1secmax_p50_all: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="43")]
    pub usec_1secmax_p95_all: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="44")]
    pub usec_1secmax_p99_all: ::core::option::Option<u32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgSource2VProfLiteReport {
    #[prost(message, optional, tag="1")]
    pub total: ::core::option::Option<CMsgSource2VProfLiteReportItem>,
    #[prost(message, repeated, tag="2")]
    pub items: ::prost::alloc::vec::Vec<CMsgSource2VProfLiteReportItem>,
    #[prost(uint32, optional, tag="3")]
    pub discarded_frames: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgSource2NetworkFlowQuality {
    #[prost(uint32, optional, tag="1")]
    pub duration: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="5")]
    pub bytes_total: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="6")]
    pub bytes_total_reliable: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="7")]
    pub bytes_total_voice: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="10")]
    pub bytes_sec_p95: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="11")]
    pub bytes_sec_p99: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="20")]
    pub enginemsgs_total: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="21")]
    pub enginemsgs_sec_p95: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="22")]
    pub enginemsgs_sec_p99: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="40")]
    pub ticks_total: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="41")]
    pub ticks_good: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="42")]
    pub ticks_good_almost_late: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="43")]
    pub ticks_fixed_dropped: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="44")]
    pub ticks_fixed_late: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="45")]
    pub ticks_bad_dropped: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="46")]
    pub ticks_bad_late: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="47")]
    pub ticks_bad_other: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="50")]
    pub tick_missrate_samples_total: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="51")]
    pub tick_missrate_samples_perfect: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="52")]
    pub tick_missrate_samples_perfectnet: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="53")]
    pub tick_missratenet_p75_x10: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="54")]
    pub tick_missratenet_p95_x10: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="55")]
    pub tick_missratenet_p99_x10: ::core::option::Option<u32>,
    #[prost(sint32, optional, tag="61")]
    pub recvmargin_p1: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag="62")]
    pub recvmargin_p5: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag="63")]
    pub recvmargin_p25: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag="64")]
    pub recvmargin_p50: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag="65")]
    pub recvmargin_p75: ::core::option::Option<i32>,
    #[prost(sint32, optional, tag="66")]
    pub recvmargin_p95: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgDiagnostic {
    #[prost(message, optional, tag="1")]
    pub system_specs: ::core::option::Option<CMsgSource2SystemSpecs>,
    #[prost(message, optional, tag="2")]
    pub vprof_report: ::core::option::Option<CMsgSource2VProfLiteReport>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CSource2MetricsMatchPerfSummaryNotification {
    #[prost(uint32, optional, tag="1")]
    pub appid: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub game_mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag="3")]
    pub server_build_id: ::core::option::Option<u32>,
    #[prost(message, optional, tag="10")]
    pub server_profile: ::core::option::Option<CMsgSource2VProfLiteReport>,
    #[prost(message, repeated, tag="11")]
    pub clients: ::prost::alloc::vec::Vec<c_source2_metrics_match_perf_summary_notification::Client>,
    #[prost(string, optional, tag="20")]
    pub map: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `CSource2Metrics_MatchPerfSummary_Notification`.
pub mod c_source2_metrics_match_perf_summary_notification {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Client {
        #[prost(message, optional, tag="1")]
        pub system_specs: ::core::option::Option<super::CMsgSource2SystemSpecs>,
        #[prost(message, optional, tag="2")]
        pub profile: ::core::option::Option<super::CMsgSource2VProfLiteReport>,
        #[prost(uint32, optional, tag="3")]
        pub build_id: ::core::option::Option<u32>,
        #[prost(fixed64, optional, tag="10")]
        pub steamid: ::core::option::Option<u64>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgServerInfo {
    #[prost(int32, optional, tag="1")]
    pub protocol: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub server_count: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="3")]
    pub is_dedicated: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="4")]
    pub is_hltv: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="6")]
    pub c_os: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="10")]
    pub max_clients: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="11")]
    pub max_classes: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="12", default="-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(float, optional, tag="13")]
    pub tick_interval: ::core::option::Option<f32>,
    #[prost(string, optional, tag="14")]
    pub game_dir: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="15")]
    pub map_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="16")]
    pub sky_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="17")]
    pub host_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag="18")]
    pub addon_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag="19")]
    pub game_session_config: ::core::option::Option<CsvcMsgGameSessionConfiguration>,
    #[prost(bytes="bytes", optional, tag="20")]
    pub game_session_manifest: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgClassInfo {
    #[prost(bool, optional, tag="1")]
    pub create_on_client: ::core::option::Option<bool>,
    #[prost(message, repeated, tag="2")]
    pub classes: ::prost::alloc::vec::Vec<csvc_msg_class_info::ClassT>,
}
/// Nested message and enum types in `CSVCMsg_ClassInfo`.
pub mod csvc_msg_class_info {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClassT {
        #[prost(int32, optional, tag="1")]
        pub class_id: ::core::option::Option<i32>,
        #[prost(string, optional, tag="3")]
        pub class_name: ::core::option::Option<::prost::alloc::string::String>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgSetPause {
    #[prost(bool, optional, tag="1")]
    pub paused: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgVoiceInit {
    #[prost(int32, optional, tag="1")]
    pub quality: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub codec: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="3", default="0")]
    pub version: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPrint {
    #[prost(string, optional, tag="1")]
    pub text: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSounds {
    #[prost(bool, optional, tag="1")]
    pub reliable_sound: ::core::option::Option<bool>,
    #[prost(message, repeated, tag="2")]
    pub sounds: ::prost::alloc::vec::Vec<csvc_msg_sounds::SounddataT>,
}
/// Nested message and enum types in `CSVCMsg_Sounds`.
pub mod csvc_msg_sounds {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct SounddataT {
        #[prost(sint32, optional, tag="1")]
        pub origin_x: ::core::option::Option<i32>,
        #[prost(sint32, optional, tag="2")]
        pub origin_y: ::core::option::Option<i32>,
        #[prost(sint32, optional, tag="3")]
        pub origin_z: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag="4")]
        pub volume: ::core::option::Option<u32>,
        #[prost(float, optional, tag="5")]
        pub delay_value: ::core::option::Option<f32>,
        #[prost(int32, optional, tag="6")]
        pub sequence_number: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="7", default="-1")]
        pub entity_index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="8")]
        pub channel: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="9")]
        pub pitch: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="10")]
        pub flags: ::core::option::Option<i32>,
        #[prost(uint32, optional, tag="11")]
        pub sound_num: ::core::option::Option<u32>,
        #[prost(fixed32, optional, tag="12")]
        pub sound_num_handle: ::core::option::Option<u32>,
        #[prost(int32, optional, tag="13")]
        pub speaker_entity: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="14")]
        pub random_seed: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="15")]
        pub sound_level: ::core::option::Option<i32>,
        #[prost(bool, optional, tag="16")]
        pub is_sentence: ::core::option::Option<bool>,
        #[prost(bool, optional, tag="17")]
        pub is_ambient: ::core::option::Option<bool>,
        #[prost(uint32, optional, tag="18")]
        pub guid: ::core::option::Option<u32>,
        #[prost(fixed64, optional, tag="19")]
        pub sound_resource_id: ::core::option::Option<u64>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgPrefetch {
    #[prost(int32, optional, tag="1")]
    pub sound_index: ::core::option::Option<i32>,
    #[prost(enumeration="PrefetchType", optional, tag="2", default="PftSound")]
    pub resource_type: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgSetView {
    #[prost(int32, optional, tag="1", default="-1")]
    pub entity_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2", default="-1")]
    pub slot: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgFixAngle {
    #[prost(bool, optional, tag="1")]
    pub relative: ::core::option::Option<bool>,
    #[prost(message, optional, tag="2")]
    pub angle: ::core::option::Option<CMsgQAngle>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgCrosshairAngle {
    #[prost(message, optional, tag="1")]
    pub angle: ::core::option::Option<CMsgQAngle>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgBspDecal {
    #[prost(message, optional, tag="1")]
    pub pos: ::core::option::Option<CMsgVector>,
    #[prost(int32, optional, tag="2")]
    pub decal_texture_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3", default="-1")]
    pub entity_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub model_index: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="5")]
    pub low_priority: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgSplitScreen {
    #[prost(enumeration="ESplitScreenMessageType", optional, tag="1", default="MsgSplitscreenAdduser")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3", default="-1")]
    pub player_index: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgGetCvarValue {
    #[prost(int32, optional, tag="1")]
    pub cookie: ::core::option::Option<i32>,
    #[prost(string, optional, tag="2")]
    pub cvar_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgMenu {
    #[prost(int32, optional, tag="1")]
    pub dialog_type: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub menu_key_values: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgUserMessage {
    #[prost(int32, optional, tag="1")]
    pub msg_type: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub msg_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(int32, optional, tag="3")]
    pub passthrough: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgSendTable {
    #[prost(bool, optional, tag="1")]
    pub is_end: ::core::option::Option<bool>,
    #[prost(string, optional, tag="2")]
    pub net_table_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="3")]
    pub needs_decoder: ::core::option::Option<bool>,
    #[prost(message, repeated, tag="4")]
    pub props: ::prost::alloc::vec::Vec<csvc_msg_send_table::SendpropT>,
}
/// Nested message and enum types in `CSVCMsg_SendTable`.
pub mod csvc_msg_send_table {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SendpropT {
        #[prost(int32, optional, tag="1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub var_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="3")]
        pub flags: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="4")]
        pub priority: ::core::option::Option<i32>,
        #[prost(string, optional, tag="5")]
        pub dt_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="6")]
        pub num_elements: ::core::option::Option<i32>,
        #[prost(float, optional, tag="7")]
        pub low_value: ::core::option::Option<f32>,
        #[prost(float, optional, tag="8")]
        pub high_value: ::core::option::Option<f32>,
        #[prost(int32, optional, tag="9")]
        pub num_bits: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgGameEventList {
    #[prost(message, repeated, tag="1")]
    pub descriptors: ::prost::alloc::vec::Vec<csvc_msg_game_event_list::DescriptorT>,
}
/// Nested message and enum types in `CSVCMsg_GameEventList`.
pub mod csvc_msg_game_event_list {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct KeyT {
        #[prost(int32, optional, tag="1")]
        pub r#type: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DescriptorT {
        #[prost(int32, optional, tag="1")]
        pub eventid: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, repeated, tag="3")]
        pub keys: ::prost::alloc::vec::Vec<KeyT>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPacketEntities {
    #[prost(int32, optional, tag="1")]
    pub max_entries: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub updated_entries: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="3")]
    pub legacy_is_delta: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="4")]
    pub update_baseline: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="5")]
    pub baseline: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub delta_from: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="7")]
    pub entity_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(bool, optional, tag="8")]
    pub pending_full_frame: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag="9")]
    pub active_spawngroup_handle: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="10")]
    pub max_spawngroup_creationsequence: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="11")]
    pub last_cmd_number_executed: ::core::option::Option<u32>,
    #[prost(sint32, optional, tag="17")]
    pub last_cmd_number_recv_delta: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="12")]
    pub server_tick: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="13")]
    pub serialized_entities: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(message, repeated, tag="15")]
    pub alternate_baselines: ::prost::alloc::vec::Vec<csvc_msg_packet_entities::AlternateBaselineT>,
    #[prost(uint32, optional, tag="16")]
    pub has_pvs_vis_bits: ::core::option::Option<u32>,
    #[prost(sint32, repeated, tag="22")]
    pub cmd_recv_status: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag="19")]
    pub non_transmitted_entities: ::core::option::Option<csvc_msg_packet_entities::NonTransmittedEntitiesT>,
    #[prost(uint32, optional, tag="20")]
    pub cq_starved_command_ticks: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag="21")]
    pub cq_discarded_command_ticks: ::core::option::Option<u32>,
    #[prost(bytes="bytes", optional, tag="999")]
    pub dev_padding: ::core::option::Option<::prost::bytes::Bytes>,
}
/// Nested message and enum types in `CSVCMsg_PacketEntities`.
pub mod csvc_msg_packet_entities {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct AlternateBaselineT {
        #[prost(int32, optional, tag="1")]
        pub entity_index: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub baseline_index: ::core::option::Option<i32>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NonTransmittedEntitiesT {
        #[prost(int32, optional, tag="1")]
        pub header_count: ::core::option::Option<i32>,
        #[prost(bytes="bytes", optional, tag="2")]
        pub data: ::core::option::Option<::prost::bytes::Bytes>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgTempEntities {
    #[prost(bool, optional, tag="1")]
    pub reliable: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="2")]
    pub num_entries: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="3")]
    pub entity_data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgCreateStringTable {
    #[prost(string, optional, tag="1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="2")]
    pub num_entries: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="3")]
    pub user_data_fixed_size: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="4")]
    pub user_data_size: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub user_data_size_bits: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub flags: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="7")]
    pub string_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(int32, optional, tag="8")]
    pub uncompressed_size: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="9")]
    pub data_compressed: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="10")]
    pub using_varint_bitcounts: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgUpdateStringTable {
    #[prost(int32, optional, tag="1")]
    pub table_id: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub num_changed_entries: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="3")]
    pub string_data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgVoiceData {
    #[prost(message, optional, tag="1")]
    pub audio: ::core::option::Option<CMsgVoiceAudio>,
    #[prost(int32, optional, tag="2", default="-1")]
    pub client: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="3")]
    pub proximity: ::core::option::Option<bool>,
    #[prost(fixed64, optional, tag="4")]
    pub xuid: ::core::option::Option<u64>,
    #[prost(int32, optional, tag="5")]
    pub audible_mask: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="6")]
    pub tick: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="7")]
    pub passthrough: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgPacketReliable {
    #[prost(int32, optional, tag="1")]
    pub tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub messagessize: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="3")]
    pub state: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgFullFrameSplit {
    #[prost(int32, optional, tag="1")]
    pub tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub section: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub total: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="4")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgHltvStatus {
    #[prost(string, optional, tag="1")]
    pub master: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag="2")]
    pub clients: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub slots: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub proxies: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgServerSteamId {
    #[prost(uint64, optional, tag="1")]
    pub steam_id: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgCmdKeyValues {
    #[prost(bytes="bytes", optional, tag="1")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgRconServerDetails {
    #[prost(bytes="bytes", optional, tag="1")]
    pub token: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, optional, tag="2")]
    pub details: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgIpcAddress {
    #[prost(fixed64, optional, tag="1")]
    pub computer_guid: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag="2")]
    pub process_id: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CMsgServerPeer {
    #[prost(int32, optional, tag="1", default="-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(fixed64, optional, tag="2")]
    pub steamid: ::core::option::Option<u64>,
    #[prost(message, optional, tag="3")]
    pub ipc: ::core::option::Option<CMsgIpcAddress>,
    #[prost(bool, optional, tag="4")]
    pub they_hear_you: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="5")]
    pub you_hear_them: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="6")]
    pub is_listenserver_host: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgPeerList {
    #[prost(message, repeated, tag="1")]
    pub peer: ::prost::alloc::vec::Vec<CMsgServerPeer>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgClearAllStringTables {
    #[prost(string, optional, tag="1")]
    pub mapname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag="3")]
    pub create_tables_skipped: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoFlattenedSerializerFieldT {
    #[prost(int32, optional, tag="1")]
    pub var_type_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub var_name_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub bit_count: ::core::option::Option<i32>,
    #[prost(float, optional, tag="4")]
    pub low_value: ::core::option::Option<f32>,
    #[prost(float, optional, tag="5")]
    pub high_value: ::core::option::Option<f32>,
    #[prost(int32, optional, tag="6")]
    pub encode_flags: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="7")]
    pub field_serializer_name_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="8")]
    pub field_serializer_version: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="9")]
    pub send_node_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="10")]
    pub var_encoder_sym: ::core::option::Option<i32>,
    #[prost(message, repeated, tag="11")]
    pub polymorphic_types: ::prost::alloc::vec::Vec<proto_flattened_serializer_field_t::PolymorphicFieldT>,
    #[prost(int32, optional, tag="12")]
    pub var_serializer_sym: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ProtoFlattenedSerializerField_t`.
pub mod proto_flattened_serializer_field_t {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PolymorphicFieldT {
        #[prost(int32, optional, tag="1")]
        pub polymorphic_field_serializer_name_sym: ::core::option::Option<i32>,
        #[prost(int32, optional, tag="2")]
        pub polymorphic_field_serializer_version: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoFlattenedSerializerT {
    #[prost(int32, optional, tag="1")]
    pub serializer_name_sym: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub serializer_version: ::core::option::Option<i32>,
    #[prost(int32, repeated, packed="false", tag="3")]
    pub fields_index: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgFlattenedSerializer {
    #[prost(message, repeated, tag="1")]
    pub serializers: ::prost::alloc::vec::Vec<ProtoFlattenedSerializerT>,
    #[prost(string, repeated, tag="2")]
    pub symbols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="3")]
    pub fields: ::prost::alloc::vec::Vec<ProtoFlattenedSerializerFieldT>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgStopSound {
    #[prost(fixed32, optional, tag="1")]
    pub guid: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CBidirMsgRebroadcastGameEvent {
    #[prost(bool, optional, tag="1")]
    pub posttoserver: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="2")]
    pub buftype: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="3")]
    pub clientbitcount: ::core::option::Option<u32>,
    #[prost(uint64, optional, tag="4")]
    pub receivingclients: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CBidirMsgRebroadcastSource {
    #[prost(int32, optional, tag="1")]
    pub eventsource: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgServerNetworkStats {
    #[prost(bool, optional, tag="1")]
    pub dedicated: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="2")]
    pub cpu_usage: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub memory_used_mb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub memory_free_mb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub uptime: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub spawn_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="8")]
    pub num_clients: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="9")]
    pub num_bots: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="10")]
    pub num_spectators: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="11")]
    pub num_tv_relays: ::core::option::Option<i32>,
    #[prost(float, optional, tag="12")]
    pub fps: ::core::option::Option<f32>,
    #[prost(message, repeated, tag="17")]
    pub ports: ::prost::alloc::vec::Vec<c_msg_server_network_stats::Port>,
    #[prost(float, optional, tag="18")]
    pub avg_ping_ms: ::core::option::Option<f32>,
    #[prost(float, optional, tag="19")]
    pub avg_engine_latency_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag="20")]
    pub avg_packets_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag="21")]
    pub avg_packets_in: ::core::option::Option<f32>,
    #[prost(float, optional, tag="22")]
    pub avg_loss_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag="23")]
    pub avg_loss_in: ::core::option::Option<f32>,
    #[prost(float, optional, tag="24")]
    pub avg_data_out: ::core::option::Option<f32>,
    #[prost(float, optional, tag="25")]
    pub avg_data_in: ::core::option::Option<f32>,
    #[prost(uint64, optional, tag="26")]
    pub total_data_in: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="27")]
    pub total_packets_in: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="28")]
    pub total_data_out: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="29")]
    pub total_packets_out: ::core::option::Option<u64>,
    #[prost(message, repeated, tag="30")]
    pub players: ::prost::alloc::vec::Vec<c_msg_server_network_stats::Player>,
}
/// Nested message and enum types in `CMsgServerNetworkStats`.
pub mod c_msg_server_network_stats {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Port {
        #[prost(int32, optional, tag="1")]
        pub port: ::core::option::Option<i32>,
        #[prost(string, optional, tag="2")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Player {
        #[prost(uint64, optional, tag="1")]
        pub steamid: ::core::option::Option<u64>,
        #[prost(string, optional, tag="2")]
        pub remote_addr: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag="4")]
        pub ping_avg_ms: ::core::option::Option<i32>,
        #[prost(float, optional, tag="5")]
        pub packet_loss_pct: ::core::option::Option<f32>,
        #[prost(bool, optional, tag="6")]
        pub is_bot: ::core::option::Option<bool>,
        #[prost(float, optional, tag="7")]
        pub loss_in: ::core::option::Option<f32>,
        #[prost(float, optional, tag="8")]
        pub loss_out: ::core::option::Option<f32>,
        #[prost(int32, optional, tag="9")]
        pub engine_latency_ms: ::core::option::Option<i32>,
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsvcMsgHltvReplay {
    #[prost(int32, optional, tag="1")]
    pub delay: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2", default="-1")]
    pub primary_target: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3")]
    pub replay_stop_at: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub replay_start_at: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub replay_slowdown_begin: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="6")]
    pub replay_slowdown_end: ::core::option::Option<i32>,
    #[prost(float, optional, tag="7")]
    pub replay_slowdown_rate: ::core::option::Option<f32>,
    #[prost(int32, optional, tag="8")]
    pub reason: ::core::option::Option<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CclcMsgHltvReplay {
    #[prost(int32, optional, tag="1")]
    pub request: ::core::option::Option<i32>,
    #[prost(float, optional, tag="2")]
    pub slowdown_length: ::core::option::Option<f32>,
    #[prost(float, optional, tag="3")]
    pub slowdown_rate: ::core::option::Option<f32>,
    #[prost(int32, optional, tag="4", default="-1")]
    pub primary_target: ::core::option::Option<i32>,
    #[prost(float, optional, tag="5")]
    pub event_time: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgBroadcastCommand {
    #[prost(string, optional, tag="1")]
    pub cmd: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CclcMsgHltvFixupOperatorTick {
    #[prost(int32, optional, tag="1")]
    pub tick: ::core::option::Option<i32>,
    #[prost(bytes="bytes", optional, tag="2")]
    pub props_data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(message, optional, tag="3")]
    pub origin: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag="4")]
    pub eye_angles: ::core::option::Option<CMsgQAngle>,
    #[prost(int32, optional, tag="5")]
    pub observer_mode: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="6")]
    pub cameraman_scoreboard: ::core::option::Option<bool>,
    #[prost(int32, optional, tag="7")]
    pub observer_target: ::core::option::Option<i32>,
    #[prost(message, optional, tag="8")]
    pub view_offset: ::core::option::Option<CMsgVector>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgHltvFixupOperatorStatus {
    #[prost(uint32, optional, tag="1")]
    pub mode: ::core::option::Option<u32>,
    #[prost(string, optional, tag="2")]
    pub override_operator_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CMsgServerUserCmd {
    #[prost(bytes="bytes", optional, tag="1")]
    pub data: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(int32, optional, tag="2")]
    pub cmd_number: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="3", default="-1")]
    pub player_slot: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="4")]
    pub server_tick_executed: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="5")]
    pub client_tick: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsvcMsgUserCommands {
    #[prost(message, repeated, tag="1")]
    pub commands: ::prost::alloc::vec::Vec<CMsgServerUserCmd>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClcMessages {
    ClcClientInfo = 20,
    ClcMove = 21,
    ClcVoiceData = 22,
    ClcBaselineAck = 23,
    ClcRespondCvarValue = 25,
    ClcFileCrcCheck = 26,
    ClcLoadingProgress = 27,
    ClcSplitPlayerConnect = 28,
    ClcSplitPlayerDisconnect = 30,
    ClcServerStatus = 31,
    ClcRequestPause = 33,
    ClcCmdKeyValues = 34,
    ClcRconServerDetails = 35,
    ClcHltvReplay = 36,
    ClcDiagnostic = 37,
}
impl ClcMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ClcClientInfo => "clc_ClientInfo",
            Self::ClcMove => "clc_Move",
            Self::ClcVoiceData => "clc_VoiceData",
            Self::ClcBaselineAck => "clc_BaselineAck",
            Self::ClcRespondCvarValue => "clc_RespondCvarValue",
            Self::ClcFileCrcCheck => "clc_FileCRCCheck",
            Self::ClcLoadingProgress => "clc_LoadingProgress",
            Self::ClcSplitPlayerConnect => "clc_SplitPlayerConnect",
            Self::ClcSplitPlayerDisconnect => "clc_SplitPlayerDisconnect",
            Self::ClcServerStatus => "clc_ServerStatus",
            Self::ClcRequestPause => "clc_RequestPause",
            Self::ClcCmdKeyValues => "clc_CmdKeyValues",
            Self::ClcRconServerDetails => "clc_RconServerDetails",
            Self::ClcHltvReplay => "clc_HltvReplay",
            Self::ClcDiagnostic => "clc_Diagnostic",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "clc_ClientInfo" => Some(Self::ClcClientInfo),
            "clc_Move" => Some(Self::ClcMove),
            "clc_VoiceData" => Some(Self::ClcVoiceData),
            "clc_BaselineAck" => Some(Self::ClcBaselineAck),
            "clc_RespondCvarValue" => Some(Self::ClcRespondCvarValue),
            "clc_FileCRCCheck" => Some(Self::ClcFileCrcCheck),
            "clc_LoadingProgress" => Some(Self::ClcLoadingProgress),
            "clc_SplitPlayerConnect" => Some(Self::ClcSplitPlayerConnect),
            "clc_SplitPlayerDisconnect" => Some(Self::ClcSplitPlayerDisconnect),
            "clc_ServerStatus" => Some(Self::ClcServerStatus),
            "clc_RequestPause" => Some(Self::ClcRequestPause),
            "clc_CmdKeyValues" => Some(Self::ClcCmdKeyValues),
            "clc_RconServerDetails" => Some(Self::ClcRconServerDetails),
            "clc_HltvReplay" => Some(Self::ClcHltvReplay),
            "clc_Diagnostic" => Some(Self::ClcDiagnostic),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SvcMessages {
    SvcServerInfo = 40,
    SvcFlattenedSerializer = 41,
    SvcClassInfo = 42,
    SvcSetPause = 43,
    SvcCreateStringTable = 44,
    SvcUpdateStringTable = 45,
    SvcVoiceInit = 46,
    SvcVoiceData = 47,
    SvcPrint = 48,
    SvcSounds = 49,
    SvcSetView = 50,
    SvcClearAllStringTables = 51,
    SvcCmdKeyValues = 52,
    SvcBspDecal = 53,
    SvcSplitScreen = 54,
    SvcPacketEntities = 55,
    SvcPrefetch = 56,
    SvcMenu = 57,
    SvcGetCvarValue = 58,
    SvcStopSound = 59,
    SvcPeerList = 60,
    SvcPacketReliable = 61,
    SvcHltvStatus = 62,
    SvcServerSteamId = 63,
    SvcFullFrameSplit = 70,
    SvcRconServerDetails = 71,
    SvcUserMessage = 72,
    SvcBroadcastCommand = 74,
    SvcHltvFixupOperatorStatus = 75,
    SvcUserCmds = 76,
}
impl SvcMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SvcServerInfo => "svc_ServerInfo",
            Self::SvcFlattenedSerializer => "svc_FlattenedSerializer",
            Self::SvcClassInfo => "svc_ClassInfo",
            Self::SvcSetPause => "svc_SetPause",
            Self::SvcCreateStringTable => "svc_CreateStringTable",
            Self::SvcUpdateStringTable => "svc_UpdateStringTable",
            Self::SvcVoiceInit => "svc_VoiceInit",
            Self::SvcVoiceData => "svc_VoiceData",
            Self::SvcPrint => "svc_Print",
            Self::SvcSounds => "svc_Sounds",
            Self::SvcSetView => "svc_SetView",
            Self::SvcClearAllStringTables => "svc_ClearAllStringTables",
            Self::SvcCmdKeyValues => "svc_CmdKeyValues",
            Self::SvcBspDecal => "svc_BSPDecal",
            Self::SvcSplitScreen => "svc_SplitScreen",
            Self::SvcPacketEntities => "svc_PacketEntities",
            Self::SvcPrefetch => "svc_Prefetch",
            Self::SvcMenu => "svc_Menu",
            Self::SvcGetCvarValue => "svc_GetCvarValue",
            Self::SvcStopSound => "svc_StopSound",
            Self::SvcPeerList => "svc_PeerList",
            Self::SvcPacketReliable => "svc_PacketReliable",
            Self::SvcHltvStatus => "svc_HLTVStatus",
            Self::SvcServerSteamId => "svc_ServerSteamID",
            Self::SvcFullFrameSplit => "svc_FullFrameSplit",
            Self::SvcRconServerDetails => "svc_RconServerDetails",
            Self::SvcUserMessage => "svc_UserMessage",
            Self::SvcBroadcastCommand => "svc_Broadcast_Command",
            Self::SvcHltvFixupOperatorStatus => "svc_HltvFixupOperatorStatus",
            Self::SvcUserCmds => "svc_UserCmds",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "svc_ServerInfo" => Some(Self::SvcServerInfo),
            "svc_FlattenedSerializer" => Some(Self::SvcFlattenedSerializer),
            "svc_ClassInfo" => Some(Self::SvcClassInfo),
            "svc_SetPause" => Some(Self::SvcSetPause),
            "svc_CreateStringTable" => Some(Self::SvcCreateStringTable),
            "svc_UpdateStringTable" => Some(Self::SvcUpdateStringTable),
            "svc_VoiceInit" => Some(Self::SvcVoiceInit),
            "svc_VoiceData" => Some(Self::SvcVoiceData),
            "svc_Print" => Some(Self::SvcPrint),
            "svc_Sounds" => Some(Self::SvcSounds),
            "svc_SetView" => Some(Self::SvcSetView),
            "svc_ClearAllStringTables" => Some(Self::SvcClearAllStringTables),
            "svc_CmdKeyValues" => Some(Self::SvcCmdKeyValues),
            "svc_BSPDecal" => Some(Self::SvcBspDecal),
            "svc_SplitScreen" => Some(Self::SvcSplitScreen),
            "svc_PacketEntities" => Some(Self::SvcPacketEntities),
            "svc_Prefetch" => Some(Self::SvcPrefetch),
            "svc_Menu" => Some(Self::SvcMenu),
            "svc_GetCvarValue" => Some(Self::SvcGetCvarValue),
            "svc_StopSound" => Some(Self::SvcStopSound),
            "svc_PeerList" => Some(Self::SvcPeerList),
            "svc_PacketReliable" => Some(Self::SvcPacketReliable),
            "svc_HLTVStatus" => Some(Self::SvcHltvStatus),
            "svc_ServerSteamID" => Some(Self::SvcServerSteamId),
            "svc_FullFrameSplit" => Some(Self::SvcFullFrameSplit),
            "svc_RconServerDetails" => Some(Self::SvcRconServerDetails),
            "svc_UserMessage" => Some(Self::SvcUserMessage),
            "svc_Broadcast_Command" => Some(Self::SvcBroadcastCommand),
            "svc_HltvFixupOperatorStatus" => Some(Self::SvcHltvFixupOperatorStatus),
            "svc_UserCmds" => Some(Self::SvcUserCmds),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VoiceDataFormatT {
    VoicedataFormatSteam = 0,
    VoicedataFormatEngine = 1,
    VoicedataFormatOpus = 2,
}
impl VoiceDataFormatT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VoicedataFormatSteam => "VOICEDATA_FORMAT_STEAM",
            Self::VoicedataFormatEngine => "VOICEDATA_FORMAT_ENGINE",
            Self::VoicedataFormatOpus => "VOICEDATA_FORMAT_OPUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VOICEDATA_FORMAT_STEAM" => Some(Self::VoicedataFormatSteam),
            "VOICEDATA_FORMAT_ENGINE" => Some(Self::VoicedataFormatEngine),
            "VOICEDATA_FORMAT_OPUS" => Some(Self::VoicedataFormatOpus),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RequestPauseT {
    RpPause = 0,
    RpUnpause = 1,
    RpTogglepause = 2,
}
impl RequestPauseT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RpPause => "RP_PAUSE",
            Self::RpUnpause => "RP_UNPAUSE",
            Self::RpTogglepause => "RP_TOGGLEPAUSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RP_PAUSE" => Some(Self::RpPause),
            "RP_UNPAUSE" => Some(Self::RpUnpause),
            "RP_TOGGLEPAUSE" => Some(Self::RpTogglepause),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PrefetchType {
    PftSound = 0,
}
impl PrefetchType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::PftSound => "PFT_SOUND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PFT_SOUND" => Some(Self::PftSound),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ESplitScreenMessageType {
    MsgSplitscreenAdduser = 0,
    MsgSplitscreenRemoveuser = 1,
}
impl ESplitScreenMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MsgSplitscreenAdduser => "MSG_SPLITSCREEN_ADDUSER",
            Self::MsgSplitscreenRemoveuser => "MSG_SPLITSCREEN_REMOVEUSER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MSG_SPLITSCREEN_ADDUSER" => Some(Self::MsgSplitscreenAdduser),
            "MSG_SPLITSCREEN_REMOVEUSER" => Some(Self::MsgSplitscreenRemoveuser),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EQueryCvarValueStatus {
    ValueIntact = 0,
    CvarNotFound = 1,
    NotACvar = 2,
    CvarProtected = 3,
}
impl EQueryCvarValueStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ValueIntact => "eQueryCvarValueStatus_ValueIntact",
            Self::CvarNotFound => "eQueryCvarValueStatus_CvarNotFound",
            Self::NotACvar => "eQueryCvarValueStatus_NotACvar",
            Self::CvarProtected => "eQueryCvarValueStatus_CvarProtected",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "eQueryCvarValueStatus_ValueIntact" => Some(Self::ValueIntact),
            "eQueryCvarValueStatus_CvarNotFound" => Some(Self::CvarNotFound),
            "eQueryCvarValueStatus_NotACvar" => Some(Self::NotACvar),
            "eQueryCvarValueStatus_CvarProtected" => Some(Self::CvarProtected),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DialogType {
    DialogMsg = 0,
    DialogMenu = 1,
    DialogText = 2,
    DialogEntry = 3,
    DialogAskconnect = 4,
}
impl DialogType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::DialogMsg => "DIALOG_MSG",
            Self::DialogMenu => "DIALOG_MENU",
            Self::DialogText => "DIALOG_TEXT",
            Self::DialogEntry => "DIALOG_ENTRY",
            Self::DialogAskconnect => "DIALOG_ASKCONNECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIALOG_MSG" => Some(Self::DialogMsg),
            "DIALOG_MENU" => Some(Self::DialogMenu),
            "DIALOG_TEXT" => Some(Self::DialogText),
            "DIALOG_ENTRY" => Some(Self::DialogEntry),
            "DIALOG_ASKCONNECT" => Some(Self::DialogAskconnect),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SvcMessagesLowFrequency {
    SvcDummy = 600,
}
impl SvcMessagesLowFrequency {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SvcDummy => "svc_dummy",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "svc_dummy" => Some(Self::SvcDummy),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BidirectionalMessages {
    BiRebroadcastGameEvent = 16,
    BiRebroadcastSource = 17,
    BiGameEvent = 18,
}
impl BidirectionalMessages {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BiRebroadcastGameEvent => "bi_RebroadcastGameEvent",
            Self::BiRebroadcastSource => "bi_RebroadcastSource",
            Self::BiGameEvent => "bi_GameEvent",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "bi_RebroadcastGameEvent" => Some(Self::BiRebroadcastGameEvent),
            "bi_RebroadcastSource" => Some(Self::BiRebroadcastSource),
            "bi_GameEvent" => Some(Self::BiGameEvent),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BidirectionalMessagesLowFrequency {
    BiRelayInfo = 700,
    BiRelayPacket = 701,
}
impl BidirectionalMessagesLowFrequency {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BiRelayInfo => "bi_RelayInfo",
            Self::BiRelayPacket => "bi_RelayPacket",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "bi_RelayInfo" => Some(Self::BiRelayInfo),
            "bi_RelayPacket" => Some(Self::BiRelayPacket),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReplayEventTypeT {
    ReplayEventCancel = 0,
    ReplayEventDeath = 1,
    ReplayEventGeneric = 2,
    ReplayEventStuckNeedFullUpdate = 3,
    ReplayEventVictory = 4,
}
impl ReplayEventTypeT {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReplayEventCancel => "REPLAY_EVENT_CANCEL",
            Self::ReplayEventDeath => "REPLAY_EVENT_DEATH",
            Self::ReplayEventGeneric => "REPLAY_EVENT_GENERIC",
            Self::ReplayEventStuckNeedFullUpdate => "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE",
            Self::ReplayEventVictory => "REPLAY_EVENT_VICTORY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPLAY_EVENT_CANCEL" => Some(Self::ReplayEventCancel),
            "REPLAY_EVENT_DEATH" => Some(Self::ReplayEventDeath),
            "REPLAY_EVENT_GENERIC" => Some(Self::ReplayEventGeneric),
            "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE" => Some(Self::ReplayEventStuckNeedFullUpdate),
            "REPLAY_EVENT_VICTORY" => Some(Self::ReplayEventVictory),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CInButtonStatePb {
    #[prost(uint64, optional, tag="1")]
    pub buttonstate1: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="2")]
    pub buttonstate2: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag="3")]
    pub buttonstate3: ::core::option::Option<u64>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CSubtickMoveStep {
    #[prost(uint64, optional, tag="1")]
    pub button: ::core::option::Option<u64>,
    #[prost(bool, optional, tag="2")]
    pub pressed: ::core::option::Option<bool>,
    #[prost(float, optional, tag="3")]
    pub when: ::core::option::Option<f32>,
    #[prost(float, optional, tag="4")]
    pub analog_forward_delta: ::core::option::Option<f32>,
    #[prost(float, optional, tag="5")]
    pub analog_left_delta: ::core::option::Option<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CBaseUserCmdPb {
    #[prost(int32, optional, tag="1")]
    pub legacy_command_number: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2")]
    pub client_tick: ::core::option::Option<i32>,
    #[prost(message, optional, tag="3")]
    pub buttons_pb: ::core::option::Option<CInButtonStatePb>,
    #[prost(message, optional, tag="4")]
    pub viewangles: ::core::option::Option<CMsgQAngle>,
    #[prost(float, optional, tag="5")]
    pub forwardmove: ::core::option::Option<f32>,
    #[prost(float, optional, tag="6")]
    pub leftmove: ::core::option::Option<f32>,
    #[prost(float, optional, tag="7")]
    pub upmove: ::core::option::Option<f32>,
    #[prost(int32, optional, tag="8")]
    pub impulse: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="9")]
    pub weaponselect: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="10")]
    pub random_seed: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="11")]
    pub mousedx: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="12")]
    pub mousedy: ::core::option::Option<i32>,
    #[prost(uint32, optional, tag="14", default="16777215")]
    pub pawn_entity_handle: ::core::option::Option<u32>,
    #[prost(message, repeated, tag="18")]
    pub subtick_moves: ::prost::alloc::vec::Vec<CSubtickMoveStep>,
    #[prost(bytes="bytes", optional, tag="19")]
    pub move_crc: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(uint32, optional, tag="20")]
    pub consumed_server_angle_changes: ::core::option::Option<u32>,
    #[prost(int32, optional, tag="21")]
    pub cmd_flags: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CUserCmdBasePb {
    #[prost(message, optional, tag="1")]
    pub base: ::core::option::Option<CBaseUserCmdPb>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsgoInterpolationInfoPb {
    #[prost(int32, optional, tag="1", default="-1")]
    pub src_tick: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="2", default="-1")]
    pub dst_tick: ::core::option::Option<i32>,
    #[prost(float, optional, tag="3", default="0")]
    pub frac: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsgoInterpolationInfoPbCl {
    #[prost(float, optional, tag="3", default="0")]
    pub frac: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CsgoInputHistoryEntryPb {
    #[prost(message, optional, tag="2")]
    pub view_angles: ::core::option::Option<CMsgQAngle>,
    #[prost(int32, optional, tag="4")]
    pub render_tick_count: ::core::option::Option<i32>,
    #[prost(float, optional, tag="5")]
    pub render_tick_fraction: ::core::option::Option<f32>,
    #[prost(int32, optional, tag="6")]
    pub player_tick_count: ::core::option::Option<i32>,
    #[prost(float, optional, tag="7")]
    pub player_tick_fraction: ::core::option::Option<f32>,
    #[prost(message, optional, tag="12")]
    pub cl_interp: ::core::option::Option<CsgoInterpolationInfoPbCl>,
    #[prost(message, optional, tag="13")]
    pub sv_interp0: ::core::option::Option<CsgoInterpolationInfoPb>,
    #[prost(message, optional, tag="14")]
    pub sv_interp1: ::core::option::Option<CsgoInterpolationInfoPb>,
    #[prost(message, optional, tag="15")]
    pub player_interp: ::core::option::Option<CsgoInterpolationInfoPb>,
    #[prost(int32, optional, tag="64")]
    pub frame_number: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="65", default="-1")]
    pub target_ent_index: ::core::option::Option<i32>,
    #[prost(message, optional, tag="66")]
    pub shoot_position: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag="67")]
    pub target_head_pos_check: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag="68")]
    pub target_abs_pos_check: ::core::option::Option<CMsgVector>,
    #[prost(message, optional, tag="69")]
    pub target_abs_ang_check: ::core::option::Option<CMsgQAngle>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CsgoUserCmdPb {
    #[prost(message, optional, tag="1")]
    pub base: ::core::option::Option<CBaseUserCmdPb>,
    #[prost(message, repeated, tag="2")]
    pub input_history: ::prost::alloc::vec::Vec<CsgoInputHistoryEntryPb>,
    #[prost(int32, optional, tag="6", default="-1")]
    pub attack1_start_history_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="7", default="-1")]
    pub attack2_start_history_index: ::core::option::Option<i32>,
    #[prost(int32, optional, tag="8", default="-1")]
    pub attack3_start_history_index: ::core::option::Option<i32>,
    #[prost(bool, optional, tag="9", default="false")]
    pub left_hand_desired: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="11", default="false")]
    pub is_predicting_body_shot_fx: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="12", default="false")]
    pub is_predicting_head_shot_fx: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="13", default="false")]
    pub is_predicting_kill_ragdolls: ::core::option::Option<bool>,
}
