// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by protoc 3.12.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cstrike15_usermessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CCSUsrMsg_VGUIMenu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VGUIMenu {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VGUIMenu.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VGUIMenu.show)
    pub show: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VGUIMenu.keys)
    pub keys: ::std::vec::Vec<ccsusr_msg_vguimenu::Keys>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VGUIMenu.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VGUIMenu {
    fn default() -> &'a CCSUsrMsg_VGUIMenu {
        <CCSUsrMsg_VGUIMenu as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VGUIMenu {
    pub fn new() -> CCSUsrMsg_VGUIMenu {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool show = 2;

    pub fn show(&self) -> bool {
        self.show.unwrap_or(false)
    }

    pub fn clear_show(&mut self) {
        self.show = ::std::option::Option::None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CCSUsrMsg_VGUIMenu| { &m.name },
            |m: &mut CCSUsrMsg_VGUIMenu| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show",
            |m: &CCSUsrMsg_VGUIMenu| { &m.show },
            |m: &mut CCSUsrMsg_VGUIMenu| { &mut m.show },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &CCSUsrMsg_VGUIMenu| { &m.keys },
            |m: &mut CCSUsrMsg_VGUIMenu| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_VGUIMenu>(
            "CCSUsrMsg_VGUIMenu",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_VGUIMenu {
    const NAME: &'static str = "CCSUsrMsg_VGUIMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.show = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.show {
            my_size += 1 + 1;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.show {
            os.write_bool(2, v)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VGUIMenu {
        CCSUsrMsg_VGUIMenu::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.show = ::std::option::Option::None;
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VGUIMenu {
        static instance: CCSUsrMsg_VGUIMenu = CCSUsrMsg_VGUIMenu {
            name: ::std::option::Option::None,
            show: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_VGUIMenu {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_VGUIMenu").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_VGUIMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VGUIMenu {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CCSUsrMsg_VGUIMenu`
pub mod ccsusr_msg_vguimenu {
    // @@protoc_insertion_point(message:CCSUsrMsg_VGUIMenu.Keys)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Keys {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_VGUIMenu.Keys.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CCSUsrMsg_VGUIMenu.Keys.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_VGUIMenu.Keys.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Keys {
        fn default() -> &'a Keys {
            <Keys as ::protobuf::Message>::default_instance()
        }
    }

    impl Keys {
        pub fn new() -> Keys {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Keys| { &m.name },
                |m: &mut Keys| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Keys| { &m.value },
                |m: &mut Keys| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Keys>(
                "CCSUsrMsg_VGUIMenu.Keys",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Keys {
        const NAME: &'static str = "Keys";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Keys {
            Keys::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Keys {
            static instance: Keys = Keys {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Keys {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_VGUIMenu.Keys").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Keys {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Keys {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_Geiger)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Geiger {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Geiger.range)
    pub range: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Geiger.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Geiger {
    fn default() -> &'a CCSUsrMsg_Geiger {
        <CCSUsrMsg_Geiger as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Geiger {
    pub fn new() -> CCSUsrMsg_Geiger {
        ::std::default::Default::default()
    }

    // optional int32 range = 1;

    pub fn range(&self) -> i32 {
        self.range.unwrap_or(0)
    }

    pub fn clear_range(&mut self) {
        self.range = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: i32) {
        self.range = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "range",
            |m: &CCSUsrMsg_Geiger| { &m.range },
            |m: &mut CCSUsrMsg_Geiger| { &mut m.range },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_Geiger>(
            "CCSUsrMsg_Geiger",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_Geiger {
    const NAME: &'static str = "CCSUsrMsg_Geiger";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.range = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.range {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.range {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Geiger {
        CCSUsrMsg_Geiger::new()
    }

    fn clear(&mut self) {
        self.range = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Geiger {
        static instance: CCSUsrMsg_Geiger = CCSUsrMsg_Geiger {
            range: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_Geiger {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_Geiger").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_Geiger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Geiger {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_Train)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Train {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Train.train)
    pub train: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Train.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Train {
    fn default() -> &'a CCSUsrMsg_Train {
        <CCSUsrMsg_Train as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Train {
    pub fn new() -> CCSUsrMsg_Train {
        ::std::default::Default::default()
    }

    // optional int32 train = 1;

    pub fn train(&self) -> i32 {
        self.train.unwrap_or(0)
    }

    pub fn clear_train(&mut self) {
        self.train = ::std::option::Option::None;
    }

    pub fn has_train(&self) -> bool {
        self.train.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train(&mut self, v: i32) {
        self.train = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "train",
            |m: &CCSUsrMsg_Train| { &m.train },
            |m: &mut CCSUsrMsg_Train| { &mut m.train },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_Train>(
            "CCSUsrMsg_Train",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_Train {
    const NAME: &'static str = "CCSUsrMsg_Train";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.train = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.train {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.train {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Train {
        CCSUsrMsg_Train::new()
    }

    fn clear(&mut self) {
        self.train = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Train {
        static instance: CCSUsrMsg_Train = CCSUsrMsg_Train {
            train: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_Train {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_Train").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_Train {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Train {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_HudText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_HudText {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_HudText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_HudText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HudText {
    fn default() -> &'a CCSUsrMsg_HudText {
        <CCSUsrMsg_HudText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HudText {
    pub fn new() -> CCSUsrMsg_HudText {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CCSUsrMsg_HudText| { &m.text },
            |m: &mut CCSUsrMsg_HudText| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_HudText>(
            "CCSUsrMsg_HudText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_HudText {
    const NAME: &'static str = "CCSUsrMsg_HudText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_HudText {
        CCSUsrMsg_HudText::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_HudText {
        static instance: CCSUsrMsg_HudText = CCSUsrMsg_HudText {
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_HudText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_HudText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_HudText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_HudText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_HudMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_HudMsg {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.channel)
    pub channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.pos)
    pub pos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector2D>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.clr1)
    pub clr1: ::protobuf::MessageField<super::networkbasetypes::CMsgRGBA>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.clr2)
    pub clr2: ::protobuf::MessageField<super::networkbasetypes::CMsgRGBA>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.effect)
    pub effect: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.fade_in_time)
    pub fade_in_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.fade_out_time)
    pub fade_out_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.hold_time)
    pub hold_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.fx_time)
    pub fx_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_HudMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HudMsg {
    fn default() -> &'a CCSUsrMsg_HudMsg {
        <CCSUsrMsg_HudMsg as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HudMsg {
    pub fn new() -> CCSUsrMsg_HudMsg {
        ::std::default::Default::default()
    }

    // optional int32 channel = 1;

    pub fn channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional int32 effect = 5;

    pub fn effect(&self) -> i32 {
        self.effect.unwrap_or(0)
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: i32) {
        self.effect = ::std::option::Option::Some(v);
    }

    // optional float fade_in_time = 6;

    pub fn fade_in_time(&self) -> f32 {
        self.fade_in_time.unwrap_or(0.)
    }

    pub fn clear_fade_in_time(&mut self) {
        self.fade_in_time = ::std::option::Option::None;
    }

    pub fn has_fade_in_time(&self) -> bool {
        self.fade_in_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_in_time(&mut self, v: f32) {
        self.fade_in_time = ::std::option::Option::Some(v);
    }

    // optional float fade_out_time = 7;

    pub fn fade_out_time(&self) -> f32 {
        self.fade_out_time.unwrap_or(0.)
    }

    pub fn clear_fade_out_time(&mut self) {
        self.fade_out_time = ::std::option::Option::None;
    }

    pub fn has_fade_out_time(&self) -> bool {
        self.fade_out_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_out_time(&mut self, v: f32) {
        self.fade_out_time = ::std::option::Option::Some(v);
    }

    // optional float hold_time = 9;

    pub fn hold_time(&self) -> f32 {
        self.hold_time.unwrap_or(0.)
    }

    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: f32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional float fx_time = 10;

    pub fn fx_time(&self) -> f32 {
        self.fx_time.unwrap_or(0.)
    }

    pub fn clear_fx_time(&mut self) {
        self.fx_time = ::std::option::Option::None;
    }

    pub fn has_fx_time(&self) -> bool {
        self.fx_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fx_time(&mut self, v: f32) {
        self.fx_time = ::std::option::Option::Some(v);
    }

    // optional string text = 11;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &CCSUsrMsg_HudMsg| { &m.channel },
            |m: &mut CCSUsrMsg_HudMsg| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector2D>(
            "pos",
            |m: &CCSUsrMsg_HudMsg| { &m.pos },
            |m: &mut CCSUsrMsg_HudMsg| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgRGBA>(
            "clr1",
            |m: &CCSUsrMsg_HudMsg| { &m.clr1 },
            |m: &mut CCSUsrMsg_HudMsg| { &mut m.clr1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgRGBA>(
            "clr2",
            |m: &CCSUsrMsg_HudMsg| { &m.clr2 },
            |m: &mut CCSUsrMsg_HudMsg| { &mut m.clr2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect",
            |m: &CCSUsrMsg_HudMsg| { &m.effect },
            |m: &mut CCSUsrMsg_HudMsg| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fade_in_time",
            |m: &CCSUsrMsg_HudMsg| { &m.fade_in_time },
            |m: &mut CCSUsrMsg_HudMsg| { &mut m.fade_in_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fade_out_time",
            |m: &CCSUsrMsg_HudMsg| { &m.fade_out_time },
            |m: &mut CCSUsrMsg_HudMsg| { &mut m.fade_out_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hold_time",
            |m: &CCSUsrMsg_HudMsg| { &m.hold_time },
            |m: &mut CCSUsrMsg_HudMsg| { &mut m.hold_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fx_time",
            |m: &CCSUsrMsg_HudMsg| { &m.fx_time },
            |m: &mut CCSUsrMsg_HudMsg| { &mut m.fx_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CCSUsrMsg_HudMsg| { &m.text },
            |m: &mut CCSUsrMsg_HudMsg| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_HudMsg>(
            "CCSUsrMsg_HudMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_HudMsg {
    const NAME: &'static str = "CCSUsrMsg_HudMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clr1)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clr2)?;
                },
                40 => {
                    self.effect = ::std::option::Option::Some(is.read_int32()?);
                },
                53 => {
                    self.fade_in_time = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.fade_out_time = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.hold_time = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.fx_time = ::std::option::Option::Some(is.read_float()?);
                },
                90 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clr1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clr2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.effect {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.fade_in_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fade_out_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.hold_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fx_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.clr1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.clr2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.effect {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.fade_in_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.fade_out_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.fx_time {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_HudMsg {
        CCSUsrMsg_HudMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.pos.clear();
        self.clr1.clear();
        self.clr2.clear();
        self.effect = ::std::option::Option::None;
        self.fade_in_time = ::std::option::Option::None;
        self.fade_out_time = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.fx_time = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_HudMsg {
        static instance: CCSUsrMsg_HudMsg = CCSUsrMsg_HudMsg {
            channel: ::std::option::Option::None,
            pos: ::protobuf::MessageField::none(),
            clr1: ::protobuf::MessageField::none(),
            clr2: ::protobuf::MessageField::none(),
            effect: ::std::option::Option::None,
            fade_in_time: ::std::option::Option::None,
            fade_out_time: ::std::option::Option::None,
            hold_time: ::std::option::Option::None,
            fx_time: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_HudMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_HudMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_HudMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_HudMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_Shake)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Shake {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Shake.command)
    pub command: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Shake.local_amplitude)
    pub local_amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Shake.frequency)
    pub frequency: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Shake.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Shake.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Shake {
    fn default() -> &'a CCSUsrMsg_Shake {
        <CCSUsrMsg_Shake as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Shake {
    pub fn new() -> CCSUsrMsg_Shake {
        ::std::default::Default::default()
    }

    // optional int32 command = 1;

    pub fn command(&self) -> i32 {
        self.command.unwrap_or(0)
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: i32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional float local_amplitude = 2;

    pub fn local_amplitude(&self) -> f32 {
        self.local_amplitude.unwrap_or(0.)
    }

    pub fn clear_local_amplitude(&mut self) {
        self.local_amplitude = ::std::option::Option::None;
    }

    pub fn has_local_amplitude(&self) -> bool {
        self.local_amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_amplitude(&mut self, v: f32) {
        self.local_amplitude = ::std::option::Option::Some(v);
    }

    // optional float frequency = 3;

    pub fn frequency(&self) -> f32 {
        self.frequency.unwrap_or(0.)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: f32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &CCSUsrMsg_Shake| { &m.command },
            |m: &mut CCSUsrMsg_Shake| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_amplitude",
            |m: &CCSUsrMsg_Shake| { &m.local_amplitude },
            |m: &mut CCSUsrMsg_Shake| { &mut m.local_amplitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frequency",
            |m: &CCSUsrMsg_Shake| { &m.frequency },
            |m: &mut CCSUsrMsg_Shake| { &mut m.frequency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CCSUsrMsg_Shake| { &m.duration },
            |m: &mut CCSUsrMsg_Shake| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_Shake>(
            "CCSUsrMsg_Shake",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_Shake {
    const NAME: &'static str = "CCSUsrMsg_Shake";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.command = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.local_amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.frequency = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.local_amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frequency {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.local_amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Shake {
        CCSUsrMsg_Shake::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.local_amplitude = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Shake {
        static instance: CCSUsrMsg_Shake = CCSUsrMsg_Shake {
            command: ::std::option::Option::None,
            local_amplitude: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_Shake {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_Shake").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_Shake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Shake {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_Fade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Fade {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Fade.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Fade.hold_time)
    pub hold_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Fade.flags)
    pub flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Fade.clr)
    pub clr: ::protobuf::MessageField<super::networkbasetypes::CMsgRGBA>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Fade.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Fade {
    fn default() -> &'a CCSUsrMsg_Fade {
        <CCSUsrMsg_Fade as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Fade {
    pub fn new() -> CCSUsrMsg_Fade {
        ::std::default::Default::default()
    }

    // optional int32 duration = 1;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 hold_time = 2;

    pub fn hold_time(&self) -> i32 {
        self.hold_time.unwrap_or(0)
    }

    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: i32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CCSUsrMsg_Fade| { &m.duration },
            |m: &mut CCSUsrMsg_Fade| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hold_time",
            |m: &CCSUsrMsg_Fade| { &m.hold_time },
            |m: &mut CCSUsrMsg_Fade| { &mut m.hold_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CCSUsrMsg_Fade| { &m.flags },
            |m: &mut CCSUsrMsg_Fade| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgRGBA>(
            "clr",
            |m: &CCSUsrMsg_Fade| { &m.clr },
            |m: &mut CCSUsrMsg_Fade| { &mut m.clr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_Fade>(
            "CCSUsrMsg_Fade",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_Fade {
    const NAME: &'static str = "CCSUsrMsg_Fade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.hold_time = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clr)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hold_time {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.clr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.duration {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.clr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Fade {
        CCSUsrMsg_Fade::new()
    }

    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.clr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Fade {
        static instance: CCSUsrMsg_Fade = CCSUsrMsg_Fade {
            duration: ::std::option::Option::None,
            hold_time: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            clr: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_Fade {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_Fade").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_Fade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Fade {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_Rumble)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Rumble {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Rumble.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Rumble.data)
    pub data: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Rumble.flags)
    pub flags: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Rumble.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Rumble {
    fn default() -> &'a CCSUsrMsg_Rumble {
        <CCSUsrMsg_Rumble as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Rumble {
    pub fn new() -> CCSUsrMsg_Rumble {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 data = 2;

    pub fn data(&self) -> i32 {
        self.data.unwrap_or(0)
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CCSUsrMsg_Rumble| { &m.index },
            |m: &mut CCSUsrMsg_Rumble| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CCSUsrMsg_Rumble| { &m.data },
            |m: &mut CCSUsrMsg_Rumble| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CCSUsrMsg_Rumble| { &m.flags },
            |m: &mut CCSUsrMsg_Rumble| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_Rumble>(
            "CCSUsrMsg_Rumble",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_Rumble {
    const NAME: &'static str = "CCSUsrMsg_Rumble";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.data = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Rumble {
        CCSUsrMsg_Rumble::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Rumble {
        static instance: CCSUsrMsg_Rumble = CCSUsrMsg_Rumble {
            index: ::std::option::Option::None,
            data: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_Rumble {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_Rumble").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_Rumble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Rumble {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_CloseCaption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CloseCaption {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaption.hash)
    pub hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaption.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaption.from_player)
    pub from_player: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaption.cctoken)
    pub cctoken: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CloseCaption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CloseCaption {
    fn default() -> &'a CCSUsrMsg_CloseCaption {
        <CCSUsrMsg_CloseCaption as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CloseCaption {
    pub fn new() -> CCSUsrMsg_CloseCaption {
        ::std::default::Default::default()
    }

    // optional uint32 hash = 1;

    pub fn hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 2;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    // optional string cctoken = 4;

    pub fn cctoken(&self) -> &str {
        match self.cctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cctoken(&mut self) {
        self.cctoken = ::std::option::Option::None;
    }

    pub fn has_cctoken(&self) -> bool {
        self.cctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cctoken(&mut self, v: ::std::string::String) {
        self.cctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cctoken(&mut self) -> &mut ::std::string::String {
        if self.cctoken.is_none() {
            self.cctoken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_cctoken(&mut self) -> ::std::string::String {
        self.cctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &CCSUsrMsg_CloseCaption| { &m.hash },
            |m: &mut CCSUsrMsg_CloseCaption| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CCSUsrMsg_CloseCaption| { &m.duration },
            |m: &mut CCSUsrMsg_CloseCaption| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_player",
            |m: &CCSUsrMsg_CloseCaption| { &m.from_player },
            |m: &mut CCSUsrMsg_CloseCaption| { &mut m.from_player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cctoken",
            |m: &CCSUsrMsg_CloseCaption| { &m.cctoken },
            |m: &mut CCSUsrMsg_CloseCaption| { &mut m.cctoken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_CloseCaption>(
            "CCSUsrMsg_CloseCaption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_CloseCaption {
    const NAME: &'static str = "CCSUsrMsg_CloseCaption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hash = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.cctoken = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.cctoken.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CloseCaption {
        CCSUsrMsg_CloseCaption::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.cctoken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CloseCaption {
        static instance: CCSUsrMsg_CloseCaption = CCSUsrMsg_CloseCaption {
            hash: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            cctoken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_CloseCaption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_CloseCaption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_CloseCaption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CloseCaption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_CloseCaptionDirect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CloseCaptionDirect {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaptionDirect.hash)
    pub hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaptionDirect.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaptionDirect.from_player)
    pub from_player: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CloseCaptionDirect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CloseCaptionDirect {
    fn default() -> &'a CCSUsrMsg_CloseCaptionDirect {
        <CCSUsrMsg_CloseCaptionDirect as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CloseCaptionDirect {
    pub fn new() -> CCSUsrMsg_CloseCaptionDirect {
        ::std::default::Default::default()
    }

    // optional uint32 hash = 1;

    pub fn hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 2;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &CCSUsrMsg_CloseCaptionDirect| { &m.hash },
            |m: &mut CCSUsrMsg_CloseCaptionDirect| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CCSUsrMsg_CloseCaptionDirect| { &m.duration },
            |m: &mut CCSUsrMsg_CloseCaptionDirect| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_player",
            |m: &CCSUsrMsg_CloseCaptionDirect| { &m.from_player },
            |m: &mut CCSUsrMsg_CloseCaptionDirect| { &mut m.from_player },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_CloseCaptionDirect>(
            "CCSUsrMsg_CloseCaptionDirect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_CloseCaptionDirect {
    const NAME: &'static str = "CCSUsrMsg_CloseCaptionDirect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hash = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CloseCaptionDirect {
        CCSUsrMsg_CloseCaptionDirect::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CloseCaptionDirect {
        static instance: CCSUsrMsg_CloseCaptionDirect = CCSUsrMsg_CloseCaptionDirect {
            hash: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_CloseCaptionDirect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_CloseCaptionDirect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_CloseCaptionDirect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CloseCaptionDirect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_SendAudio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SendAudio {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SendAudio.radio_sound)
    pub radio_sound: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SendAudio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendAudio {
    fn default() -> &'a CCSUsrMsg_SendAudio {
        <CCSUsrMsg_SendAudio as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendAudio {
    pub fn new() -> CCSUsrMsg_SendAudio {
        ::std::default::Default::default()
    }

    // optional string radio_sound = 1;

    pub fn radio_sound(&self) -> &str {
        match self.radio_sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_radio_sound(&mut self) {
        self.radio_sound = ::std::option::Option::None;
    }

    pub fn has_radio_sound(&self) -> bool {
        self.radio_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_sound(&mut self, v: ::std::string::String) {
        self.radio_sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radio_sound(&mut self) -> &mut ::std::string::String {
        if self.radio_sound.is_none() {
            self.radio_sound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.radio_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_radio_sound(&mut self) -> ::std::string::String {
        self.radio_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_sound",
            |m: &CCSUsrMsg_SendAudio| { &m.radio_sound },
            |m: &mut CCSUsrMsg_SendAudio| { &mut m.radio_sound },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_SendAudio>(
            "CCSUsrMsg_SendAudio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendAudio {
    const NAME: &'static str = "CCSUsrMsg_SendAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.radio_sound = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_sound.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_sound.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SendAudio {
        CCSUsrMsg_SendAudio::new()
    }

    fn clear(&mut self) {
        self.radio_sound = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SendAudio {
        static instance: CCSUsrMsg_SendAudio = CCSUsrMsg_SendAudio {
            radio_sound: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_SendAudio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_SendAudio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_SendAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendAudio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_RawAudio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_RawAudio {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_RawAudio.pitch)
    pub pitch: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RawAudio.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RawAudio.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RawAudio.voice_filename)
    pub voice_filename: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_RawAudio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RawAudio {
    fn default() -> &'a CCSUsrMsg_RawAudio {
        <CCSUsrMsg_RawAudio as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RawAudio {
    pub fn new() -> CCSUsrMsg_RawAudio {
        ::std::default::Default::default()
    }

    // optional int32 pitch = 1;

    pub fn pitch(&self) -> i32 {
        self.pitch.unwrap_or(0)
    }

    pub fn clear_pitch(&mut self) {
        self.pitch = ::std::option::Option::None;
    }

    pub fn has_pitch(&self) -> bool {
        self.pitch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch(&mut self, v: i32) {
        self.pitch = ::std::option::Option::Some(v);
    }

    // optional int32 entidx = 2;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string voice_filename = 4;

    pub fn voice_filename(&self) -> &str {
        match self.voice_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_voice_filename(&mut self) {
        self.voice_filename = ::std::option::Option::None;
    }

    pub fn has_voice_filename(&self) -> bool {
        self.voice_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_filename(&mut self, v: ::std::string::String) {
        self.voice_filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_filename(&mut self) -> &mut ::std::string::String {
        if self.voice_filename.is_none() {
            self.voice_filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.voice_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_filename(&mut self) -> ::std::string::String {
        self.voice_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pitch",
            |m: &CCSUsrMsg_RawAudio| { &m.pitch },
            |m: &mut CCSUsrMsg_RawAudio| { &mut m.pitch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CCSUsrMsg_RawAudio| { &m.entidx },
            |m: &mut CCSUsrMsg_RawAudio| { &mut m.entidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CCSUsrMsg_RawAudio| { &m.duration },
            |m: &mut CCSUsrMsg_RawAudio| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_filename",
            |m: &CCSUsrMsg_RawAudio| { &m.voice_filename },
            |m: &mut CCSUsrMsg_RawAudio| { &mut m.voice_filename },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_RawAudio>(
            "CCSUsrMsg_RawAudio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_RawAudio {
    const NAME: &'static str = "CCSUsrMsg_RawAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pitch = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                34 => {
                    self.voice_filename = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pitch {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.voice_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pitch {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entidx {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.voice_filename.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_RawAudio {
        CCSUsrMsg_RawAudio::new()
    }

    fn clear(&mut self) {
        self.pitch = ::std::option::Option::None;
        self.entidx = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.voice_filename = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_RawAudio {
        static instance: CCSUsrMsg_RawAudio = CCSUsrMsg_RawAudio {
            pitch: ::std::option::Option::None,
            entidx: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            voice_filename: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_RawAudio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_RawAudio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_RawAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RawAudio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_VoiceMask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VoiceMask {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VoiceMask.player_masks)
    pub player_masks: ::std::vec::Vec<ccsusr_msg_voice_mask::PlayerMask>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoiceMask.player_mod_enable)
    pub player_mod_enable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VoiceMask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoiceMask {
    fn default() -> &'a CCSUsrMsg_VoiceMask {
        <CCSUsrMsg_VoiceMask as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoiceMask {
    pub fn new() -> CCSUsrMsg_VoiceMask {
        ::std::default::Default::default()
    }

    // optional bool player_mod_enable = 2;

    pub fn player_mod_enable(&self) -> bool {
        self.player_mod_enable.unwrap_or(false)
    }

    pub fn clear_player_mod_enable(&mut self) {
        self.player_mod_enable = ::std::option::Option::None;
    }

    pub fn has_player_mod_enable(&self) -> bool {
        self.player_mod_enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_mod_enable(&mut self, v: bool) {
        self.player_mod_enable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_masks",
            |m: &CCSUsrMsg_VoiceMask| { &m.player_masks },
            |m: &mut CCSUsrMsg_VoiceMask| { &mut m.player_masks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_mod_enable",
            |m: &CCSUsrMsg_VoiceMask| { &m.player_mod_enable },
            |m: &mut CCSUsrMsg_VoiceMask| { &mut m.player_mod_enable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_VoiceMask>(
            "CCSUsrMsg_VoiceMask",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoiceMask {
    const NAME: &'static str = "CCSUsrMsg_VoiceMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_masks.push(is.read_message()?);
                },
                16 => {
                    self.player_mod_enable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_masks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.player_mod_enable {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_masks {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.player_mod_enable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VoiceMask {
        CCSUsrMsg_VoiceMask::new()
    }

    fn clear(&mut self) {
        self.player_masks.clear();
        self.player_mod_enable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VoiceMask {
        static instance: CCSUsrMsg_VoiceMask = CCSUsrMsg_VoiceMask {
            player_masks: ::std::vec::Vec::new(),
            player_mod_enable: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_VoiceMask {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_VoiceMask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_VoiceMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoiceMask {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CCSUsrMsg_VoiceMask`
pub mod ccsusr_msg_voice_mask {
    // @@protoc_insertion_point(message:CCSUsrMsg_VoiceMask.PlayerMask)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerMask {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_VoiceMask.PlayerMask.game_rules_mask)
        pub game_rules_mask: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_VoiceMask.PlayerMask.ban_masks)
        pub ban_masks: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_VoiceMask.PlayerMask.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerMask {
        fn default() -> &'a PlayerMask {
            <PlayerMask as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerMask {
        pub fn new() -> PlayerMask {
            ::std::default::Default::default()
        }

        // optional int32 game_rules_mask = 1;

        pub fn game_rules_mask(&self) -> i32 {
            self.game_rules_mask.unwrap_or(0)
        }

        pub fn clear_game_rules_mask(&mut self) {
            self.game_rules_mask = ::std::option::Option::None;
        }

        pub fn has_game_rules_mask(&self) -> bool {
            self.game_rules_mask.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_rules_mask(&mut self, v: i32) {
            self.game_rules_mask = ::std::option::Option::Some(v);
        }

        // optional int32 ban_masks = 2;

        pub fn ban_masks(&self) -> i32 {
            self.ban_masks.unwrap_or(0)
        }

        pub fn clear_ban_masks(&mut self) {
            self.ban_masks = ::std::option::Option::None;
        }

        pub fn has_ban_masks(&self) -> bool {
            self.ban_masks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ban_masks(&mut self, v: i32) {
            self.ban_masks = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_rules_mask",
                |m: &PlayerMask| { &m.game_rules_mask },
                |m: &mut PlayerMask| { &mut m.game_rules_mask },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ban_masks",
                |m: &PlayerMask| { &m.ban_masks },
                |m: &mut PlayerMask| { &mut m.ban_masks },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerMask>(
                "CCSUsrMsg_VoiceMask.PlayerMask",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerMask {
        const NAME: &'static str = "PlayerMask";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.game_rules_mask = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.ban_masks = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_rules_mask {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.ban_masks {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.game_rules_mask {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.ban_masks {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerMask {
            PlayerMask::new()
        }

        fn clear(&mut self) {
            self.game_rules_mask = ::std::option::Option::None;
            self.ban_masks = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerMask {
            static instance: PlayerMask = PlayerMask {
                game_rules_mask: ::std::option::Option::None,
                ban_masks: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerMask {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_VoiceMask.PlayerMask").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerMask {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerMask {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_Damage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Damage {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Damage.amount)
    pub amount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Damage.inflictor_world_pos)
    pub inflictor_world_pos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Damage.victim_entindex)
    pub victim_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Damage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Damage {
    fn default() -> &'a CCSUsrMsg_Damage {
        <CCSUsrMsg_Damage as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Damage {
    pub fn new() -> CCSUsrMsg_Damage {
        ::std::default::Default::default()
    }

    // optional int32 amount = 1;

    pub fn amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional int32 victim_entindex = 3;

    pub fn victim_entindex(&self) -> i32 {
        self.victim_entindex.unwrap_or(-1i32)
    }

    pub fn clear_victim_entindex(&mut self) {
        self.victim_entindex = ::std::option::Option::None;
    }

    pub fn has_victim_entindex(&self) -> bool {
        self.victim_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_entindex(&mut self, v: i32) {
        self.victim_entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &CCSUsrMsg_Damage| { &m.amount },
            |m: &mut CCSUsrMsg_Damage| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "inflictor_world_pos",
            |m: &CCSUsrMsg_Damage| { &m.inflictor_world_pos },
            |m: &mut CCSUsrMsg_Damage| { &mut m.inflictor_world_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_entindex",
            |m: &CCSUsrMsg_Damage| { &m.victim_entindex },
            |m: &mut CCSUsrMsg_Damage| { &mut m.victim_entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_Damage>(
            "CCSUsrMsg_Damage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_Damage {
    const NAME: &'static str = "CCSUsrMsg_Damage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.amount = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inflictor_world_pos)?;
                },
                24 => {
                    self.victim_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.inflictor_world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.victim_entindex {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.amount {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.inflictor_world_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.victim_entindex {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Damage {
        CCSUsrMsg_Damage::new()
    }

    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.inflictor_world_pos.clear();
        self.victim_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Damage {
        static instance: CCSUsrMsg_Damage = CCSUsrMsg_Damage {
            amount: ::std::option::Option::None,
            inflictor_world_pos: ::protobuf::MessageField::none(),
            victim_entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_Damage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_Damage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_Damage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_Damage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_RadioText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_RadioText {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_RadioText.msg_dst)
    pub msg_dst: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RadioText.client)
    pub client: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RadioText.msg_name)
    pub msg_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RadioText.params)
    pub params: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_RadioText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RadioText {
    fn default() -> &'a CCSUsrMsg_RadioText {
        <CCSUsrMsg_RadioText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RadioText {
    pub fn new() -> CCSUsrMsg_RadioText {
        ::std::default::Default::default()
    }

    // optional int32 msg_dst = 1;

    pub fn msg_dst(&self) -> i32 {
        self.msg_dst.unwrap_or(0)
    }

    pub fn clear_msg_dst(&mut self) {
        self.msg_dst = ::std::option::Option::None;
    }

    pub fn has_msg_dst(&self) -> bool {
        self.msg_dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_dst(&mut self, v: i32) {
        self.msg_dst = ::std::option::Option::Some(v);
    }

    // optional int32 client = 2;

    pub fn client(&self) -> i32 {
        self.client.unwrap_or(-1i32)
    }

    pub fn clear_client(&mut self) {
        self.client = ::std::option::Option::None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: i32) {
        self.client = ::std::option::Option::Some(v);
    }

    // optional string msg_name = 3;

    pub fn msg_name(&self) -> &str {
        match self.msg_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_msg_name(&mut self) {
        self.msg_name = ::std::option::Option::None;
    }

    pub fn has_msg_name(&self) -> bool {
        self.msg_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_name(&mut self, v: ::std::string::String) {
        self.msg_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_name(&mut self) -> &mut ::std::string::String {
        if self.msg_name.is_none() {
            self.msg_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.msg_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_name(&mut self) -> ::std::string::String {
        self.msg_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_dst",
            |m: &CCSUsrMsg_RadioText| { &m.msg_dst },
            |m: &mut CCSUsrMsg_RadioText| { &mut m.msg_dst },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client",
            |m: &CCSUsrMsg_RadioText| { &m.client },
            |m: &mut CCSUsrMsg_RadioText| { &mut m.client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_name",
            |m: &CCSUsrMsg_RadioText| { &m.msg_name },
            |m: &mut CCSUsrMsg_RadioText| { &mut m.msg_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "params",
            |m: &CCSUsrMsg_RadioText| { &m.params },
            |m: &mut CCSUsrMsg_RadioText| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_RadioText>(
            "CCSUsrMsg_RadioText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_RadioText {
    const NAME: &'static str = "CCSUsrMsg_RadioText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_dst = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.client = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.msg_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.params.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_dst {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.client {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.msg_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_dst {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.client {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.msg_name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.params {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_RadioText {
        CCSUsrMsg_RadioText::new()
    }

    fn clear(&mut self) {
        self.msg_dst = ::std::option::Option::None;
        self.client = ::std::option::Option::None;
        self.msg_name = ::std::option::Option::None;
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_RadioText {
        static instance: CCSUsrMsg_RadioText = CCSUsrMsg_RadioText {
            msg_dst: ::std::option::Option::None,
            client: ::std::option::Option::None,
            msg_name: ::std::option::Option::None,
            params: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_RadioText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_RadioText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_RadioText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RadioText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_HintText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_HintText {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_HintText.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_HintText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HintText {
    fn default() -> &'a CCSUsrMsg_HintText {
        <CCSUsrMsg_HintText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HintText {
    pub fn new() -> CCSUsrMsg_HintText {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CCSUsrMsg_HintText| { &m.message },
            |m: &mut CCSUsrMsg_HintText| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_HintText>(
            "CCSUsrMsg_HintText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_HintText {
    const NAME: &'static str = "CCSUsrMsg_HintText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_HintText {
        CCSUsrMsg_HintText::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_HintText {
        static instance: CCSUsrMsg_HintText = CCSUsrMsg_HintText {
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_HintText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_HintText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_HintText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_HintText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_KeyHintText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_KeyHintText {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_KeyHintText.messages)
    pub messages: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_KeyHintText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_KeyHintText {
    fn default() -> &'a CCSUsrMsg_KeyHintText {
        <CCSUsrMsg_KeyHintText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_KeyHintText {
    pub fn new() -> CCSUsrMsg_KeyHintText {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CCSUsrMsg_KeyHintText| { &m.messages },
            |m: &mut CCSUsrMsg_KeyHintText| { &mut m.messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_KeyHintText>(
            "CCSUsrMsg_KeyHintText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_KeyHintText {
    const NAME: &'static str = "CCSUsrMsg_KeyHintText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.messages {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_KeyHintText {
        CCSUsrMsg_KeyHintText::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_KeyHintText {
        static instance: CCSUsrMsg_KeyHintText = CCSUsrMsg_KeyHintText {
            messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_KeyHintText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_KeyHintText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_KeyHintText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_KeyHintText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ProcessSpottedEntityUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ProcessSpottedEntityUpdate {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.new_update)
    pub new_update: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.entity_updates)
    pub entity_updates: ::std::vec::Vec<ccsusr_msg_process_spotted_entity_update::SpottedEntityUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ProcessSpottedEntityUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn default() -> &'a CCSUsrMsg_ProcessSpottedEntityUpdate {
        <CCSUsrMsg_ProcessSpottedEntityUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ProcessSpottedEntityUpdate {
    pub fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate {
        ::std::default::Default::default()
    }

    // optional bool new_update = 1;

    pub fn new_update(&self) -> bool {
        self.new_update.unwrap_or(false)
    }

    pub fn clear_new_update(&mut self) {
        self.new_update = ::std::option::Option::None;
    }

    pub fn has_new_update(&self) -> bool {
        self.new_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_update(&mut self, v: bool) {
        self.new_update = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_update",
            |m: &CCSUsrMsg_ProcessSpottedEntityUpdate| { &m.new_update },
            |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate| { &mut m.new_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entity_updates",
            |m: &CCSUsrMsg_ProcessSpottedEntityUpdate| { &m.entity_updates },
            |m: &mut CCSUsrMsg_ProcessSpottedEntityUpdate| { &mut m.entity_updates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ProcessSpottedEntityUpdate>(
            "CCSUsrMsg_ProcessSpottedEntityUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ProcessSpottedEntityUpdate {
    const NAME: &'static str = "CCSUsrMsg_ProcessSpottedEntityUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_update = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.entity_updates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_update {
            my_size += 1 + 1;
        }
        for value in &self.entity_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_update {
            os.write_bool(1, v)?;
        }
        for v in &self.entity_updates {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate {
        CCSUsrMsg_ProcessSpottedEntityUpdate::new()
    }

    fn clear(&mut self) {
        self.new_update = ::std::option::Option::None;
        self.entity_updates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ProcessSpottedEntityUpdate {
        static instance: CCSUsrMsg_ProcessSpottedEntityUpdate = CCSUsrMsg_ProcessSpottedEntityUpdate {
            new_update: ::std::option::Option::None,
            entity_updates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ProcessSpottedEntityUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ProcessSpottedEntityUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CCSUsrMsg_ProcessSpottedEntityUpdate`
pub mod ccsusr_msg_process_spotted_entity_update {
    // @@protoc_insertion_point(message:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SpottedEntityUpdate {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.entity_idx)
        pub entity_idx: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.class_id)
        pub class_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.origin_x)
        pub origin_x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.origin_y)
        pub origin_y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.origin_z)
        pub origin_z: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.angle_y)
        pub angle_y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.defuser)
        pub defuser: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.player_has_defuser)
        pub player_has_defuser: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.player_has_c4)
        pub player_has_c4: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SpottedEntityUpdate {
        fn default() -> &'a SpottedEntityUpdate {
            <SpottedEntityUpdate as ::protobuf::Message>::default_instance()
        }
    }

    impl SpottedEntityUpdate {
        pub fn new() -> SpottedEntityUpdate {
            ::std::default::Default::default()
        }

        // optional int32 entity_idx = 1;

        pub fn entity_idx(&self) -> i32 {
            self.entity_idx.unwrap_or(-1i32)
        }

        pub fn clear_entity_idx(&mut self) {
            self.entity_idx = ::std::option::Option::None;
        }

        pub fn has_entity_idx(&self) -> bool {
            self.entity_idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_idx(&mut self, v: i32) {
            self.entity_idx = ::std::option::Option::Some(v);
        }

        // optional int32 class_id = 2;

        pub fn class_id(&self) -> i32 {
            self.class_id.unwrap_or(0)
        }

        pub fn clear_class_id(&mut self) {
            self.class_id = ::std::option::Option::None;
        }

        pub fn has_class_id(&self) -> bool {
            self.class_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_id(&mut self, v: i32) {
            self.class_id = ::std::option::Option::Some(v);
        }

        // optional int32 origin_x = 3;

        pub fn origin_x(&self) -> i32 {
            self.origin_x.unwrap_or(0)
        }

        pub fn clear_origin_x(&mut self) {
            self.origin_x = ::std::option::Option::None;
        }

        pub fn has_origin_x(&self) -> bool {
            self.origin_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_x(&mut self, v: i32) {
            self.origin_x = ::std::option::Option::Some(v);
        }

        // optional int32 origin_y = 4;

        pub fn origin_y(&self) -> i32 {
            self.origin_y.unwrap_or(0)
        }

        pub fn clear_origin_y(&mut self) {
            self.origin_y = ::std::option::Option::None;
        }

        pub fn has_origin_y(&self) -> bool {
            self.origin_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_y(&mut self, v: i32) {
            self.origin_y = ::std::option::Option::Some(v);
        }

        // optional int32 origin_z = 5;

        pub fn origin_z(&self) -> i32 {
            self.origin_z.unwrap_or(0)
        }

        pub fn clear_origin_z(&mut self) {
            self.origin_z = ::std::option::Option::None;
        }

        pub fn has_origin_z(&self) -> bool {
            self.origin_z.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_z(&mut self, v: i32) {
            self.origin_z = ::std::option::Option::Some(v);
        }

        // optional int32 angle_y = 6;

        pub fn angle_y(&self) -> i32 {
            self.angle_y.unwrap_or(0)
        }

        pub fn clear_angle_y(&mut self) {
            self.angle_y = ::std::option::Option::None;
        }

        pub fn has_angle_y(&self) -> bool {
            self.angle_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_angle_y(&mut self, v: i32) {
            self.angle_y = ::std::option::Option::Some(v);
        }

        // optional bool defuser = 7;

        pub fn defuser(&self) -> bool {
            self.defuser.unwrap_or(false)
        }

        pub fn clear_defuser(&mut self) {
            self.defuser = ::std::option::Option::None;
        }

        pub fn has_defuser(&self) -> bool {
            self.defuser.is_some()
        }

        // Param is passed by value, moved
        pub fn set_defuser(&mut self, v: bool) {
            self.defuser = ::std::option::Option::Some(v);
        }

        // optional bool player_has_defuser = 8;

        pub fn player_has_defuser(&self) -> bool {
            self.player_has_defuser.unwrap_or(false)
        }

        pub fn clear_player_has_defuser(&mut self) {
            self.player_has_defuser = ::std::option::Option::None;
        }

        pub fn has_player_has_defuser(&self) -> bool {
            self.player_has_defuser.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_has_defuser(&mut self, v: bool) {
            self.player_has_defuser = ::std::option::Option::Some(v);
        }

        // optional bool player_has_c4 = 9;

        pub fn player_has_c4(&self) -> bool {
            self.player_has_c4.unwrap_or(false)
        }

        pub fn clear_player_has_c4(&mut self) {
            self.player_has_c4 = ::std::option::Option::None;
        }

        pub fn has_player_has_c4(&self) -> bool {
            self.player_has_c4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_has_c4(&mut self, v: bool) {
            self.player_has_c4 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_idx",
                |m: &SpottedEntityUpdate| { &m.entity_idx },
                |m: &mut SpottedEntityUpdate| { &mut m.entity_idx },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "class_id",
                |m: &SpottedEntityUpdate| { &m.class_id },
                |m: &mut SpottedEntityUpdate| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_x",
                |m: &SpottedEntityUpdate| { &m.origin_x },
                |m: &mut SpottedEntityUpdate| { &mut m.origin_x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_y",
                |m: &SpottedEntityUpdate| { &m.origin_y },
                |m: &mut SpottedEntityUpdate| { &mut m.origin_y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_z",
                |m: &SpottedEntityUpdate| { &m.origin_z },
                |m: &mut SpottedEntityUpdate| { &mut m.origin_z },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "angle_y",
                |m: &SpottedEntityUpdate| { &m.angle_y },
                |m: &mut SpottedEntityUpdate| { &mut m.angle_y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "defuser",
                |m: &SpottedEntityUpdate| { &m.defuser },
                |m: &mut SpottedEntityUpdate| { &mut m.defuser },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_has_defuser",
                |m: &SpottedEntityUpdate| { &m.player_has_defuser },
                |m: &mut SpottedEntityUpdate| { &mut m.player_has_defuser },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_has_c4",
                |m: &SpottedEntityUpdate| { &m.player_has_c4 },
                |m: &mut SpottedEntityUpdate| { &mut m.player_has_c4 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpottedEntityUpdate>(
                "CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SpottedEntityUpdate {
        const NAME: &'static str = "SpottedEntityUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.entity_idx = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.class_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.origin_x = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.origin_y = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.origin_z = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.angle_y = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.defuser = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.player_has_defuser = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.player_has_c4 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entity_idx {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.class_id {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.origin_x {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.origin_y {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.origin_z {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.angle_y {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.defuser {
                my_size += 1 + 1;
            }
            if let Some(v) = self.player_has_defuser {
                my_size += 1 + 1;
            }
            if let Some(v) = self.player_has_c4 {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.entity_idx {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.class_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.origin_x {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.origin_y {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.origin_z {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.angle_y {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.defuser {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.player_has_defuser {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.player_has_c4 {
                os.write_bool(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SpottedEntityUpdate {
            SpottedEntityUpdate::new()
        }

        fn clear(&mut self) {
            self.entity_idx = ::std::option::Option::None;
            self.class_id = ::std::option::Option::None;
            self.origin_x = ::std::option::Option::None;
            self.origin_y = ::std::option::Option::None;
            self.origin_z = ::std::option::Option::None;
            self.angle_y = ::std::option::Option::None;
            self.defuser = ::std::option::Option::None;
            self.player_has_defuser = ::std::option::Option::None;
            self.player_has_c4 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SpottedEntityUpdate {
            static instance: SpottedEntityUpdate = SpottedEntityUpdate {
                entity_idx: ::std::option::Option::None,
                class_id: ::std::option::Option::None,
                origin_x: ::std::option::Option::None,
                origin_y: ::std::option::Option::None,
                origin_z: ::std::option::Option::None,
                angle_y: ::std::option::Option::None,
                defuser: ::std::option::Option::None,
                player_has_defuser: ::std::option::Option::None,
                player_has_c4: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SpottedEntityUpdate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SpottedEntityUpdate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SpottedEntityUpdate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_SendPlayerItemDrops)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SendPlayerItemDrops {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SendPlayerItemDrops.entity_updates)
    pub entity_updates: ::std::vec::Vec<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SendPlayerItemDrops.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendPlayerItemDrops {
    fn default() -> &'a CCSUsrMsg_SendPlayerItemDrops {
        <CCSUsrMsg_SendPlayerItemDrops as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendPlayerItemDrops {
    pub fn new() -> CCSUsrMsg_SendPlayerItemDrops {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entity_updates",
            |m: &CCSUsrMsg_SendPlayerItemDrops| { &m.entity_updates },
            |m: &mut CCSUsrMsg_SendPlayerItemDrops| { &mut m.entity_updates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_SendPlayerItemDrops>(
            "CCSUsrMsg_SendPlayerItemDrops",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendPlayerItemDrops {
    const NAME: &'static str = "CCSUsrMsg_SendPlayerItemDrops";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_updates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entity_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entity_updates {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SendPlayerItemDrops {
        CCSUsrMsg_SendPlayerItemDrops::new()
    }

    fn clear(&mut self) {
        self.entity_updates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SendPlayerItemDrops {
        static instance: CCSUsrMsg_SendPlayerItemDrops = CCSUsrMsg_SendPlayerItemDrops {
            entity_updates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_SendPlayerItemDrops {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_SendPlayerItemDrops").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_SendPlayerItemDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendPlayerItemDrops {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_SendPlayerItemFound)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SendPlayerItemFound {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SendPlayerItemFound.iteminfo)
    pub iteminfo: ::protobuf::MessageField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendPlayerItemFound.playerslot)
    pub playerslot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SendPlayerItemFound.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendPlayerItemFound {
    fn default() -> &'a CCSUsrMsg_SendPlayerItemFound {
        <CCSUsrMsg_SendPlayerItemFound as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendPlayerItemFound {
    pub fn new() -> CCSUsrMsg_SendPlayerItemFound {
        ::std::default::Default::default()
    }

    // optional int32 playerslot = 2;

    pub fn playerslot(&self) -> i32 {
        self.playerslot.unwrap_or(-1i32)
    }

    pub fn clear_playerslot(&mut self) {
        self.playerslot = ::std::option::Option::None;
    }

    pub fn has_playerslot(&self) -> bool {
        self.playerslot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerslot(&mut self, v: i32) {
        self.playerslot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::CEconItemPreviewDataBlock>(
            "iteminfo",
            |m: &CCSUsrMsg_SendPlayerItemFound| { &m.iteminfo },
            |m: &mut CCSUsrMsg_SendPlayerItemFound| { &mut m.iteminfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playerslot",
            |m: &CCSUsrMsg_SendPlayerItemFound| { &m.playerslot },
            |m: &mut CCSUsrMsg_SendPlayerItemFound| { &mut m.playerslot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_SendPlayerItemFound>(
            "CCSUsrMsg_SendPlayerItemFound",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendPlayerItemFound {
    const NAME: &'static str = "CCSUsrMsg_SendPlayerItemFound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.iteminfo)?;
                },
                16 => {
                    self.playerslot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.playerslot {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.iteminfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.playerslot {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SendPlayerItemFound {
        CCSUsrMsg_SendPlayerItemFound::new()
    }

    fn clear(&mut self) {
        self.iteminfo.clear();
        self.playerslot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SendPlayerItemFound {
        static instance: CCSUsrMsg_SendPlayerItemFound = CCSUsrMsg_SendPlayerItemFound {
            iteminfo: ::protobuf::MessageField::none(),
            playerslot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_SendPlayerItemFound {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_SendPlayerItemFound").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_SendPlayerItemFound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendPlayerItemFound {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ReloadEffect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ReloadEffect {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ReloadEffect.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReloadEffect.actanim)
    pub actanim: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReloadEffect.origin_x)
    pub origin_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReloadEffect.origin_y)
    pub origin_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReloadEffect.origin_z)
    pub origin_z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ReloadEffect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ReloadEffect {
    fn default() -> &'a CCSUsrMsg_ReloadEffect {
        <CCSUsrMsg_ReloadEffect as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ReloadEffect {
    pub fn new() -> CCSUsrMsg_ReloadEffect {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional int32 actanim = 2;

    pub fn actanim(&self) -> i32 {
        self.actanim.unwrap_or(0)
    }

    pub fn clear_actanim(&mut self) {
        self.actanim = ::std::option::Option::None;
    }

    pub fn has_actanim(&self) -> bool {
        self.actanim.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actanim(&mut self, v: i32) {
        self.actanim = ::std::option::Option::Some(v);
    }

    // optional float origin_x = 3;

    pub fn origin_x(&self) -> f32 {
        self.origin_x.unwrap_or(0.)
    }

    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: f32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional float origin_y = 4;

    pub fn origin_y(&self) -> f32 {
        self.origin_y.unwrap_or(0.)
    }

    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: f32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional float origin_z = 5;

    pub fn origin_z(&self) -> f32 {
        self.origin_z.unwrap_or(0.)
    }

    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: f32) {
        self.origin_z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CCSUsrMsg_ReloadEffect| { &m.entidx },
            |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.entidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actanim",
            |m: &CCSUsrMsg_ReloadEffect| { &m.actanim },
            |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.actanim },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_x",
            |m: &CCSUsrMsg_ReloadEffect| { &m.origin_x },
            |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.origin_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_y",
            |m: &CCSUsrMsg_ReloadEffect| { &m.origin_y },
            |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.origin_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_z",
            |m: &CCSUsrMsg_ReloadEffect| { &m.origin_z },
            |m: &mut CCSUsrMsg_ReloadEffect| { &mut m.origin_z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ReloadEffect>(
            "CCSUsrMsg_ReloadEffect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ReloadEffect {
    const NAME: &'static str = "CCSUsrMsg_ReloadEffect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.actanim = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.origin_x = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.origin_y = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.origin_z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.actanim {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.origin_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_z {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.actanim {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ReloadEffect {
        CCSUsrMsg_ReloadEffect::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.actanim = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ReloadEffect {
        static instance: CCSUsrMsg_ReloadEffect = CCSUsrMsg_ReloadEffect {
            entidx: ::std::option::Option::None,
            actanim: ::std::option::Option::None,
            origin_x: ::std::option::Option::None,
            origin_y: ::std::option::Option::None,
            origin_z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ReloadEffect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ReloadEffect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ReloadEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ReloadEffect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_WeaponSound)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_WeaponSound {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.origin_x)
    pub origin_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.origin_y)
    pub origin_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.origin_z)
    pub origin_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.sound)
    pub sound: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.game_timestamp)
    pub game_timestamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.source_soundscapeid)
    pub source_soundscapeid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_WeaponSound.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_WeaponSound {
    fn default() -> &'a CCSUsrMsg_WeaponSound {
        <CCSUsrMsg_WeaponSound as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_WeaponSound {
    pub fn new() -> CCSUsrMsg_WeaponSound {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float origin_x = 2;

    pub fn origin_x(&self) -> f32 {
        self.origin_x.unwrap_or(0.)
    }

    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: f32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional float origin_y = 3;

    pub fn origin_y(&self) -> f32 {
        self.origin_y.unwrap_or(0.)
    }

    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: f32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional float origin_z = 4;

    pub fn origin_z(&self) -> f32 {
        self.origin_z.unwrap_or(0.)
    }

    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: f32) {
        self.origin_z = ::std::option::Option::Some(v);
    }

    // optional string sound = 5;

    pub fn sound(&self) -> &str {
        match self.sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sound(&mut self) {
        self.sound = ::std::option::Option::None;
    }

    pub fn has_sound(&self) -> bool {
        self.sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound(&mut self, v: ::std::string::String) {
        self.sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sound(&mut self) -> &mut ::std::string::String {
        if self.sound.is_none() {
            self.sound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_sound(&mut self) -> ::std::string::String {
        self.sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float game_timestamp = 6;

    pub fn game_timestamp(&self) -> f32 {
        self.game_timestamp.unwrap_or(0.)
    }

    pub fn clear_game_timestamp(&mut self) {
        self.game_timestamp = ::std::option::Option::None;
    }

    pub fn has_game_timestamp(&self) -> bool {
        self.game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_timestamp(&mut self, v: f32) {
        self.game_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 source_soundscapeid = 7;

    pub fn source_soundscapeid(&self) -> u32 {
        self.source_soundscapeid.unwrap_or(0)
    }

    pub fn clear_source_soundscapeid(&mut self) {
        self.source_soundscapeid = ::std::option::Option::None;
    }

    pub fn has_source_soundscapeid(&self) -> bool {
        self.source_soundscapeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_soundscapeid(&mut self, v: u32) {
        self.source_soundscapeid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CCSUsrMsg_WeaponSound| { &m.entidx },
            |m: &mut CCSUsrMsg_WeaponSound| { &mut m.entidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_x",
            |m: &CCSUsrMsg_WeaponSound| { &m.origin_x },
            |m: &mut CCSUsrMsg_WeaponSound| { &mut m.origin_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_y",
            |m: &CCSUsrMsg_WeaponSound| { &m.origin_y },
            |m: &mut CCSUsrMsg_WeaponSound| { &mut m.origin_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_z",
            |m: &CCSUsrMsg_WeaponSound| { &m.origin_z },
            |m: &mut CCSUsrMsg_WeaponSound| { &mut m.origin_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sound",
            |m: &CCSUsrMsg_WeaponSound| { &m.sound },
            |m: &mut CCSUsrMsg_WeaponSound| { &mut m.sound },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_timestamp",
            |m: &CCSUsrMsg_WeaponSound| { &m.game_timestamp },
            |m: &mut CCSUsrMsg_WeaponSound| { &mut m.game_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_soundscapeid",
            |m: &CCSUsrMsg_WeaponSound| { &m.source_soundscapeid },
            |m: &mut CCSUsrMsg_WeaponSound| { &mut m.source_soundscapeid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_WeaponSound>(
            "CCSUsrMsg_WeaponSound",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_WeaponSound {
    const NAME: &'static str = "CCSUsrMsg_WeaponSound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.origin_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.origin_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.origin_z = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    self.sound = ::std::option::Option::Some(is.read_string()?);
                },
                53 => {
                    self.game_timestamp = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.source_soundscapeid = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.origin_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.sound.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.game_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.source_soundscapeid {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.sound.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.game_timestamp {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.source_soundscapeid {
            os.write_fixed32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_WeaponSound {
        CCSUsrMsg_WeaponSound::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.sound = ::std::option::Option::None;
        self.game_timestamp = ::std::option::Option::None;
        self.source_soundscapeid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_WeaponSound {
        static instance: CCSUsrMsg_WeaponSound = CCSUsrMsg_WeaponSound {
            entidx: ::std::option::Option::None,
            origin_x: ::std::option::Option::None,
            origin_y: ::std::option::Option::None,
            origin_z: ::std::option::Option::None,
            sound: ::std::option::Option::None,
            game_timestamp: ::std::option::Option::None,
            source_soundscapeid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_WeaponSound {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_WeaponSound").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_WeaponSound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_WeaponSound {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_UpdateScreenHealthBar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_UpdateScreenHealthBar {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_UpdateScreenHealthBar.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_UpdateScreenHealthBar.healthratio_old)
    pub healthratio_old: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_UpdateScreenHealthBar.healthratio_new)
    pub healthratio_new: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_UpdateScreenHealthBar.style)
    pub style: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_UpdateScreenHealthBar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_UpdateScreenHealthBar {
    fn default() -> &'a CCSUsrMsg_UpdateScreenHealthBar {
        <CCSUsrMsg_UpdateScreenHealthBar as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_UpdateScreenHealthBar {
    pub fn new() -> CCSUsrMsg_UpdateScreenHealthBar {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float healthratio_old = 2;

    pub fn healthratio_old(&self) -> f32 {
        self.healthratio_old.unwrap_or(0.)
    }

    pub fn clear_healthratio_old(&mut self) {
        self.healthratio_old = ::std::option::Option::None;
    }

    pub fn has_healthratio_old(&self) -> bool {
        self.healthratio_old.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthratio_old(&mut self, v: f32) {
        self.healthratio_old = ::std::option::Option::Some(v);
    }

    // optional float healthratio_new = 3;

    pub fn healthratio_new(&self) -> f32 {
        self.healthratio_new.unwrap_or(0.)
    }

    pub fn clear_healthratio_new(&mut self) {
        self.healthratio_new = ::std::option::Option::None;
    }

    pub fn has_healthratio_new(&self) -> bool {
        self.healthratio_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthratio_new(&mut self, v: f32) {
        self.healthratio_new = ::std::option::Option::Some(v);
    }

    // optional int32 style = 4;

    pub fn style(&self) -> i32 {
        self.style.unwrap_or(0)
    }

    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: i32) {
        self.style = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.entidx },
            |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.entidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healthratio_old",
            |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.healthratio_old },
            |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.healthratio_old },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healthratio_new",
            |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.healthratio_new },
            |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.healthratio_new },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style",
            |m: &CCSUsrMsg_UpdateScreenHealthBar| { &m.style },
            |m: &mut CCSUsrMsg_UpdateScreenHealthBar| { &mut m.style },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_UpdateScreenHealthBar>(
            "CCSUsrMsg_UpdateScreenHealthBar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_UpdateScreenHealthBar {
    const NAME: &'static str = "CCSUsrMsg_UpdateScreenHealthBar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.healthratio_old = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.healthratio_new = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.style = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.healthratio_old {
            my_size += 1 + 4;
        }
        if let Some(v) = self.healthratio_new {
            my_size += 1 + 4;
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.healthratio_old {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.healthratio_new {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.style {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_UpdateScreenHealthBar {
        CCSUsrMsg_UpdateScreenHealthBar::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.healthratio_old = ::std::option::Option::None;
        self.healthratio_new = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_UpdateScreenHealthBar {
        static instance: CCSUsrMsg_UpdateScreenHealthBar = CCSUsrMsg_UpdateScreenHealthBar {
            entidx: ::std::option::Option::None,
            healthratio_old: ::std::option::Option::None,
            healthratio_new: ::std::option::Option::None,
            style: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_UpdateScreenHealthBar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_UpdateScreenHealthBar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_UpdateScreenHealthBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_UpdateScreenHealthBar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_EntityOutlineHighlight)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_EntityOutlineHighlight {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_EntityOutlineHighlight.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_EntityOutlineHighlight.removehighlight)
    pub removehighlight: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_EntityOutlineHighlight.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_EntityOutlineHighlight {
    fn default() -> &'a CCSUsrMsg_EntityOutlineHighlight {
        <CCSUsrMsg_EntityOutlineHighlight as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_EntityOutlineHighlight {
    pub fn new() -> CCSUsrMsg_EntityOutlineHighlight {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional bool removehighlight = 2;

    pub fn removehighlight(&self) -> bool {
        self.removehighlight.unwrap_or(false)
    }

    pub fn clear_removehighlight(&mut self) {
        self.removehighlight = ::std::option::Option::None;
    }

    pub fn has_removehighlight(&self) -> bool {
        self.removehighlight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_removehighlight(&mut self, v: bool) {
        self.removehighlight = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CCSUsrMsg_EntityOutlineHighlight| { &m.entidx },
            |m: &mut CCSUsrMsg_EntityOutlineHighlight| { &mut m.entidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "removehighlight",
            |m: &CCSUsrMsg_EntityOutlineHighlight| { &m.removehighlight },
            |m: &mut CCSUsrMsg_EntityOutlineHighlight| { &mut m.removehighlight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_EntityOutlineHighlight>(
            "CCSUsrMsg_EntityOutlineHighlight",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_EntityOutlineHighlight {
    const NAME: &'static str = "CCSUsrMsg_EntityOutlineHighlight";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.removehighlight = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.removehighlight {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.removehighlight {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_EntityOutlineHighlight {
        CCSUsrMsg_EntityOutlineHighlight::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.removehighlight = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_EntityOutlineHighlight {
        static instance: CCSUsrMsg_EntityOutlineHighlight = CCSUsrMsg_EntityOutlineHighlight {
            entidx: ::std::option::Option::None,
            removehighlight: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_EntityOutlineHighlight {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_EntityOutlineHighlight").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_EntityOutlineHighlight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_EntityOutlineHighlight {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_AdjustMoney)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_AdjustMoney {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_AdjustMoney.amount)
    pub amount: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_AdjustMoney.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AdjustMoney {
    fn default() -> &'a CCSUsrMsg_AdjustMoney {
        <CCSUsrMsg_AdjustMoney as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AdjustMoney {
    pub fn new() -> CCSUsrMsg_AdjustMoney {
        ::std::default::Default::default()
    }

    // optional int32 amount = 1;

    pub fn amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &CCSUsrMsg_AdjustMoney| { &m.amount },
            |m: &mut CCSUsrMsg_AdjustMoney| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_AdjustMoney>(
            "CCSUsrMsg_AdjustMoney",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_AdjustMoney {
    const NAME: &'static str = "CCSUsrMsg_AdjustMoney";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.amount = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.amount {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_AdjustMoney {
        CCSUsrMsg_AdjustMoney::new()
    }

    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_AdjustMoney {
        static instance: CCSUsrMsg_AdjustMoney = CCSUsrMsg_AdjustMoney {
            amount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_AdjustMoney {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_AdjustMoney").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_AdjustMoney {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_AdjustMoney {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ReportHit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ReportHit {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ReportHit.pos_x)
    pub pos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReportHit.pos_y)
    pub pos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReportHit.timestamp)
    pub timestamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReportHit.pos_z)
    pub pos_z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ReportHit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ReportHit {
    fn default() -> &'a CCSUsrMsg_ReportHit {
        <CCSUsrMsg_ReportHit as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ReportHit {
    pub fn new() -> CCSUsrMsg_ReportHit {
        ::std::default::Default::default()
    }

    // optional float pos_x = 1;

    pub fn pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 2;

    pub fn pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float timestamp = 4;

    pub fn timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 3;

    pub fn pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x",
            |m: &CCSUsrMsg_ReportHit| { &m.pos_x },
            |m: &mut CCSUsrMsg_ReportHit| { &mut m.pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y",
            |m: &CCSUsrMsg_ReportHit| { &m.pos_y },
            |m: &mut CCSUsrMsg_ReportHit| { &mut m.pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CCSUsrMsg_ReportHit| { &m.timestamp },
            |m: &mut CCSUsrMsg_ReportHit| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z",
            |m: &CCSUsrMsg_ReportHit| { &m.pos_z },
            |m: &mut CCSUsrMsg_ReportHit| { &mut m.pos_z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ReportHit>(
            "CCSUsrMsg_ReportHit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ReportHit {
    const NAME: &'static str = "CCSUsrMsg_ReportHit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.pos_x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.pos_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.timestamp = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.pos_z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_z {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos_x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ReportHit {
        CCSUsrMsg_ReportHit::new()
    }

    fn clear(&mut self) {
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ReportHit {
        static instance: CCSUsrMsg_ReportHit = CCSUsrMsg_ReportHit {
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ReportHit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ReportHit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ReportHit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ReportHit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_KillCam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_KillCam {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_KillCam.obs_mode)
    pub obs_mode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_KillCam.first_target)
    pub first_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_KillCam.second_target)
    pub second_target: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_KillCam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_KillCam {
    fn default() -> &'a CCSUsrMsg_KillCam {
        <CCSUsrMsg_KillCam as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_KillCam {
    pub fn new() -> CCSUsrMsg_KillCam {
        ::std::default::Default::default()
    }

    // optional int32 obs_mode = 1;

    pub fn obs_mode(&self) -> i32 {
        self.obs_mode.unwrap_or(0)
    }

    pub fn clear_obs_mode(&mut self) {
        self.obs_mode = ::std::option::Option::None;
    }

    pub fn has_obs_mode(&self) -> bool {
        self.obs_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_obs_mode(&mut self, v: i32) {
        self.obs_mode = ::std::option::Option::Some(v);
    }

    // optional int32 first_target = 2;

    pub fn first_target(&self) -> i32 {
        self.first_target.unwrap_or(-1i32)
    }

    pub fn clear_first_target(&mut self) {
        self.first_target = ::std::option::Option::None;
    }

    pub fn has_first_target(&self) -> bool {
        self.first_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_target(&mut self, v: i32) {
        self.first_target = ::std::option::Option::Some(v);
    }

    // optional int32 second_target = 3;

    pub fn second_target(&self) -> i32 {
        self.second_target.unwrap_or(-1i32)
    }

    pub fn clear_second_target(&mut self) {
        self.second_target = ::std::option::Option::None;
    }

    pub fn has_second_target(&self) -> bool {
        self.second_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_second_target(&mut self, v: i32) {
        self.second_target = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "obs_mode",
            |m: &CCSUsrMsg_KillCam| { &m.obs_mode },
            |m: &mut CCSUsrMsg_KillCam| { &mut m.obs_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_target",
            |m: &CCSUsrMsg_KillCam| { &m.first_target },
            |m: &mut CCSUsrMsg_KillCam| { &mut m.first_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "second_target",
            |m: &CCSUsrMsg_KillCam| { &m.second_target },
            |m: &mut CCSUsrMsg_KillCam| { &mut m.second_target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_KillCam>(
            "CCSUsrMsg_KillCam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_KillCam {
    const NAME: &'static str = "CCSUsrMsg_KillCam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.obs_mode = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.first_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.second_target = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.obs_mode {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.first_target {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.second_target {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.obs_mode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.first_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.second_target {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_KillCam {
        CCSUsrMsg_KillCam::new()
    }

    fn clear(&mut self) {
        self.obs_mode = ::std::option::Option::None;
        self.first_target = ::std::option::Option::None;
        self.second_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_KillCam {
        static instance: CCSUsrMsg_KillCam = CCSUsrMsg_KillCam {
            obs_mode: ::std::option::Option::None,
            first_target: ::std::option::Option::None,
            second_target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_KillCam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_KillCam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_KillCam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_KillCam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_DesiredTimescale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_DesiredTimescale {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_DesiredTimescale.desired_timescale)
    pub desired_timescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DesiredTimescale.duration_realtime_sec)
    pub duration_realtime_sec: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DesiredTimescale.interpolator_type)
    pub interpolator_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DesiredTimescale.start_blend_time)
    pub start_blend_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_DesiredTimescale.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DesiredTimescale {
    fn default() -> &'a CCSUsrMsg_DesiredTimescale {
        <CCSUsrMsg_DesiredTimescale as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DesiredTimescale {
    pub fn new() -> CCSUsrMsg_DesiredTimescale {
        ::std::default::Default::default()
    }

    // optional float desired_timescale = 1;

    pub fn desired_timescale(&self) -> f32 {
        self.desired_timescale.unwrap_or(0.)
    }

    pub fn clear_desired_timescale(&mut self) {
        self.desired_timescale = ::std::option::Option::None;
    }

    pub fn has_desired_timescale(&self) -> bool {
        self.desired_timescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_timescale(&mut self, v: f32) {
        self.desired_timescale = ::std::option::Option::Some(v);
    }

    // optional float duration_realtime_sec = 2;

    pub fn duration_realtime_sec(&self) -> f32 {
        self.duration_realtime_sec.unwrap_or(0.)
    }

    pub fn clear_duration_realtime_sec(&mut self) {
        self.duration_realtime_sec = ::std::option::Option::None;
    }

    pub fn has_duration_realtime_sec(&self) -> bool {
        self.duration_realtime_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_realtime_sec(&mut self, v: f32) {
        self.duration_realtime_sec = ::std::option::Option::Some(v);
    }

    // optional int32 interpolator_type = 3;

    pub fn interpolator_type(&self) -> i32 {
        self.interpolator_type.unwrap_or(0)
    }

    pub fn clear_interpolator_type(&mut self) {
        self.interpolator_type = ::std::option::Option::None;
    }

    pub fn has_interpolator_type(&self) -> bool {
        self.interpolator_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interpolator_type(&mut self, v: i32) {
        self.interpolator_type = ::std::option::Option::Some(v);
    }

    // optional float start_blend_time = 4;

    pub fn start_blend_time(&self) -> f32 {
        self.start_blend_time.unwrap_or(0.)
    }

    pub fn clear_start_blend_time(&mut self) {
        self.start_blend_time = ::std::option::Option::None;
    }

    pub fn has_start_blend_time(&self) -> bool {
        self.start_blend_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_blend_time(&mut self, v: f32) {
        self.start_blend_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired_timescale",
            |m: &CCSUsrMsg_DesiredTimescale| { &m.desired_timescale },
            |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.desired_timescale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration_realtime_sec",
            |m: &CCSUsrMsg_DesiredTimescale| { &m.duration_realtime_sec },
            |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.duration_realtime_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "interpolator_type",
            |m: &CCSUsrMsg_DesiredTimescale| { &m.interpolator_type },
            |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.interpolator_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_blend_time",
            |m: &CCSUsrMsg_DesiredTimescale| { &m.start_blend_time },
            |m: &mut CCSUsrMsg_DesiredTimescale| { &mut m.start_blend_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_DesiredTimescale>(
            "CCSUsrMsg_DesiredTimescale",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_DesiredTimescale {
    const NAME: &'static str = "CCSUsrMsg_DesiredTimescale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.desired_timescale = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.duration_realtime_sec = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.interpolator_type = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.start_blend_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.desired_timescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration_realtime_sec {
            my_size += 1 + 4;
        }
        if let Some(v) = self.interpolator_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.start_blend_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.desired_timescale {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.duration_realtime_sec {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.interpolator_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.start_blend_time {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_DesiredTimescale {
        CCSUsrMsg_DesiredTimescale::new()
    }

    fn clear(&mut self) {
        self.desired_timescale = ::std::option::Option::None;
        self.duration_realtime_sec = ::std::option::Option::None;
        self.interpolator_type = ::std::option::Option::None;
        self.start_blend_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_DesiredTimescale {
        static instance: CCSUsrMsg_DesiredTimescale = CCSUsrMsg_DesiredTimescale {
            desired_timescale: ::std::option::Option::None,
            duration_realtime_sec: ::std::option::Option::None,
            interpolator_type: ::std::option::Option::None,
            start_blend_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_DesiredTimescale {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_DesiredTimescale").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_DesiredTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DesiredTimescale {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_CurrentTimescale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CurrentTimescale {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CurrentTimescale.cur_timescale)
    pub cur_timescale: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CurrentTimescale.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CurrentTimescale {
    fn default() -> &'a CCSUsrMsg_CurrentTimescale {
        <CCSUsrMsg_CurrentTimescale as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CurrentTimescale {
    pub fn new() -> CCSUsrMsg_CurrentTimescale {
        ::std::default::Default::default()
    }

    // optional float cur_timescale = 1;

    pub fn cur_timescale(&self) -> f32 {
        self.cur_timescale.unwrap_or(0.)
    }

    pub fn clear_cur_timescale(&mut self) {
        self.cur_timescale = ::std::option::Option::None;
    }

    pub fn has_cur_timescale(&self) -> bool {
        self.cur_timescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cur_timescale(&mut self, v: f32) {
        self.cur_timescale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cur_timescale",
            |m: &CCSUsrMsg_CurrentTimescale| { &m.cur_timescale },
            |m: &mut CCSUsrMsg_CurrentTimescale| { &mut m.cur_timescale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_CurrentTimescale>(
            "CCSUsrMsg_CurrentTimescale",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_CurrentTimescale {
    const NAME: &'static str = "CCSUsrMsg_CurrentTimescale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.cur_timescale = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cur_timescale {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cur_timescale {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CurrentTimescale {
        CCSUsrMsg_CurrentTimescale::new()
    }

    fn clear(&mut self) {
        self.cur_timescale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CurrentTimescale {
        static instance: CCSUsrMsg_CurrentTimescale = CCSUsrMsg_CurrentTimescale {
            cur_timescale: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_CurrentTimescale {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_CurrentTimescale").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_CurrentTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CurrentTimescale {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_AchievementEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_AchievementEvent {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_AchievementEvent.achievement)
    pub achievement: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_AchievementEvent.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_AchievementEvent.user_id)
    pub user_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_AchievementEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AchievementEvent {
    fn default() -> &'a CCSUsrMsg_AchievementEvent {
        <CCSUsrMsg_AchievementEvent as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AchievementEvent {
    pub fn new() -> CCSUsrMsg_AchievementEvent {
        ::std::default::Default::default()
    }

    // optional int32 achievement = 1;

    pub fn achievement(&self) -> i32 {
        self.achievement.unwrap_or(0)
    }

    pub fn clear_achievement(&mut self) {
        self.achievement = ::std::option::Option::None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: i32) {
        self.achievement = ::std::option::Option::Some(v);
    }

    // optional int32 count = 2;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 user_id = 3;

    pub fn user_id(&self) -> i32 {
        self.user_id.unwrap_or(0)
    }

    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: i32) {
        self.user_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "achievement",
            |m: &CCSUsrMsg_AchievementEvent| { &m.achievement },
            |m: &mut CCSUsrMsg_AchievementEvent| { &mut m.achievement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CCSUsrMsg_AchievementEvent| { &m.count },
            |m: &mut CCSUsrMsg_AchievementEvent| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_id",
            |m: &CCSUsrMsg_AchievementEvent| { &m.user_id },
            |m: &mut CCSUsrMsg_AchievementEvent| { &mut m.user_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_AchievementEvent>(
            "CCSUsrMsg_AchievementEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_AchievementEvent {
    const NAME: &'static str = "CCSUsrMsg_AchievementEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.achievement = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.user_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.achievement {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.user_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.achievement {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.user_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_AchievementEvent {
        CCSUsrMsg_AchievementEvent::new()
    }

    fn clear(&mut self) {
        self.achievement = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.user_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_AchievementEvent {
        static instance: CCSUsrMsg_AchievementEvent = CCSUsrMsg_AchievementEvent {
            achievement: ::std::option::Option::None,
            count: ::std::option::Option::None,
            user_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_AchievementEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_AchievementEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_AchievementEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_AchievementEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_MatchEndConditions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_MatchEndConditions {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_MatchEndConditions.fraglimit)
    pub fraglimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_MatchEndConditions.mp_maxrounds)
    pub mp_maxrounds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_MatchEndConditions.mp_winlimit)
    pub mp_winlimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_MatchEndConditions.mp_timelimit)
    pub mp_timelimit: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_MatchEndConditions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MatchEndConditions {
    fn default() -> &'a CCSUsrMsg_MatchEndConditions {
        <CCSUsrMsg_MatchEndConditions as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MatchEndConditions {
    pub fn new() -> CCSUsrMsg_MatchEndConditions {
        ::std::default::Default::default()
    }

    // optional int32 fraglimit = 1;

    pub fn fraglimit(&self) -> i32 {
        self.fraglimit.unwrap_or(0)
    }

    pub fn clear_fraglimit(&mut self) {
        self.fraglimit = ::std::option::Option::None;
    }

    pub fn has_fraglimit(&self) -> bool {
        self.fraglimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fraglimit(&mut self, v: i32) {
        self.fraglimit = ::std::option::Option::Some(v);
    }

    // optional int32 mp_maxrounds = 2;

    pub fn mp_maxrounds(&self) -> i32 {
        self.mp_maxrounds.unwrap_or(0)
    }

    pub fn clear_mp_maxrounds(&mut self) {
        self.mp_maxrounds = ::std::option::Option::None;
    }

    pub fn has_mp_maxrounds(&self) -> bool {
        self.mp_maxrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_maxrounds(&mut self, v: i32) {
        self.mp_maxrounds = ::std::option::Option::Some(v);
    }

    // optional int32 mp_winlimit = 3;

    pub fn mp_winlimit(&self) -> i32 {
        self.mp_winlimit.unwrap_or(0)
    }

    pub fn clear_mp_winlimit(&mut self) {
        self.mp_winlimit = ::std::option::Option::None;
    }

    pub fn has_mp_winlimit(&self) -> bool {
        self.mp_winlimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_winlimit(&mut self, v: i32) {
        self.mp_winlimit = ::std::option::Option::Some(v);
    }

    // optional float mp_timelimit = 4;

    pub fn mp_timelimit(&self) -> f32 {
        self.mp_timelimit.unwrap_or(0.)
    }

    pub fn clear_mp_timelimit(&mut self) {
        self.mp_timelimit = ::std::option::Option::None;
    }

    pub fn has_mp_timelimit(&self) -> bool {
        self.mp_timelimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_timelimit(&mut self, v: f32) {
        self.mp_timelimit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fraglimit",
            |m: &CCSUsrMsg_MatchEndConditions| { &m.fraglimit },
            |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.fraglimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mp_maxrounds",
            |m: &CCSUsrMsg_MatchEndConditions| { &m.mp_maxrounds },
            |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.mp_maxrounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mp_winlimit",
            |m: &CCSUsrMsg_MatchEndConditions| { &m.mp_winlimit },
            |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.mp_winlimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mp_timelimit",
            |m: &CCSUsrMsg_MatchEndConditions| { &m.mp_timelimit },
            |m: &mut CCSUsrMsg_MatchEndConditions| { &mut m.mp_timelimit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_MatchEndConditions>(
            "CCSUsrMsg_MatchEndConditions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_MatchEndConditions {
    const NAME: &'static str = "CCSUsrMsg_MatchEndConditions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fraglimit = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.mp_maxrounds = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.mp_winlimit = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.mp_timelimit = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fraglimit {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mp_maxrounds {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.mp_winlimit {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.mp_timelimit {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fraglimit {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mp_maxrounds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.mp_winlimit {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.mp_timelimit {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_MatchEndConditions {
        CCSUsrMsg_MatchEndConditions::new()
    }

    fn clear(&mut self) {
        self.fraglimit = ::std::option::Option::None;
        self.mp_maxrounds = ::std::option::Option::None;
        self.mp_winlimit = ::std::option::Option::None;
        self.mp_timelimit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_MatchEndConditions {
        static instance: CCSUsrMsg_MatchEndConditions = CCSUsrMsg_MatchEndConditions {
            fraglimit: ::std::option::Option::None,
            mp_maxrounds: ::std::option::Option::None,
            mp_winlimit: ::std::option::Option::None,
            mp_timelimit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_MatchEndConditions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_MatchEndConditions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_MatchEndConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_MatchEndConditions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_PlayerStatsUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_PlayerStatsUpdate {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.stats)
    pub stats: ::std::vec::Vec<ccsusr_msg_player_stats_update::Stat>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.crc)
    pub crc: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_PlayerStatsUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PlayerStatsUpdate {
    fn default() -> &'a CCSUsrMsg_PlayerStatsUpdate {
        <CCSUsrMsg_PlayerStatsUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PlayerStatsUpdate {
    pub fn new() -> CCSUsrMsg_PlayerStatsUpdate {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 ehandle = 5;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(0)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional int32 crc = 6;

    pub fn crc(&self) -> i32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: i32) {
        self.crc = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.version },
            |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.stats },
            |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ehandle",
            |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.ehandle },
            |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.ehandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc",
            |m: &CCSUsrMsg_PlayerStatsUpdate| { &m.crc },
            |m: &mut CCSUsrMsg_PlayerStatsUpdate| { &mut m.crc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_PlayerStatsUpdate>(
            "CCSUsrMsg_PlayerStatsUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_PlayerStatsUpdate {
    const NAME: &'static str = "CCSUsrMsg_PlayerStatsUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.stats.push(is.read_message()?);
                },
                40 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.crc = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ehandle {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.crc {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.ehandle {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.crc {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_PlayerStatsUpdate {
        CCSUsrMsg_PlayerStatsUpdate::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.stats.clear();
        self.ehandle = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_PlayerStatsUpdate {
        static instance: CCSUsrMsg_PlayerStatsUpdate = CCSUsrMsg_PlayerStatsUpdate {
            version: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            ehandle: ::std::option::Option::None,
            crc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_PlayerStatsUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_PlayerStatsUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_PlayerStatsUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_PlayerStatsUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CCSUsrMsg_PlayerStatsUpdate`
pub mod ccsusr_msg_player_stats_update {
    // @@protoc_insertion_point(message:CCSUsrMsg_PlayerStatsUpdate.Stat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stat {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.Stat.idx)
        pub idx: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.Stat.delta)
        pub delta: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_PlayerStatsUpdate.Stat.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stat {
        fn default() -> &'a Stat {
            <Stat as ::protobuf::Message>::default_instance()
        }
    }

    impl Stat {
        pub fn new() -> Stat {
            ::std::default::Default::default()
        }

        // optional int32 idx = 1;

        pub fn idx(&self) -> i32 {
            self.idx.unwrap_or(0)
        }

        pub fn clear_idx(&mut self) {
            self.idx = ::std::option::Option::None;
        }

        pub fn has_idx(&self) -> bool {
            self.idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_idx(&mut self, v: i32) {
            self.idx = ::std::option::Option::Some(v);
        }

        // optional int32 delta = 2;

        pub fn delta(&self) -> i32 {
            self.delta.unwrap_or(0)
        }

        pub fn clear_delta(&mut self) {
            self.delta = ::std::option::Option::None;
        }

        pub fn has_delta(&self) -> bool {
            self.delta.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delta(&mut self, v: i32) {
            self.delta = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "idx",
                |m: &Stat| { &m.idx },
                |m: &mut Stat| { &mut m.idx },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "delta",
                |m: &Stat| { &m.delta },
                |m: &mut Stat| { &mut m.delta },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stat>(
                "CCSUsrMsg_PlayerStatsUpdate.Stat",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stat {
        const NAME: &'static str = "Stat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.idx = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.delta = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.idx {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.delta {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.idx {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.delta {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stat {
            Stat::new()
        }

        fn clear(&mut self) {
            self.idx = ::std::option::Option::None;
            self.delta = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stat {
            static instance: Stat = Stat {
                idx: ::std::option::Option::None,
                delta: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stat {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_PlayerStatsUpdate.Stat").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stat {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_QuestProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_QuestProgress {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_QuestProgress.quest_id)
    pub quest_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_QuestProgress.normal_points)
    pub normal_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_QuestProgress.bonus_points)
    pub bonus_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_QuestProgress.is_event_quest)
    pub is_event_quest: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_QuestProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_QuestProgress {
    fn default() -> &'a CCSUsrMsg_QuestProgress {
        <CCSUsrMsg_QuestProgress as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_QuestProgress {
    pub fn new() -> CCSUsrMsg_QuestProgress {
        ::std::default::Default::default()
    }

    // optional uint32 quest_id = 1;

    pub fn quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 normal_points = 2;

    pub fn normal_points(&self) -> u32 {
        self.normal_points.unwrap_or(0)
    }

    pub fn clear_normal_points(&mut self) {
        self.normal_points = ::std::option::Option::None;
    }

    pub fn has_normal_points(&self) -> bool {
        self.normal_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal_points(&mut self, v: u32) {
        self.normal_points = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_points = 3;

    pub fn bonus_points(&self) -> u32 {
        self.bonus_points.unwrap_or(0)
    }

    pub fn clear_bonus_points(&mut self) {
        self.bonus_points = ::std::option::Option::None;
    }

    pub fn has_bonus_points(&self) -> bool {
        self.bonus_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_points(&mut self, v: u32) {
        self.bonus_points = ::std::option::Option::Some(v);
    }

    // optional bool is_event_quest = 4;

    pub fn is_event_quest(&self) -> bool {
        self.is_event_quest.unwrap_or(false)
    }

    pub fn clear_is_event_quest(&mut self) {
        self.is_event_quest = ::std::option::Option::None;
    }

    pub fn has_is_event_quest(&self) -> bool {
        self.is_event_quest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_event_quest(&mut self, v: bool) {
        self.is_event_quest = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CCSUsrMsg_QuestProgress| { &m.quest_id },
            |m: &mut CCSUsrMsg_QuestProgress| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "normal_points",
            |m: &CCSUsrMsg_QuestProgress| { &m.normal_points },
            |m: &mut CCSUsrMsg_QuestProgress| { &mut m.normal_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_points",
            |m: &CCSUsrMsg_QuestProgress| { &m.bonus_points },
            |m: &mut CCSUsrMsg_QuestProgress| { &mut m.bonus_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_event_quest",
            |m: &CCSUsrMsg_QuestProgress| { &m.is_event_quest },
            |m: &mut CCSUsrMsg_QuestProgress| { &mut m.is_event_quest },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_QuestProgress>(
            "CCSUsrMsg_QuestProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_QuestProgress {
    const NAME: &'static str = "CCSUsrMsg_QuestProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.normal_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bonus_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_event_quest = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.normal_points {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bonus_points {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_event_quest {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.normal_points {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_event_quest {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_QuestProgress {
        CCSUsrMsg_QuestProgress::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.normal_points = ::std::option::Option::None;
        self.bonus_points = ::std::option::Option::None;
        self.is_event_quest = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_QuestProgress {
        static instance: CCSUsrMsg_QuestProgress = CCSUsrMsg_QuestProgress {
            quest_id: ::std::option::Option::None,
            normal_points: ::std::option::Option::None,
            bonus_points: ::std::option::Option::None,
            is_event_quest: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_QuestProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_QuestProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_QuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_QuestProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ScoreLeaderboardData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ScoreLeaderboardData {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ScoreLeaderboardData.data)
    pub data: ::protobuf::MessageField<super::cstrike15_gcmessages::ScoreLeaderboardData>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ScoreLeaderboardData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ScoreLeaderboardData {
    fn default() -> &'a CCSUsrMsg_ScoreLeaderboardData {
        <CCSUsrMsg_ScoreLeaderboardData as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ScoreLeaderboardData {
    pub fn new() -> CCSUsrMsg_ScoreLeaderboardData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::ScoreLeaderboardData>(
            "data",
            |m: &CCSUsrMsg_ScoreLeaderboardData| { &m.data },
            |m: &mut CCSUsrMsg_ScoreLeaderboardData| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ScoreLeaderboardData>(
            "CCSUsrMsg_ScoreLeaderboardData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ScoreLeaderboardData {
    const NAME: &'static str = "CCSUsrMsg_ScoreLeaderboardData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ScoreLeaderboardData {
        CCSUsrMsg_ScoreLeaderboardData::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ScoreLeaderboardData {
        static instance: CCSUsrMsg_ScoreLeaderboardData = CCSUsrMsg_ScoreLeaderboardData {
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ScoreLeaderboardData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ScoreLeaderboardData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ScoreLeaderboardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ScoreLeaderboardData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_PlayerDecalDigitalSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_PlayerDecalDigitalSignature {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_PlayerDecalDigitalSignature.data)
    pub data: ::protobuf::MessageField<super::cstrike15_gcmessages::PlayerDecalDigitalSignature>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_PlayerDecalDigitalSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PlayerDecalDigitalSignature {
    fn default() -> &'a CCSUsrMsg_PlayerDecalDigitalSignature {
        <CCSUsrMsg_PlayerDecalDigitalSignature as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PlayerDecalDigitalSignature {
    pub fn new() -> CCSUsrMsg_PlayerDecalDigitalSignature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::PlayerDecalDigitalSignature>(
            "data",
            |m: &CCSUsrMsg_PlayerDecalDigitalSignature| { &m.data },
            |m: &mut CCSUsrMsg_PlayerDecalDigitalSignature| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_PlayerDecalDigitalSignature>(
            "CCSUsrMsg_PlayerDecalDigitalSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_PlayerDecalDigitalSignature {
    const NAME: &'static str = "CCSUsrMsg_PlayerDecalDigitalSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_PlayerDecalDigitalSignature {
        CCSUsrMsg_PlayerDecalDigitalSignature::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_PlayerDecalDigitalSignature {
        static instance: CCSUsrMsg_PlayerDecalDigitalSignature = CCSUsrMsg_PlayerDecalDigitalSignature {
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_PlayerDecalDigitalSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_PlayerDecalDigitalSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_XRankGet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_XRankGet {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_XRankGet.mode_idx)
    pub mode_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_XRankGet.controller)
    pub controller: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_XRankGet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XRankGet {
    fn default() -> &'a CCSUsrMsg_XRankGet {
        <CCSUsrMsg_XRankGet as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XRankGet {
    pub fn new() -> CCSUsrMsg_XRankGet {
        ::std::default::Default::default()
    }

    // optional int32 mode_idx = 1;

    pub fn mode_idx(&self) -> i32 {
        self.mode_idx.unwrap_or(0)
    }

    pub fn clear_mode_idx(&mut self) {
        self.mode_idx = ::std::option::Option::None;
    }

    pub fn has_mode_idx(&self) -> bool {
        self.mode_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_idx(&mut self, v: i32) {
        self.mode_idx = ::std::option::Option::Some(v);
    }

    // optional int32 controller = 2;

    pub fn controller(&self) -> i32 {
        self.controller.unwrap_or(0)
    }

    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: i32) {
        self.controller = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode_idx",
            |m: &CCSUsrMsg_XRankGet| { &m.mode_idx },
            |m: &mut CCSUsrMsg_XRankGet| { &mut m.mode_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller",
            |m: &CCSUsrMsg_XRankGet| { &m.controller },
            |m: &mut CCSUsrMsg_XRankGet| { &mut m.controller },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_XRankGet>(
            "CCSUsrMsg_XRankGet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_XRankGet {
    const NAME: &'static str = "CCSUsrMsg_XRankGet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.controller = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode_idx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.controller {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mode_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.controller {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_XRankGet {
        CCSUsrMsg_XRankGet::new()
    }

    fn clear(&mut self) {
        self.mode_idx = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_XRankGet {
        static instance: CCSUsrMsg_XRankGet = CCSUsrMsg_XRankGet {
            mode_idx: ::std::option::Option::None,
            controller: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_XRankGet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_XRankGet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_XRankGet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_XRankGet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_XRankUpd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_XRankUpd {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_XRankUpd.mode_idx)
    pub mode_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_XRankUpd.controller)
    pub controller: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_XRankUpd.ranking)
    pub ranking: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_XRankUpd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XRankUpd {
    fn default() -> &'a CCSUsrMsg_XRankUpd {
        <CCSUsrMsg_XRankUpd as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XRankUpd {
    pub fn new() -> CCSUsrMsg_XRankUpd {
        ::std::default::Default::default()
    }

    // optional int32 mode_idx = 1;

    pub fn mode_idx(&self) -> i32 {
        self.mode_idx.unwrap_or(0)
    }

    pub fn clear_mode_idx(&mut self) {
        self.mode_idx = ::std::option::Option::None;
    }

    pub fn has_mode_idx(&self) -> bool {
        self.mode_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_idx(&mut self, v: i32) {
        self.mode_idx = ::std::option::Option::Some(v);
    }

    // optional int32 controller = 2;

    pub fn controller(&self) -> i32 {
        self.controller.unwrap_or(0)
    }

    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: i32) {
        self.controller = ::std::option::Option::Some(v);
    }

    // optional int32 ranking = 3;

    pub fn ranking(&self) -> i32 {
        self.ranking.unwrap_or(0)
    }

    pub fn clear_ranking(&mut self) {
        self.ranking = ::std::option::Option::None;
    }

    pub fn has_ranking(&self) -> bool {
        self.ranking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranking(&mut self, v: i32) {
        self.ranking = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode_idx",
            |m: &CCSUsrMsg_XRankUpd| { &m.mode_idx },
            |m: &mut CCSUsrMsg_XRankUpd| { &mut m.mode_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller",
            |m: &CCSUsrMsg_XRankUpd| { &m.controller },
            |m: &mut CCSUsrMsg_XRankUpd| { &mut m.controller },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ranking",
            |m: &CCSUsrMsg_XRankUpd| { &m.ranking },
            |m: &mut CCSUsrMsg_XRankUpd| { &mut m.ranking },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_XRankUpd>(
            "CCSUsrMsg_XRankUpd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_XRankUpd {
    const NAME: &'static str = "CCSUsrMsg_XRankUpd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.controller = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ranking = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode_idx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.controller {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ranking {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mode_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.controller {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ranking {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_XRankUpd {
        CCSUsrMsg_XRankUpd::new()
    }

    fn clear(&mut self) {
        self.mode_idx = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.ranking = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_XRankUpd {
        static instance: CCSUsrMsg_XRankUpd = CCSUsrMsg_XRankUpd {
            mode_idx: ::std::option::Option::None,
            controller: ::std::option::Option::None,
            ranking: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_XRankUpd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_XRankUpd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_XRankUpd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_XRankUpd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_CallVoteFailed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CallVoteFailed {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CallVoteFailed.reason)
    pub reason: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CallVoteFailed.time)
    pub time: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CallVoteFailed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CallVoteFailed {
    fn default() -> &'a CCSUsrMsg_CallVoteFailed {
        <CCSUsrMsg_CallVoteFailed as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CallVoteFailed {
    pub fn new() -> CCSUsrMsg_CallVoteFailed {
        ::std::default::Default::default()
    }

    // optional int32 reason = 1;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional int32 time = 2;

    pub fn time(&self) -> i32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CCSUsrMsg_CallVoteFailed| { &m.reason },
            |m: &mut CCSUsrMsg_CallVoteFailed| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time",
            |m: &CCSUsrMsg_CallVoteFailed| { &m.time },
            |m: &mut CCSUsrMsg_CallVoteFailed| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_CallVoteFailed>(
            "CCSUsrMsg_CallVoteFailed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_CallVoteFailed {
    const NAME: &'static str = "CCSUsrMsg_CallVoteFailed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.time = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reason {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CallVoteFailed {
        CCSUsrMsg_CallVoteFailed::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CallVoteFailed {
        static instance: CCSUsrMsg_CallVoteFailed = CCSUsrMsg_CallVoteFailed {
            reason: ::std::option::Option::None,
            time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_CallVoteFailed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_CallVoteFailed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_CallVoteFailed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CallVoteFailed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_VoteStart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VoteStart {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.team)
    pub team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.vote_type)
    pub vote_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.disp_str)
    pub disp_str: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.details_str)
    pub details_str: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.other_team_str)
    pub other_team_str: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.is_yes_no_vote)
    pub is_yes_no_vote: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.player_slot_target)
    pub player_slot_target: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VoteStart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteStart {
    fn default() -> &'a CCSUsrMsg_VoteStart {
        <CCSUsrMsg_VoteStart as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteStart {
    pub fn new() -> CCSUsrMsg_VoteStart {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot = 2;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional int32 vote_type = 3;

    pub fn vote_type(&self) -> i32 {
        self.vote_type.unwrap_or(0)
    }

    pub fn clear_vote_type(&mut self) {
        self.vote_type = ::std::option::Option::None;
    }

    pub fn has_vote_type(&self) -> bool {
        self.vote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_type(&mut self, v: i32) {
        self.vote_type = ::std::option::Option::Some(v);
    }

    // optional string disp_str = 4;

    pub fn disp_str(&self) -> &str {
        match self.disp_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_disp_str(&mut self) {
        self.disp_str = ::std::option::Option::None;
    }

    pub fn has_disp_str(&self) -> bool {
        self.disp_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_str(&mut self, v: ::std::string::String) {
        self.disp_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disp_str(&mut self) -> &mut ::std::string::String {
        if self.disp_str.is_none() {
            self.disp_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.disp_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_disp_str(&mut self) -> ::std::string::String {
        self.disp_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string details_str = 5;

    pub fn details_str(&self) -> &str {
        match self.details_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_details_str(&mut self) {
        self.details_str = ::std::option::Option::None;
    }

    pub fn has_details_str(&self) -> bool {
        self.details_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details_str(&mut self, v: ::std::string::String) {
        self.details_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details_str(&mut self) -> &mut ::std::string::String {
        if self.details_str.is_none() {
            self.details_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.details_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_details_str(&mut self) -> ::std::string::String {
        self.details_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string other_team_str = 6;

    pub fn other_team_str(&self) -> &str {
        match self.other_team_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_other_team_str(&mut self) {
        self.other_team_str = ::std::option::Option::None;
    }

    pub fn has_other_team_str(&self) -> bool {
        self.other_team_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_team_str(&mut self, v: ::std::string::String) {
        self.other_team_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_team_str(&mut self) -> &mut ::std::string::String {
        if self.other_team_str.is_none() {
            self.other_team_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.other_team_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_team_str(&mut self) -> ::std::string::String {
        self.other_team_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_yes_no_vote = 7;

    pub fn is_yes_no_vote(&self) -> bool {
        self.is_yes_no_vote.unwrap_or(false)
    }

    pub fn clear_is_yes_no_vote(&mut self) {
        self.is_yes_no_vote = ::std::option::Option::None;
    }

    pub fn has_is_yes_no_vote(&self) -> bool {
        self.is_yes_no_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_yes_no_vote(&mut self, v: bool) {
        self.is_yes_no_vote = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot_target = 8;

    pub fn player_slot_target(&self) -> i32 {
        self.player_slot_target.unwrap_or(-1i32)
    }

    pub fn clear_player_slot_target(&mut self) {
        self.player_slot_target = ::std::option::Option::None;
    }

    pub fn has_player_slot_target(&self) -> bool {
        self.player_slot_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot_target(&mut self, v: i32) {
        self.player_slot_target = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CCSUsrMsg_VoteStart| { &m.team },
            |m: &mut CCSUsrMsg_VoteStart| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &CCSUsrMsg_VoteStart| { &m.player_slot },
            |m: &mut CCSUsrMsg_VoteStart| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote_type",
            |m: &CCSUsrMsg_VoteStart| { &m.vote_type },
            |m: &mut CCSUsrMsg_VoteStart| { &mut m.vote_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disp_str",
            |m: &CCSUsrMsg_VoteStart| { &m.disp_str },
            |m: &mut CCSUsrMsg_VoteStart| { &mut m.disp_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details_str",
            |m: &CCSUsrMsg_VoteStart| { &m.details_str },
            |m: &mut CCSUsrMsg_VoteStart| { &mut m.details_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_team_str",
            |m: &CCSUsrMsg_VoteStart| { &m.other_team_str },
            |m: &mut CCSUsrMsg_VoteStart| { &mut m.other_team_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_yes_no_vote",
            |m: &CCSUsrMsg_VoteStart| { &m.is_yes_no_vote },
            |m: &mut CCSUsrMsg_VoteStart| { &mut m.is_yes_no_vote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot_target",
            |m: &CCSUsrMsg_VoteStart| { &m.player_slot_target },
            |m: &mut CCSUsrMsg_VoteStart| { &mut m.player_slot_target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_VoteStart>(
            "CCSUsrMsg_VoteStart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoteStart {
    const NAME: &'static str = "CCSUsrMsg_VoteStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.vote_type = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.disp_str = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.details_str = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.other_team_str = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.is_yes_no_vote = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.player_slot_target = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.vote_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.disp_str.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.details_str.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.other_team_str.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.is_yes_no_vote {
            my_size += 1 + 1;
        }
        if let Some(v) = self.player_slot_target {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.vote_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.disp_str.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.details_str.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.other_team_str.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.is_yes_no_vote {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.player_slot_target {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VoteStart {
        CCSUsrMsg_VoteStart::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.vote_type = ::std::option::Option::None;
        self.disp_str = ::std::option::Option::None;
        self.details_str = ::std::option::Option::None;
        self.other_team_str = ::std::option::Option::None;
        self.is_yes_no_vote = ::std::option::Option::None;
        self.player_slot_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteStart {
        static instance: CCSUsrMsg_VoteStart = CCSUsrMsg_VoteStart {
            team: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            vote_type: ::std::option::Option::None,
            disp_str: ::std::option::Option::None,
            details_str: ::std::option::Option::None,
            other_team_str: ::std::option::Option::None,
            is_yes_no_vote: ::std::option::Option::None,
            player_slot_target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_VoteStart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_VoteStart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_VoteStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoteStart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_VotePass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VotePass {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VotePass.team)
    pub team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VotePass.vote_type)
    pub vote_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VotePass.disp_str)
    pub disp_str: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VotePass.details_str)
    pub details_str: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VotePass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VotePass {
    fn default() -> &'a CCSUsrMsg_VotePass {
        <CCSUsrMsg_VotePass as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VotePass {
    pub fn new() -> CCSUsrMsg_VotePass {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 vote_type = 2;

    pub fn vote_type(&self) -> i32 {
        self.vote_type.unwrap_or(0)
    }

    pub fn clear_vote_type(&mut self) {
        self.vote_type = ::std::option::Option::None;
    }

    pub fn has_vote_type(&self) -> bool {
        self.vote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_type(&mut self, v: i32) {
        self.vote_type = ::std::option::Option::Some(v);
    }

    // optional string disp_str = 3;

    pub fn disp_str(&self) -> &str {
        match self.disp_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_disp_str(&mut self) {
        self.disp_str = ::std::option::Option::None;
    }

    pub fn has_disp_str(&self) -> bool {
        self.disp_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_str(&mut self, v: ::std::string::String) {
        self.disp_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disp_str(&mut self) -> &mut ::std::string::String {
        if self.disp_str.is_none() {
            self.disp_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.disp_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_disp_str(&mut self) -> ::std::string::String {
        self.disp_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string details_str = 4;

    pub fn details_str(&self) -> &str {
        match self.details_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_details_str(&mut self) {
        self.details_str = ::std::option::Option::None;
    }

    pub fn has_details_str(&self) -> bool {
        self.details_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details_str(&mut self, v: ::std::string::String) {
        self.details_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details_str(&mut self) -> &mut ::std::string::String {
        if self.details_str.is_none() {
            self.details_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.details_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_details_str(&mut self) -> ::std::string::String {
        self.details_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CCSUsrMsg_VotePass| { &m.team },
            |m: &mut CCSUsrMsg_VotePass| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote_type",
            |m: &CCSUsrMsg_VotePass| { &m.vote_type },
            |m: &mut CCSUsrMsg_VotePass| { &mut m.vote_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disp_str",
            |m: &CCSUsrMsg_VotePass| { &m.disp_str },
            |m: &mut CCSUsrMsg_VotePass| { &mut m.disp_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details_str",
            |m: &CCSUsrMsg_VotePass| { &m.details_str },
            |m: &mut CCSUsrMsg_VotePass| { &mut m.details_str },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_VotePass>(
            "CCSUsrMsg_VotePass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_VotePass {
    const NAME: &'static str = "CCSUsrMsg_VotePass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.vote_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.disp_str = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.details_str = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.vote_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.disp_str.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.details_str.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.vote_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.disp_str.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.details_str.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VotePass {
        CCSUsrMsg_VotePass::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.vote_type = ::std::option::Option::None;
        self.disp_str = ::std::option::Option::None;
        self.details_str = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VotePass {
        static instance: CCSUsrMsg_VotePass = CCSUsrMsg_VotePass {
            team: ::std::option::Option::None,
            vote_type: ::std::option::Option::None,
            disp_str: ::std::option::Option::None,
            details_str: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_VotePass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_VotePass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_VotePass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VotePass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_VoteFailed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VoteFailed {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteFailed.team)
    pub team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteFailed.reason)
    pub reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VoteFailed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteFailed {
    fn default() -> &'a CCSUsrMsg_VoteFailed {
        <CCSUsrMsg_VoteFailed as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteFailed {
    pub fn new() -> CCSUsrMsg_VoteFailed {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 reason = 2;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CCSUsrMsg_VoteFailed| { &m.team },
            |m: &mut CCSUsrMsg_VoteFailed| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CCSUsrMsg_VoteFailed| { &m.reason },
            |m: &mut CCSUsrMsg_VoteFailed| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_VoteFailed>(
            "CCSUsrMsg_VoteFailed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoteFailed {
    const NAME: &'static str = "CCSUsrMsg_VoteFailed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VoteFailed {
        CCSUsrMsg_VoteFailed::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteFailed {
        static instance: CCSUsrMsg_VoteFailed = CCSUsrMsg_VoteFailed {
            team: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_VoteFailed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_VoteFailed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_VoteFailed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoteFailed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_VoteSetup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VoteSetup {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteSetup.potential_issues)
    pub potential_issues: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VoteSetup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteSetup {
    fn default() -> &'a CCSUsrMsg_VoteSetup {
        <CCSUsrMsg_VoteSetup as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteSetup {
    pub fn new() -> CCSUsrMsg_VoteSetup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "potential_issues",
            |m: &CCSUsrMsg_VoteSetup| { &m.potential_issues },
            |m: &mut CCSUsrMsg_VoteSetup| { &mut m.potential_issues },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_VoteSetup>(
            "CCSUsrMsg_VoteSetup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_VoteSetup {
    const NAME: &'static str = "CCSUsrMsg_VoteSetup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.potential_issues.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.potential_issues {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.potential_issues {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VoteSetup {
        CCSUsrMsg_VoteSetup::new()
    }

    fn clear(&mut self) {
        self.potential_issues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteSetup {
        static instance: CCSUsrMsg_VoteSetup = CCSUsrMsg_VoteSetup {
            potential_issues: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_VoteSetup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_VoteSetup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_VoteSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_VoteSetup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_SendLastKillerDamageToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SendLastKillerDamageToClient {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.num_hits_given)
    pub num_hits_given: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.damage_given)
    pub damage_given: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.num_hits_taken)
    pub num_hits_taken: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.damage_taken)
    pub damage_taken: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.actual_damage_given)
    pub actual_damage_given: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.actual_damage_taken)
    pub actual_damage_taken: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SendLastKillerDamageToClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendLastKillerDamageToClient {
    fn default() -> &'a CCSUsrMsg_SendLastKillerDamageToClient {
        <CCSUsrMsg_SendLastKillerDamageToClient as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendLastKillerDamageToClient {
    pub fn new() -> CCSUsrMsg_SendLastKillerDamageToClient {
        ::std::default::Default::default()
    }

    // optional int32 num_hits_given = 1;

    pub fn num_hits_given(&self) -> i32 {
        self.num_hits_given.unwrap_or(0)
    }

    pub fn clear_num_hits_given(&mut self) {
        self.num_hits_given = ::std::option::Option::None;
    }

    pub fn has_num_hits_given(&self) -> bool {
        self.num_hits_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits_given(&mut self, v: i32) {
        self.num_hits_given = ::std::option::Option::Some(v);
    }

    // optional int32 damage_given = 2;

    pub fn damage_given(&self) -> i32 {
        self.damage_given.unwrap_or(0)
    }

    pub fn clear_damage_given(&mut self) {
        self.damage_given = ::std::option::Option::None;
    }

    pub fn has_damage_given(&self) -> bool {
        self.damage_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_given(&mut self, v: i32) {
        self.damage_given = ::std::option::Option::Some(v);
    }

    // optional int32 num_hits_taken = 3;

    pub fn num_hits_taken(&self) -> i32 {
        self.num_hits_taken.unwrap_or(0)
    }

    pub fn clear_num_hits_taken(&mut self) {
        self.num_hits_taken = ::std::option::Option::None;
    }

    pub fn has_num_hits_taken(&self) -> bool {
        self.num_hits_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits_taken(&mut self, v: i32) {
        self.num_hits_taken = ::std::option::Option::Some(v);
    }

    // optional int32 damage_taken = 4;

    pub fn damage_taken(&self) -> i32 {
        self.damage_taken.unwrap_or(0)
    }

    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: i32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }

    // optional int32 actual_damage_given = 5;

    pub fn actual_damage_given(&self) -> i32 {
        self.actual_damage_given.unwrap_or(0)
    }

    pub fn clear_actual_damage_given(&mut self) {
        self.actual_damage_given = ::std::option::Option::None;
    }

    pub fn has_actual_damage_given(&self) -> bool {
        self.actual_damage_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actual_damage_given(&mut self, v: i32) {
        self.actual_damage_given = ::std::option::Option::Some(v);
    }

    // optional int32 actual_damage_taken = 6;

    pub fn actual_damage_taken(&self) -> i32 {
        self.actual_damage_taken.unwrap_or(0)
    }

    pub fn clear_actual_damage_taken(&mut self) {
        self.actual_damage_taken = ::std::option::Option::None;
    }

    pub fn has_actual_damage_taken(&self) -> bool {
        self.actual_damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actual_damage_taken(&mut self, v: i32) {
        self.actual_damage_taken = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_hits_given",
            |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.num_hits_given },
            |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.num_hits_given },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_given",
            |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.damage_given },
            |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.damage_given },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_hits_taken",
            |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.num_hits_taken },
            |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.num_hits_taken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_taken",
            |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.damage_taken },
            |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.damage_taken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actual_damage_given",
            |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.actual_damage_given },
            |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.actual_damage_given },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actual_damage_taken",
            |m: &CCSUsrMsg_SendLastKillerDamageToClient| { &m.actual_damage_taken },
            |m: &mut CCSUsrMsg_SendLastKillerDamageToClient| { &mut m.actual_damage_taken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_SendLastKillerDamageToClient>(
            "CCSUsrMsg_SendLastKillerDamageToClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_SendLastKillerDamageToClient {
    const NAME: &'static str = "CCSUsrMsg_SendLastKillerDamageToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_hits_given = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.damage_given = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.num_hits_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.damage_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.actual_damage_given = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.actual_damage_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_hits_given {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.damage_given {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.num_hits_taken {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.actual_damage_given {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.actual_damage_taken {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num_hits_given {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_given {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.num_hits_taken {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.actual_damage_given {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.actual_damage_taken {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SendLastKillerDamageToClient {
        CCSUsrMsg_SendLastKillerDamageToClient::new()
    }

    fn clear(&mut self) {
        self.num_hits_given = ::std::option::Option::None;
        self.damage_given = ::std::option::Option::None;
        self.num_hits_taken = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.actual_damage_given = ::std::option::Option::None;
        self.actual_damage_taken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SendLastKillerDamageToClient {
        static instance: CCSUsrMsg_SendLastKillerDamageToClient = CCSUsrMsg_SendLastKillerDamageToClient {
            num_hits_given: ::std::option::Option::None,
            damage_given: ::std::option::Option::None,
            num_hits_taken: ::std::option::Option::None,
            damage_taken: ::std::option::Option::None,
            actual_damage_given: ::std::option::Option::None,
            actual_damage_taken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_SendLastKillerDamageToClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_SendLastKillerDamageToClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_SendLastKillerDamageToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SendLastKillerDamageToClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ServerRankUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ServerRankUpdate {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.rank_update)
    pub rank_update: ::std::vec::Vec<ccsusr_msg_server_rank_update::RankUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ServerRankUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ServerRankUpdate {
    fn default() -> &'a CCSUsrMsg_ServerRankUpdate {
        <CCSUsrMsg_ServerRankUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ServerRankUpdate {
    pub fn new() -> CCSUsrMsg_ServerRankUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rank_update",
            |m: &CCSUsrMsg_ServerRankUpdate| { &m.rank_update },
            |m: &mut CCSUsrMsg_ServerRankUpdate| { &mut m.rank_update },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ServerRankUpdate>(
            "CCSUsrMsg_ServerRankUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ServerRankUpdate {
    const NAME: &'static str = "CCSUsrMsg_ServerRankUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rank_update.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rank_update {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rank_update {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ServerRankUpdate {
        CCSUsrMsg_ServerRankUpdate::new()
    }

    fn clear(&mut self) {
        self.rank_update.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ServerRankUpdate {
        static instance: CCSUsrMsg_ServerRankUpdate = CCSUsrMsg_ServerRankUpdate {
            rank_update: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ServerRankUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ServerRankUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ServerRankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ServerRankUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CCSUsrMsg_ServerRankUpdate`
pub mod ccsusr_msg_server_rank_update {
    // @@protoc_insertion_point(message:CCSUsrMsg_ServerRankUpdate.RankUpdate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RankUpdate {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.account_id)
        pub account_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.rank_old)
        pub rank_old: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.rank_new)
        pub rank_new: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.num_wins)
        pub num_wins: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.rank_change)
        pub rank_change: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.rank_type_id)
        pub rank_type_id: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_ServerRankUpdate.RankUpdate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RankUpdate {
        fn default() -> &'a RankUpdate {
            <RankUpdate as ::protobuf::Message>::default_instance()
        }
    }

    impl RankUpdate {
        pub fn new() -> RankUpdate {
            ::std::default::Default::default()
        }

        // optional int32 account_id = 1;

        pub fn account_id(&self) -> i32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: i32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional int32 rank_old = 2;

        pub fn rank_old(&self) -> i32 {
            self.rank_old.unwrap_or(0)
        }

        pub fn clear_rank_old(&mut self) {
            self.rank_old = ::std::option::Option::None;
        }

        pub fn has_rank_old(&self) -> bool {
            self.rank_old.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_old(&mut self, v: i32) {
            self.rank_old = ::std::option::Option::Some(v);
        }

        // optional int32 rank_new = 3;

        pub fn rank_new(&self) -> i32 {
            self.rank_new.unwrap_or(0)
        }

        pub fn clear_rank_new(&mut self) {
            self.rank_new = ::std::option::Option::None;
        }

        pub fn has_rank_new(&self) -> bool {
            self.rank_new.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_new(&mut self, v: i32) {
            self.rank_new = ::std::option::Option::Some(v);
        }

        // optional int32 num_wins = 4;

        pub fn num_wins(&self) -> i32 {
            self.num_wins.unwrap_or(0)
        }

        pub fn clear_num_wins(&mut self) {
            self.num_wins = ::std::option::Option::None;
        }

        pub fn has_num_wins(&self) -> bool {
            self.num_wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_wins(&mut self, v: i32) {
            self.num_wins = ::std::option::Option::Some(v);
        }

        // optional float rank_change = 5;

        pub fn rank_change(&self) -> f32 {
            self.rank_change.unwrap_or(0.)
        }

        pub fn clear_rank_change(&mut self) {
            self.rank_change = ::std::option::Option::None;
        }

        pub fn has_rank_change(&self) -> bool {
            self.rank_change.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_change(&mut self, v: f32) {
            self.rank_change = ::std::option::Option::Some(v);
        }

        // optional int32 rank_type_id = 6;

        pub fn rank_type_id(&self) -> i32 {
            self.rank_type_id.unwrap_or(0)
        }

        pub fn clear_rank_type_id(&mut self) {
            self.rank_type_id = ::std::option::Option::None;
        }

        pub fn has_rank_type_id(&self) -> bool {
            self.rank_type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_type_id(&mut self, v: i32) {
            self.rank_type_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &RankUpdate| { &m.account_id },
                |m: &mut RankUpdate| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_old",
                |m: &RankUpdate| { &m.rank_old },
                |m: &mut RankUpdate| { &mut m.rank_old },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_new",
                |m: &RankUpdate| { &m.rank_new },
                |m: &mut RankUpdate| { &mut m.rank_new },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_wins",
                |m: &RankUpdate| { &m.num_wins },
                |m: &mut RankUpdate| { &mut m.num_wins },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_change",
                |m: &RankUpdate| { &m.rank_change },
                |m: &mut RankUpdate| { &mut m.rank_change },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_type_id",
                |m: &RankUpdate| { &m.rank_type_id },
                |m: &mut RankUpdate| { &mut m.rank_type_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RankUpdate>(
                "CCSUsrMsg_ServerRankUpdate.RankUpdate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RankUpdate {
        const NAME: &'static str = "RankUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.rank_old = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.rank_new = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.num_wins = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.rank_change = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.rank_type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.rank_old {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.rank_new {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.num_wins {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.rank_change {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rank_type_id {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.rank_old {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.rank_new {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.num_wins {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.rank_change {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.rank_type_id {
                os.write_int32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RankUpdate {
            RankUpdate::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.rank_old = ::std::option::Option::None;
            self.rank_new = ::std::option::Option::None;
            self.num_wins = ::std::option::Option::None;
            self.rank_change = ::std::option::Option::None;
            self.rank_type_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RankUpdate {
            static instance: RankUpdate = RankUpdate {
                account_id: ::std::option::Option::None,
                rank_old: ::std::option::Option::None,
                rank_new: ::std::option::Option::None,
                num_wins: ::std::option::Option::None,
                rank_change: ::std::option::Option::None,
                rank_type_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RankUpdate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_ServerRankUpdate.RankUpdate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RankUpdate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RankUpdate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_XpUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_XpUpdate {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_XpUpdate.data)
    pub data: ::protobuf::MessageField<super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_XpUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XpUpdate {
    fn default() -> &'a CCSUsrMsg_XpUpdate {
        <CCSUsrMsg_XpUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XpUpdate {
    pub fn new() -> CCSUsrMsg_XpUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>(
            "data",
            |m: &CCSUsrMsg_XpUpdate| { &m.data },
            |m: &mut CCSUsrMsg_XpUpdate| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_XpUpdate>(
            "CCSUsrMsg_XpUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_XpUpdate {
    const NAME: &'static str = "CCSUsrMsg_XpUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_XpUpdate {
        CCSUsrMsg_XpUpdate::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_XpUpdate {
        static instance: CCSUsrMsg_XpUpdate = CCSUsrMsg_XpUpdate {
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_XpUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_XpUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_XpUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_XpUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ItemPickup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ItemPickup {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ItemPickup.item)
    pub item: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ItemPickup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ItemPickup {
    fn default() -> &'a CCSUsrMsg_ItemPickup {
        <CCSUsrMsg_ItemPickup as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ItemPickup {
    pub fn new() -> CCSUsrMsg_ItemPickup {
        ::std::default::Default::default()
    }

    // optional string item = 1;

    pub fn item(&self) -> &str {
        match self.item.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::std::string::String) {
        self.item = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut ::std::string::String {
        if self.item.is_none() {
            self.item = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> ::std::string::String {
        self.item.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item",
            |m: &CCSUsrMsg_ItemPickup| { &m.item },
            |m: &mut CCSUsrMsg_ItemPickup| { &mut m.item },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ItemPickup>(
            "CCSUsrMsg_ItemPickup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ItemPickup {
    const NAME: &'static str = "CCSUsrMsg_ItemPickup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.item = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ItemPickup {
        CCSUsrMsg_ItemPickup::new()
    }

    fn clear(&mut self) {
        self.item = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ItemPickup {
        static instance: CCSUsrMsg_ItemPickup = CCSUsrMsg_ItemPickup {
            item: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ItemPickup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ItemPickup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ItemPickup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ItemPickup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ShowMenu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ShowMenu {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ShowMenu.bits_valid_slots)
    pub bits_valid_slots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ShowMenu.display_time)
    pub display_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ShowMenu.menu_string)
    pub menu_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ShowMenu.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ShowMenu {
    fn default() -> &'a CCSUsrMsg_ShowMenu {
        <CCSUsrMsg_ShowMenu as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ShowMenu {
    pub fn new() -> CCSUsrMsg_ShowMenu {
        ::std::default::Default::default()
    }

    // optional int32 bits_valid_slots = 1;

    pub fn bits_valid_slots(&self) -> i32 {
        self.bits_valid_slots.unwrap_or(0)
    }

    pub fn clear_bits_valid_slots(&mut self) {
        self.bits_valid_slots = ::std::option::Option::None;
    }

    pub fn has_bits_valid_slots(&self) -> bool {
        self.bits_valid_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bits_valid_slots(&mut self, v: i32) {
        self.bits_valid_slots = ::std::option::Option::Some(v);
    }

    // optional int32 display_time = 2;

    pub fn display_time(&self) -> i32 {
        self.display_time.unwrap_or(0)
    }

    pub fn clear_display_time(&mut self) {
        self.display_time = ::std::option::Option::None;
    }

    pub fn has_display_time(&self) -> bool {
        self.display_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_time(&mut self, v: i32) {
        self.display_time = ::std::option::Option::Some(v);
    }

    // optional string menu_string = 3;

    pub fn menu_string(&self) -> &str {
        match self.menu_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_menu_string(&mut self) {
        self.menu_string = ::std::option::Option::None;
    }

    pub fn has_menu_string(&self) -> bool {
        self.menu_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_string(&mut self, v: ::std::string::String) {
        self.menu_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu_string(&mut self) -> &mut ::std::string::String {
        if self.menu_string.is_none() {
            self.menu_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.menu_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_menu_string(&mut self) -> ::std::string::String {
        self.menu_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bits_valid_slots",
            |m: &CCSUsrMsg_ShowMenu| { &m.bits_valid_slots },
            |m: &mut CCSUsrMsg_ShowMenu| { &mut m.bits_valid_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_time",
            |m: &CCSUsrMsg_ShowMenu| { &m.display_time },
            |m: &mut CCSUsrMsg_ShowMenu| { &mut m.display_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "menu_string",
            |m: &CCSUsrMsg_ShowMenu| { &m.menu_string },
            |m: &mut CCSUsrMsg_ShowMenu| { &mut m.menu_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ShowMenu>(
            "CCSUsrMsg_ShowMenu",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ShowMenu {
    const NAME: &'static str = "CCSUsrMsg_ShowMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bits_valid_slots = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.display_time = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.menu_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bits_valid_slots {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.display_time {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.menu_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bits_valid_slots {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.display_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.menu_string.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ShowMenu {
        CCSUsrMsg_ShowMenu::new()
    }

    fn clear(&mut self) {
        self.bits_valid_slots = ::std::option::Option::None;
        self.display_time = ::std::option::Option::None;
        self.menu_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ShowMenu {
        static instance: CCSUsrMsg_ShowMenu = CCSUsrMsg_ShowMenu {
            bits_valid_slots: ::std::option::Option::None,
            display_time: ::std::option::Option::None,
            menu_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ShowMenu {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ShowMenu").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ShowMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ShowMenu {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_BarTime)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_BarTime {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_BarTime.time)
    pub time: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_BarTime.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_BarTime {
    fn default() -> &'a CCSUsrMsg_BarTime {
        <CCSUsrMsg_BarTime as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_BarTime {
    pub fn new() -> CCSUsrMsg_BarTime {
        ::std::default::Default::default()
    }

    // optional string time = 1;

    pub fn time(&self) -> &str {
        match self.time.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::std::string::String) {
        self.time = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::std::string::String {
        if self.time.is_none() {
            self.time = ::std::option::Option::Some(::std::string::String::new());
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::std::string::String {
        self.time.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time",
            |m: &CCSUsrMsg_BarTime| { &m.time },
            |m: &mut CCSUsrMsg_BarTime| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_BarTime>(
            "CCSUsrMsg_BarTime",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_BarTime {
    const NAME: &'static str = "CCSUsrMsg_BarTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.time = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.time.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_BarTime {
        CCSUsrMsg_BarTime::new()
    }

    fn clear(&mut self) {
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_BarTime {
        static instance: CCSUsrMsg_BarTime = CCSUsrMsg_BarTime {
            time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_BarTime {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_BarTime").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_BarTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_BarTime {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_AmmoDenied)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_AmmoDenied {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_AmmoDenied.ammoidx)
    pub ammoidx: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_AmmoDenied.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AmmoDenied {
    fn default() -> &'a CCSUsrMsg_AmmoDenied {
        <CCSUsrMsg_AmmoDenied as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AmmoDenied {
    pub fn new() -> CCSUsrMsg_AmmoDenied {
        ::std::default::Default::default()
    }

    // optional int32 ammoidx = 1;

    pub fn ammoidx(&self) -> i32 {
        self.ammoidx.unwrap_or(0)
    }

    pub fn clear_ammoidx(&mut self) {
        self.ammoidx = ::std::option::Option::None;
    }

    pub fn has_ammoidx(&self) -> bool {
        self.ammoidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammoidx(&mut self, v: i32) {
        self.ammoidx = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ammoidx",
            |m: &CCSUsrMsg_AmmoDenied| { &m.ammoidx },
            |m: &mut CCSUsrMsg_AmmoDenied| { &mut m.ammoidx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_AmmoDenied>(
            "CCSUsrMsg_AmmoDenied",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_AmmoDenied {
    const NAME: &'static str = "CCSUsrMsg_AmmoDenied";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ammoidx = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ammoidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ammoidx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_AmmoDenied {
        CCSUsrMsg_AmmoDenied::new()
    }

    fn clear(&mut self) {
        self.ammoidx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_AmmoDenied {
        static instance: CCSUsrMsg_AmmoDenied = CCSUsrMsg_AmmoDenied {
            ammoidx: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_AmmoDenied {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_AmmoDenied").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_AmmoDenied {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_AmmoDenied {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_MarkAchievement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_MarkAchievement {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_MarkAchievement.achievement)
    pub achievement: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_MarkAchievement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MarkAchievement {
    fn default() -> &'a CCSUsrMsg_MarkAchievement {
        <CCSUsrMsg_MarkAchievement as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MarkAchievement {
    pub fn new() -> CCSUsrMsg_MarkAchievement {
        ::std::default::Default::default()
    }

    // optional string achievement = 1;

    pub fn achievement(&self) -> &str {
        match self.achievement.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_achievement(&mut self) {
        self.achievement = ::std::option::Option::None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: ::std::string::String) {
        self.achievement = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievement(&mut self) -> &mut ::std::string::String {
        if self.achievement.is_none() {
            self.achievement = ::std::option::Option::Some(::std::string::String::new());
        }
        self.achievement.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievement(&mut self) -> ::std::string::String {
        self.achievement.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "achievement",
            |m: &CCSUsrMsg_MarkAchievement| { &m.achievement },
            |m: &mut CCSUsrMsg_MarkAchievement| { &mut m.achievement },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_MarkAchievement>(
            "CCSUsrMsg_MarkAchievement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_MarkAchievement {
    const NAME: &'static str = "CCSUsrMsg_MarkAchievement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.achievement = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.achievement.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.achievement.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_MarkAchievement {
        CCSUsrMsg_MarkAchievement::new()
    }

    fn clear(&mut self) {
        self.achievement = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_MarkAchievement {
        static instance: CCSUsrMsg_MarkAchievement = CCSUsrMsg_MarkAchievement {
            achievement: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_MarkAchievement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_MarkAchievement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_MarkAchievement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_MarkAchievement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_MatchStatsUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_MatchStatsUpdate {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_MatchStatsUpdate.update)
    pub update: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_MatchStatsUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MatchStatsUpdate {
    fn default() -> &'a CCSUsrMsg_MatchStatsUpdate {
        <CCSUsrMsg_MatchStatsUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MatchStatsUpdate {
    pub fn new() -> CCSUsrMsg_MatchStatsUpdate {
        ::std::default::Default::default()
    }

    // optional string update = 1;

    pub fn update(&self) -> &str {
        match self.update.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_update(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: ::std::string::String) {
        self.update = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut ::std::string::String {
        if self.update.is_none() {
            self.update = ::std::option::Option::Some(::std::string::String::new());
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> ::std::string::String {
        self.update.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update",
            |m: &CCSUsrMsg_MatchStatsUpdate| { &m.update },
            |m: &mut CCSUsrMsg_MatchStatsUpdate| { &mut m.update },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_MatchStatsUpdate>(
            "CCSUsrMsg_MatchStatsUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_MatchStatsUpdate {
    const NAME: &'static str = "CCSUsrMsg_MatchStatsUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.update = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.update.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.update.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_MatchStatsUpdate {
        CCSUsrMsg_MatchStatsUpdate::new()
    }

    fn clear(&mut self) {
        self.update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_MatchStatsUpdate {
        static instance: CCSUsrMsg_MatchStatsUpdate = CCSUsrMsg_MatchStatsUpdate {
            update: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_MatchStatsUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_MatchStatsUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_MatchStatsUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_MatchStatsUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ItemDrop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ItemDrop {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ItemDrop.itemid)
    pub itemid: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ItemDrop.death)
    pub death: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ItemDrop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ItemDrop {
    fn default() -> &'a CCSUsrMsg_ItemDrop {
        <CCSUsrMsg_ItemDrop as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ItemDrop {
    pub fn new() -> CCSUsrMsg_ItemDrop {
        ::std::default::Default::default()
    }

    // optional int64 itemid = 1;

    pub fn itemid(&self) -> i64 {
        self.itemid.unwrap_or(0)
    }

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: i64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    // optional bool death = 2;

    pub fn death(&self) -> bool {
        self.death.unwrap_or(false)
    }

    pub fn clear_death(&mut self) {
        self.death = ::std::option::Option::None;
    }

    pub fn has_death(&self) -> bool {
        self.death.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death(&mut self, v: bool) {
        self.death = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemid",
            |m: &CCSUsrMsg_ItemDrop| { &m.itemid },
            |m: &mut CCSUsrMsg_ItemDrop| { &mut m.itemid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "death",
            |m: &CCSUsrMsg_ItemDrop| { &m.death },
            |m: &mut CCSUsrMsg_ItemDrop| { &mut m.death },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ItemDrop>(
            "CCSUsrMsg_ItemDrop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ItemDrop {
    const NAME: &'static str = "CCSUsrMsg_ItemDrop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.itemid = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.death = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.death {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.itemid {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.death {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ItemDrop {
        CCSUsrMsg_ItemDrop::new()
    }

    fn clear(&mut self) {
        self.itemid = ::std::option::Option::None;
        self.death = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ItemDrop {
        static instance: CCSUsrMsg_ItemDrop = CCSUsrMsg_ItemDrop {
            itemid: ::std::option::Option::None,
            death: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ItemDrop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ItemDrop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ItemDrop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ItemDrop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_GlowPropTurnOff)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_GlowPropTurnOff {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_GlowPropTurnOff.entidx)
    pub entidx: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_GlowPropTurnOff.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_GlowPropTurnOff {
    fn default() -> &'a CCSUsrMsg_GlowPropTurnOff {
        <CCSUsrMsg_GlowPropTurnOff as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_GlowPropTurnOff {
    pub fn new() -> CCSUsrMsg_GlowPropTurnOff {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CCSUsrMsg_GlowPropTurnOff| { &m.entidx },
            |m: &mut CCSUsrMsg_GlowPropTurnOff| { &mut m.entidx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_GlowPropTurnOff>(
            "CCSUsrMsg_GlowPropTurnOff",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_GlowPropTurnOff {
    const NAME: &'static str = "CCSUsrMsg_GlowPropTurnOff";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_GlowPropTurnOff {
        CCSUsrMsg_GlowPropTurnOff::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_GlowPropTurnOff {
        static instance: CCSUsrMsg_GlowPropTurnOff = CCSUsrMsg_GlowPropTurnOff {
            entidx: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_GlowPropTurnOff {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_GlowPropTurnOff").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_GlowPropTurnOff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_GlowPropTurnOff {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_RoundBackupFilenames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_RoundBackupFilenames {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundBackupFilenames.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundBackupFilenames.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundBackupFilenames.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundBackupFilenames.nicename)
    pub nicename: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundBackupFilenames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundBackupFilenames {
    fn default() -> &'a CCSUsrMsg_RoundBackupFilenames {
        <CCSUsrMsg_RoundBackupFilenames as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundBackupFilenames {
    pub fn new() -> CCSUsrMsg_RoundBackupFilenames {
        ::std::default::Default::default()
    }

    // optional int32 count = 1;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 index = 2;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string filename = 3;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nicename = 4;

    pub fn nicename(&self) -> &str {
        match self.nicename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nicename(&mut self) {
        self.nicename = ::std::option::Option::None;
    }

    pub fn has_nicename(&self) -> bool {
        self.nicename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nicename(&mut self, v: ::std::string::String) {
        self.nicename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nicename(&mut self) -> &mut ::std::string::String {
        if self.nicename.is_none() {
            self.nicename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nicename.as_mut().unwrap()
    }

    // Take field
    pub fn take_nicename(&mut self) -> ::std::string::String {
        self.nicename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CCSUsrMsg_RoundBackupFilenames| { &m.count },
            |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CCSUsrMsg_RoundBackupFilenames| { &m.index },
            |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CCSUsrMsg_RoundBackupFilenames| { &m.filename },
            |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nicename",
            |m: &CCSUsrMsg_RoundBackupFilenames| { &m.nicename },
            |m: &mut CCSUsrMsg_RoundBackupFilenames| { &mut m.nicename },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_RoundBackupFilenames>(
            "CCSUsrMsg_RoundBackupFilenames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_RoundBackupFilenames {
    const NAME: &'static str = "CCSUsrMsg_RoundBackupFilenames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.nicename = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.nicename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.nicename.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_RoundBackupFilenames {
        CCSUsrMsg_RoundBackupFilenames::new()
    }

    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.nicename = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundBackupFilenames {
        static instance: CCSUsrMsg_RoundBackupFilenames = CCSUsrMsg_RoundBackupFilenames {
            count: ::std::option::Option::None,
            index: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            nicename: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_RoundBackupFilenames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_RoundBackupFilenames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_RoundBackupFilenames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RoundBackupFilenames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_SSUI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SSUI {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SSUI.show)
    pub show: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SSUI.start_time)
    pub start_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SSUI.end_time)
    pub end_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SSUI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SSUI {
    fn default() -> &'a CCSUsrMsg_SSUI {
        <CCSUsrMsg_SSUI as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SSUI {
    pub fn new() -> CCSUsrMsg_SSUI {
        ::std::default::Default::default()
    }

    // optional bool show = 1;

    pub fn show(&self) -> bool {
        self.show.unwrap_or(false)
    }

    pub fn clear_show(&mut self) {
        self.show = ::std::option::Option::None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = ::std::option::Option::Some(v);
    }

    // optional float start_time = 2;

    pub fn start_time(&self) -> f32 {
        self.start_time.unwrap_or(0.)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional float end_time = 3;

    pub fn end_time(&self) -> f32 {
        self.end_time.unwrap_or(0.)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: f32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show",
            |m: &CCSUsrMsg_SSUI| { &m.show },
            |m: &mut CCSUsrMsg_SSUI| { &mut m.show },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CCSUsrMsg_SSUI| { &m.start_time },
            |m: &mut CCSUsrMsg_SSUI| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_time",
            |m: &CCSUsrMsg_SSUI| { &m.end_time },
            |m: &mut CCSUsrMsg_SSUI| { &mut m.end_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_SSUI>(
            "CCSUsrMsg_SSUI",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_SSUI {
    const NAME: &'static str = "CCSUsrMsg_SSUI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.show = ::std::option::Option::Some(is.read_bool()?);
                },
                21 => {
                    self.start_time = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.end_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.show {
            my_size += 1 + 1;
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.end_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.show {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SSUI {
        CCSUsrMsg_SSUI::new()
    }

    fn clear(&mut self) {
        self.show = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SSUI {
        static instance: CCSUsrMsg_SSUI = CCSUsrMsg_SSUI {
            show: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_SSUI {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_SSUI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_SSUI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SSUI {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_SurvivalStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SurvivalStats {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.facts)
    pub facts: ::std::vec::Vec<ccsusr_msg_survival_stats::Fact>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.users)
    pub users: ::std::vec::Vec<ccsusr_msg_survival_stats::Placement>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.damages)
    pub damages: ::std::vec::Vec<ccsusr_msg_survival_stats::Damage>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.ticknumber)
    pub ticknumber: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SurvivalStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SurvivalStats {
    fn default() -> &'a CCSUsrMsg_SurvivalStats {
        <CCSUsrMsg_SurvivalStats as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SurvivalStats {
    pub fn new() -> CCSUsrMsg_SurvivalStats {
        ::std::default::Default::default()
    }

    // optional uint64 xuid = 1;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 ticknumber = 4;

    pub fn ticknumber(&self) -> i32 {
        self.ticknumber.unwrap_or(0)
    }

    pub fn clear_ticknumber(&mut self) {
        self.ticknumber = ::std::option::Option::None;
    }

    pub fn has_ticknumber(&self) -> bool {
        self.ticknumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticknumber(&mut self, v: i32) {
        self.ticknumber = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xuid",
            |m: &CCSUsrMsg_SurvivalStats| { &m.xuid },
            |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.xuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "facts",
            |m: &CCSUsrMsg_SurvivalStats| { &m.facts },
            |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.facts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "users",
            |m: &CCSUsrMsg_SurvivalStats| { &m.users },
            |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.users },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "damages",
            |m: &CCSUsrMsg_SurvivalStats| { &m.damages },
            |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.damages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticknumber",
            |m: &CCSUsrMsg_SurvivalStats| { &m.ticknumber },
            |m: &mut CCSUsrMsg_SurvivalStats| { &mut m.ticknumber },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_SurvivalStats>(
            "CCSUsrMsg_SurvivalStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_SurvivalStats {
    const NAME: &'static str = "CCSUsrMsg_SurvivalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.facts.push(is.read_message()?);
                },
                26 => {
                    self.users.push(is.read_message()?);
                },
                42 => {
                    self.damages.push(is.read_message()?);
                },
                32 => {
                    self.ticknumber = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.xuid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.facts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.damages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ticknumber {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.xuid {
            os.write_uint64(1, v)?;
        }
        for v in &self.facts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.users {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.damages {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.ticknumber {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SurvivalStats {
        CCSUsrMsg_SurvivalStats::new()
    }

    fn clear(&mut self) {
        self.xuid = ::std::option::Option::None;
        self.facts.clear();
        self.users.clear();
        self.damages.clear();
        self.ticknumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SurvivalStats {
        static instance: CCSUsrMsg_SurvivalStats = CCSUsrMsg_SurvivalStats {
            xuid: ::std::option::Option::None,
            facts: ::std::vec::Vec::new(),
            users: ::std::vec::Vec::new(),
            damages: ::std::vec::Vec::new(),
            ticknumber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_SurvivalStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_SurvivalStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_SurvivalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_SurvivalStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CCSUsrMsg_SurvivalStats`
pub mod ccsusr_msg_survival_stats {
    // @@protoc_insertion_point(message:CCSUsrMsg_SurvivalStats.Fact)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Fact {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Fact.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Fact.display)
        pub display: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Fact.value)
        pub value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Fact.interestingness)
        pub interestingness: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_SurvivalStats.Fact.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Fact {
        fn default() -> &'a Fact {
            <Fact as ::protobuf::Message>::default_instance()
        }
    }

    impl Fact {
        pub fn new() -> Fact {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional int32 display = 2;

        pub fn display(&self) -> i32 {
            self.display.unwrap_or(0)
        }

        pub fn clear_display(&mut self) {
            self.display = ::std::option::Option::None;
        }

        pub fn has_display(&self) -> bool {
            self.display.is_some()
        }

        // Param is passed by value, moved
        pub fn set_display(&mut self, v: i32) {
            self.display = ::std::option::Option::Some(v);
        }

        // optional int32 value = 3;

        pub fn value(&self) -> i32 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: i32) {
            self.value = ::std::option::Option::Some(v);
        }

        // optional float interestingness = 4;

        pub fn interestingness(&self) -> f32 {
            self.interestingness.unwrap_or(0.)
        }

        pub fn clear_interestingness(&mut self) {
            self.interestingness = ::std::option::Option::None;
        }

        pub fn has_interestingness(&self) -> bool {
            self.interestingness.is_some()
        }

        // Param is passed by value, moved
        pub fn set_interestingness(&mut self, v: f32) {
            self.interestingness = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Fact| { &m.type_ },
                |m: &mut Fact| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "display",
                |m: &Fact| { &m.display },
                |m: &mut Fact| { &mut m.display },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Fact| { &m.value },
                |m: &mut Fact| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "interestingness",
                |m: &Fact| { &m.interestingness },
                |m: &mut Fact| { &mut m.interestingness },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Fact>(
                "CCSUsrMsg_SurvivalStats.Fact",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Fact {
        const NAME: &'static str = "Fact";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.display = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    37 => {
                        self.interestingness = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.display {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.value {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.interestingness {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.display {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.interestingness {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Fact {
            Fact::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.display = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.interestingness = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Fact {
            static instance: Fact = Fact {
                type_: ::std::option::Option::None,
                display: ::std::option::Option::None,
                value: ::std::option::Option::None,
                interestingness: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Fact {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_SurvivalStats.Fact").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Fact {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Fact {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CCSUsrMsg_SurvivalStats.Placement)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Placement {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Placement.xuid)
        pub xuid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Placement.teamnumber)
        pub teamnumber: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Placement.placement)
        pub placement: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_SurvivalStats.Placement.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Placement {
        fn default() -> &'a Placement {
            <Placement as ::protobuf::Message>::default_instance()
        }
    }

    impl Placement {
        pub fn new() -> Placement {
            ::std::default::Default::default()
        }

        // optional uint64 xuid = 1;

        pub fn xuid(&self) -> u64 {
            self.xuid.unwrap_or(0)
        }

        pub fn clear_xuid(&mut self) {
            self.xuid = ::std::option::Option::None;
        }

        pub fn has_xuid(&self) -> bool {
            self.xuid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xuid(&mut self, v: u64) {
            self.xuid = ::std::option::Option::Some(v);
        }

        // optional int32 teamnumber = 2;

        pub fn teamnumber(&self) -> i32 {
            self.teamnumber.unwrap_or(0)
        }

        pub fn clear_teamnumber(&mut self) {
            self.teamnumber = ::std::option::Option::None;
        }

        pub fn has_teamnumber(&self) -> bool {
            self.teamnumber.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamnumber(&mut self, v: i32) {
            self.teamnumber = ::std::option::Option::Some(v);
        }

        // optional int32 placement = 3;

        pub fn placement(&self) -> i32 {
            self.placement.unwrap_or(0)
        }

        pub fn clear_placement(&mut self) {
            self.placement = ::std::option::Option::None;
        }

        pub fn has_placement(&self) -> bool {
            self.placement.is_some()
        }

        // Param is passed by value, moved
        pub fn set_placement(&mut self, v: i32) {
            self.placement = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xuid",
                |m: &Placement| { &m.xuid },
                |m: &mut Placement| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "teamnumber",
                |m: &Placement| { &m.teamnumber },
                |m: &mut Placement| { &mut m.teamnumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "placement",
                |m: &Placement| { &m.placement },
                |m: &mut Placement| { &mut m.placement },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Placement>(
                "CCSUsrMsg_SurvivalStats.Placement",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Placement {
        const NAME: &'static str = "Placement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.teamnumber = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.placement = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.xuid {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.teamnumber {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.placement {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.xuid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.teamnumber {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.placement {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Placement {
            Placement::new()
        }

        fn clear(&mut self) {
            self.xuid = ::std::option::Option::None;
            self.teamnumber = ::std::option::Option::None;
            self.placement = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Placement {
            static instance: Placement = Placement {
                xuid: ::std::option::Option::None,
                teamnumber: ::std::option::Option::None,
                placement: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Placement {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_SurvivalStats.Placement").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Placement {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Placement {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CCSUsrMsg_SurvivalStats.Damage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Damage {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Damage.xuid)
        pub xuid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Damage.to)
        pub to: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Damage.to_hits)
        pub to_hits: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Damage.from)
        pub from: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Damage.from_hits)
        pub from_hits: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_SurvivalStats.Damage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Damage {
        fn default() -> &'a Damage {
            <Damage as ::protobuf::Message>::default_instance()
        }
    }

    impl Damage {
        pub fn new() -> Damage {
            ::std::default::Default::default()
        }

        // optional uint64 xuid = 1;

        pub fn xuid(&self) -> u64 {
            self.xuid.unwrap_or(0)
        }

        pub fn clear_xuid(&mut self) {
            self.xuid = ::std::option::Option::None;
        }

        pub fn has_xuid(&self) -> bool {
            self.xuid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xuid(&mut self, v: u64) {
            self.xuid = ::std::option::Option::Some(v);
        }

        // optional int32 to = 2;

        pub fn to(&self) -> i32 {
            self.to.unwrap_or(0)
        }

        pub fn clear_to(&mut self) {
            self.to = ::std::option::Option::None;
        }

        pub fn has_to(&self) -> bool {
            self.to.is_some()
        }

        // Param is passed by value, moved
        pub fn set_to(&mut self, v: i32) {
            self.to = ::std::option::Option::Some(v);
        }

        // optional int32 to_hits = 3;

        pub fn to_hits(&self) -> i32 {
            self.to_hits.unwrap_or(0)
        }

        pub fn clear_to_hits(&mut self) {
            self.to_hits = ::std::option::Option::None;
        }

        pub fn has_to_hits(&self) -> bool {
            self.to_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_to_hits(&mut self, v: i32) {
            self.to_hits = ::std::option::Option::Some(v);
        }

        // optional int32 from = 4;

        pub fn from(&self) -> i32 {
            self.from.unwrap_or(0)
        }

        pub fn clear_from(&mut self) {
            self.from = ::std::option::Option::None;
        }

        pub fn has_from(&self) -> bool {
            self.from.is_some()
        }

        // Param is passed by value, moved
        pub fn set_from(&mut self, v: i32) {
            self.from = ::std::option::Option::Some(v);
        }

        // optional int32 from_hits = 5;

        pub fn from_hits(&self) -> i32 {
            self.from_hits.unwrap_or(0)
        }

        pub fn clear_from_hits(&mut self) {
            self.from_hits = ::std::option::Option::None;
        }

        pub fn has_from_hits(&self) -> bool {
            self.from_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_from_hits(&mut self, v: i32) {
            self.from_hits = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xuid",
                |m: &Damage| { &m.xuid },
                |m: &mut Damage| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "to",
                |m: &Damage| { &m.to },
                |m: &mut Damage| { &mut m.to },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "to_hits",
                |m: &Damage| { &m.to_hits },
                |m: &mut Damage| { &mut m.to_hits },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "from",
                |m: &Damage| { &m.from },
                |m: &mut Damage| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "from_hits",
                |m: &Damage| { &m.from_hits },
                |m: &mut Damage| { &mut m.from_hits },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Damage>(
                "CCSUsrMsg_SurvivalStats.Damage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Damage {
        const NAME: &'static str = "Damage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.to = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.to_hits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.from = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.from_hits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.xuid {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.to {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.to_hits {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.from {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.from_hits {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.xuid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.to {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.to_hits {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.from {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.from_hits {
                os.write_int32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Damage {
            Damage::new()
        }

        fn clear(&mut self) {
            self.xuid = ::std::option::Option::None;
            self.to = ::std::option::Option::None;
            self.to_hits = ::std::option::Option::None;
            self.from = ::std::option::Option::None;
            self.from_hits = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Damage {
            static instance: Damage = Damage {
                xuid: ::std::option::Option::None,
                to: ::std::option::Option::None,
                to_hits: ::std::option::Option::None,
                from: ::std::option::Option::None,
                from_hits: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Damage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_SurvivalStats.Damage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Damage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Damage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_EndOfMatchAllPlayersData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_EndOfMatchAllPlayersData {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.allplayerdata)
    pub allplayerdata: ::std::vec::Vec<ccsusr_msg_end_of_match_all_players_data::PlayerData>,
    // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.scene)
    pub scene: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_EndOfMatchAllPlayersData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_EndOfMatchAllPlayersData {
    fn default() -> &'a CCSUsrMsg_EndOfMatchAllPlayersData {
        <CCSUsrMsg_EndOfMatchAllPlayersData as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_EndOfMatchAllPlayersData {
    pub fn new() -> CCSUsrMsg_EndOfMatchAllPlayersData {
        ::std::default::Default::default()
    }

    // optional int32 scene = 2;

    pub fn scene(&self) -> i32 {
        self.scene.unwrap_or(0)
    }

    pub fn clear_scene(&mut self) {
        self.scene = ::std::option::Option::None;
    }

    pub fn has_scene(&self) -> bool {
        self.scene.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scene(&mut self, v: i32) {
        self.scene = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allplayerdata",
            |m: &CCSUsrMsg_EndOfMatchAllPlayersData| { &m.allplayerdata },
            |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData| { &mut m.allplayerdata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scene",
            |m: &CCSUsrMsg_EndOfMatchAllPlayersData| { &m.scene },
            |m: &mut CCSUsrMsg_EndOfMatchAllPlayersData| { &mut m.scene },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_EndOfMatchAllPlayersData>(
            "CCSUsrMsg_EndOfMatchAllPlayersData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_EndOfMatchAllPlayersData {
    const NAME: &'static str = "CCSUsrMsg_EndOfMatchAllPlayersData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.allplayerdata.push(is.read_message()?);
                },
                16 => {
                    self.scene = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.allplayerdata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.scene {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.allplayerdata {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.scene {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_EndOfMatchAllPlayersData {
        CCSUsrMsg_EndOfMatchAllPlayersData::new()
    }

    fn clear(&mut self) {
        self.allplayerdata.clear();
        self.scene = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_EndOfMatchAllPlayersData {
        static instance: CCSUsrMsg_EndOfMatchAllPlayersData = CCSUsrMsg_EndOfMatchAllPlayersData {
            allplayerdata: ::std::vec::Vec::new(),
            scene: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_EndOfMatchAllPlayersData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_EndOfMatchAllPlayersData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_EndOfMatchAllPlayersData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_EndOfMatchAllPlayersData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CCSUsrMsg_EndOfMatchAllPlayersData`
pub mod ccsusr_msg_end_of_match_all_players_data {
    // @@protoc_insertion_point(message:CCSUsrMsg_EndOfMatchAllPlayersData.Accolade)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Accolade {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.Accolade.eaccolade)
        pub eaccolade: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.Accolade.value)
        pub value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.Accolade.position)
        pub position: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_EndOfMatchAllPlayersData.Accolade.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Accolade {
        fn default() -> &'a Accolade {
            <Accolade as ::protobuf::Message>::default_instance()
        }
    }

    impl Accolade {
        pub fn new() -> Accolade {
            ::std::default::Default::default()
        }

        // optional int32 eaccolade = 1;

        pub fn eaccolade(&self) -> i32 {
            self.eaccolade.unwrap_or(0)
        }

        pub fn clear_eaccolade(&mut self) {
            self.eaccolade = ::std::option::Option::None;
        }

        pub fn has_eaccolade(&self) -> bool {
            self.eaccolade.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eaccolade(&mut self, v: i32) {
            self.eaccolade = ::std::option::Option::Some(v);
        }

        // optional float value = 2;

        pub fn value(&self) -> f32 {
            self.value.unwrap_or(0.)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: f32) {
            self.value = ::std::option::Option::Some(v);
        }

        // optional int32 position = 3;

        pub fn position(&self) -> i32 {
            self.position.unwrap_or(0)
        }

        pub fn clear_position(&mut self) {
            self.position = ::std::option::Option::None;
        }

        pub fn has_position(&self) -> bool {
            self.position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position(&mut self, v: i32) {
            self.position = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eaccolade",
                |m: &Accolade| { &m.eaccolade },
                |m: &mut Accolade| { &mut m.eaccolade },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Accolade| { &m.value },
                |m: &mut Accolade| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "position",
                |m: &Accolade| { &m.position },
                |m: &mut Accolade| { &mut m.position },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Accolade>(
                "CCSUsrMsg_EndOfMatchAllPlayersData.Accolade",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Accolade {
        const NAME: &'static str = "Accolade";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eaccolade = ::std::option::Option::Some(is.read_int32()?);
                    },
                    21 => {
                        self.value = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.position = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eaccolade {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.position {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eaccolade {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.position {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Accolade {
            Accolade::new()
        }

        fn clear(&mut self) {
            self.eaccolade = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.position = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Accolade {
            static instance: Accolade = Accolade {
                eaccolade: ::std::option::Option::None,
                value: ::std::option::Option::None,
                position: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Accolade {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_EndOfMatchAllPlayersData.Accolade").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Accolade {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Accolade {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerData {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.slot)
        pub slot: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.xuid)
        pub xuid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.teamnumber)
        pub teamnumber: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.nomination)
        pub nomination: ::protobuf::MessageField<Accolade>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.items)
        pub items: ::std::vec::Vec<super::super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.playercolor)
        pub playercolor: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.isbot)
        pub isbot: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerData {
        fn default() -> &'a PlayerData {
            <PlayerData as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerData {
        pub fn new() -> PlayerData {
            ::std::default::Default::default()
        }

        // optional int32 slot = 1;

        pub fn slot(&self) -> i32 {
            self.slot.unwrap_or(-1i32)
        }

        pub fn clear_slot(&mut self) {
            self.slot = ::std::option::Option::None;
        }

        pub fn has_slot(&self) -> bool {
            self.slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot(&mut self, v: i32) {
            self.slot = ::std::option::Option::Some(v);
        }

        // optional uint64 xuid = 2;

        pub fn xuid(&self) -> u64 {
            self.xuid.unwrap_or(0)
        }

        pub fn clear_xuid(&mut self) {
            self.xuid = ::std::option::Option::None;
        }

        pub fn has_xuid(&self) -> bool {
            self.xuid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xuid(&mut self, v: u64) {
            self.xuid = ::std::option::Option::Some(v);
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 teamnumber = 4;

        pub fn teamnumber(&self) -> i32 {
            self.teamnumber.unwrap_or(0)
        }

        pub fn clear_teamnumber(&mut self) {
            self.teamnumber = ::std::option::Option::None;
        }

        pub fn has_teamnumber(&self) -> bool {
            self.teamnumber.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamnumber(&mut self, v: i32) {
            self.teamnumber = ::std::option::Option::Some(v);
        }

        // optional int32 playercolor = 7;

        pub fn playercolor(&self) -> i32 {
            self.playercolor.unwrap_or(0)
        }

        pub fn clear_playercolor(&mut self) {
            self.playercolor = ::std::option::Option::None;
        }

        pub fn has_playercolor(&self) -> bool {
            self.playercolor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playercolor(&mut self, v: i32) {
            self.playercolor = ::std::option::Option::Some(v);
        }

        // optional bool isbot = 8;

        pub fn isbot(&self) -> bool {
            self.isbot.unwrap_or(false)
        }

        pub fn clear_isbot(&mut self) {
            self.isbot = ::std::option::Option::None;
        }

        pub fn has_isbot(&self) -> bool {
            self.isbot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_isbot(&mut self, v: bool) {
            self.isbot = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot",
                |m: &PlayerData| { &m.slot },
                |m: &mut PlayerData| { &mut m.slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xuid",
                |m: &PlayerData| { &m.xuid },
                |m: &mut PlayerData| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &PlayerData| { &m.name },
                |m: &mut PlayerData| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "teamnumber",
                |m: &PlayerData| { &m.teamnumber },
                |m: &mut PlayerData| { &mut m.teamnumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Accolade>(
                "nomination",
                |m: &PlayerData| { &m.nomination },
                |m: &mut PlayerData| { &mut m.nomination },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "items",
                |m: &PlayerData| { &m.items },
                |m: &mut PlayerData| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "playercolor",
                |m: &PlayerData| { &m.playercolor },
                |m: &mut PlayerData| { &mut m.playercolor },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "isbot",
                |m: &PlayerData| { &m.isbot },
                |m: &mut PlayerData| { &mut m.isbot },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerData>(
                "CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerData {
        const NAME: &'static str = "PlayerData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.teamnumber = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.nomination)?;
                    },
                    50 => {
                        self.items.push(is.read_message()?);
                    },
                    56 => {
                        self.playercolor = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.isbot = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.xuid {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.teamnumber {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.nomination.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.items {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.playercolor {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.isbot {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.slot {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.xuid {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.teamnumber {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.nomination.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            for v in &self.items {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.playercolor {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.isbot {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerData {
            PlayerData::new()
        }

        fn clear(&mut self) {
            self.slot = ::std::option::Option::None;
            self.xuid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.teamnumber = ::std::option::Option::None;
            self.nomination.clear();
            self.items.clear();
            self.playercolor = ::std::option::Option::None;
            self.isbot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerData {
            static instance: PlayerData = PlayerData {
                slot: ::std::option::Option::None,
                xuid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                teamnumber: ::std::option::Option::None,
                nomination: ::protobuf::MessageField::none(),
                items: ::std::vec::Vec::new(),
                playercolor: ::std::option::Option::None,
                isbot: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_RoundEndReportData {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.init_conditions)
    pub init_conditions: ::protobuf::MessageField<ccsusr_msg_round_end_report_data::InitialConditions>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.all_rer_event_data)
    pub all_rer_event_data: ::std::vec::Vec<ccsusr_msg_round_end_report_data::RerEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundEndReportData {
    fn default() -> &'a CCSUsrMsg_RoundEndReportData {
        <CCSUsrMsg_RoundEndReportData as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundEndReportData {
    pub fn new() -> CCSUsrMsg_RoundEndReportData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ccsusr_msg_round_end_report_data::InitialConditions>(
            "init_conditions",
            |m: &CCSUsrMsg_RoundEndReportData| { &m.init_conditions },
            |m: &mut CCSUsrMsg_RoundEndReportData| { &mut m.init_conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "all_rer_event_data",
            |m: &CCSUsrMsg_RoundEndReportData| { &m.all_rer_event_data },
            |m: &mut CCSUsrMsg_RoundEndReportData| { &mut m.all_rer_event_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_RoundEndReportData>(
            "CCSUsrMsg_RoundEndReportData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_RoundEndReportData {
    const NAME: &'static str = "CCSUsrMsg_RoundEndReportData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.init_conditions)?;
                },
                18 => {
                    self.all_rer_event_data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.init_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.all_rer_event_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.init_conditions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.all_rer_event_data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_RoundEndReportData {
        CCSUsrMsg_RoundEndReportData::new()
    }

    fn clear(&mut self) {
        self.init_conditions.clear();
        self.all_rer_event_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundEndReportData {
        static instance: CCSUsrMsg_RoundEndReportData = CCSUsrMsg_RoundEndReportData {
            init_conditions: ::protobuf::MessageField::none(),
            all_rer_event_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_RoundEndReportData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_RoundEndReportData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_RoundEndReportData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RoundEndReportData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CCSUsrMsg_RoundEndReportData`
pub mod ccsusr_msg_round_end_report_data {
    // @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData.RerEvent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RerEvent {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.timestamp)
        pub timestamp: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.terrorist_odds)
        pub terrorist_odds: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.ct_alive)
        pub ct_alive: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.t_alive)
        pub t_alive: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.victim_data)
        pub victim_data: ::protobuf::MessageField<rer_event::Victim>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.objective_data)
        pub objective_data: ::protobuf::MessageField<rer_event::Objective>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.all_damage_data)
        pub all_damage_data: ::std::vec::Vec<rer_event::Damage>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.RerEvent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RerEvent {
        fn default() -> &'a RerEvent {
            <RerEvent as ::protobuf::Message>::default_instance()
        }
    }

    impl RerEvent {
        pub fn new() -> RerEvent {
            ::std::default::Default::default()
        }

        // optional float timestamp = 1;

        pub fn timestamp(&self) -> f32 {
            self.timestamp.unwrap_or(0.)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: f32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional int32 terrorist_odds = 2;

        pub fn terrorist_odds(&self) -> i32 {
            self.terrorist_odds.unwrap_or(0)
        }

        pub fn clear_terrorist_odds(&mut self) {
            self.terrorist_odds = ::std::option::Option::None;
        }

        pub fn has_terrorist_odds(&self) -> bool {
            self.terrorist_odds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_terrorist_odds(&mut self, v: i32) {
            self.terrorist_odds = ::std::option::Option::Some(v);
        }

        // optional int32 ct_alive = 3;

        pub fn ct_alive(&self) -> i32 {
            self.ct_alive.unwrap_or(0)
        }

        pub fn clear_ct_alive(&mut self) {
            self.ct_alive = ::std::option::Option::None;
        }

        pub fn has_ct_alive(&self) -> bool {
            self.ct_alive.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ct_alive(&mut self, v: i32) {
            self.ct_alive = ::std::option::Option::Some(v);
        }

        // optional int32 t_alive = 4;

        pub fn t_alive(&self) -> i32 {
            self.t_alive.unwrap_or(0)
        }

        pub fn clear_t_alive(&mut self) {
            self.t_alive = ::std::option::Option::None;
        }

        pub fn has_t_alive(&self) -> bool {
            self.t_alive.is_some()
        }

        // Param is passed by value, moved
        pub fn set_t_alive(&mut self, v: i32) {
            self.t_alive = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &RerEvent| { &m.timestamp },
                |m: &mut RerEvent| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "terrorist_odds",
                |m: &RerEvent| { &m.terrorist_odds },
                |m: &mut RerEvent| { &mut m.terrorist_odds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ct_alive",
                |m: &RerEvent| { &m.ct_alive },
                |m: &mut RerEvent| { &mut m.ct_alive },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "t_alive",
                |m: &RerEvent| { &m.t_alive },
                |m: &mut RerEvent| { &mut m.t_alive },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, rer_event::Victim>(
                "victim_data",
                |m: &RerEvent| { &m.victim_data },
                |m: &mut RerEvent| { &mut m.victim_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, rer_event::Objective>(
                "objective_data",
                |m: &RerEvent| { &m.objective_data },
                |m: &mut RerEvent| { &mut m.objective_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "all_damage_data",
                |m: &RerEvent| { &m.all_damage_data },
                |m: &mut RerEvent| { &mut m.all_damage_data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RerEvent>(
                "CCSUsrMsg_RoundEndReportData.RerEvent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RerEvent {
        const NAME: &'static str = "RerEvent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.timestamp = ::std::option::Option::Some(is.read_float()?);
                    },
                    16 => {
                        self.terrorist_odds = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.ct_alive = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.t_alive = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.victim_data)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.objective_data)?;
                    },
                    58 => {
                        self.all_damage_data.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += 1 + 4;
            }
            if let Some(v) = self.terrorist_odds {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.ct_alive {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.t_alive {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.victim_data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.objective_data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.all_damage_data {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.timestamp {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.terrorist_odds {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.ct_alive {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.t_alive {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.victim_data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.objective_data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            for v in &self.all_damage_data {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RerEvent {
            RerEvent::new()
        }

        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.terrorist_odds = ::std::option::Option::None;
            self.ct_alive = ::std::option::Option::None;
            self.t_alive = ::std::option::Option::None;
            self.victim_data.clear();
            self.objective_data.clear();
            self.all_damage_data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RerEvent {
            static instance: RerEvent = RerEvent {
                timestamp: ::std::option::Option::None,
                terrorist_odds: ::std::option::Option::None,
                ct_alive: ::std::option::Option::None,
                t_alive: ::std::option::Option::None,
                victim_data: ::protobuf::MessageField::none(),
                objective_data: ::protobuf::MessageField::none(),
                all_damage_data: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RerEvent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_RoundEndReportData.RerEvent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RerEvent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RerEvent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `RerEvent`
    pub mod rer_event {
        // @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData.RerEvent.Victim)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Victim {
            // message fields
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.team_number)
            pub team_number: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.playerslot)
            pub playerslot: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.xuid)
            pub xuid: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.color)
            pub color: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.is_bot)
            pub is_bot: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.is_dead)
            pub is_dead: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Victim {
            fn default() -> &'a Victim {
                <Victim as ::protobuf::Message>::default_instance()
            }
        }

        impl Victim {
            pub fn new() -> Victim {
                ::std::default::Default::default()
            }

            // optional int32 team_number = 1;

            pub fn team_number(&self) -> i32 {
                self.team_number.unwrap_or(0)
            }

            pub fn clear_team_number(&mut self) {
                self.team_number = ::std::option::Option::None;
            }

            pub fn has_team_number(&self) -> bool {
                self.team_number.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_number(&mut self, v: i32) {
                self.team_number = ::std::option::Option::Some(v);
            }

            // optional int32 playerslot = 2;

            pub fn playerslot(&self) -> i32 {
                self.playerslot.unwrap_or(-1i32)
            }

            pub fn clear_playerslot(&mut self) {
                self.playerslot = ::std::option::Option::None;
            }

            pub fn has_playerslot(&self) -> bool {
                self.playerslot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_playerslot(&mut self, v: i32) {
                self.playerslot = ::std::option::Option::Some(v);
            }

            // optional uint64 xuid = 3;

            pub fn xuid(&self) -> u64 {
                self.xuid.unwrap_or(0)
            }

            pub fn clear_xuid(&mut self) {
                self.xuid = ::std::option::Option::None;
            }

            pub fn has_xuid(&self) -> bool {
                self.xuid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_xuid(&mut self, v: u64) {
                self.xuid = ::std::option::Option::Some(v);
            }

            // optional int32 color = 4;

            pub fn color(&self) -> i32 {
                self.color.unwrap_or(0)
            }

            pub fn clear_color(&mut self) {
                self.color = ::std::option::Option::None;
            }

            pub fn has_color(&self) -> bool {
                self.color.is_some()
            }

            // Param is passed by value, moved
            pub fn set_color(&mut self, v: i32) {
                self.color = ::std::option::Option::Some(v);
            }

            // optional bool is_bot = 5;

            pub fn is_bot(&self) -> bool {
                self.is_bot.unwrap_or(false)
            }

            pub fn clear_is_bot(&mut self) {
                self.is_bot = ::std::option::Option::None;
            }

            pub fn has_is_bot(&self) -> bool {
                self.is_bot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_bot(&mut self, v: bool) {
                self.is_bot = ::std::option::Option::Some(v);
            }

            // optional bool is_dead = 6;

            pub fn is_dead(&self) -> bool {
                self.is_dead.unwrap_or(false)
            }

            pub fn clear_is_dead(&mut self) {
                self.is_dead = ::std::option::Option::None;
            }

            pub fn has_is_dead(&self) -> bool {
                self.is_dead.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_dead(&mut self, v: bool) {
                self.is_dead = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team_number",
                    |m: &Victim| { &m.team_number },
                    |m: &mut Victim| { &mut m.team_number },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "playerslot",
                    |m: &Victim| { &m.playerslot },
                    |m: &mut Victim| { &mut m.playerslot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "xuid",
                    |m: &Victim| { &m.xuid },
                    |m: &mut Victim| { &mut m.xuid },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "color",
                    |m: &Victim| { &m.color },
                    |m: &mut Victim| { &mut m.color },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "is_bot",
                    |m: &Victim| { &m.is_bot },
                    |m: &mut Victim| { &mut m.is_bot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "is_dead",
                    |m: &Victim| { &m.is_dead },
                    |m: &mut Victim| { &mut m.is_dead },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Victim>(
                    "CCSUsrMsg_RoundEndReportData.RerEvent.Victim",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Victim {
            const NAME: &'static str = "Victim";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.team_number = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.playerslot = ::std::option::Option::Some(is.read_int32()?);
                        },
                        24 => {
                            self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        32 => {
                            self.color = ::std::option::Option::Some(is.read_int32()?);
                        },
                        40 => {
                            self.is_bot = ::std::option::Option::Some(is.read_bool()?);
                        },
                        48 => {
                            self.is_dead = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.team_number {
                    my_size += ::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.playerslot {
                    my_size += ::protobuf::rt::int32_size(2, v);
                }
                if let Some(v) = self.xuid {
                    my_size += ::protobuf::rt::uint64_size(3, v);
                }
                if let Some(v) = self.color {
                    my_size += ::protobuf::rt::int32_size(4, v);
                }
                if let Some(v) = self.is_bot {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.is_dead {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.team_number {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.playerslot {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.xuid {
                    os.write_uint64(3, v)?;
                }
                if let Some(v) = self.color {
                    os.write_int32(4, v)?;
                }
                if let Some(v) = self.is_bot {
                    os.write_bool(5, v)?;
                }
                if let Some(v) = self.is_dead {
                    os.write_bool(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Victim {
                Victim::new()
            }

            fn clear(&mut self) {
                self.team_number = ::std::option::Option::None;
                self.playerslot = ::std::option::Option::None;
                self.xuid = ::std::option::Option::None;
                self.color = ::std::option::Option::None;
                self.is_bot = ::std::option::Option::None;
                self.is_dead = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Victim {
                static instance: Victim = Victim {
                    team_number: ::std::option::Option::None,
                    playerslot: ::std::option::Option::None,
                    xuid: ::std::option::Option::None,
                    color: ::std::option::Option::None,
                    is_bot: ::std::option::Option::None,
                    is_dead: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Victim {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_RoundEndReportData.RerEvent.Victim").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Victim {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Victim {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData.RerEvent.Objective)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Objective {
            // message fields
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Objective.type)
            pub type_: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.RerEvent.Objective.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Objective {
            fn default() -> &'a Objective {
                <Objective as ::protobuf::Message>::default_instance()
            }
        }

        impl Objective {
            pub fn new() -> Objective {
                ::std::default::Default::default()
            }

            // optional int32 type = 1;

            pub fn type_(&self) -> i32 {
                self.type_.unwrap_or(0)
            }

            pub fn clear_type_(&mut self) {
                self.type_ = ::std::option::Option::None;
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: i32) {
                self.type_ = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "type",
                    |m: &Objective| { &m.type_ },
                    |m: &mut Objective| { &mut m.type_ },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Objective>(
                    "CCSUsrMsg_RoundEndReportData.RerEvent.Objective",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Objective {
            const NAME: &'static str = "Objective";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_ = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.type_ {
                    my_size += ::protobuf::rt::int32_size(1, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.type_ {
                    os.write_int32(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Objective {
                Objective::new()
            }

            fn clear(&mut self) {
                self.type_ = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Objective {
                static instance: Objective = Objective {
                    type_: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Objective {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_RoundEndReportData.RerEvent.Objective").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Objective {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Objective {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData.RerEvent.Damage)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Damage {
            // message fields
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.other_playerslot)
            pub other_playerslot: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.other_xuid)
            pub other_xuid: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.health_removed)
            pub health_removed: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.num_hits)
            pub num_hits: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.return_health_removed)
            pub return_health_removed: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.return_num_hits)
            pub return_num_hits: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Damage {
            fn default() -> &'a Damage {
                <Damage as ::protobuf::Message>::default_instance()
            }
        }

        impl Damage {
            pub fn new() -> Damage {
                ::std::default::Default::default()
            }

            // optional int32 other_playerslot = 1;

            pub fn other_playerslot(&self) -> i32 {
                self.other_playerslot.unwrap_or(-1i32)
            }

            pub fn clear_other_playerslot(&mut self) {
                self.other_playerslot = ::std::option::Option::None;
            }

            pub fn has_other_playerslot(&self) -> bool {
                self.other_playerslot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_other_playerslot(&mut self, v: i32) {
                self.other_playerslot = ::std::option::Option::Some(v);
            }

            // optional uint64 other_xuid = 2;

            pub fn other_xuid(&self) -> u64 {
                self.other_xuid.unwrap_or(0)
            }

            pub fn clear_other_xuid(&mut self) {
                self.other_xuid = ::std::option::Option::None;
            }

            pub fn has_other_xuid(&self) -> bool {
                self.other_xuid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_other_xuid(&mut self, v: u64) {
                self.other_xuid = ::std::option::Option::Some(v);
            }

            // optional int32 health_removed = 3;

            pub fn health_removed(&self) -> i32 {
                self.health_removed.unwrap_or(0)
            }

            pub fn clear_health_removed(&mut self) {
                self.health_removed = ::std::option::Option::None;
            }

            pub fn has_health_removed(&self) -> bool {
                self.health_removed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_health_removed(&mut self, v: i32) {
                self.health_removed = ::std::option::Option::Some(v);
            }

            // optional int32 num_hits = 4;

            pub fn num_hits(&self) -> i32 {
                self.num_hits.unwrap_or(0)
            }

            pub fn clear_num_hits(&mut self) {
                self.num_hits = ::std::option::Option::None;
            }

            pub fn has_num_hits(&self) -> bool {
                self.num_hits.is_some()
            }

            // Param is passed by value, moved
            pub fn set_num_hits(&mut self, v: i32) {
                self.num_hits = ::std::option::Option::Some(v);
            }

            // optional int32 return_health_removed = 5;

            pub fn return_health_removed(&self) -> i32 {
                self.return_health_removed.unwrap_or(0)
            }

            pub fn clear_return_health_removed(&mut self) {
                self.return_health_removed = ::std::option::Option::None;
            }

            pub fn has_return_health_removed(&self) -> bool {
                self.return_health_removed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_return_health_removed(&mut self, v: i32) {
                self.return_health_removed = ::std::option::Option::Some(v);
            }

            // optional int32 return_num_hits = 6;

            pub fn return_num_hits(&self) -> i32 {
                self.return_num_hits.unwrap_or(0)
            }

            pub fn clear_return_num_hits(&mut self) {
                self.return_num_hits = ::std::option::Option::None;
            }

            pub fn has_return_num_hits(&self) -> bool {
                self.return_num_hits.is_some()
            }

            // Param is passed by value, moved
            pub fn set_return_num_hits(&mut self, v: i32) {
                self.return_num_hits = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "other_playerslot",
                    |m: &Damage| { &m.other_playerslot },
                    |m: &mut Damage| { &mut m.other_playerslot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "other_xuid",
                    |m: &Damage| { &m.other_xuid },
                    |m: &mut Damage| { &mut m.other_xuid },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "health_removed",
                    |m: &Damage| { &m.health_removed },
                    |m: &mut Damage| { &mut m.health_removed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "num_hits",
                    |m: &Damage| { &m.num_hits },
                    |m: &mut Damage| { &mut m.num_hits },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "return_health_removed",
                    |m: &Damage| { &m.return_health_removed },
                    |m: &mut Damage| { &mut m.return_health_removed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "return_num_hits",
                    |m: &Damage| { &m.return_num_hits },
                    |m: &mut Damage| { &mut m.return_num_hits },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Damage>(
                    "CCSUsrMsg_RoundEndReportData.RerEvent.Damage",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Damage {
            const NAME: &'static str = "Damage";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.other_playerslot = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.other_xuid = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        24 => {
                            self.health_removed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        32 => {
                            self.num_hits = ::std::option::Option::Some(is.read_int32()?);
                        },
                        40 => {
                            self.return_health_removed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        48 => {
                            self.return_num_hits = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.other_playerslot {
                    my_size += ::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.other_xuid {
                    my_size += ::protobuf::rt::uint64_size(2, v);
                }
                if let Some(v) = self.health_removed {
                    my_size += ::protobuf::rt::int32_size(3, v);
                }
                if let Some(v) = self.num_hits {
                    my_size += ::protobuf::rt::int32_size(4, v);
                }
                if let Some(v) = self.return_health_removed {
                    my_size += ::protobuf::rt::int32_size(5, v);
                }
                if let Some(v) = self.return_num_hits {
                    my_size += ::protobuf::rt::int32_size(6, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.other_playerslot {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.other_xuid {
                    os.write_uint64(2, v)?;
                }
                if let Some(v) = self.health_removed {
                    os.write_int32(3, v)?;
                }
                if let Some(v) = self.num_hits {
                    os.write_int32(4, v)?;
                }
                if let Some(v) = self.return_health_removed {
                    os.write_int32(5, v)?;
                }
                if let Some(v) = self.return_num_hits {
                    os.write_int32(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Damage {
                Damage::new()
            }

            fn clear(&mut self) {
                self.other_playerslot = ::std::option::Option::None;
                self.other_xuid = ::std::option::Option::None;
                self.health_removed = ::std::option::Option::None;
                self.num_hits = ::std::option::Option::None;
                self.return_health_removed = ::std::option::Option::None;
                self.return_num_hits = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Damage {
                static instance: Damage = Damage {
                    other_playerslot: ::std::option::Option::None,
                    other_xuid: ::std::option::Option::None,
                    health_removed: ::std::option::Option::None,
                    num_hits: ::std::option::Option::None,
                    return_health_removed: ::std::option::Option::None,
                    return_num_hits: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Damage {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_RoundEndReportData.RerEvent.Damage").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Damage {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Damage {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData.InitialConditions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InitialConditions {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.InitialConditions.ct_equip_value)
        pub ct_equip_value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.InitialConditions.t_equip_value)
        pub t_equip_value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.InitialConditions.terrorist_odds)
        pub terrorist_odds: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.InitialConditions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InitialConditions {
        fn default() -> &'a InitialConditions {
            <InitialConditions as ::protobuf::Message>::default_instance()
        }
    }

    impl InitialConditions {
        pub fn new() -> InitialConditions {
            ::std::default::Default::default()
        }

        // optional int32 ct_equip_value = 1;

        pub fn ct_equip_value(&self) -> i32 {
            self.ct_equip_value.unwrap_or(0)
        }

        pub fn clear_ct_equip_value(&mut self) {
            self.ct_equip_value = ::std::option::Option::None;
        }

        pub fn has_ct_equip_value(&self) -> bool {
            self.ct_equip_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ct_equip_value(&mut self, v: i32) {
            self.ct_equip_value = ::std::option::Option::Some(v);
        }

        // optional int32 t_equip_value = 2;

        pub fn t_equip_value(&self) -> i32 {
            self.t_equip_value.unwrap_or(0)
        }

        pub fn clear_t_equip_value(&mut self) {
            self.t_equip_value = ::std::option::Option::None;
        }

        pub fn has_t_equip_value(&self) -> bool {
            self.t_equip_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_t_equip_value(&mut self, v: i32) {
            self.t_equip_value = ::std::option::Option::Some(v);
        }

        // optional int32 terrorist_odds = 3;

        pub fn terrorist_odds(&self) -> i32 {
            self.terrorist_odds.unwrap_or(0)
        }

        pub fn clear_terrorist_odds(&mut self) {
            self.terrorist_odds = ::std::option::Option::None;
        }

        pub fn has_terrorist_odds(&self) -> bool {
            self.terrorist_odds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_terrorist_odds(&mut self, v: i32) {
            self.terrorist_odds = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ct_equip_value",
                |m: &InitialConditions| { &m.ct_equip_value },
                |m: &mut InitialConditions| { &mut m.ct_equip_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "t_equip_value",
                |m: &InitialConditions| { &m.t_equip_value },
                |m: &mut InitialConditions| { &mut m.t_equip_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "terrorist_odds",
                |m: &InitialConditions| { &m.terrorist_odds },
                |m: &mut InitialConditions| { &mut m.terrorist_odds },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InitialConditions>(
                "CCSUsrMsg_RoundEndReportData.InitialConditions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for InitialConditions {
        const NAME: &'static str = "InitialConditions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.ct_equip_value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.t_equip_value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.terrorist_odds = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ct_equip_value {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.t_equip_value {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.terrorist_odds {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ct_equip_value {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.t_equip_value {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.terrorist_odds {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InitialConditions {
            InitialConditions::new()
        }

        fn clear(&mut self) {
            self.ct_equip_value = ::std::option::Option::None;
            self.t_equip_value = ::std::option::Option::None;
            self.terrorist_odds = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InitialConditions {
            static instance: InitialConditions = InitialConditions {
                ct_equip_value: ::std::option::Option::None,
                t_equip_value: ::std::option::Option::None,
                terrorist_odds: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for InitialConditions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CCSUsrMsg_RoundEndReportData.InitialConditions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for InitialConditions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for InitialConditions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_PostRoundDamageReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_PostRoundDamageReport {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.other_xuid)
    pub other_xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.given_kill_type)
    pub given_kill_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.given_health_removed)
    pub given_health_removed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.given_num_hits)
    pub given_num_hits: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.taken_kill_type)
    pub taken_kill_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.taken_health_removed)
    pub taken_health_removed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.taken_num_hits)
    pub taken_num_hits: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_PostRoundDamageReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PostRoundDamageReport {
    fn default() -> &'a CCSUsrMsg_PostRoundDamageReport {
        <CCSUsrMsg_PostRoundDamageReport as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PostRoundDamageReport {
    pub fn new() -> CCSUsrMsg_PostRoundDamageReport {
        ::std::default::Default::default()
    }

    // optional uint64 other_xuid = 1;

    pub fn other_xuid(&self) -> u64 {
        self.other_xuid.unwrap_or(0)
    }

    pub fn clear_other_xuid(&mut self) {
        self.other_xuid = ::std::option::Option::None;
    }

    pub fn has_other_xuid(&self) -> bool {
        self.other_xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_xuid(&mut self, v: u64) {
        self.other_xuid = ::std::option::Option::Some(v);
    }

    // optional int32 given_kill_type = 2;

    pub fn given_kill_type(&self) -> i32 {
        self.given_kill_type.unwrap_or(0)
    }

    pub fn clear_given_kill_type(&mut self) {
        self.given_kill_type = ::std::option::Option::None;
    }

    pub fn has_given_kill_type(&self) -> bool {
        self.given_kill_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_given_kill_type(&mut self, v: i32) {
        self.given_kill_type = ::std::option::Option::Some(v);
    }

    // optional int32 given_health_removed = 3;

    pub fn given_health_removed(&self) -> i32 {
        self.given_health_removed.unwrap_or(0)
    }

    pub fn clear_given_health_removed(&mut self) {
        self.given_health_removed = ::std::option::Option::None;
    }

    pub fn has_given_health_removed(&self) -> bool {
        self.given_health_removed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_given_health_removed(&mut self, v: i32) {
        self.given_health_removed = ::std::option::Option::Some(v);
    }

    // optional int32 given_num_hits = 4;

    pub fn given_num_hits(&self) -> i32 {
        self.given_num_hits.unwrap_or(0)
    }

    pub fn clear_given_num_hits(&mut self) {
        self.given_num_hits = ::std::option::Option::None;
    }

    pub fn has_given_num_hits(&self) -> bool {
        self.given_num_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_given_num_hits(&mut self, v: i32) {
        self.given_num_hits = ::std::option::Option::Some(v);
    }

    // optional int32 taken_kill_type = 5;

    pub fn taken_kill_type(&self) -> i32 {
        self.taken_kill_type.unwrap_or(0)
    }

    pub fn clear_taken_kill_type(&mut self) {
        self.taken_kill_type = ::std::option::Option::None;
    }

    pub fn has_taken_kill_type(&self) -> bool {
        self.taken_kill_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taken_kill_type(&mut self, v: i32) {
        self.taken_kill_type = ::std::option::Option::Some(v);
    }

    // optional int32 taken_health_removed = 6;

    pub fn taken_health_removed(&self) -> i32 {
        self.taken_health_removed.unwrap_or(0)
    }

    pub fn clear_taken_health_removed(&mut self) {
        self.taken_health_removed = ::std::option::Option::None;
    }

    pub fn has_taken_health_removed(&self) -> bool {
        self.taken_health_removed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taken_health_removed(&mut self, v: i32) {
        self.taken_health_removed = ::std::option::Option::Some(v);
    }

    // optional int32 taken_num_hits = 7;

    pub fn taken_num_hits(&self) -> i32 {
        self.taken_num_hits.unwrap_or(0)
    }

    pub fn clear_taken_num_hits(&mut self) {
        self.taken_num_hits = ::std::option::Option::None;
    }

    pub fn has_taken_num_hits(&self) -> bool {
        self.taken_num_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taken_num_hits(&mut self, v: i32) {
        self.taken_num_hits = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_xuid",
            |m: &CCSUsrMsg_PostRoundDamageReport| { &m.other_xuid },
            |m: &mut CCSUsrMsg_PostRoundDamageReport| { &mut m.other_xuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "given_kill_type",
            |m: &CCSUsrMsg_PostRoundDamageReport| { &m.given_kill_type },
            |m: &mut CCSUsrMsg_PostRoundDamageReport| { &mut m.given_kill_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "given_health_removed",
            |m: &CCSUsrMsg_PostRoundDamageReport| { &m.given_health_removed },
            |m: &mut CCSUsrMsg_PostRoundDamageReport| { &mut m.given_health_removed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "given_num_hits",
            |m: &CCSUsrMsg_PostRoundDamageReport| { &m.given_num_hits },
            |m: &mut CCSUsrMsg_PostRoundDamageReport| { &mut m.given_num_hits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "taken_kill_type",
            |m: &CCSUsrMsg_PostRoundDamageReport| { &m.taken_kill_type },
            |m: &mut CCSUsrMsg_PostRoundDamageReport| { &mut m.taken_kill_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "taken_health_removed",
            |m: &CCSUsrMsg_PostRoundDamageReport| { &m.taken_health_removed },
            |m: &mut CCSUsrMsg_PostRoundDamageReport| { &mut m.taken_health_removed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "taken_num_hits",
            |m: &CCSUsrMsg_PostRoundDamageReport| { &m.taken_num_hits },
            |m: &mut CCSUsrMsg_PostRoundDamageReport| { &mut m.taken_num_hits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_PostRoundDamageReport>(
            "CCSUsrMsg_PostRoundDamageReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_PostRoundDamageReport {
    const NAME: &'static str = "CCSUsrMsg_PostRoundDamageReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.other_xuid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.given_kill_type = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.given_health_removed = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.given_num_hits = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.taken_kill_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.taken_health_removed = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.taken_num_hits = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_xuid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.given_kill_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.given_health_removed {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.given_num_hits {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.taken_kill_type {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.taken_health_removed {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.taken_num_hits {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.other_xuid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.given_kill_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.given_health_removed {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.given_num_hits {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.taken_kill_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.taken_health_removed {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.taken_num_hits {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_PostRoundDamageReport {
        CCSUsrMsg_PostRoundDamageReport::new()
    }

    fn clear(&mut self) {
        self.other_xuid = ::std::option::Option::None;
        self.given_kill_type = ::std::option::Option::None;
        self.given_health_removed = ::std::option::Option::None;
        self.given_num_hits = ::std::option::Option::None;
        self.taken_kill_type = ::std::option::Option::None;
        self.taken_health_removed = ::std::option::Option::None;
        self.taken_num_hits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_PostRoundDamageReport {
        static instance: CCSUsrMsg_PostRoundDamageReport = CCSUsrMsg_PostRoundDamageReport {
            other_xuid: ::std::option::Option::None,
            given_kill_type: ::std::option::Option::None,
            given_health_removed: ::std::option::Option::None,
            given_num_hits: ::std::option::Option::None,
            taken_kill_type: ::std::option::Option::None,
            taken_health_removed: ::std::option::Option::None,
            taken_num_hits: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_PostRoundDamageReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_PostRoundDamageReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_PostRoundDamageReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_PostRoundDamageReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_CurrentRoundOdds)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CurrentRoundOdds {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CurrentRoundOdds.odds)
    pub odds: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CurrentRoundOdds.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CurrentRoundOdds {
    fn default() -> &'a CCSUsrMsg_CurrentRoundOdds {
        <CCSUsrMsg_CurrentRoundOdds as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CurrentRoundOdds {
    pub fn new() -> CCSUsrMsg_CurrentRoundOdds {
        ::std::default::Default::default()
    }

    // optional int32 odds = 1;

    pub fn odds(&self) -> i32 {
        self.odds.unwrap_or(0)
    }

    pub fn clear_odds(&mut self) {
        self.odds = ::std::option::Option::None;
    }

    pub fn has_odds(&self) -> bool {
        self.odds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_odds(&mut self, v: i32) {
        self.odds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "odds",
            |m: &CCSUsrMsg_CurrentRoundOdds| { &m.odds },
            |m: &mut CCSUsrMsg_CurrentRoundOdds| { &mut m.odds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_CurrentRoundOdds>(
            "CCSUsrMsg_CurrentRoundOdds",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_CurrentRoundOdds {
    const NAME: &'static str = "CCSUsrMsg_CurrentRoundOdds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.odds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.odds {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.odds {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CurrentRoundOdds {
        CCSUsrMsg_CurrentRoundOdds::new()
    }

    fn clear(&mut self) {
        self.odds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CurrentRoundOdds {
        static instance: CCSUsrMsg_CurrentRoundOdds = CCSUsrMsg_CurrentRoundOdds {
            odds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_CurrentRoundOdds {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_CurrentRoundOdds").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_CurrentRoundOdds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CurrentRoundOdds {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_DeepStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_DeepStats {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_DeepStats.stats)
    pub stats: ::protobuf::MessageField<super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_DeepStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DeepStats {
    fn default() -> &'a CCSUsrMsg_DeepStats {
        <CCSUsrMsg_DeepStats as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DeepStats {
    pub fn new() -> CCSUsrMsg_DeepStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats>(
            "stats",
            |m: &CCSUsrMsg_DeepStats| { &m.stats },
            |m: &mut CCSUsrMsg_DeepStats| { &mut m.stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_DeepStats>(
            "CCSUsrMsg_DeepStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_DeepStats {
    const NAME: &'static str = "CCSUsrMsg_DeepStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_DeepStats {
        CCSUsrMsg_DeepStats::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_DeepStats {
        static instance: CCSUsrMsg_DeepStats = CCSUsrMsg_DeepStats {
            stats: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_DeepStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_DeepStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_DeepStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DeepStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ShootInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ShootInfo {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ShootInfo.frame_number)
    pub frame_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ShootInfo.hitbox_transforms)
    pub hitbox_transforms: ::std::vec::Vec<super::networkbasetypes::CMsgTransform>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ShootInfo.shoot_pos)
    pub shoot_pos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ShootInfo.shoot_dir)
    pub shoot_dir: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ShootInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ShootInfo {
    fn default() -> &'a CCSUsrMsg_ShootInfo {
        <CCSUsrMsg_ShootInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ShootInfo {
    pub fn new() -> CCSUsrMsg_ShootInfo {
        ::std::default::Default::default()
    }

    // optional int32 frame_number = 1;

    pub fn frame_number(&self) -> i32 {
        self.frame_number.unwrap_or(0)
    }

    pub fn clear_frame_number(&mut self) {
        self.frame_number = ::std::option::Option::None;
    }

    pub fn has_frame_number(&self) -> bool {
        self.frame_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_number(&mut self, v: i32) {
        self.frame_number = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frame_number",
            |m: &CCSUsrMsg_ShootInfo| { &m.frame_number },
            |m: &mut CCSUsrMsg_ShootInfo| { &mut m.frame_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hitbox_transforms",
            |m: &CCSUsrMsg_ShootInfo| { &m.hitbox_transforms },
            |m: &mut CCSUsrMsg_ShootInfo| { &mut m.hitbox_transforms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "shoot_pos",
            |m: &CCSUsrMsg_ShootInfo| { &m.shoot_pos },
            |m: &mut CCSUsrMsg_ShootInfo| { &mut m.shoot_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "shoot_dir",
            |m: &CCSUsrMsg_ShootInfo| { &m.shoot_dir },
            |m: &mut CCSUsrMsg_ShootInfo| { &mut m.shoot_dir },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ShootInfo>(
            "CCSUsrMsg_ShootInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ShootInfo {
    const NAME: &'static str = "CCSUsrMsg_ShootInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.frame_number = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.hitbox_transforms.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shoot_pos)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shoot_dir)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_number {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.hitbox_transforms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.shoot_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shoot_dir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.frame_number {
            os.write_int32(1, v)?;
        }
        for v in &self.hitbox_transforms {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.shoot_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.shoot_dir.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ShootInfo {
        CCSUsrMsg_ShootInfo::new()
    }

    fn clear(&mut self) {
        self.frame_number = ::std::option::Option::None;
        self.hitbox_transforms.clear();
        self.shoot_pos.clear();
        self.shoot_dir.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ShootInfo {
        static instance: CCSUsrMsg_ShootInfo = CCSUsrMsg_ShootInfo {
            frame_number: ::std::option::Option::None,
            hitbox_transforms: ::std::vec::Vec::new(),
            shoot_pos: ::protobuf::MessageField::none(),
            shoot_dir: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ShootInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ShootInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ShootInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ShootInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ResetHud)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ResetHud {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ResetHud.reset)
    pub reset: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ResetHud.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ResetHud {
    fn default() -> &'a CCSUsrMsg_ResetHud {
        <CCSUsrMsg_ResetHud as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ResetHud {
    pub fn new() -> CCSUsrMsg_ResetHud {
        ::std::default::Default::default()
    }

    // optional bool reset = 1;

    pub fn reset(&self) -> bool {
        self.reset.unwrap_or(false)
    }

    pub fn clear_reset(&mut self) {
        self.reset = ::std::option::Option::None;
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: bool) {
        self.reset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reset",
            |m: &CCSUsrMsg_ResetHud| { &m.reset },
            |m: &mut CCSUsrMsg_ResetHud| { &mut m.reset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ResetHud>(
            "CCSUsrMsg_ResetHud",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ResetHud {
    const NAME: &'static str = "CCSUsrMsg_ResetHud";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reset = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reset {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reset {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ResetHud {
        CCSUsrMsg_ResetHud::new()
    }

    fn clear(&mut self) {
        self.reset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ResetHud {
        static instance: CCSUsrMsg_ResetHud = CCSUsrMsg_ResetHud {
            reset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ResetHud {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ResetHud").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ResetHud {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ResetHud {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_GameTitle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_GameTitle {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_GameTitle.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_GameTitle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_GameTitle {
    fn default() -> &'a CCSUsrMsg_GameTitle {
        <CCSUsrMsg_GameTitle as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_GameTitle {
    pub fn new() -> CCSUsrMsg_GameTitle {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CCSUsrMsg_GameTitle| { &m.dummy },
            |m: &mut CCSUsrMsg_GameTitle| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_GameTitle>(
            "CCSUsrMsg_GameTitle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_GameTitle {
    const NAME: &'static str = "CCSUsrMsg_GameTitle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_GameTitle {
        CCSUsrMsg_GameTitle::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_GameTitle {
        static instance: CCSUsrMsg_GameTitle = CCSUsrMsg_GameTitle {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_GameTitle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_GameTitle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_GameTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_GameTitle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_RequestState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_RequestState {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_RequestState.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_RequestState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RequestState {
    fn default() -> &'a CCSUsrMsg_RequestState {
        <CCSUsrMsg_RequestState as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RequestState {
    pub fn new() -> CCSUsrMsg_RequestState {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CCSUsrMsg_RequestState| { &m.dummy },
            |m: &mut CCSUsrMsg_RequestState| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_RequestState>(
            "CCSUsrMsg_RequestState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_RequestState {
    const NAME: &'static str = "CCSUsrMsg_RequestState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_RequestState {
        CCSUsrMsg_RequestState::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_RequestState {
        static instance: CCSUsrMsg_RequestState = CCSUsrMsg_RequestState {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_RequestState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_RequestState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_RequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_RequestState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_StopSpectatorMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_StopSpectatorMode {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_StopSpectatorMode.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_StopSpectatorMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_StopSpectatorMode {
    fn default() -> &'a CCSUsrMsg_StopSpectatorMode {
        <CCSUsrMsg_StopSpectatorMode as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_StopSpectatorMode {
    pub fn new() -> CCSUsrMsg_StopSpectatorMode {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CCSUsrMsg_StopSpectatorMode| { &m.dummy },
            |m: &mut CCSUsrMsg_StopSpectatorMode| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_StopSpectatorMode>(
            "CCSUsrMsg_StopSpectatorMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_StopSpectatorMode {
    const NAME: &'static str = "CCSUsrMsg_StopSpectatorMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_StopSpectatorMode {
        CCSUsrMsg_StopSpectatorMode::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_StopSpectatorMode {
        static instance: CCSUsrMsg_StopSpectatorMode = CCSUsrMsg_StopSpectatorMode {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_StopSpectatorMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_StopSpectatorMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_StopSpectatorMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_StopSpectatorMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_DisconnectToLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_DisconnectToLobby {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_DisconnectToLobby.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_DisconnectToLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DisconnectToLobby {
    fn default() -> &'a CCSUsrMsg_DisconnectToLobby {
        <CCSUsrMsg_DisconnectToLobby as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DisconnectToLobby {
    pub fn new() -> CCSUsrMsg_DisconnectToLobby {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CCSUsrMsg_DisconnectToLobby| { &m.dummy },
            |m: &mut CCSUsrMsg_DisconnectToLobby| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_DisconnectToLobby>(
            "CCSUsrMsg_DisconnectToLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_DisconnectToLobby {
    const NAME: &'static str = "CCSUsrMsg_DisconnectToLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_DisconnectToLobby {
        CCSUsrMsg_DisconnectToLobby::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_DisconnectToLobby {
        static instance: CCSUsrMsg_DisconnectToLobby = CCSUsrMsg_DisconnectToLobby {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_DisconnectToLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_DisconnectToLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_DisconnectToLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DisconnectToLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_WarmupHasEnded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_WarmupHasEnded {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_WarmupHasEnded.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_WarmupHasEnded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_WarmupHasEnded {
    fn default() -> &'a CCSUsrMsg_WarmupHasEnded {
        <CCSUsrMsg_WarmupHasEnded as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_WarmupHasEnded {
    pub fn new() -> CCSUsrMsg_WarmupHasEnded {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CCSUsrMsg_WarmupHasEnded| { &m.dummy },
            |m: &mut CCSUsrMsg_WarmupHasEnded| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_WarmupHasEnded>(
            "CCSUsrMsg_WarmupHasEnded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_WarmupHasEnded {
    const NAME: &'static str = "CCSUsrMsg_WarmupHasEnded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_WarmupHasEnded {
        CCSUsrMsg_WarmupHasEnded::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_WarmupHasEnded {
        static instance: CCSUsrMsg_WarmupHasEnded = CCSUsrMsg_WarmupHasEnded {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_WarmupHasEnded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_WarmupHasEnded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_WarmupHasEnded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_WarmupHasEnded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ClientInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ClientInfo {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ClientInfo.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ClientInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ClientInfo {
    fn default() -> &'a CCSUsrMsg_ClientInfo {
        <CCSUsrMsg_ClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ClientInfo {
    pub fn new() -> CCSUsrMsg_ClientInfo {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CCSUsrMsg_ClientInfo| { &m.dummy },
            |m: &mut CCSUsrMsg_ClientInfo| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ClientInfo>(
            "CCSUsrMsg_ClientInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ClientInfo {
    const NAME: &'static str = "CCSUsrMsg_ClientInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ClientInfo {
        CCSUsrMsg_ClientInfo::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ClientInfo {
        static instance: CCSUsrMsg_ClientInfo = CCSUsrMsg_ClientInfo {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ClientInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ClientInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ClientInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_ServerRankRevealAll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ServerRankRevealAll {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankRevealAll.seconds_till_shutdown)
    pub seconds_till_shutdown: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankRevealAll.reservation)
    pub reservation: ::protobuf::MessageField<super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ServerRankRevealAll.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ServerRankRevealAll {
    fn default() -> &'a CCSUsrMsg_ServerRankRevealAll {
        <CCSUsrMsg_ServerRankRevealAll as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ServerRankRevealAll {
    pub fn new() -> CCSUsrMsg_ServerRankRevealAll {
        ::std::default::Default::default()
    }

    // optional int32 seconds_till_shutdown = 1;

    pub fn seconds_till_shutdown(&self) -> i32 {
        self.seconds_till_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_till_shutdown(&mut self) {
        self.seconds_till_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_till_shutdown(&self) -> bool {
        self.seconds_till_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_till_shutdown(&mut self, v: i32) {
        self.seconds_till_shutdown = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_till_shutdown",
            |m: &CCSUsrMsg_ServerRankRevealAll| { &m.seconds_till_shutdown },
            |m: &mut CCSUsrMsg_ServerRankRevealAll| { &mut m.seconds_till_shutdown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "reservation",
            |m: &CCSUsrMsg_ServerRankRevealAll| { &m.reservation },
            |m: &mut CCSUsrMsg_ServerRankRevealAll| { &mut m.reservation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_ServerRankRevealAll>(
            "CCSUsrMsg_ServerRankRevealAll",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_ServerRankRevealAll {
    const NAME: &'static str = "CCSUsrMsg_ServerRankRevealAll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds_till_shutdown = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reservation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seconds_till_shutdown {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seconds_till_shutdown {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.reservation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ServerRankRevealAll {
        CCSUsrMsg_ServerRankRevealAll::new()
    }

    fn clear(&mut self) {
        self.seconds_till_shutdown = ::std::option::Option::None;
        self.reservation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ServerRankRevealAll {
        static instance: CCSUsrMsg_ServerRankRevealAll = CCSUsrMsg_ServerRankRevealAll {
            seconds_till_shutdown: ::std::option::Option::None,
            reservation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_ServerRankRevealAll {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_ServerRankRevealAll").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_ServerRankRevealAll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_ServerRankRevealAll {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsgPreMatchSayText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsgPreMatchSayText {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsgPreMatchSayText.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsgPreMatchSayText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsgPreMatchSayText.all_chat)
    pub all_chat: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsgPreMatchSayText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsgPreMatchSayText {
    fn default() -> &'a CCSUsrMsgPreMatchSayText {
        <CCSUsrMsgPreMatchSayText as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsgPreMatchSayText {
    pub fn new() -> CCSUsrMsgPreMatchSayText {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool all_chat = 3;

    pub fn all_chat(&self) -> bool {
        self.all_chat.unwrap_or(false)
    }

    pub fn clear_all_chat(&mut self) {
        self.all_chat = ::std::option::Option::None;
    }

    pub fn has_all_chat(&self) -> bool {
        self.all_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_chat(&mut self, v: bool) {
        self.all_chat = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CCSUsrMsgPreMatchSayText| { &m.account_id },
            |m: &mut CCSUsrMsgPreMatchSayText| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CCSUsrMsgPreMatchSayText| { &m.text },
            |m: &mut CCSUsrMsgPreMatchSayText| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "all_chat",
            |m: &CCSUsrMsgPreMatchSayText| { &m.all_chat },
            |m: &mut CCSUsrMsgPreMatchSayText| { &mut m.all_chat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsgPreMatchSayText>(
            "CCSUsrMsgPreMatchSayText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsgPreMatchSayText {
    const NAME: &'static str = "CCSUsrMsgPreMatchSayText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.all_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.all_chat {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.all_chat {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsgPreMatchSayText {
        CCSUsrMsgPreMatchSayText::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.all_chat = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsgPreMatchSayText {
        static instance: CCSUsrMsgPreMatchSayText = CCSUsrMsgPreMatchSayText {
            account_id: ::std::option::Option::None,
            text: ::std::option::Option::None,
            all_chat: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsgPreMatchSayText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsgPreMatchSayText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsgPreMatchSayText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsgPreMatchSayText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_CounterStrafe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CounterStrafe {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CounterStrafe.press_to_release_ns)
    pub press_to_release_ns: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CounterStrafe.total_keys_down)
    pub total_keys_down: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CounterStrafe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CounterStrafe {
    fn default() -> &'a CCSUsrMsg_CounterStrafe {
        <CCSUsrMsg_CounterStrafe as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CounterStrafe {
    pub fn new() -> CCSUsrMsg_CounterStrafe {
        ::std::default::Default::default()
    }

    // optional int32 press_to_release_ns = 1;

    pub fn press_to_release_ns(&self) -> i32 {
        self.press_to_release_ns.unwrap_or(0)
    }

    pub fn clear_press_to_release_ns(&mut self) {
        self.press_to_release_ns = ::std::option::Option::None;
    }

    pub fn has_press_to_release_ns(&self) -> bool {
        self.press_to_release_ns.is_some()
    }

    // Param is passed by value, moved
    pub fn set_press_to_release_ns(&mut self, v: i32) {
        self.press_to_release_ns = ::std::option::Option::Some(v);
    }

    // optional int32 total_keys_down = 2;

    pub fn total_keys_down(&self) -> i32 {
        self.total_keys_down.unwrap_or(0)
    }

    pub fn clear_total_keys_down(&mut self) {
        self.total_keys_down = ::std::option::Option::None;
    }

    pub fn has_total_keys_down(&self) -> bool {
        self.total_keys_down.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_keys_down(&mut self, v: i32) {
        self.total_keys_down = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "press_to_release_ns",
            |m: &CCSUsrMsg_CounterStrafe| { &m.press_to_release_ns },
            |m: &mut CCSUsrMsg_CounterStrafe| { &mut m.press_to_release_ns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_keys_down",
            |m: &CCSUsrMsg_CounterStrafe| { &m.total_keys_down },
            |m: &mut CCSUsrMsg_CounterStrafe| { &mut m.total_keys_down },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_CounterStrafe>(
            "CCSUsrMsg_CounterStrafe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_CounterStrafe {
    const NAME: &'static str = "CCSUsrMsg_CounterStrafe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.press_to_release_ns = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.total_keys_down = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.press_to_release_ns {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.total_keys_down {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.press_to_release_ns {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.total_keys_down {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CounterStrafe {
        CCSUsrMsg_CounterStrafe::new()
    }

    fn clear(&mut self) {
        self.press_to_release_ns = ::std::option::Option::None;
        self.total_keys_down = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CounterStrafe {
        static instance: CCSUsrMsg_CounterStrafe = CCSUsrMsg_CounterStrafe {
            press_to_release_ns: ::std::option::Option::None,
            total_keys_down: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_CounterStrafe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_CounterStrafe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_CounterStrafe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_CounterStrafe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCSUsrMsg_DamagePrediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_DamagePrediction {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_DamagePrediction.command_num)
    pub command_num: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DamagePrediction.pellet_idx)
    pub pellet_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DamagePrediction.victim_slot)
    pub victim_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DamagePrediction.victim_starting_health)
    pub victim_starting_health: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DamagePrediction.victim_damage)
    pub victim_damage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DamagePrediction.shoot_pos)
    pub shoot_pos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DamagePrediction.shoot_dir)
    pub shoot_dir: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DamagePrediction.aim_punch)
    pub aim_punch: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_DamagePrediction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DamagePrediction {
    fn default() -> &'a CCSUsrMsg_DamagePrediction {
        <CCSUsrMsg_DamagePrediction as ::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DamagePrediction {
    pub fn new() -> CCSUsrMsg_DamagePrediction {
        ::std::default::Default::default()
    }

    // optional int32 command_num = 1;

    pub fn command_num(&self) -> i32 {
        self.command_num.unwrap_or(0)
    }

    pub fn clear_command_num(&mut self) {
        self.command_num = ::std::option::Option::None;
    }

    pub fn has_command_num(&self) -> bool {
        self.command_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command_num(&mut self, v: i32) {
        self.command_num = ::std::option::Option::Some(v);
    }

    // optional int32 pellet_idx = 2;

    pub fn pellet_idx(&self) -> i32 {
        self.pellet_idx.unwrap_or(0)
    }

    pub fn clear_pellet_idx(&mut self) {
        self.pellet_idx = ::std::option::Option::None;
    }

    pub fn has_pellet_idx(&self) -> bool {
        self.pellet_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pellet_idx(&mut self, v: i32) {
        self.pellet_idx = ::std::option::Option::Some(v);
    }

    // optional int32 victim_slot = 3;

    pub fn victim_slot(&self) -> i32 {
        self.victim_slot.unwrap_or(0)
    }

    pub fn clear_victim_slot(&mut self) {
        self.victim_slot = ::std::option::Option::None;
    }

    pub fn has_victim_slot(&self) -> bool {
        self.victim_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_slot(&mut self, v: i32) {
        self.victim_slot = ::std::option::Option::Some(v);
    }

    // optional int32 victim_starting_health = 4;

    pub fn victim_starting_health(&self) -> i32 {
        self.victim_starting_health.unwrap_or(0)
    }

    pub fn clear_victim_starting_health(&mut self) {
        self.victim_starting_health = ::std::option::Option::None;
    }

    pub fn has_victim_starting_health(&self) -> bool {
        self.victim_starting_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_starting_health(&mut self, v: i32) {
        self.victim_starting_health = ::std::option::Option::Some(v);
    }

    // optional int32 victim_damage = 5;

    pub fn victim_damage(&self) -> i32 {
        self.victim_damage.unwrap_or(0)
    }

    pub fn clear_victim_damage(&mut self) {
        self.victim_damage = ::std::option::Option::None;
    }

    pub fn has_victim_damage(&self) -> bool {
        self.victim_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_damage(&mut self, v: i32) {
        self.victim_damage = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command_num",
            |m: &CCSUsrMsg_DamagePrediction| { &m.command_num },
            |m: &mut CCSUsrMsg_DamagePrediction| { &mut m.command_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pellet_idx",
            |m: &CCSUsrMsg_DamagePrediction| { &m.pellet_idx },
            |m: &mut CCSUsrMsg_DamagePrediction| { &mut m.pellet_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_slot",
            |m: &CCSUsrMsg_DamagePrediction| { &m.victim_slot },
            |m: &mut CCSUsrMsg_DamagePrediction| { &mut m.victim_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_starting_health",
            |m: &CCSUsrMsg_DamagePrediction| { &m.victim_starting_health },
            |m: &mut CCSUsrMsg_DamagePrediction| { &mut m.victim_starting_health },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_damage",
            |m: &CCSUsrMsg_DamagePrediction| { &m.victim_damage },
            |m: &mut CCSUsrMsg_DamagePrediction| { &mut m.victim_damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "shoot_pos",
            |m: &CCSUsrMsg_DamagePrediction| { &m.shoot_pos },
            |m: &mut CCSUsrMsg_DamagePrediction| { &mut m.shoot_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "shoot_dir",
            |m: &CCSUsrMsg_DamagePrediction| { &m.shoot_dir },
            |m: &mut CCSUsrMsg_DamagePrediction| { &mut m.shoot_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "aim_punch",
            |m: &CCSUsrMsg_DamagePrediction| { &m.aim_punch },
            |m: &mut CCSUsrMsg_DamagePrediction| { &mut m.aim_punch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCSUsrMsg_DamagePrediction>(
            "CCSUsrMsg_DamagePrediction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCSUsrMsg_DamagePrediction {
    const NAME: &'static str = "CCSUsrMsg_DamagePrediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.command_num = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.pellet_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.victim_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.victim_starting_health = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.victim_damage = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shoot_pos)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shoot_dir)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.aim_punch)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command_num {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pellet_idx {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.victim_slot {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.victim_starting_health {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.victim_damage {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.shoot_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shoot_dir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.aim_punch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command_num {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pellet_idx {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.victim_slot {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.victim_starting_health {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.victim_damage {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.shoot_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.shoot_dir.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.aim_punch.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_DamagePrediction {
        CCSUsrMsg_DamagePrediction::new()
    }

    fn clear(&mut self) {
        self.command_num = ::std::option::Option::None;
        self.pellet_idx = ::std::option::Option::None;
        self.victim_slot = ::std::option::Option::None;
        self.victim_starting_health = ::std::option::Option::None;
        self.victim_damage = ::std::option::Option::None;
        self.shoot_pos.clear();
        self.shoot_dir.clear();
        self.aim_punch.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_DamagePrediction {
        static instance: CCSUsrMsg_DamagePrediction = CCSUsrMsg_DamagePrediction {
            command_num: ::std::option::Option::None,
            pellet_idx: ::std::option::Option::None,
            victim_slot: ::std::option::Option::None,
            victim_starting_health: ::std::option::Option::None,
            victim_damage: ::std::option::Option::None,
            shoot_pos: ::protobuf::MessageField::none(),
            shoot_dir: ::protobuf::MessageField::none(),
            aim_punch: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCSUsrMsg_DamagePrediction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCSUsrMsg_DamagePrediction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCSUsrMsg_DamagePrediction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCSUsrMsg_DamagePrediction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECstrike15UserMessages)
pub enum ECstrike15UserMessages {
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VGUIMenu)
    CS_UM_VGUIMenu = 301,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Geiger)
    CS_UM_Geiger = 302,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Train)
    CS_UM_Train = 303,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_HudText)
    CS_UM_HudText = 304,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SayText)
    CS_UM_SayText = 305,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SayText2)
    CS_UM_SayText2 = 306,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_TextMsg)
    CS_UM_TextMsg = 307,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_HudMsg)
    CS_UM_HudMsg = 308,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ResetHud)
    CS_UM_ResetHud = 309,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_GameTitle)
    CS_UM_GameTitle = 310,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Shake)
    CS_UM_Shake = 312,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Fade)
    CS_UM_Fade = 313,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Rumble)
    CS_UM_Rumble = 314,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CloseCaption)
    CS_UM_CloseCaption = 315,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CloseCaptionDirect)
    CS_UM_CloseCaptionDirect = 316,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SendAudio)
    CS_UM_SendAudio = 317,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_RawAudio)
    CS_UM_RawAudio = 318,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VoiceMask)
    CS_UM_VoiceMask = 319,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_RequestState)
    CS_UM_RequestState = 320,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Damage)
    CS_UM_Damage = 321,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_RadioText)
    CS_UM_RadioText = 322,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_HintText)
    CS_UM_HintText = 323,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_KeyHintText)
    CS_UM_KeyHintText = 324,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ProcessSpottedEntityUpdate)
    CS_UM_ProcessSpottedEntityUpdate = 325,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ReloadEffect)
    CS_UM_ReloadEffect = 326,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_AdjustMoney)
    CS_UM_AdjustMoney = 327,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_UpdateTeamMoney)
    CS_UM_UpdateTeamMoney = 328,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_StopSpectatorMode)
    CS_UM_StopSpectatorMode = 329,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_KillCam)
    CS_UM_KillCam = 330,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_DesiredTimescale)
    CS_UM_DesiredTimescale = 331,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CurrentTimescale)
    CS_UM_CurrentTimescale = 332,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_AchievementEvent)
    CS_UM_AchievementEvent = 333,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_MatchEndConditions)
    CS_UM_MatchEndConditions = 334,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_DisconnectToLobby)
    CS_UM_DisconnectToLobby = 335,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_PlayerStatsUpdate)
    CS_UM_PlayerStatsUpdate = 336,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_WarmupHasEnded)
    CS_UM_WarmupHasEnded = 338,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ClientInfo)
    CS_UM_ClientInfo = 339,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_XRankGet)
    CS_UM_XRankGet = 340,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_XRankUpd)
    CS_UM_XRankUpd = 341,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CallVoteFailed)
    CS_UM_CallVoteFailed = 345,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VoteStart)
    CS_UM_VoteStart = 346,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VotePass)
    CS_UM_VotePass = 347,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VoteFailed)
    CS_UM_VoteFailed = 348,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VoteSetup)
    CS_UM_VoteSetup = 349,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ServerRankRevealAll)
    CS_UM_ServerRankRevealAll = 350,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SendLastKillerDamageToClient)
    CS_UM_SendLastKillerDamageToClient = 351,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ServerRankUpdate)
    CS_UM_ServerRankUpdate = 352,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ItemPickup)
    CS_UM_ItemPickup = 353,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ShowMenu)
    CS_UM_ShowMenu = 354,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_BarTime)
    CS_UM_BarTime = 355,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_AmmoDenied)
    CS_UM_AmmoDenied = 356,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_MarkAchievement)
    CS_UM_MarkAchievement = 357,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_MatchStatsUpdate)
    CS_UM_MatchStatsUpdate = 358,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ItemDrop)
    CS_UM_ItemDrop = 359,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_GlowPropTurnOff)
    CS_UM_GlowPropTurnOff = 360,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SendPlayerItemDrops)
    CS_UM_SendPlayerItemDrops = 361,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_RoundBackupFilenames)
    CS_UM_RoundBackupFilenames = 362,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SendPlayerItemFound)
    CS_UM_SendPlayerItemFound = 363,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ReportHit)
    CS_UM_ReportHit = 364,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_XpUpdate)
    CS_UM_XpUpdate = 365,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_QuestProgress)
    CS_UM_QuestProgress = 366,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ScoreLeaderboardData)
    CS_UM_ScoreLeaderboardData = 367,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_PlayerDecalDigitalSignature)
    CS_UM_PlayerDecalDigitalSignature = 368,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_WeaponSound)
    CS_UM_WeaponSound = 369,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_UpdateScreenHealthBar)
    CS_UM_UpdateScreenHealthBar = 370,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_EntityOutlineHighlight)
    CS_UM_EntityOutlineHighlight = 371,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SSUI)
    CS_UM_SSUI = 372,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SurvivalStats)
    CS_UM_SurvivalStats = 373,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_DisconnectToLobby2)
    CS_UM_DisconnectToLobby2 = 374,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_EndOfMatchAllPlayersData)
    CS_UM_EndOfMatchAllPlayersData = 375,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_PostRoundDamageReport)
    CS_UM_PostRoundDamageReport = 376,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_RoundEndReportData)
    CS_UM_RoundEndReportData = 379,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CurrentRoundOdds)
    CS_UM_CurrentRoundOdds = 380,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_DeepStats)
    CS_UM_DeepStats = 381,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ShootInfo)
    CS_UM_ShootInfo = 383,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CounterStrafe)
    CS_UM_CounterStrafe = 385,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_DamagePrediction)
    CS_UM_DamagePrediction = 386,
}

impl ::protobuf::Enum for ECstrike15UserMessages {
    const NAME: &'static str = "ECstrike15UserMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECstrike15UserMessages> {
        match value {
            301 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VGUIMenu),
            302 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Geiger),
            303 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Train),
            304 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudText),
            305 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText),
            306 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText2),
            307 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_TextMsg),
            308 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudMsg),
            309 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ResetHud),
            310 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GameTitle),
            312 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Shake),
            313 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Fade),
            314 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Rumble),
            315 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaption),
            316 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaptionDirect),
            317 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendAudio),
            318 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RawAudio),
            319 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoiceMask),
            320 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RequestState),
            321 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Damage),
            322 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RadioText),
            323 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HintText),
            324 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KeyHintText),
            325 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate),
            326 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReloadEffect),
            327 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AdjustMoney),
            328 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateTeamMoney),
            329 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_StopSpectatorMode),
            330 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KillCam),
            331 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DesiredTimescale),
            332 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentTimescale),
            333 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AchievementEvent),
            334 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchEndConditions),
            335 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby),
            336 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerStatsUpdate),
            338 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WarmupHasEnded),
            339 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ClientInfo),
            340 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankGet),
            341 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankUpd),
            345 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CallVoteFailed),
            346 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteStart),
            347 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VotePass),
            348 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteFailed),
            349 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteSetup),
            350 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankRevealAll),
            351 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient),
            352 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankUpdate),
            353 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemPickup),
            354 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ShowMenu),
            355 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_BarTime),
            356 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AmmoDenied),
            357 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MarkAchievement),
            358 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchStatsUpdate),
            359 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemDrop),
            360 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GlowPropTurnOff),
            361 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemDrops),
            362 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundBackupFilenames),
            363 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemFound),
            364 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReportHit),
            365 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XpUpdate),
            366 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_QuestProgress),
            367 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ScoreLeaderboardData),
            368 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature),
            369 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WeaponSound),
            370 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar),
            371 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EntityOutlineHighlight),
            372 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SSUI),
            373 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SurvivalStats),
            374 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby2),
            375 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EndOfMatchAllPlayersData),
            376 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PostRoundDamageReport),
            379 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundEndReportData),
            380 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentRoundOdds),
            381 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DeepStats),
            383 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ShootInfo),
            385 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CounterStrafe),
            386 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DamagePrediction),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECstrike15UserMessages> {
        match str {
            "CS_UM_VGUIMenu" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VGUIMenu),
            "CS_UM_Geiger" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Geiger),
            "CS_UM_Train" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Train),
            "CS_UM_HudText" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudText),
            "CS_UM_SayText" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText),
            "CS_UM_SayText2" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText2),
            "CS_UM_TextMsg" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_TextMsg),
            "CS_UM_HudMsg" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudMsg),
            "CS_UM_ResetHud" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ResetHud),
            "CS_UM_GameTitle" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GameTitle),
            "CS_UM_Shake" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Shake),
            "CS_UM_Fade" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Fade),
            "CS_UM_Rumble" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Rumble),
            "CS_UM_CloseCaption" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaption),
            "CS_UM_CloseCaptionDirect" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaptionDirect),
            "CS_UM_SendAudio" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendAudio),
            "CS_UM_RawAudio" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RawAudio),
            "CS_UM_VoiceMask" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoiceMask),
            "CS_UM_RequestState" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RequestState),
            "CS_UM_Damage" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Damage),
            "CS_UM_RadioText" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RadioText),
            "CS_UM_HintText" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HintText),
            "CS_UM_KeyHintText" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KeyHintText),
            "CS_UM_ProcessSpottedEntityUpdate" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate),
            "CS_UM_ReloadEffect" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReloadEffect),
            "CS_UM_AdjustMoney" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AdjustMoney),
            "CS_UM_UpdateTeamMoney" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateTeamMoney),
            "CS_UM_StopSpectatorMode" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_StopSpectatorMode),
            "CS_UM_KillCam" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KillCam),
            "CS_UM_DesiredTimescale" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DesiredTimescale),
            "CS_UM_CurrentTimescale" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentTimescale),
            "CS_UM_AchievementEvent" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AchievementEvent),
            "CS_UM_MatchEndConditions" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchEndConditions),
            "CS_UM_DisconnectToLobby" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby),
            "CS_UM_PlayerStatsUpdate" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerStatsUpdate),
            "CS_UM_WarmupHasEnded" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WarmupHasEnded),
            "CS_UM_ClientInfo" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ClientInfo),
            "CS_UM_XRankGet" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankGet),
            "CS_UM_XRankUpd" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankUpd),
            "CS_UM_CallVoteFailed" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CallVoteFailed),
            "CS_UM_VoteStart" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteStart),
            "CS_UM_VotePass" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VotePass),
            "CS_UM_VoteFailed" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteFailed),
            "CS_UM_VoteSetup" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteSetup),
            "CS_UM_ServerRankRevealAll" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankRevealAll),
            "CS_UM_SendLastKillerDamageToClient" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient),
            "CS_UM_ServerRankUpdate" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankUpdate),
            "CS_UM_ItemPickup" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemPickup),
            "CS_UM_ShowMenu" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ShowMenu),
            "CS_UM_BarTime" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_BarTime),
            "CS_UM_AmmoDenied" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AmmoDenied),
            "CS_UM_MarkAchievement" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MarkAchievement),
            "CS_UM_MatchStatsUpdate" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchStatsUpdate),
            "CS_UM_ItemDrop" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemDrop),
            "CS_UM_GlowPropTurnOff" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GlowPropTurnOff),
            "CS_UM_SendPlayerItemDrops" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemDrops),
            "CS_UM_RoundBackupFilenames" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundBackupFilenames),
            "CS_UM_SendPlayerItemFound" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemFound),
            "CS_UM_ReportHit" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReportHit),
            "CS_UM_XpUpdate" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XpUpdate),
            "CS_UM_QuestProgress" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_QuestProgress),
            "CS_UM_ScoreLeaderboardData" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ScoreLeaderboardData),
            "CS_UM_PlayerDecalDigitalSignature" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature),
            "CS_UM_WeaponSound" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WeaponSound),
            "CS_UM_UpdateScreenHealthBar" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar),
            "CS_UM_EntityOutlineHighlight" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EntityOutlineHighlight),
            "CS_UM_SSUI" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SSUI),
            "CS_UM_SurvivalStats" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SurvivalStats),
            "CS_UM_DisconnectToLobby2" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby2),
            "CS_UM_EndOfMatchAllPlayersData" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EndOfMatchAllPlayersData),
            "CS_UM_PostRoundDamageReport" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PostRoundDamageReport),
            "CS_UM_RoundEndReportData" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundEndReportData),
            "CS_UM_CurrentRoundOdds" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentRoundOdds),
            "CS_UM_DeepStats" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DeepStats),
            "CS_UM_ShootInfo" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ShootInfo),
            "CS_UM_CounterStrafe" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CounterStrafe),
            "CS_UM_DamagePrediction" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DamagePrediction),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECstrike15UserMessages] = &[
        ECstrike15UserMessages::CS_UM_VGUIMenu,
        ECstrike15UserMessages::CS_UM_Geiger,
        ECstrike15UserMessages::CS_UM_Train,
        ECstrike15UserMessages::CS_UM_HudText,
        ECstrike15UserMessages::CS_UM_SayText,
        ECstrike15UserMessages::CS_UM_SayText2,
        ECstrike15UserMessages::CS_UM_TextMsg,
        ECstrike15UserMessages::CS_UM_HudMsg,
        ECstrike15UserMessages::CS_UM_ResetHud,
        ECstrike15UserMessages::CS_UM_GameTitle,
        ECstrike15UserMessages::CS_UM_Shake,
        ECstrike15UserMessages::CS_UM_Fade,
        ECstrike15UserMessages::CS_UM_Rumble,
        ECstrike15UserMessages::CS_UM_CloseCaption,
        ECstrike15UserMessages::CS_UM_CloseCaptionDirect,
        ECstrike15UserMessages::CS_UM_SendAudio,
        ECstrike15UserMessages::CS_UM_RawAudio,
        ECstrike15UserMessages::CS_UM_VoiceMask,
        ECstrike15UserMessages::CS_UM_RequestState,
        ECstrike15UserMessages::CS_UM_Damage,
        ECstrike15UserMessages::CS_UM_RadioText,
        ECstrike15UserMessages::CS_UM_HintText,
        ECstrike15UserMessages::CS_UM_KeyHintText,
        ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate,
        ECstrike15UserMessages::CS_UM_ReloadEffect,
        ECstrike15UserMessages::CS_UM_AdjustMoney,
        ECstrike15UserMessages::CS_UM_UpdateTeamMoney,
        ECstrike15UserMessages::CS_UM_StopSpectatorMode,
        ECstrike15UserMessages::CS_UM_KillCam,
        ECstrike15UserMessages::CS_UM_DesiredTimescale,
        ECstrike15UserMessages::CS_UM_CurrentTimescale,
        ECstrike15UserMessages::CS_UM_AchievementEvent,
        ECstrike15UserMessages::CS_UM_MatchEndConditions,
        ECstrike15UserMessages::CS_UM_DisconnectToLobby,
        ECstrike15UserMessages::CS_UM_PlayerStatsUpdate,
        ECstrike15UserMessages::CS_UM_WarmupHasEnded,
        ECstrike15UserMessages::CS_UM_ClientInfo,
        ECstrike15UserMessages::CS_UM_XRankGet,
        ECstrike15UserMessages::CS_UM_XRankUpd,
        ECstrike15UserMessages::CS_UM_CallVoteFailed,
        ECstrike15UserMessages::CS_UM_VoteStart,
        ECstrike15UserMessages::CS_UM_VotePass,
        ECstrike15UserMessages::CS_UM_VoteFailed,
        ECstrike15UserMessages::CS_UM_VoteSetup,
        ECstrike15UserMessages::CS_UM_ServerRankRevealAll,
        ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient,
        ECstrike15UserMessages::CS_UM_ServerRankUpdate,
        ECstrike15UserMessages::CS_UM_ItemPickup,
        ECstrike15UserMessages::CS_UM_ShowMenu,
        ECstrike15UserMessages::CS_UM_BarTime,
        ECstrike15UserMessages::CS_UM_AmmoDenied,
        ECstrike15UserMessages::CS_UM_MarkAchievement,
        ECstrike15UserMessages::CS_UM_MatchStatsUpdate,
        ECstrike15UserMessages::CS_UM_ItemDrop,
        ECstrike15UserMessages::CS_UM_GlowPropTurnOff,
        ECstrike15UserMessages::CS_UM_SendPlayerItemDrops,
        ECstrike15UserMessages::CS_UM_RoundBackupFilenames,
        ECstrike15UserMessages::CS_UM_SendPlayerItemFound,
        ECstrike15UserMessages::CS_UM_ReportHit,
        ECstrike15UserMessages::CS_UM_XpUpdate,
        ECstrike15UserMessages::CS_UM_QuestProgress,
        ECstrike15UserMessages::CS_UM_ScoreLeaderboardData,
        ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature,
        ECstrike15UserMessages::CS_UM_WeaponSound,
        ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar,
        ECstrike15UserMessages::CS_UM_EntityOutlineHighlight,
        ECstrike15UserMessages::CS_UM_SSUI,
        ECstrike15UserMessages::CS_UM_SurvivalStats,
        ECstrike15UserMessages::CS_UM_DisconnectToLobby2,
        ECstrike15UserMessages::CS_UM_EndOfMatchAllPlayersData,
        ECstrike15UserMessages::CS_UM_PostRoundDamageReport,
        ECstrike15UserMessages::CS_UM_RoundEndReportData,
        ECstrike15UserMessages::CS_UM_CurrentRoundOdds,
        ECstrike15UserMessages::CS_UM_DeepStats,
        ECstrike15UserMessages::CS_UM_ShootInfo,
        ECstrike15UserMessages::CS_UM_CounterStrafe,
        ECstrike15UserMessages::CS_UM_DamagePrediction,
    ];
}

impl ::protobuf::EnumFull for ECstrike15UserMessages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECstrike15UserMessages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ECstrike15UserMessages::CS_UM_VGUIMenu => 0,
            ECstrike15UserMessages::CS_UM_Geiger => 1,
            ECstrike15UserMessages::CS_UM_Train => 2,
            ECstrike15UserMessages::CS_UM_HudText => 3,
            ECstrike15UserMessages::CS_UM_SayText => 4,
            ECstrike15UserMessages::CS_UM_SayText2 => 5,
            ECstrike15UserMessages::CS_UM_TextMsg => 6,
            ECstrike15UserMessages::CS_UM_HudMsg => 7,
            ECstrike15UserMessages::CS_UM_ResetHud => 8,
            ECstrike15UserMessages::CS_UM_GameTitle => 9,
            ECstrike15UserMessages::CS_UM_Shake => 10,
            ECstrike15UserMessages::CS_UM_Fade => 11,
            ECstrike15UserMessages::CS_UM_Rumble => 12,
            ECstrike15UserMessages::CS_UM_CloseCaption => 13,
            ECstrike15UserMessages::CS_UM_CloseCaptionDirect => 14,
            ECstrike15UserMessages::CS_UM_SendAudio => 15,
            ECstrike15UserMessages::CS_UM_RawAudio => 16,
            ECstrike15UserMessages::CS_UM_VoiceMask => 17,
            ECstrike15UserMessages::CS_UM_RequestState => 18,
            ECstrike15UserMessages::CS_UM_Damage => 19,
            ECstrike15UserMessages::CS_UM_RadioText => 20,
            ECstrike15UserMessages::CS_UM_HintText => 21,
            ECstrike15UserMessages::CS_UM_KeyHintText => 22,
            ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate => 23,
            ECstrike15UserMessages::CS_UM_ReloadEffect => 24,
            ECstrike15UserMessages::CS_UM_AdjustMoney => 25,
            ECstrike15UserMessages::CS_UM_UpdateTeamMoney => 26,
            ECstrike15UserMessages::CS_UM_StopSpectatorMode => 27,
            ECstrike15UserMessages::CS_UM_KillCam => 28,
            ECstrike15UserMessages::CS_UM_DesiredTimescale => 29,
            ECstrike15UserMessages::CS_UM_CurrentTimescale => 30,
            ECstrike15UserMessages::CS_UM_AchievementEvent => 31,
            ECstrike15UserMessages::CS_UM_MatchEndConditions => 32,
            ECstrike15UserMessages::CS_UM_DisconnectToLobby => 33,
            ECstrike15UserMessages::CS_UM_PlayerStatsUpdate => 34,
            ECstrike15UserMessages::CS_UM_WarmupHasEnded => 35,
            ECstrike15UserMessages::CS_UM_ClientInfo => 36,
            ECstrike15UserMessages::CS_UM_XRankGet => 37,
            ECstrike15UserMessages::CS_UM_XRankUpd => 38,
            ECstrike15UserMessages::CS_UM_CallVoteFailed => 39,
            ECstrike15UserMessages::CS_UM_VoteStart => 40,
            ECstrike15UserMessages::CS_UM_VotePass => 41,
            ECstrike15UserMessages::CS_UM_VoteFailed => 42,
            ECstrike15UserMessages::CS_UM_VoteSetup => 43,
            ECstrike15UserMessages::CS_UM_ServerRankRevealAll => 44,
            ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient => 45,
            ECstrike15UserMessages::CS_UM_ServerRankUpdate => 46,
            ECstrike15UserMessages::CS_UM_ItemPickup => 47,
            ECstrike15UserMessages::CS_UM_ShowMenu => 48,
            ECstrike15UserMessages::CS_UM_BarTime => 49,
            ECstrike15UserMessages::CS_UM_AmmoDenied => 50,
            ECstrike15UserMessages::CS_UM_MarkAchievement => 51,
            ECstrike15UserMessages::CS_UM_MatchStatsUpdate => 52,
            ECstrike15UserMessages::CS_UM_ItemDrop => 53,
            ECstrike15UserMessages::CS_UM_GlowPropTurnOff => 54,
            ECstrike15UserMessages::CS_UM_SendPlayerItemDrops => 55,
            ECstrike15UserMessages::CS_UM_RoundBackupFilenames => 56,
            ECstrike15UserMessages::CS_UM_SendPlayerItemFound => 57,
            ECstrike15UserMessages::CS_UM_ReportHit => 58,
            ECstrike15UserMessages::CS_UM_XpUpdate => 59,
            ECstrike15UserMessages::CS_UM_QuestProgress => 60,
            ECstrike15UserMessages::CS_UM_ScoreLeaderboardData => 61,
            ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature => 62,
            ECstrike15UserMessages::CS_UM_WeaponSound => 63,
            ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar => 64,
            ECstrike15UserMessages::CS_UM_EntityOutlineHighlight => 65,
            ECstrike15UserMessages::CS_UM_SSUI => 66,
            ECstrike15UserMessages::CS_UM_SurvivalStats => 67,
            ECstrike15UserMessages::CS_UM_DisconnectToLobby2 => 68,
            ECstrike15UserMessages::CS_UM_EndOfMatchAllPlayersData => 69,
            ECstrike15UserMessages::CS_UM_PostRoundDamageReport => 70,
            ECstrike15UserMessages::CS_UM_RoundEndReportData => 71,
            ECstrike15UserMessages::CS_UM_CurrentRoundOdds => 72,
            ECstrike15UserMessages::CS_UM_DeepStats => 73,
            ECstrike15UserMessages::CS_UM_ShootInfo => 74,
            ECstrike15UserMessages::CS_UM_CounterStrafe => 75,
            ECstrike15UserMessages::CS_UM_DamagePrediction => 76,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ECstrike15UserMessages {
    fn default() -> Self {
        ECstrike15UserMessages::CS_UM_VGUIMenu
    }
}

impl ECstrike15UserMessages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECstrike15UserMessages>("ECstrike15UserMessages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECSUsrMsg_DisconnectToLobby_Action)
pub enum ECSUsrMsg_DisconnectToLobby_Action {
    // @@protoc_insertion_point(enum_value:ECSUsrMsg_DisconnectToLobby_Action.k_ECSUsrMsg_DisconnectToLobby_Action_Default)
    k_ECSUsrMsg_DisconnectToLobby_Action_Default = 0,
    // @@protoc_insertion_point(enum_value:ECSUsrMsg_DisconnectToLobby_Action.k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue)
    k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue = 1,
}

impl ::protobuf::Enum for ECSUsrMsg_DisconnectToLobby_Action {
    const NAME: &'static str = "ECSUsrMsg_DisconnectToLobby_Action";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECSUsrMsg_DisconnectToLobby_Action> {
        match value {
            0 => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default),
            1 => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECSUsrMsg_DisconnectToLobby_Action> {
        match str {
            "k_ECSUsrMsg_DisconnectToLobby_Action_Default" => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default),
            "k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue" => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECSUsrMsg_DisconnectToLobby_Action] = &[
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default,
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue,
    ];
}

impl ::protobuf::EnumFull for ECSUsrMsg_DisconnectToLobby_Action {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECSUsrMsg_DisconnectToLobby_Action").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECSUsrMsg_DisconnectToLobby_Action {
    fn default() -> Self {
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default
    }
}

impl ECSUsrMsg_DisconnectToLobby_Action {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECSUsrMsg_DisconnectToLobby_Action>("ECSUsrMsg_DisconnectToLobby_Action")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1ccstrike15_usermessages.proto\x1a\x16networkbasetypes.proto\x1a\x1a\
    cstrike15_gcmessages.proto\"\x9c\x01\n\x12CCSUsrMsg_VGUIMenu\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04show\x18\x02\x20\x01(\
    \x08R\x04show\x12,\n\x04keys\x18\x03\x20\x03(\x0b2\x18.CCSUsrMsg_VGUIMen\
    u.KeysR\x04keys\x1a0\n\x04Keys\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"(\n\x10CCSUsrMsg_G\
    eiger\x12\x14\n\x05range\x18\x01\x20\x01(\x05R\x05range\"'\n\x0fCCSUsrMs\
    g_Train\x12\x14\n\x05train\x18\x01\x20\x01(\x05R\x05train\"'\n\x11CCSUsr\
    Msg_HudText\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"\xb3\x02\n\
    \x10CCSUsrMsg_HudMsg\x12\x18\n\x07channel\x18\x01\x20\x01(\x05R\x07chann\
    el\x12\x1f\n\x03pos\x18\x02\x20\x01(\x0b2\r.CMsgVector2DR\x03pos\x12\x1d\
    \n\x04clr1\x18\x03\x20\x01(\x0b2\t.CMsgRGBAR\x04clr1\x12\x1d\n\x04clr2\
    \x18\x04\x20\x01(\x0b2\t.CMsgRGBAR\x04clr2\x12\x16\n\x06effect\x18\x05\
    \x20\x01(\x05R\x06effect\x12\x20\n\x0cfade_in_time\x18\x06\x20\x01(\x02R\
    \nfadeInTime\x12\"\n\rfade_out_time\x18\x07\x20\x01(\x02R\x0bfadeOutTime\
    \x12\x1b\n\thold_time\x18\t\x20\x01(\x02R\x08holdTime\x12\x17\n\x07fx_ti\
    me\x18\n\x20\x01(\x02R\x06fxTime\x12\x12\n\x04text\x18\x0b\x20\x01(\tR\
    \x04text\"\x8e\x01\n\x0fCCSUsrMsg_Shake\x12\x18\n\x07command\x18\x01\x20\
    \x01(\x05R\x07command\x12'\n\x0flocal_amplitude\x18\x02\x20\x01(\x02R\
    \x0elocalAmplitude\x12\x1c\n\tfrequency\x18\x03\x20\x01(\x02R\tfrequency\
    \x12\x1a\n\x08duration\x18\x04\x20\x01(\x02R\x08duration\"|\n\x0eCCSUsrM\
    sg_Fade\x12\x1a\n\x08duration\x18\x01\x20\x01(\x05R\x08duration\x12\x1b\
    \n\thold_time\x18\x02\x20\x01(\x05R\x08holdTime\x12\x14\n\x05flags\x18\
    \x03\x20\x01(\x05R\x05flags\x12\x1b\n\x03clr\x18\x04\x20\x01(\x0b2\t.CMs\
    gRGBAR\x03clr\"R\n\x10CCSUsrMsg_Rumble\x12\x14\n\x05index\x18\x01\x20\
    \x01(\x05R\x05index\x12\x12\n\x04data\x18\x02\x20\x01(\x05R\x04data\x12\
    \x14\n\x05flags\x18\x03\x20\x01(\x05R\x05flags\"\x83\x01\n\x16CCSUsrMsg_\
    CloseCaption\x12\x12\n\x04hash\x18\x01\x20\x01(\rR\x04hash\x12\x1a\n\x08\
    duration\x18\x02\x20\x01(\x05R\x08duration\x12\x1f\n\x0bfrom_player\x18\
    \x03\x20\x01(\x08R\nfromPlayer\x12\x18\n\x07cctoken\x18\x04\x20\x01(\tR\
    \x07cctoken\"o\n\x1cCCSUsrMsg_CloseCaptionDirect\x12\x12\n\x04hash\x18\
    \x01\x20\x01(\rR\x04hash\x12\x1a\n\x08duration\x18\x02\x20\x01(\x05R\x08\
    duration\x12\x1f\n\x0bfrom_player\x18\x03\x20\x01(\x08R\nfromPlayer\"6\n\
    \x13CCSUsrMsg_SendAudio\x12\x1f\n\x0bradio_sound\x18\x01\x20\x01(\tR\nra\
    dioSound\"\x89\x01\n\x12CCSUsrMsg_RawAudio\x12\x14\n\x05pitch\x18\x01\
    \x20\x01(\x05R\x05pitch\x12\x1a\n\x06entidx\x18\x02\x20\x01(\x05:\x02-1R\
    \x06entidx\x12\x1a\n\x08duration\x18\x03\x20\x01(\x02R\x08duration\x12%\
    \n\x0evoice_filename\x18\x04\x20\x01(\tR\rvoiceFilename\"\xd8\x01\n\x13C\
    CSUsrMsg_VoiceMask\x12B\n\x0cplayer_masks\x18\x01\x20\x03(\x0b2\x1f.CCSU\
    srMsg_VoiceMask.PlayerMaskR\x0bplayerMasks\x12*\n\x11player_mod_enable\
    \x18\x02\x20\x01(\x08R\x0fplayerModEnable\x1aQ\n\nPlayerMask\x12&\n\x0fg\
    ame_rules_mask\x18\x01\x20\x01(\x05R\rgameRulesMask\x12\x1b\n\tban_masks\
    \x18\x02\x20\x01(\x05R\x08banMasks\"\x94\x01\n\x10CCSUsrMsg_Damage\x12\
    \x16\n\x06amount\x18\x01\x20\x01(\x05R\x06amount\x12;\n\x13inflictor_wor\
    ld_pos\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x11inflictorWorldPos\x12+\n\
    \x0fvictim_entindex\x18\x03\x20\x01(\x05:\x02-1R\x0evictimEntindex\"}\n\
    \x13CCSUsrMsg_RadioText\x12\x17\n\x07msg_dst\x18\x01\x20\x01(\x05R\x06ms\
    gDst\x12\x1a\n\x06client\x18\x02\x20\x01(\x05:\x02-1R\x06client\x12\x19\
    \n\x08msg_name\x18\x03\x20\x01(\tR\x07msgName\x12\x16\n\x06params\x18\
    \x04\x20\x03(\tR\x06params\".\n\x12CCSUsrMsg_HintText\x12\x18\n\x07messa\
    ge\x18\x01\x20\x01(\tR\x07message\"3\n\x15CCSUsrMsg_KeyHintText\x12\x1a\
    \n\x08messages\x18\x01\x20\x03(\tR\x08messages\"\xd3\x03\n$CCSUsrMsg_Pro\
    cessSpottedEntityUpdate\x12\x1d\n\nnew_update\x18\x01\x20\x01(\x08R\tnew\
    Update\x12`\n\x0eentity_updates\x18\x02\x20\x03(\x0b29.CCSUsrMsg_Process\
    SpottedEntityUpdate.SpottedEntityUpdateR\rentityUpdates\x1a\xa9\x02\n\
    \x13SpottedEntityUpdate\x12!\n\nentity_idx\x18\x01\x20\x01(\x05:\x02-1R\
    \tentityIdx\x12\x19\n\x08class_id\x18\x02\x20\x01(\x05R\x07classId\x12\
    \x19\n\x08origin_x\x18\x03\x20\x01(\x05R\x07originX\x12\x19\n\x08origin_\
    y\x18\x04\x20\x01(\x05R\x07originY\x12\x19\n\x08origin_z\x18\x05\x20\x01\
    (\x05R\x07originZ\x12\x17\n\x07angle_y\x18\x06\x20\x01(\x05R\x06angleY\
    \x12\x18\n\x07defuser\x18\x07\x20\x01(\x08R\x07defuser\x12,\n\x12player_\
    has_defuser\x18\x08\x20\x01(\x08R\x10playerHasDefuser\x12\"\n\rplayer_ha\
    s_c4\x18\t\x20\x01(\x08R\x0bplayerHasC4\"b\n\x1dCCSUsrMsg_SendPlayerItem\
    Drops\x12A\n\x0eentity_updates\x18\x01\x20\x03(\x0b2\x1a.CEconItemPrevie\
    wDataBlockR\rentityUpdates\"{\n\x1dCCSUsrMsg_SendPlayerItemFound\x126\n\
    \x08iteminfo\x18\x01\x20\x01(\x0b2\x1a.CEconItemPreviewDataBlockR\x08ite\
    minfo\x12\"\n\nplayerslot\x18\x02\x20\x01(\x05:\x02-1R\nplayerslot\"\x9f\
    \x01\n\x16CCSUsrMsg_ReloadEffect\x12\x1a\n\x06entidx\x18\x01\x20\x01(\
    \x05:\x02-1R\x06entidx\x12\x18\n\x07actanim\x18\x02\x20\x01(\x05R\x07act\
    anim\x12\x19\n\x08origin_x\x18\x03\x20\x01(\x02R\x07originX\x12\x19\n\
    \x08origin_y\x18\x04\x20\x01(\x02R\x07originY\x12\x19\n\x08origin_z\x18\
    \x05\x20\x01(\x02R\x07originZ\"\xf2\x01\n\x15CCSUsrMsg_WeaponSound\x12\
    \x1a\n\x06entidx\x18\x01\x20\x01(\x05:\x02-1R\x06entidx\x12\x19\n\x08ori\
    gin_x\x18\x02\x20\x01(\x02R\x07originX\x12\x19\n\x08origin_y\x18\x03\x20\
    \x01(\x02R\x07originY\x12\x19\n\x08origin_z\x18\x04\x20\x01(\x02R\x07ori\
    ginZ\x12\x14\n\x05sound\x18\x05\x20\x01(\tR\x05sound\x12%\n\x0egame_time\
    stamp\x18\x06\x20\x01(\x02R\rgameTimestamp\x12/\n\x13source_soundscapeid\
    \x18\x07\x20\x01(\x07R\x12sourceSoundscapeid\"\xa5\x01\n\x1fCCSUsrMsg_Up\
    dateScreenHealthBar\x12\x1a\n\x06entidx\x18\x01\x20\x01(\x05:\x02-1R\x06\
    entidx\x12'\n\x0fhealthratio_old\x18\x02\x20\x01(\x02R\x0ehealthratioOld\
    \x12'\n\x0fhealthratio_new\x18\x03\x20\x01(\x02R\x0ehealthratioNew\x12\
    \x14\n\x05style\x18\x04\x20\x01(\x05R\x05style\"h\n\x20CCSUsrMsg_EntityO\
    utlineHighlight\x12\x1a\n\x06entidx\x18\x01\x20\x01(\x05:\x02-1R\x06enti\
    dx\x12(\n\x0fremovehighlight\x18\x02\x20\x01(\x08R\x0fremovehighlight\"/\
    \n\x15CCSUsrMsg_AdjustMoney\x12\x16\n\x06amount\x18\x01\x20\x01(\x05R\
    \x06amount\"r\n\x13CCSUsrMsg_ReportHit\x12\x13\n\x05pos_x\x18\x01\x20\
    \x01(\x02R\x04posX\x12\x13\n\x05pos_y\x18\x02\x20\x01(\x02R\x04posY\x12\
    \x1c\n\ttimestamp\x18\x04\x20\x01(\x02R\ttimestamp\x12\x13\n\x05pos_z\
    \x18\x03\x20\x01(\x02R\x04posZ\"~\n\x11CCSUsrMsg_KillCam\x12\x19\n\x08ob\
    s_mode\x18\x01\x20\x01(\x05R\x07obsMode\x12%\n\x0cfirst_target\x18\x02\
    \x20\x01(\x05:\x02-1R\x0bfirstTarget\x12'\n\rsecond_target\x18\x03\x20\
    \x01(\x05:\x02-1R\x0csecondTarget\"\xd4\x01\n\x1aCCSUsrMsg_DesiredTimesc\
    ale\x12+\n\x11desired_timescale\x18\x01\x20\x01(\x02R\x10desiredTimescal\
    e\x122\n\x15duration_realtime_sec\x18\x02\x20\x01(\x02R\x13durationRealt\
    imeSec\x12+\n\x11interpolator_type\x18\x03\x20\x01(\x05R\x10interpolator\
    Type\x12(\n\x10start_blend_time\x18\x04\x20\x01(\x02R\x0estartBlendTime\
    \"A\n\x1aCCSUsrMsg_CurrentTimescale\x12#\n\rcur_timescale\x18\x01\x20\
    \x01(\x02R\x0ccurTimescale\"m\n\x1aCCSUsrMsg_AchievementEvent\x12\x20\n\
    \x0bachievement\x18\x01\x20\x01(\x05R\x0bachievement\x12\x14\n\x05count\
    \x18\x02\x20\x01(\x05R\x05count\x12\x17\n\x07user_id\x18\x03\x20\x01(\
    \x05R\x06userId\"\xa3\x01\n\x1cCCSUsrMsg_MatchEndConditions\x12\x1c\n\tf\
    raglimit\x18\x01\x20\x01(\x05R\tfraglimit\x12!\n\x0cmp_maxrounds\x18\x02\
    \x20\x01(\x05R\x0bmpMaxrounds\x12\x1f\n\x0bmp_winlimit\x18\x03\x20\x01(\
    \x05R\nmpWinlimit\x12!\n\x0cmp_timelimit\x18\x04\x20\x01(\x02R\x0bmpTime\
    limit\"\xcc\x01\n\x1bCCSUsrMsg_PlayerStatsUpdate\x12\x18\n\x07version\
    \x18\x01\x20\x01(\x05R\x07version\x127\n\x05stats\x18\x04\x20\x03(\x0b2!\
    .CCSUsrMsg_PlayerStatsUpdate.StatR\x05stats\x12\x18\n\x07ehandle\x18\x05\
    \x20\x01(\rR\x07ehandle\x12\x10\n\x03crc\x18\x06\x20\x01(\x05R\x03crc\
    \x1a.\n\x04Stat\x12\x10\n\x03idx\x18\x01\x20\x01(\x05R\x03idx\x12\x14\n\
    \x05delta\x18\x02\x20\x01(\x05R\x05delta\"\xa2\x01\n\x17CCSUsrMsg_QuestP\
    rogress\x12\x19\n\x08quest_id\x18\x01\x20\x01(\rR\x07questId\x12#\n\rnor\
    mal_points\x18\x02\x20\x01(\rR\x0cnormalPoints\x12!\n\x0cbonus_points\
    \x18\x03\x20\x01(\rR\x0bbonusPoints\x12$\n\x0eis_event_quest\x18\x04\x20\
    \x01(\x08R\x0cisEventQuest\"K\n\x1eCCSUsrMsg_ScoreLeaderboardData\x12)\n\
    \x04data\x18\x01\x20\x01(\x0b2\x15.ScoreLeaderboardDataR\x04data\"Y\n%CC\
    SUsrMsg_PlayerDecalDigitalSignature\x120\n\x04data\x18\x01\x20\x01(\x0b2\
    \x1c.PlayerDecalDigitalSignatureR\x04data\"O\n\x12CCSUsrMsg_XRankGet\x12\
    \x19\n\x08mode_idx\x18\x01\x20\x01(\x05R\x07modeIdx\x12\x1e\n\ncontrolle\
    r\x18\x02\x20\x01(\x05R\ncontroller\"i\n\x12CCSUsrMsg_XRankUpd\x12\x19\n\
    \x08mode_idx\x18\x01\x20\x01(\x05R\x07modeIdx\x12\x1e\n\ncontroller\x18\
    \x02\x20\x01(\x05R\ncontroller\x12\x18\n\x07ranking\x18\x03\x20\x01(\x05\
    R\x07ranking\"F\n\x18CCSUsrMsg_CallVoteFailed\x12\x16\n\x06reason\x18\
    \x01\x20\x01(\x05R\x06reason\x12\x12\n\x04time\x18\x02\x20\x01(\x05R\x04\
    time\"\xa4\x02\n\x13CCSUsrMsg_VoteStart\x12\x12\n\x04team\x18\x01\x20\
    \x01(\x05R\x04team\x12#\n\x0bplayer_slot\x18\x02\x20\x01(\x05:\x02-1R\np\
    layerSlot\x12\x1b\n\tvote_type\x18\x03\x20\x01(\x05R\x08voteType\x12\x19\
    \n\x08disp_str\x18\x04\x20\x01(\tR\x07dispStr\x12\x1f\n\x0bdetails_str\
    \x18\x05\x20\x01(\tR\ndetailsStr\x12$\n\x0eother_team_str\x18\x06\x20\
    \x01(\tR\x0cotherTeamStr\x12#\n\x0eis_yes_no_vote\x18\x07\x20\x01(\x08R\
    \x0bisYesNoVote\x120\n\x12player_slot_target\x18\x08\x20\x01(\x05:\x02-1\
    R\x10playerSlotTarget\"\x81\x01\n\x12CCSUsrMsg_VotePass\x12\x12\n\x04tea\
    m\x18\x01\x20\x01(\x05R\x04team\x12\x1b\n\tvote_type\x18\x02\x20\x01(\
    \x05R\x08voteType\x12\x19\n\x08disp_str\x18\x03\x20\x01(\tR\x07dispStr\
    \x12\x1f\n\x0bdetails_str\x18\x04\x20\x01(\tR\ndetailsStr\"B\n\x14CCSUsr\
    Msg_VoteFailed\x12\x12\n\x04team\x18\x01\x20\x01(\x05R\x04team\x12\x16\n\
    \x06reason\x18\x02\x20\x01(\x05R\x06reason\"@\n\x13CCSUsrMsg_VoteSetup\
    \x12)\n\x10potential_issues\x18\x01\x20\x03(\tR\x0fpotentialIssues\"\x9a\
    \x02\n&CCSUsrMsg_SendLastKillerDamageToClient\x12$\n\x0enum_hits_given\
    \x18\x01\x20\x01(\x05R\x0cnumHitsGiven\x12!\n\x0cdamage_given\x18\x02\
    \x20\x01(\x05R\x0bdamageGiven\x12$\n\x0enum_hits_taken\x18\x03\x20\x01(\
    \x05R\x0cnumHitsTaken\x12!\n\x0cdamage_taken\x18\x04\x20\x01(\x05R\x0bda\
    mageTaken\x12.\n\x13actual_damage_given\x18\x05\x20\x01(\x05R\x11actualD\
    amageGiven\x12.\n\x13actual_damage_taken\x18\x06\x20\x01(\x05R\x11actual\
    DamageTaken\"\xa7\x02\n\x1aCCSUsrMsg_ServerRankUpdate\x12G\n\x0brank_upd\
    ate\x18\x01\x20\x03(\x0b2&.CCSUsrMsg_ServerRankUpdate.RankUpdateR\nrankU\
    pdate\x1a\xbf\x01\n\nRankUpdate\x12\x1d\n\naccount_id\x18\x01\x20\x01(\
    \x05R\taccountId\x12\x19\n\x08rank_old\x18\x02\x20\x01(\x05R\x07rankOld\
    \x12\x19\n\x08rank_new\x18\x03\x20\x01(\x05R\x07rankNew\x12\x19\n\x08num\
    _wins\x18\x04\x20\x01(\x05R\x07numWins\x12\x1f\n\x0brank_change\x18\x05\
    \x20\x01(\x02R\nrankChange\x12\x20\n\x0crank_type_id\x18\x06\x20\x01(\
    \x05R\nrankTypeId\"W\n\x12CCSUsrMsg_XpUpdate\x12A\n\x04data\x18\x01\x20\
    \x01(\x0b2-.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewardedR\x04data\"*\n\
    \x14CCSUsrMsg_ItemPickup\x12\x12\n\x04item\x18\x01\x20\x01(\tR\x04item\"\
    \x82\x01\n\x12CCSUsrMsg_ShowMenu\x12(\n\x10bits_valid_slots\x18\x01\x20\
    \x01(\x05R\x0ebitsValidSlots\x12!\n\x0cdisplay_time\x18\x02\x20\x01(\x05\
    R\x0bdisplayTime\x12\x1f\n\x0bmenu_string\x18\x03\x20\x01(\tR\nmenuStrin\
    g\"'\n\x11CCSUsrMsg_BarTime\x12\x12\n\x04time\x18\x01\x20\x01(\tR\x04tim\
    e\"0\n\x14CCSUsrMsg_AmmoDenied\x12\x18\n\x07ammoidx\x18\x01\x20\x01(\x05\
    R\x07ammoidx\"=\n\x19CCSUsrMsg_MarkAchievement\x12\x20\n\x0bachievement\
    \x18\x01\x20\x01(\tR\x0bachievement\"4\n\x1aCCSUsrMsg_MatchStatsUpdate\
    \x12\x16\n\x06update\x18\x01\x20\x01(\tR\x06update\"B\n\x12CCSUsrMsg_Ite\
    mDrop\x12\x16\n\x06itemid\x18\x01\x20\x01(\x03R\x06itemid\x12\x14\n\x05d\
    eath\x18\x02\x20\x01(\x08R\x05death\"7\n\x19CCSUsrMsg_GlowPropTurnOff\
    \x12\x1a\n\x06entidx\x18\x01\x20\x01(\x05:\x02-1R\x06entidx\"\x84\x01\n\
    \x1eCCSUsrMsg_RoundBackupFilenames\x12\x14\n\x05count\x18\x01\x20\x01(\
    \x05R\x05count\x12\x14\n\x05index\x18\x02\x20\x01(\x05R\x05index\x12\x1a\
    \n\x08filename\x18\x03\x20\x01(\tR\x08filename\x12\x1a\n\x08nicename\x18\
    \x04\x20\x01(\tR\x08nicename\"^\n\x0eCCSUsrMsg_SSUI\x12\x12\n\x04show\
    \x18\x01\x20\x01(\x08R\x04show\x12\x1d\n\nstart_time\x18\x02\x20\x01(\
    \x02R\tstartTime\x12\x19\n\x08end_time\x18\x03\x20\x01(\x02R\x07endTime\
    \"\xc4\x04\n\x17CCSUsrMsg_SurvivalStats\x12\x12\n\x04xuid\x18\x01\x20\
    \x01(\x04R\x04xuid\x123\n\x05facts\x18\x02\x20\x03(\x0b2\x1d.CCSUsrMsg_S\
    urvivalStats.FactR\x05facts\x128\n\x05users\x18\x03\x20\x03(\x0b2\".CCSU\
    srMsg_SurvivalStats.PlacementR\x05users\x129\n\x07damages\x18\x05\x20\
    \x03(\x0b2\x1f.CCSUsrMsg_SurvivalStats.DamageR\x07damages\x12\x1e\n\ntic\
    knumber\x18\x04\x20\x01(\x05R\nticknumber\x1at\n\x04Fact\x12\x12\n\x04ty\
    pe\x18\x01\x20\x01(\x05R\x04type\x12\x18\n\x07display\x18\x02\x20\x01(\
    \x05R\x07display\x12\x14\n\x05value\x18\x03\x20\x01(\x05R\x05value\x12(\
    \n\x0finterestingness\x18\x04\x20\x01(\x02R\x0finterestingness\x1a]\n\tP\
    lacement\x12\x12\n\x04xuid\x18\x01\x20\x01(\x04R\x04xuid\x12\x1e\n\nteam\
    number\x18\x02\x20\x01(\x05R\nteamnumber\x12\x1c\n\tplacement\x18\x03\
    \x20\x01(\x05R\tplacement\x1av\n\x06Damage\x12\x12\n\x04xuid\x18\x01\x20\
    \x01(\x04R\x04xuid\x12\x0e\n\x02to\x18\x02\x20\x01(\x05R\x02to\x12\x17\n\
    \x07to_hits\x18\x03\x20\x01(\x05R\x06toHits\x12\x12\n\x04from\x18\x04\
    \x20\x01(\x05R\x04from\x12\x1b\n\tfrom_hits\x18\x05\x20\x01(\x05R\x08fro\
    mHits\"\x93\x04\n\"CCSUsrMsg_EndOfMatchAllPlayersData\x12T\n\rallplayerd\
    ata\x18\x01\x20\x03(\x0b2..CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData\
    R\rallplayerdata\x12\x14\n\x05scene\x18\x02\x20\x01(\x05R\x05scene\x1aZ\
    \n\x08Accolade\x12\x1c\n\teaccolade\x18\x01\x20\x01(\x05R\teaccolade\x12\
    \x14\n\x05value\x18\x02\x20\x01(\x02R\x05value\x12\x1a\n\x08position\x18\
    \x03\x20\x01(\x05R\x08position\x1a\xa4\x02\n\nPlayerData\x12\x16\n\x04sl\
    ot\x18\x01\x20\x01(\x05:\x02-1R\x04slot\x12\x12\n\x04xuid\x18\x02\x20\
    \x01(\x04R\x04xuid\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1e\
    \n\nteamnumber\x18\x04\x20\x01(\x05R\nteamnumber\x12L\n\nnomination\x18\
    \x05\x20\x01(\x0b2,.CCSUsrMsg_EndOfMatchAllPlayersData.AccoladeR\nnomina\
    tion\x120\n\x05items\x18\x06\x20\x03(\x0b2\x1a.CEconItemPreviewDataBlock\
    R\x05items\x12\x20\n\x0bplayercolor\x18\x07\x20\x01(\x05R\x0bplayercolor\
    \x12\x14\n\x05isbot\x18\x08\x20\x01(\x08R\x05isbot\"\x9c\t\n\x1cCCSUsrMs\
    g_RoundEndReportData\x12X\n\x0finit_conditions\x18\x01\x20\x01(\x0b2/.CC\
    SUsrMsg_RoundEndReportData.InitialConditionsR\x0einitConditions\x12S\n\
    \x12all_rer_event_data\x18\x02\x20\x03(\x0b2&.CCSUsrMsg_RoundEndReportDa\
    ta.RerEventR\x0fallRerEventData\x1a\xc5\x06\n\x08RerEvent\x12\x1c\n\ttim\
    estamp\x18\x01\x20\x01(\x02R\ttimestamp\x12%\n\x0eterrorist_odds\x18\x02\
    \x20\x01(\x05R\rterroristOdds\x12\x19\n\x08ct_alive\x18\x03\x20\x01(\x05\
    R\x07ctAlive\x12\x17\n\x07t_alive\x18\x04\x20\x01(\x05R\x06tAlive\x12N\n\
    \x0bvictim_data\x18\x05\x20\x01(\x0b2-.CCSUsrMsg_RoundEndReportData.RerE\
    vent.VictimR\nvictimData\x12W\n\x0eobjective_data\x18\x06\x20\x01(\x0b20\
    .CCSUsrMsg_RoundEndReportData.RerEvent.ObjectiveR\robjectiveData\x12U\n\
    \x0fall_damage_data\x18\x07\x20\x03(\x0b2-.CCSUsrMsg_RoundEndReportData.\
    RerEvent.DamageR\rallDamageData\x1a\xa7\x01\n\x06Victim\x12\x1f\n\x0btea\
    m_number\x18\x01\x20\x01(\x05R\nteamNumber\x12\"\n\nplayerslot\x18\x02\
    \x20\x01(\x05:\x02-1R\nplayerslot\x12\x12\n\x04xuid\x18\x03\x20\x01(\x04\
    R\x04xuid\x12\x14\n\x05color\x18\x04\x20\x01(\x05R\x05color\x12\x15\n\
    \x06is_bot\x18\x05\x20\x01(\x08R\x05isBot\x12\x17\n\x07is_dead\x18\x06\
    \x20\x01(\x08R\x06isDead\x1a\x1f\n\tObjective\x12\x12\n\x04type\x18\x01\
    \x20\x01(\x05R\x04type\x1a\xf4\x01\n\x06Damage\x12-\n\x10other_playerslo\
    t\x18\x01\x20\x01(\x05:\x02-1R\x0fotherPlayerslot\x12\x1d\n\nother_xuid\
    \x18\x02\x20\x01(\x04R\totherXuid\x12%\n\x0ehealth_removed\x18\x03\x20\
    \x01(\x05R\rhealthRemoved\x12\x19\n\x08num_hits\x18\x04\x20\x01(\x05R\
    \x07numHits\x122\n\x15return_health_removed\x18\x05\x20\x01(\x05R\x13ret\
    urnHealthRemoved\x12&\n\x0freturn_num_hits\x18\x06\x20\x01(\x05R\rreturn\
    NumHits\x1a\x84\x01\n\x11InitialConditions\x12$\n\x0ect_equip_value\x18\
    \x01\x20\x01(\x05R\x0cctEquipValue\x12\"\n\rt_equip_value\x18\x02\x20\
    \x01(\x05R\x0btEquipValue\x12%\n\x0eterrorist_odds\x18\x03\x20\x01(\x05R\
    \rterroristOdds\"\xc0\x02\n\x1fCCSUsrMsg_PostRoundDamageReport\x12\x1d\n\
    \nother_xuid\x18\x01\x20\x01(\x04R\totherXuid\x12&\n\x0fgiven_kill_type\
    \x18\x02\x20\x01(\x05R\rgivenKillType\x120\n\x14given_health_removed\x18\
    \x03\x20\x01(\x05R\x12givenHealthRemoved\x12$\n\x0egiven_num_hits\x18\
    \x04\x20\x01(\x05R\x0cgivenNumHits\x12&\n\x0ftaken_kill_type\x18\x05\x20\
    \x01(\x05R\rtakenKillType\x120\n\x14taken_health_removed\x18\x06\x20\x01\
    (\x05R\x12takenHealthRemoved\x12$\n\x0etaken_num_hits\x18\x07\x20\x01(\
    \x05R\x0ctakenNumHits\"0\n\x1aCCSUsrMsg_CurrentRoundOdds\x12\x12\n\x04od\
    ds\x18\x01\x20\x01(\x05R\x04odds\"M\n\x13CCSUsrMsg_DeepStats\x126\n\x05s\
    tats\x18\x01\x20\x01(\x0b2\x20.CMsgGCCStrike15_ClientDeepStatsR\x05stats\
    \"\xc9\x01\n\x13CCSUsrMsg_ShootInfo\x12!\n\x0cframe_number\x18\x01\x20\
    \x01(\x05R\x0bframeNumber\x12;\n\x11hitbox_transforms\x18\x02\x20\x03(\
    \x0b2\x0e.CMsgTransformR\x10hitboxTransforms\x12(\n\tshoot_pos\x18\x03\
    \x20\x01(\x0b2\x0b.CMsgVectorR\x08shootPos\x12(\n\tshoot_dir\x18\x04\x20\
    \x01(\x0b2\x0b.CMsgQAngleR\x08shootDir\"*\n\x12CCSUsrMsg_ResetHud\x12\
    \x14\n\x05reset\x18\x01\x20\x01(\x08R\x05reset\"+\n\x13CCSUsrMsg_GameTit\
    le\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05dummy\".\n\x16CCSUsrMsg_R\
    equestState\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05dummy\"3\n\x1bCC\
    SUsrMsg_StopSpectatorMode\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05du\
    mmy\"3\n\x1bCCSUsrMsg_DisconnectToLobby\x12\x14\n\x05dummy\x18\x01\x20\
    \x01(\x05R\x05dummy\"0\n\x18CCSUsrMsg_WarmupHasEnded\x12\x14\n\x05dummy\
    \x18\x01\x20\x01(\x05R\x05dummy\",\n\x14CCSUsrMsg_ClientInfo\x12\x14\n\
    \x05dummy\x18\x01\x20\x01(\x05R\x05dummy\"\xa6\x01\n\x1dCCSUsrMsg_Server\
    RankRevealAll\x122\n\x15seconds_till_shutdown\x18\x01\x20\x01(\x05R\x13s\
    econdsTillShutdown\x12Q\n\x0breservation\x18\x02\x20\x01(\x0b2/.CMsgGCCS\
    trike15_v2_MatchmakingGC2ServerReserveR\x0breservation\"h\n\x18CCSUsrMsg\
    PreMatchSayText\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    \x12\n\x04text\x18\x02\x20\x01(\tR\x04text\x12\x19\n\x08all_chat\x18\x03\
    \x20\x01(\x08R\x07allChat\"p\n\x17CCSUsrMsg_CounterStrafe\x12-\n\x13pres\
    s_to_release_ns\x18\x01\x20\x01(\x05R\x10pressToReleaseNs\x12&\n\x0ftota\
    l_keys_down\x18\x02\x20\x01(\x05R\rtotalKeysDown\"\xd6\x02\n\x1aCCSUsrMs\
    g_DamagePrediction\x12\x1f\n\x0bcommand_num\x18\x01\x20\x01(\x05R\ncomma\
    ndNum\x12\x1d\n\npellet_idx\x18\x02\x20\x01(\x05R\tpelletIdx\x12\x1f\n\
    \x0bvictim_slot\x18\x03\x20\x01(\x05R\nvictimSlot\x124\n\x16victim_start\
    ing_health\x18\x04\x20\x01(\x05R\x14victimStartingHealth\x12#\n\rvictim_\
    damage\x18\x05\x20\x01(\x05R\x0cvictimDamage\x12(\n\tshoot_pos\x18\x06\
    \x20\x01(\x0b2\x0b.CMsgVectorR\x08shootPos\x12(\n\tshoot_dir\x18\x07\x20\
    \x01(\x0b2\x0b.CMsgQAngleR\x08shootDir\x12(\n\taim_punch\x18\x08\x20\x01\
    (\x0b2\x0b.CMsgQAngleR\x08aimPunch*\xc9\x0f\n\x16ECstrike15UserMessages\
    \x12\x13\n\x0eCS_UM_VGUIMenu\x10\xad\x02\x12\x11\n\x0cCS_UM_Geiger\x10\
    \xae\x02\x12\x10\n\x0bCS_UM_Train\x10\xaf\x02\x12\x12\n\rCS_UM_HudText\
    \x10\xb0\x02\x12\x12\n\rCS_UM_SayText\x10\xb1\x02\x12\x13\n\x0eCS_UM_Say\
    Text2\x10\xb2\x02\x12\x12\n\rCS_UM_TextMsg\x10\xb3\x02\x12\x11\n\x0cCS_U\
    M_HudMsg\x10\xb4\x02\x12\x13\n\x0eCS_UM_ResetHud\x10\xb5\x02\x12\x14\n\
    \x0fCS_UM_GameTitle\x10\xb6\x02\x12\x10\n\x0bCS_UM_Shake\x10\xb8\x02\x12\
    \x0f\n\nCS_UM_Fade\x10\xb9\x02\x12\x11\n\x0cCS_UM_Rumble\x10\xba\x02\x12\
    \x17\n\x12CS_UM_CloseCaption\x10\xbb\x02\x12\x1d\n\x18CS_UM_CloseCaption\
    Direct\x10\xbc\x02\x12\x14\n\x0fCS_UM_SendAudio\x10\xbd\x02\x12\x13\n\
    \x0eCS_UM_RawAudio\x10\xbe\x02\x12\x14\n\x0fCS_UM_VoiceMask\x10\xbf\x02\
    \x12\x17\n\x12CS_UM_RequestState\x10\xc0\x02\x12\x11\n\x0cCS_UM_Damage\
    \x10\xc1\x02\x12\x14\n\x0fCS_UM_RadioText\x10\xc2\x02\x12\x13\n\x0eCS_UM\
    _HintText\x10\xc3\x02\x12\x16\n\x11CS_UM_KeyHintText\x10\xc4\x02\x12%\n\
    \x20CS_UM_ProcessSpottedEntityUpdate\x10\xc5\x02\x12\x17\n\x12CS_UM_Relo\
    adEffect\x10\xc6\x02\x12\x16\n\x11CS_UM_AdjustMoney\x10\xc7\x02\x12\x1a\
    \n\x15CS_UM_UpdateTeamMoney\x10\xc8\x02\x12\x1c\n\x17CS_UM_StopSpectator\
    Mode\x10\xc9\x02\x12\x12\n\rCS_UM_KillCam\x10\xca\x02\x12\x1b\n\x16CS_UM\
    _DesiredTimescale\x10\xcb\x02\x12\x1b\n\x16CS_UM_CurrentTimescale\x10\
    \xcc\x02\x12\x1b\n\x16CS_UM_AchievementEvent\x10\xcd\x02\x12\x1d\n\x18CS\
    _UM_MatchEndConditions\x10\xce\x02\x12\x1c\n\x17CS_UM_DisconnectToLobby\
    \x10\xcf\x02\x12\x1c\n\x17CS_UM_PlayerStatsUpdate\x10\xd0\x02\x12\x19\n\
    \x14CS_UM_WarmupHasEnded\x10\xd2\x02\x12\x15\n\x10CS_UM_ClientInfo\x10\
    \xd3\x02\x12\x13\n\x0eCS_UM_XRankGet\x10\xd4\x02\x12\x13\n\x0eCS_UM_XRan\
    kUpd\x10\xd5\x02\x12\x19\n\x14CS_UM_CallVoteFailed\x10\xd9\x02\x12\x14\n\
    \x0fCS_UM_VoteStart\x10\xda\x02\x12\x13\n\x0eCS_UM_VotePass\x10\xdb\x02\
    \x12\x15\n\x10CS_UM_VoteFailed\x10\xdc\x02\x12\x14\n\x0fCS_UM_VoteSetup\
    \x10\xdd\x02\x12\x1e\n\x19CS_UM_ServerRankRevealAll\x10\xde\x02\x12'\n\"\
    CS_UM_SendLastKillerDamageToClient\x10\xdf\x02\x12\x1b\n\x16CS_UM_Server\
    RankUpdate\x10\xe0\x02\x12\x15\n\x10CS_UM_ItemPickup\x10\xe1\x02\x12\x13\
    \n\x0eCS_UM_ShowMenu\x10\xe2\x02\x12\x12\n\rCS_UM_BarTime\x10\xe3\x02\
    \x12\x15\n\x10CS_UM_AmmoDenied\x10\xe4\x02\x12\x1a\n\x15CS_UM_MarkAchiev\
    ement\x10\xe5\x02\x12\x1b\n\x16CS_UM_MatchStatsUpdate\x10\xe6\x02\x12\
    \x13\n\x0eCS_UM_ItemDrop\x10\xe7\x02\x12\x1a\n\x15CS_UM_GlowPropTurnOff\
    \x10\xe8\x02\x12\x1e\n\x19CS_UM_SendPlayerItemDrops\x10\xe9\x02\x12\x1f\
    \n\x1aCS_UM_RoundBackupFilenames\x10\xea\x02\x12\x1e\n\x19CS_UM_SendPlay\
    erItemFound\x10\xeb\x02\x12\x14\n\x0fCS_UM_ReportHit\x10\xec\x02\x12\x13\
    \n\x0eCS_UM_XpUpdate\x10\xed\x02\x12\x18\n\x13CS_UM_QuestProgress\x10\
    \xee\x02\x12\x1f\n\x1aCS_UM_ScoreLeaderboardData\x10\xef\x02\x12&\n!CS_U\
    M_PlayerDecalDigitalSignature\x10\xf0\x02\x12\x16\n\x11CS_UM_WeaponSound\
    \x10\xf1\x02\x12\x20\n\x1bCS_UM_UpdateScreenHealthBar\x10\xf2\x02\x12!\n\
    \x1cCS_UM_EntityOutlineHighlight\x10\xf3\x02\x12\x0f\n\nCS_UM_SSUI\x10\
    \xf4\x02\x12\x18\n\x13CS_UM_SurvivalStats\x10\xf5\x02\x12\x1d\n\x18CS_UM\
    _DisconnectToLobby2\x10\xf6\x02\x12#\n\x1eCS_UM_EndOfMatchAllPlayersData\
    \x10\xf7\x02\x12\x20\n\x1bCS_UM_PostRoundDamageReport\x10\xf8\x02\x12\
    \x1d\n\x18CS_UM_RoundEndReportData\x10\xfb\x02\x12\x1b\n\x16CS_UM_Curren\
    tRoundOdds\x10\xfc\x02\x12\x14\n\x0fCS_UM_DeepStats\x10\xfd\x02\x12\x14\
    \n\x0fCS_UM_ShootInfo\x10\xff\x02\x12\x18\n\x13CS_UM_CounterStrafe\x10\
    \x81\x03\x12\x1b\n\x16CS_UM_DamagePrediction\x10\x82\x03*\x88\x01\n\"ECS\
    UsrMsg_DisconnectToLobby_Action\x120\n,k_ECSUsrMsg_DisconnectToLobby_Act\
    ion_Default\x10\0\x120\n,k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue\
    \x10\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::networkbasetypes::file_descriptor().clone());
            deps.push(super::cstrike15_gcmessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(88);
            messages.push(CCSUsrMsg_VGUIMenu::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_Geiger::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_Train::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_HudText::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_HudMsg::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_Shake::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_Fade::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_Rumble::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_CloseCaption::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_CloseCaptionDirect::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_SendAudio::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_RawAudio::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_VoiceMask::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_Damage::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_RadioText::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_HintText::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_KeyHintText::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ProcessSpottedEntityUpdate::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_SendPlayerItemDrops::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_SendPlayerItemFound::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ReloadEffect::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_WeaponSound::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_UpdateScreenHealthBar::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_EntityOutlineHighlight::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_AdjustMoney::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ReportHit::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_KillCam::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_DesiredTimescale::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_CurrentTimescale::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_AchievementEvent::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_MatchEndConditions::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_PlayerStatsUpdate::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_QuestProgress::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ScoreLeaderboardData::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_PlayerDecalDigitalSignature::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_XRankGet::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_XRankUpd::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_CallVoteFailed::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_VoteStart::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_VotePass::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_VoteFailed::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_VoteSetup::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_SendLastKillerDamageToClient::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ServerRankUpdate::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_XpUpdate::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ItemPickup::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ShowMenu::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_BarTime::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_AmmoDenied::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_MarkAchievement::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_MatchStatsUpdate::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ItemDrop::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_GlowPropTurnOff::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_RoundBackupFilenames::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_SSUI::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_SurvivalStats::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_EndOfMatchAllPlayersData::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_RoundEndReportData::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_PostRoundDamageReport::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_CurrentRoundOdds::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_DeepStats::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ShootInfo::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ResetHud::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_GameTitle::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_RequestState::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_StopSpectatorMode::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_DisconnectToLobby::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_WarmupHasEnded::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ClientInfo::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_ServerRankRevealAll::generated_message_descriptor_data());
            messages.push(CCSUsrMsgPreMatchSayText::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_CounterStrafe::generated_message_descriptor_data());
            messages.push(CCSUsrMsg_DamagePrediction::generated_message_descriptor_data());
            messages.push(ccsusr_msg_vguimenu::Keys::generated_message_descriptor_data());
            messages.push(ccsusr_msg_voice_mask::PlayerMask::generated_message_descriptor_data());
            messages.push(ccsusr_msg_process_spotted_entity_update::SpottedEntityUpdate::generated_message_descriptor_data());
            messages.push(ccsusr_msg_player_stats_update::Stat::generated_message_descriptor_data());
            messages.push(ccsusr_msg_server_rank_update::RankUpdate::generated_message_descriptor_data());
            messages.push(ccsusr_msg_survival_stats::Fact::generated_message_descriptor_data());
            messages.push(ccsusr_msg_survival_stats::Placement::generated_message_descriptor_data());
            messages.push(ccsusr_msg_survival_stats::Damage::generated_message_descriptor_data());
            messages.push(ccsusr_msg_end_of_match_all_players_data::Accolade::generated_message_descriptor_data());
            messages.push(ccsusr_msg_end_of_match_all_players_data::PlayerData::generated_message_descriptor_data());
            messages.push(ccsusr_msg_round_end_report_data::RerEvent::generated_message_descriptor_data());
            messages.push(ccsusr_msg_round_end_report_data::InitialConditions::generated_message_descriptor_data());
            messages.push(ccsusr_msg_round_end_report_data::rer_event::Victim::generated_message_descriptor_data());
            messages.push(ccsusr_msg_round_end_report_data::rer_event::Objective::generated_message_descriptor_data());
            messages.push(ccsusr_msg_round_end_report_data::rer_event::Damage::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(ECstrike15UserMessages::generated_enum_descriptor_data());
            enums.push(ECSUsrMsg_DisconnectToLobby_Action::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
