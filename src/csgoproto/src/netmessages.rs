// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `netmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CCLCMsg_ClientInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ClientInfo {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.send_table_crc)
    pub send_table_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.server_count)
    pub server_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.is_hltv)
    pub is_hltv: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.friends_id)
    pub friends_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.friends_name)
    pub friends_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ClientInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ClientInfo {
    fn default() -> &'a CCLCMsg_ClientInfo {
        <CCLCMsg_ClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ClientInfo {
    pub fn new() -> CCLCMsg_ClientInfo {
        ::std::default::Default::default()
    }

    // optional fixed32 send_table_crc = 1;

    pub fn send_table_crc(&self) -> u32 {
        self.send_table_crc.unwrap_or(0)
    }

    pub fn clear_send_table_crc(&mut self) {
        self.send_table_crc = ::std::option::Option::None;
    }

    pub fn has_send_table_crc(&self) -> bool {
        self.send_table_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_table_crc(&mut self, v: u32) {
        self.send_table_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 server_count = 2;

    pub fn server_count(&self) -> u32 {
        self.server_count.unwrap_or(0)
    }

    pub fn clear_server_count(&mut self) {
        self.server_count = ::std::option::Option::None;
    }

    pub fn has_server_count(&self) -> bool {
        self.server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_count(&mut self, v: u32) {
        self.server_count = ::std::option::Option::Some(v);
    }

    // optional bool is_hltv = 3;

    pub fn is_hltv(&self) -> bool {
        self.is_hltv.unwrap_or(false)
    }

    pub fn clear_is_hltv(&mut self) {
        self.is_hltv = ::std::option::Option::None;
    }

    pub fn has_is_hltv(&self) -> bool {
        self.is_hltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hltv(&mut self, v: bool) {
        self.is_hltv = ::std::option::Option::Some(v);
    }

    // optional uint32 friends_id = 5;

    pub fn friends_id(&self) -> u32 {
        self.friends_id.unwrap_or(0)
    }

    pub fn clear_friends_id(&mut self) {
        self.friends_id = ::std::option::Option::None;
    }

    pub fn has_friends_id(&self) -> bool {
        self.friends_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_id(&mut self, v: u32) {
        self.friends_id = ::std::option::Option::Some(v);
    }

    // optional string friends_name = 6;

    pub fn friends_name(&self) -> &str {
        match self.friends_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_friends_name(&mut self) {
        self.friends_name = ::std::option::Option::None;
    }

    pub fn has_friends_name(&self) -> bool {
        self.friends_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_name(&mut self, v: ::std::string::String) {
        self.friends_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_friends_name(&mut self) -> &mut ::std::string::String {
        if self.friends_name.is_none() {
            self.friends_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.friends_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_friends_name(&mut self) -> ::std::string::String {
        self.friends_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_table_crc",
            |m: &CCLCMsg_ClientInfo| { &m.send_table_crc },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.send_table_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_count",
            |m: &CCLCMsg_ClientInfo| { &m.server_count },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.server_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hltv",
            |m: &CCLCMsg_ClientInfo| { &m.is_hltv },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.is_hltv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friends_id",
            |m: &CCLCMsg_ClientInfo| { &m.friends_id },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.friends_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friends_name",
            |m: &CCLCMsg_ClientInfo| { &m.friends_name },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.friends_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ClientInfo>(
            "CCLCMsg_ClientInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ClientInfo {
    const NAME: &'static str = "CCLCMsg_ClientInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.send_table_crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.server_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_hltv = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.friends_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.friends_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.send_table_crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_hltv {
            my_size += 1 + 1;
        }
        if let Some(v) = self.friends_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.friends_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.send_table_crc {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_hltv {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.friends_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.friends_name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ClientInfo {
        CCLCMsg_ClientInfo::new()
    }

    fn clear(&mut self) {
        self.send_table_crc = ::std::option::Option::None;
        self.server_count = ::std::option::Option::None;
        self.is_hltv = ::std::option::Option::None;
        self.friends_id = ::std::option::Option::None;
        self.friends_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ClientInfo {
        static instance: CCLCMsg_ClientInfo = CCLCMsg_ClientInfo {
            send_table_crc: ::std::option::Option::None,
            server_count: ::std::option::Option::None,
            is_hltv: ::std::option::Option::None,
            friends_id: ::std::option::Option::None,
            friends_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ClientInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ClientInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ClientInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_Move)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_Move {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_Move.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CCLCMsg_Move.command_number)
    pub command_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_Move.num_commands)
    pub num_commands: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_Move.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_Move {
    fn default() -> &'a CCLCMsg_Move {
        <CCLCMsg_Move as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_Move {
    pub fn new() -> CCLCMsg_Move {
        ::std::default::Default::default()
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 command_number = 4;

    pub fn command_number(&self) -> u32 {
        self.command_number.unwrap_or(0)
    }

    pub fn clear_command_number(&mut self) {
        self.command_number = ::std::option::Option::None;
    }

    pub fn has_command_number(&self) -> bool {
        self.command_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command_number(&mut self, v: u32) {
        self.command_number = ::std::option::Option::Some(v);
    }

    // optional uint32 num_commands = 5;

    pub fn num_commands(&self) -> u32 {
        self.num_commands.unwrap_or(0)
    }

    pub fn clear_num_commands(&mut self) {
        self.num_commands = ::std::option::Option::None;
    }

    pub fn has_num_commands(&self) -> bool {
        self.num_commands.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_commands(&mut self, v: u32) {
        self.num_commands = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CCLCMsg_Move| { &m.data },
            |m: &mut CCLCMsg_Move| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command_number",
            |m: &CCLCMsg_Move| { &m.command_number },
            |m: &mut CCLCMsg_Move| { &mut m.command_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_commands",
            |m: &CCLCMsg_Move| { &m.num_commands },
            |m: &mut CCLCMsg_Move| { &mut m.num_commands },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_Move>(
            "CCLCMsg_Move",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_Move {
    const NAME: &'static str = "CCLCMsg_Move";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.command_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.num_commands = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.command_number {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.num_commands {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.command_number {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.num_commands {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_Move {
        CCLCMsg_Move::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.command_number = ::std::option::Option::None;
        self.num_commands = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_Move {
        static instance: CCLCMsg_Move = CCLCMsg_Move {
            data: ::std::option::Option::None,
            command_number: ::std::option::Option::None,
            num_commands: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_Move {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_Move").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_Move {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_Move {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgVoiceAudio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVoiceAudio {
    // message fields
    // @@protoc_insertion_point(field:CMsgVoiceAudio.format)
    pub format: ::std::option::Option<::protobuf::EnumOrUnknown<VoiceDataFormat_t>>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.voice_data)
    pub voice_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.sequence_bytes)
    pub sequence_bytes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.section_number)
    pub section_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.sample_rate)
    pub sample_rate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.uncompressed_sample_offset)
    pub uncompressed_sample_offset: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVoiceAudio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVoiceAudio {
    fn default() -> &'a CMsgVoiceAudio {
        <CMsgVoiceAudio as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVoiceAudio {
    pub fn new() -> CMsgVoiceAudio {
        ::std::default::Default::default()
    }

    // optional .VoiceDataFormat_t format = 1;

    pub fn format(&self) -> VoiceDataFormat_t {
        match self.format {
            Some(e) => e.enum_value_or(VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM),
            None => VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: VoiceDataFormat_t) {
        self.format = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes voice_data = 2;

    pub fn voice_data(&self) -> &[u8] {
        match self.voice_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_voice_data(&mut self) {
        self.voice_data = ::std::option::Option::None;
    }

    pub fn has_voice_data(&self) -> bool {
        self.voice_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.voice_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.voice_data.is_none() {
            self.voice_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.voice_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_data(&mut self) -> ::std::vec::Vec<u8> {
        self.voice_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 sequence_bytes = 3;

    pub fn sequence_bytes(&self) -> i32 {
        self.sequence_bytes.unwrap_or(0)
    }

    pub fn clear_sequence_bytes(&mut self) {
        self.sequence_bytes = ::std::option::Option::None;
    }

    pub fn has_sequence_bytes(&self) -> bool {
        self.sequence_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_bytes(&mut self, v: i32) {
        self.sequence_bytes = ::std::option::Option::Some(v);
    }

    // optional uint32 section_number = 4;

    pub fn section_number(&self) -> u32 {
        self.section_number.unwrap_or(0)
    }

    pub fn clear_section_number(&mut self) {
        self.section_number = ::std::option::Option::None;
    }

    pub fn has_section_number(&self) -> bool {
        self.section_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_number(&mut self, v: u32) {
        self.section_number = ::std::option::Option::Some(v);
    }

    // optional uint32 sample_rate = 5;

    pub fn sample_rate(&self) -> u32 {
        self.sample_rate.unwrap_or(0)
    }

    pub fn clear_sample_rate(&mut self) {
        self.sample_rate = ::std::option::Option::None;
    }

    pub fn has_sample_rate(&self) -> bool {
        self.sample_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sample_rate(&mut self, v: u32) {
        self.sample_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 uncompressed_sample_offset = 6;

    pub fn uncompressed_sample_offset(&self) -> u32 {
        self.uncompressed_sample_offset.unwrap_or(0)
    }

    pub fn clear_uncompressed_sample_offset(&mut self) {
        self.uncompressed_sample_offset = ::std::option::Option::None;
    }

    pub fn has_uncompressed_sample_offset(&self) -> bool {
        self.uncompressed_sample_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_sample_offset(&mut self, v: u32) {
        self.uncompressed_sample_offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &CMsgVoiceAudio| { &m.format },
            |m: &mut CMsgVoiceAudio| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_data",
            |m: &CMsgVoiceAudio| { &m.voice_data },
            |m: &mut CMsgVoiceAudio| { &mut m.voice_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_bytes",
            |m: &CMsgVoiceAudio| { &m.sequence_bytes },
            |m: &mut CMsgVoiceAudio| { &mut m.sequence_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "section_number",
            |m: &CMsgVoiceAudio| { &m.section_number },
            |m: &mut CMsgVoiceAudio| { &mut m.section_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sample_rate",
            |m: &CMsgVoiceAudio| { &m.sample_rate },
            |m: &mut CMsgVoiceAudio| { &mut m.sample_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uncompressed_sample_offset",
            |m: &CMsgVoiceAudio| { &m.uncompressed_sample_offset },
            |m: &mut CMsgVoiceAudio| { &mut m.uncompressed_sample_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVoiceAudio>(
            "CMsgVoiceAudio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVoiceAudio {
    const NAME: &'static str = "CMsgVoiceAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.voice_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.sequence_bytes = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.section_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.sample_rate = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.uncompressed_sample_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.voice_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.sequence_bytes {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.section_number {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.sample_rate {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.uncompressed_sample_offset {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.format {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voice_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.sequence_bytes {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.section_number {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sample_rate {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.uncompressed_sample_offset {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVoiceAudio {
        CMsgVoiceAudio::new()
    }

    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.voice_data = ::std::option::Option::None;
        self.sequence_bytes = ::std::option::Option::None;
        self.section_number = ::std::option::Option::None;
        self.sample_rate = ::std::option::Option::None;
        self.uncompressed_sample_offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVoiceAudio {
        static instance: CMsgVoiceAudio = CMsgVoiceAudio {
            format: ::std::option::Option::None,
            voice_data: ::std::option::Option::None,
            sequence_bytes: ::std::option::Option::None,
            section_number: ::std::option::Option::None,
            sample_rate: ::std::option::Option::None,
            uncompressed_sample_offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVoiceAudio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVoiceAudio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVoiceAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVoiceAudio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_VoiceData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_VoiceData {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.audio)
    pub audio: ::protobuf::MessageField<CMsgVoiceAudio>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.tick)
    pub tick: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_VoiceData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_VoiceData {
    fn default() -> &'a CCLCMsg_VoiceData {
        <CCLCMsg_VoiceData as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_VoiceData {
    pub fn new() -> CCLCMsg_VoiceData {
        ::std::default::Default::default()
    }

    // optional fixed64 xuid = 2;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional uint32 tick = 3;

    pub fn tick(&self) -> u32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: u32) {
        self.tick = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVoiceAudio>(
            "audio",
            |m: &CCLCMsg_VoiceData| { &m.audio },
            |m: &mut CCLCMsg_VoiceData| { &mut m.audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xuid",
            |m: &CCLCMsg_VoiceData| { &m.xuid },
            |m: &mut CCLCMsg_VoiceData| { &mut m.xuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CCLCMsg_VoiceData| { &m.tick },
            |m: &mut CCLCMsg_VoiceData| { &mut m.tick },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_VoiceData>(
            "CCLCMsg_VoiceData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_VoiceData {
    const NAME: &'static str = "CCLCMsg_VoiceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audio)?;
                },
                17 => {
                    self.xuid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.audio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.xuid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.audio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.xuid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.tick {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_VoiceData {
        CCLCMsg_VoiceData::new()
    }

    fn clear(&mut self) {
        self.audio.clear();
        self.xuid = ::std::option::Option::None;
        self.tick = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_VoiceData {
        static instance: CCLCMsg_VoiceData = CCLCMsg_VoiceData {
            audio: ::protobuf::MessageField::none(),
            xuid: ::std::option::Option::None,
            tick: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_VoiceData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_VoiceData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_VoiceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_VoiceData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_BaselineAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_BaselineAck {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_BaselineAck.baseline_tick)
    pub baseline_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_BaselineAck.baseline_nr)
    pub baseline_nr: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_BaselineAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_BaselineAck {
    fn default() -> &'a CCLCMsg_BaselineAck {
        <CCLCMsg_BaselineAck as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_BaselineAck {
    pub fn new() -> CCLCMsg_BaselineAck {
        ::std::default::Default::default()
    }

    // optional int32 baseline_tick = 1;

    pub fn baseline_tick(&self) -> i32 {
        self.baseline_tick.unwrap_or(0)
    }

    pub fn clear_baseline_tick(&mut self) {
        self.baseline_tick = ::std::option::Option::None;
    }

    pub fn has_baseline_tick(&self) -> bool {
        self.baseline_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline_tick(&mut self, v: i32) {
        self.baseline_tick = ::std::option::Option::Some(v);
    }

    // optional int32 baseline_nr = 2;

    pub fn baseline_nr(&self) -> i32 {
        self.baseline_nr.unwrap_or(0)
    }

    pub fn clear_baseline_nr(&mut self) {
        self.baseline_nr = ::std::option::Option::None;
    }

    pub fn has_baseline_nr(&self) -> bool {
        self.baseline_nr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline_nr(&mut self, v: i32) {
        self.baseline_nr = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseline_tick",
            |m: &CCLCMsg_BaselineAck| { &m.baseline_tick },
            |m: &mut CCLCMsg_BaselineAck| { &mut m.baseline_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseline_nr",
            |m: &CCLCMsg_BaselineAck| { &m.baseline_nr },
            |m: &mut CCLCMsg_BaselineAck| { &mut m.baseline_nr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_BaselineAck>(
            "CCLCMsg_BaselineAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_BaselineAck {
    const NAME: &'static str = "CCLCMsg_BaselineAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.baseline_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.baseline_nr = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.baseline_tick {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.baseline_nr {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.baseline_tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.baseline_nr {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_BaselineAck {
        CCLCMsg_BaselineAck::new()
    }

    fn clear(&mut self) {
        self.baseline_tick = ::std::option::Option::None;
        self.baseline_nr = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_BaselineAck {
        static instance: CCLCMsg_BaselineAck = CCLCMsg_BaselineAck {
            baseline_tick: ::std::option::Option::None,
            baseline_nr: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_BaselineAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_BaselineAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_BaselineAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_BaselineAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_ListenEvents)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ListenEvents {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ListenEvents.event_mask)
    pub event_mask: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ListenEvents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ListenEvents {
    fn default() -> &'a CCLCMsg_ListenEvents {
        <CCLCMsg_ListenEvents as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ListenEvents {
    pub fn new() -> CCLCMsg_ListenEvents {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_mask",
            |m: &CCLCMsg_ListenEvents| { &m.event_mask },
            |m: &mut CCLCMsg_ListenEvents| { &mut m.event_mask },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ListenEvents>(
            "CCLCMsg_ListenEvents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ListenEvents {
    const NAME: &'static str = "CCLCMsg_ListenEvents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed32_into(&mut self.event_mask)?;
                },
                13 => {
                    self.event_mask.push(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.event_mask.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.event_mask {
            os.write_fixed32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ListenEvents {
        CCLCMsg_ListenEvents::new()
    }

    fn clear(&mut self) {
        self.event_mask.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ListenEvents {
        static instance: CCLCMsg_ListenEvents = CCLCMsg_ListenEvents {
            event_mask: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ListenEvents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ListenEvents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ListenEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ListenEvents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_RespondCvarValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_RespondCvarValue {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.cookie)
    pub cookie: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.status_code)
    pub status_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_RespondCvarValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_RespondCvarValue {
    fn default() -> &'a CCLCMsg_RespondCvarValue {
        <CCLCMsg_RespondCvarValue as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_RespondCvarValue {
    pub fn new() -> CCLCMsg_RespondCvarValue {
        ::std::default::Default::default()
    }

    // optional int32 cookie = 1;

    pub fn cookie(&self) -> i32 {
        self.cookie.unwrap_or(0)
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = ::std::option::Option::Some(v);
    }

    // optional int32 status_code = 2;

    pub fn status_code(&self) -> i32 {
        self.status_code.unwrap_or(0)
    }

    pub fn clear_status_code(&mut self) {
        self.status_code = ::std::option::Option::None;
    }

    pub fn has_status_code(&self) -> bool {
        self.status_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: i32) {
        self.status_code = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 4;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cookie",
            |m: &CCLCMsg_RespondCvarValue| { &m.cookie },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_code",
            |m: &CCLCMsg_RespondCvarValue| { &m.status_code },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.status_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CCLCMsg_RespondCvarValue| { &m.name },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CCLCMsg_RespondCvarValue| { &m.value },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_RespondCvarValue>(
            "CCLCMsg_RespondCvarValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_RespondCvarValue {
    const NAME: &'static str = "CCLCMsg_RespondCvarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cookie = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.status_code = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cookie {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.status_code {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cookie {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.status_code {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_RespondCvarValue {
        CCLCMsg_RespondCvarValue::new()
    }

    fn clear(&mut self) {
        self.cookie = ::std::option::Option::None;
        self.status_code = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_RespondCvarValue {
        static instance: CCLCMsg_RespondCvarValue = CCLCMsg_RespondCvarValue {
            cookie: ::std::option::Option::None,
            status_code: ::std::option::Option::None,
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_RespondCvarValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_RespondCvarValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_RespondCvarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_RespondCvarValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_FileCRCCheck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_FileCRCCheck {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.code_path)
    pub code_path: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.code_filename)
    pub code_filename: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.crc)
    pub crc: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_FileCRCCheck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_FileCRCCheck {
    fn default() -> &'a CCLCMsg_FileCRCCheck {
        <CCLCMsg_FileCRCCheck as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_FileCRCCheck {
    pub fn new() -> CCLCMsg_FileCRCCheck {
        ::std::default::Default::default()
    }

    // optional int32 code_path = 1;

    pub fn code_path(&self) -> i32 {
        self.code_path.unwrap_or(0)
    }

    pub fn clear_code_path(&mut self) {
        self.code_path = ::std::option::Option::None;
    }

    pub fn has_code_path(&self) -> bool {
        self.code_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_path(&mut self, v: i32) {
        self.code_path = ::std::option::Option::Some(v);
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 code_filename = 3;

    pub fn code_filename(&self) -> i32 {
        self.code_filename.unwrap_or(0)
    }

    pub fn clear_code_filename(&mut self) {
        self.code_filename = ::std::option::Option::None;
    }

    pub fn has_code_filename(&self) -> bool {
        self.code_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_filename(&mut self, v: i32) {
        self.code_filename = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 crc = 5;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code_path",
            |m: &CCLCMsg_FileCRCCheck| { &m.code_path },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.code_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CCLCMsg_FileCRCCheck| { &m.path },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code_filename",
            |m: &CCLCMsg_FileCRCCheck| { &m.code_filename },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.code_filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CCLCMsg_FileCRCCheck| { &m.filename },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc",
            |m: &CCLCMsg_FileCRCCheck| { &m.crc },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.crc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_FileCRCCheck>(
            "CCLCMsg_FileCRCCheck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_FileCRCCheck {
    const NAME: &'static str = "CCLCMsg_FileCRCCheck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code_path = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.code_filename = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                45 => {
                    self.crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code_path {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.code_filename {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.crc {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.code_path {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.code_filename {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.crc {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_FileCRCCheck {
        CCLCMsg_FileCRCCheck::new()
    }

    fn clear(&mut self) {
        self.code_path = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.code_filename = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_FileCRCCheck {
        static instance: CCLCMsg_FileCRCCheck = CCLCMsg_FileCRCCheck {
            code_path: ::std::option::Option::None,
            path: ::std::option::Option::None,
            code_filename: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            crc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_FileCRCCheck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_FileCRCCheck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_FileCRCCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_FileCRCCheck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_LoadingProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_LoadingProgress {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_LoadingProgress.progress)
    pub progress: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_LoadingProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_LoadingProgress {
    fn default() -> &'a CCLCMsg_LoadingProgress {
        <CCLCMsg_LoadingProgress as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_LoadingProgress {
    pub fn new() -> CCLCMsg_LoadingProgress {
        ::std::default::Default::default()
    }

    // optional int32 progress = 1;

    pub fn progress(&self) -> i32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &CCLCMsg_LoadingProgress| { &m.progress },
            |m: &mut CCLCMsg_LoadingProgress| { &mut m.progress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_LoadingProgress>(
            "CCLCMsg_LoadingProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_LoadingProgress {
    const NAME: &'static str = "CCLCMsg_LoadingProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.progress = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.progress {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_LoadingProgress {
        CCLCMsg_LoadingProgress::new()
    }

    fn clear(&mut self) {
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_LoadingProgress {
        static instance: CCLCMsg_LoadingProgress = CCLCMsg_LoadingProgress {
            progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_LoadingProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_LoadingProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_LoadingProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_LoadingProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_SplitPlayerConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_SplitPlayerConnect {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_SplitPlayerConnect.playername)
    pub playername: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_SplitPlayerConnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_SplitPlayerConnect {
    fn default() -> &'a CCLCMsg_SplitPlayerConnect {
        <CCLCMsg_SplitPlayerConnect as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_SplitPlayerConnect {
    pub fn new() -> CCLCMsg_SplitPlayerConnect {
        ::std::default::Default::default()
    }

    // optional string playername = 1;

    pub fn playername(&self) -> &str {
        match self.playername.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_playername(&mut self) {
        self.playername = ::std::option::Option::None;
    }

    pub fn has_playername(&self) -> bool {
        self.playername.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playername(&mut self, v: ::std::string::String) {
        self.playername = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playername(&mut self) -> &mut ::std::string::String {
        if self.playername.is_none() {
            self.playername = ::std::option::Option::Some(::std::string::String::new());
        }
        self.playername.as_mut().unwrap()
    }

    // Take field
    pub fn take_playername(&mut self) -> ::std::string::String {
        self.playername.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playername",
            |m: &CCLCMsg_SplitPlayerConnect| { &m.playername },
            |m: &mut CCLCMsg_SplitPlayerConnect| { &mut m.playername },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_SplitPlayerConnect>(
            "CCLCMsg_SplitPlayerConnect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_SplitPlayerConnect {
    const NAME: &'static str = "CCLCMsg_SplitPlayerConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.playername = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playername.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.playername.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_SplitPlayerConnect {
        CCLCMsg_SplitPlayerConnect::new()
    }

    fn clear(&mut self) {
        self.playername = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_SplitPlayerConnect {
        static instance: CCLCMsg_SplitPlayerConnect = CCLCMsg_SplitPlayerConnect {
            playername: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_SplitPlayerConnect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_SplitPlayerConnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_SplitPlayerConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_SplitPlayerConnect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_ClientMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ClientMessage {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ClientMessage.msg_type)
    pub msg_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientMessage.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ClientMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ClientMessage {
    fn default() -> &'a CCLCMsg_ClientMessage {
        <CCLCMsg_ClientMessage as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ClientMessage {
    pub fn new() -> CCLCMsg_ClientMessage {
        ::std::default::Default::default()
    }

    // optional int32 msg_type = 1;

    pub fn msg_type(&self) -> i32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: i32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CCLCMsg_ClientMessage| { &m.msg_type },
            |m: &mut CCLCMsg_ClientMessage| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CCLCMsg_ClientMessage| { &m.data },
            |m: &mut CCLCMsg_ClientMessage| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ClientMessage>(
            "CCLCMsg_ClientMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ClientMessage {
    const NAME: &'static str = "CCLCMsg_ClientMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ClientMessage {
        CCLCMsg_ClientMessage::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ClientMessage {
        static instance: CCLCMsg_ClientMessage = CCLCMsg_ClientMessage {
            msg_type: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ClientMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ClientMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ClientMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ClientMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_SplitPlayerDisconnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_SplitPlayerDisconnect {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_SplitPlayerDisconnect.slot)
    pub slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_SplitPlayerDisconnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_SplitPlayerDisconnect {
    fn default() -> &'a CCLCMsg_SplitPlayerDisconnect {
        <CCLCMsg_SplitPlayerDisconnect as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_SplitPlayerDisconnect {
    pub fn new() -> CCLCMsg_SplitPlayerDisconnect {
        ::std::default::Default::default()
    }

    // optional int32 slot = 1;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CCLCMsg_SplitPlayerDisconnect| { &m.slot },
            |m: &mut CCLCMsg_SplitPlayerDisconnect| { &mut m.slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_SplitPlayerDisconnect>(
            "CCLCMsg_SplitPlayerDisconnect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_SplitPlayerDisconnect {
    const NAME: &'static str = "CCLCMsg_SplitPlayerDisconnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.slot {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_SplitPlayerDisconnect {
        CCLCMsg_SplitPlayerDisconnect::new()
    }

    fn clear(&mut self) {
        self.slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_SplitPlayerDisconnect {
        static instance: CCLCMsg_SplitPlayerDisconnect = CCLCMsg_SplitPlayerDisconnect {
            slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_SplitPlayerDisconnect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_SplitPlayerDisconnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_SplitPlayerDisconnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_SplitPlayerDisconnect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_ServerStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ServerStatus {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ServerStatus.simplified)
    pub simplified: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ServerStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ServerStatus {
    fn default() -> &'a CCLCMsg_ServerStatus {
        <CCLCMsg_ServerStatus as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ServerStatus {
    pub fn new() -> CCLCMsg_ServerStatus {
        ::std::default::Default::default()
    }

    // optional bool simplified = 1;

    pub fn simplified(&self) -> bool {
        self.simplified.unwrap_or(false)
    }

    pub fn clear_simplified(&mut self) {
        self.simplified = ::std::option::Option::None;
    }

    pub fn has_simplified(&self) -> bool {
        self.simplified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_simplified(&mut self, v: bool) {
        self.simplified = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "simplified",
            |m: &CCLCMsg_ServerStatus| { &m.simplified },
            |m: &mut CCLCMsg_ServerStatus| { &mut m.simplified },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ServerStatus>(
            "CCLCMsg_ServerStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ServerStatus {
    const NAME: &'static str = "CCLCMsg_ServerStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.simplified = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.simplified {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.simplified {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ServerStatus {
        CCLCMsg_ServerStatus::new()
    }

    fn clear(&mut self) {
        self.simplified = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ServerStatus {
        static instance: CCLCMsg_ServerStatus = CCLCMsg_ServerStatus {
            simplified: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ServerStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ServerStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ServerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ServerStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_ServerPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ServerPing {
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ServerPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ServerPing {
    fn default() -> &'a CCLCMsg_ServerPing {
        <CCLCMsg_ServerPing as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ServerPing {
    pub fn new() -> CCLCMsg_ServerPing {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ServerPing>(
            "CCLCMsg_ServerPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ServerPing {
    const NAME: &'static str = "CCLCMsg_ServerPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ServerPing {
        CCLCMsg_ServerPing::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ServerPing {
        static instance: CCLCMsg_ServerPing = CCLCMsg_ServerPing {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ServerPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ServerPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ServerPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ServerPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_RequestPause)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_RequestPause {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_RequestPause.pause_type)
    pub pause_type: ::std::option::Option<::protobuf::EnumOrUnknown<RequestPause_t>>,
    // @@protoc_insertion_point(field:CCLCMsg_RequestPause.pause_group)
    pub pause_group: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_RequestPause.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_RequestPause {
    fn default() -> &'a CCLCMsg_RequestPause {
        <CCLCMsg_RequestPause as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_RequestPause {
    pub fn new() -> CCLCMsg_RequestPause {
        ::std::default::Default::default()
    }

    // optional .RequestPause_t pause_type = 1;

    pub fn pause_type(&self) -> RequestPause_t {
        match self.pause_type {
            Some(e) => e.enum_value_or(RequestPause_t::RP_PAUSE),
            None => RequestPause_t::RP_PAUSE,
        }
    }

    pub fn clear_pause_type(&mut self) {
        self.pause_type = ::std::option::Option::None;
    }

    pub fn has_pause_type(&self) -> bool {
        self.pause_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pause_type(&mut self, v: RequestPause_t) {
        self.pause_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 pause_group = 2;

    pub fn pause_group(&self) -> i32 {
        self.pause_group.unwrap_or(0)
    }

    pub fn clear_pause_group(&mut self) {
        self.pause_group = ::std::option::Option::None;
    }

    pub fn has_pause_group(&self) -> bool {
        self.pause_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pause_group(&mut self, v: i32) {
        self.pause_group = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pause_type",
            |m: &CCLCMsg_RequestPause| { &m.pause_type },
            |m: &mut CCLCMsg_RequestPause| { &mut m.pause_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pause_group",
            |m: &CCLCMsg_RequestPause| { &m.pause_group },
            |m: &mut CCLCMsg_RequestPause| { &mut m.pause_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_RequestPause>(
            "CCLCMsg_RequestPause",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_RequestPause {
    const NAME: &'static str = "CCLCMsg_RequestPause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pause_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.pause_group = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pause_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.pause_group {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pause_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.pause_group {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_RequestPause {
        CCLCMsg_RequestPause::new()
    }

    fn clear(&mut self) {
        self.pause_type = ::std::option::Option::None;
        self.pause_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_RequestPause {
        static instance: CCLCMsg_RequestPause = CCLCMsg_RequestPause {
            pause_type: ::std::option::Option::None,
            pause_group: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_RequestPause {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_RequestPause").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_RequestPause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_RequestPause {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_CmdKeyValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_CmdKeyValues {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_CmdKeyValues.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_CmdKeyValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_CmdKeyValues {
    fn default() -> &'a CCLCMsg_CmdKeyValues {
        <CCLCMsg_CmdKeyValues as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_CmdKeyValues {
    pub fn new() -> CCLCMsg_CmdKeyValues {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CCLCMsg_CmdKeyValues| { &m.data },
            |m: &mut CCLCMsg_CmdKeyValues| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_CmdKeyValues>(
            "CCLCMsg_CmdKeyValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_CmdKeyValues {
    const NAME: &'static str = "CCLCMsg_CmdKeyValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_CmdKeyValues {
        CCLCMsg_CmdKeyValues::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_CmdKeyValues {
        static instance: CCLCMsg_CmdKeyValues = CCLCMsg_CmdKeyValues {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_CmdKeyValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_CmdKeyValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_CmdKeyValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_CmdKeyValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_RconServerDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_RconServerDetails {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_RconServerDetails.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_RconServerDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_RconServerDetails {
    fn default() -> &'a CCLCMsg_RconServerDetails {
        <CCLCMsg_RconServerDetails as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_RconServerDetails {
    pub fn new() -> CCLCMsg_RconServerDetails {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CCLCMsg_RconServerDetails| { &m.token },
            |m: &mut CCLCMsg_RconServerDetails| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_RconServerDetails>(
            "CCLCMsg_RconServerDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_RconServerDetails {
    const NAME: &'static str = "CCLCMsg_RconServerDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_RconServerDetails {
        CCLCMsg_RconServerDetails::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_RconServerDetails {
        static instance: CCLCMsg_RconServerDetails = CCLCMsg_RconServerDetails {
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_RconServerDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_RconServerDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_RconServerDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_RconServerDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_ServerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ServerInfo {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.protocol)
    pub protocol: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.server_count)
    pub server_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_dedicated)
    pub is_dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_hltv)
    pub is_hltv: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.c_os)
    pub c_os: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.max_clients)
    pub max_clients: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.max_classes)
    pub max_classes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.tick_interval)
    pub tick_interval: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.game_dir)
    pub game_dir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.sky_name)
    pub sky_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.host_name)
    pub host_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.addon_name)
    pub addon_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.game_session_config)
    pub game_session_config: ::protobuf::MessageField<super::networkbasetypes::CSVCMsg_GameSessionConfiguration>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.game_session_manifest)
    pub game_session_manifest: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ServerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ServerInfo {
    fn default() -> &'a CSVCMsg_ServerInfo {
        <CSVCMsg_ServerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ServerInfo {
    pub fn new() -> CSVCMsg_ServerInfo {
        ::std::default::Default::default()
    }

    // optional int32 protocol = 1;

    pub fn protocol(&self) -> i32 {
        self.protocol.unwrap_or(0)
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: i32) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // optional int32 server_count = 2;

    pub fn server_count(&self) -> i32 {
        self.server_count.unwrap_or(0)
    }

    pub fn clear_server_count(&mut self) {
        self.server_count = ::std::option::Option::None;
    }

    pub fn has_server_count(&self) -> bool {
        self.server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_count(&mut self, v: i32) {
        self.server_count = ::std::option::Option::Some(v);
    }

    // optional bool is_dedicated = 3;

    pub fn is_dedicated(&self) -> bool {
        self.is_dedicated.unwrap_or(false)
    }

    pub fn clear_is_dedicated(&mut self) {
        self.is_dedicated = ::std::option::Option::None;
    }

    pub fn has_is_dedicated(&self) -> bool {
        self.is_dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dedicated(&mut self, v: bool) {
        self.is_dedicated = ::std::option::Option::Some(v);
    }

    // optional bool is_hltv = 4;

    pub fn is_hltv(&self) -> bool {
        self.is_hltv.unwrap_or(false)
    }

    pub fn clear_is_hltv(&mut self) {
        self.is_hltv = ::std::option::Option::None;
    }

    pub fn has_is_hltv(&self) -> bool {
        self.is_hltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hltv(&mut self, v: bool) {
        self.is_hltv = ::std::option::Option::Some(v);
    }

    // optional int32 c_os = 6;

    pub fn c_os(&self) -> i32 {
        self.c_os.unwrap_or(0)
    }

    pub fn clear_c_os(&mut self) {
        self.c_os = ::std::option::Option::None;
    }

    pub fn has_c_os(&self) -> bool {
        self.c_os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c_os(&mut self, v: i32) {
        self.c_os = ::std::option::Option::Some(v);
    }

    // optional int32 max_clients = 10;

    pub fn max_clients(&self) -> i32 {
        self.max_clients.unwrap_or(0)
    }

    pub fn clear_max_clients(&mut self) {
        self.max_clients = ::std::option::Option::None;
    }

    pub fn has_max_clients(&self) -> bool {
        self.max_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_clients(&mut self, v: i32) {
        self.max_clients = ::std::option::Option::Some(v);
    }

    // optional int32 max_classes = 11;

    pub fn max_classes(&self) -> i32 {
        self.max_classes.unwrap_or(0)
    }

    pub fn clear_max_classes(&mut self) {
        self.max_classes = ::std::option::Option::None;
    }

    pub fn has_max_classes(&self) -> bool {
        self.max_classes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_classes(&mut self, v: i32) {
        self.max_classes = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot = 12;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional float tick_interval = 13;

    pub fn tick_interval(&self) -> f32 {
        self.tick_interval.unwrap_or(0.)
    }

    pub fn clear_tick_interval(&mut self) {
        self.tick_interval = ::std::option::Option::None;
    }

    pub fn has_tick_interval(&self) -> bool {
        self.tick_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_interval(&mut self, v: f32) {
        self.tick_interval = ::std::option::Option::Some(v);
    }

    // optional string game_dir = 14;

    pub fn game_dir(&self) -> &str {
        match self.game_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_dir(&mut self) {
        self.game_dir = ::std::option::Option::None;
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: ::std::string::String) {
        self.game_dir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir(&mut self) -> &mut ::std::string::String {
        if self.game_dir.is_none() {
            self.game_dir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_dir(&mut self) -> ::std::string::String {
        self.game_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map_name = 15;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sky_name = 16;

    pub fn sky_name(&self) -> &str {
        match self.sky_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sky_name(&mut self) {
        self.sky_name = ::std::option::Option::None;
    }

    pub fn has_sky_name(&self) -> bool {
        self.sky_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sky_name(&mut self, v: ::std::string::String) {
        self.sky_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sky_name(&mut self) -> &mut ::std::string::String {
        if self.sky_name.is_none() {
            self.sky_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sky_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sky_name(&mut self) -> ::std::string::String {
        self.sky_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host_name = 17;

    pub fn host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host_name(&mut self) {
        self.host_name = ::std::option::Option::None;
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if self.host_name.is_none() {
            self.host_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string addon_name = 18;

    pub fn addon_name(&self) -> &str {
        match self.addon_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_addon_name(&mut self) {
        self.addon_name = ::std::option::Option::None;
    }

    pub fn has_addon_name(&self) -> bool {
        self.addon_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addon_name(&mut self, v: ::std::string::String) {
        self.addon_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addon_name(&mut self) -> &mut ::std::string::String {
        if self.addon_name.is_none() {
            self.addon_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.addon_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_addon_name(&mut self) -> ::std::string::String {
        self.addon_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes game_session_manifest = 20;

    pub fn game_session_manifest(&self) -> &[u8] {
        match self.game_session_manifest.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_session_manifest(&mut self) {
        self.game_session_manifest = ::std::option::Option::None;
    }

    pub fn has_game_session_manifest(&self) -> bool {
        self.game_session_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_session_manifest(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_session_manifest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_session_manifest(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_session_manifest.is_none() {
            self.game_session_manifest = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_session_manifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_session_manifest(&mut self) -> ::std::vec::Vec<u8> {
        self.game_session_manifest.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &CSVCMsg_ServerInfo| { &m.protocol },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_count",
            |m: &CSVCMsg_ServerInfo| { &m.server_count },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.server_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_dedicated",
            |m: &CSVCMsg_ServerInfo| { &m.is_dedicated },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.is_dedicated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hltv",
            |m: &CSVCMsg_ServerInfo| { &m.is_hltv },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.is_hltv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "c_os",
            |m: &CSVCMsg_ServerInfo| { &m.c_os },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.c_os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_clients",
            |m: &CSVCMsg_ServerInfo| { &m.max_clients },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.max_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_classes",
            |m: &CSVCMsg_ServerInfo| { &m.max_classes },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.max_classes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &CSVCMsg_ServerInfo| { &m.player_slot },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick_interval",
            |m: &CSVCMsg_ServerInfo| { &m.tick_interval },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.tick_interval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_dir",
            |m: &CSVCMsg_ServerInfo| { &m.game_dir },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.game_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &CSVCMsg_ServerInfo| { &m.map_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sky_name",
            |m: &CSVCMsg_ServerInfo| { &m.sky_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.sky_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_name",
            |m: &CSVCMsg_ServerInfo| { &m.host_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.host_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "addon_name",
            |m: &CSVCMsg_ServerInfo| { &m.addon_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.addon_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CSVCMsg_GameSessionConfiguration>(
            "game_session_config",
            |m: &CSVCMsg_ServerInfo| { &m.game_session_config },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.game_session_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_session_manifest",
            |m: &CSVCMsg_ServerInfo| { &m.game_session_manifest },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.game_session_manifest },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_ServerInfo>(
            "CSVCMsg_ServerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_ServerInfo {
    const NAME: &'static str = "CSVCMsg_ServerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.server_count = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.is_dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_hltv = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.c_os = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.max_clients = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.max_classes = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                109 => {
                    self.tick_interval = ::std::option::Option::Some(is.read_float()?);
                },
                114 => {
                    self.game_dir = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.sky_name = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.host_name = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.addon_name = ::std::option::Option::Some(is.read_string()?);
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_session_config)?;
                },
                162 => {
                    self.game_session_manifest = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.server_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.is_dedicated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_hltv {
            my_size += 1 + 1;
        }
        if let Some(v) = self.c_os {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.max_clients {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.max_classes {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.tick_interval {
            my_size += 1 + 4;
        }
        if let Some(v) = self.game_dir.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.sky_name.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.host_name.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.addon_name.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.game_session_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_session_manifest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.server_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.is_dedicated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_hltv {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.c_os {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.max_clients {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.max_classes {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.tick_interval {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.game_dir.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.sky_name.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.host_name.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.addon_name.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.game_session_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.game_session_manifest.as_ref() {
            os.write_bytes(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ServerInfo {
        CSVCMsg_ServerInfo::new()
    }

    fn clear(&mut self) {
        self.protocol = ::std::option::Option::None;
        self.server_count = ::std::option::Option::None;
        self.is_dedicated = ::std::option::Option::None;
        self.is_hltv = ::std::option::Option::None;
        self.c_os = ::std::option::Option::None;
        self.max_clients = ::std::option::Option::None;
        self.max_classes = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.tick_interval = ::std::option::Option::None;
        self.game_dir = ::std::option::Option::None;
        self.map_name = ::std::option::Option::None;
        self.sky_name = ::std::option::Option::None;
        self.host_name = ::std::option::Option::None;
        self.addon_name = ::std::option::Option::None;
        self.game_session_config.clear();
        self.game_session_manifest = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ServerInfo {
        static instance: CSVCMsg_ServerInfo = CSVCMsg_ServerInfo {
            protocol: ::std::option::Option::None,
            server_count: ::std::option::Option::None,
            is_dedicated: ::std::option::Option::None,
            is_hltv: ::std::option::Option::None,
            c_os: ::std::option::Option::None,
            max_clients: ::std::option::Option::None,
            max_classes: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            tick_interval: ::std::option::Option::None,
            game_dir: ::std::option::Option::None,
            map_name: ::std::option::Option::None,
            sky_name: ::std::option::Option::None,
            host_name: ::std::option::Option::None,
            addon_name: ::std::option::Option::None,
            game_session_config: ::protobuf::MessageField::none(),
            game_session_manifest: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_ServerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_ServerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_ServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_ServerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_ClassInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ClassInfo {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.create_on_client)
    pub create_on_client: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.classes)
    pub classes: ::std::vec::Vec<csvcmsg_class_info::Class_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ClassInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ClassInfo {
    fn default() -> &'a CSVCMsg_ClassInfo {
        <CSVCMsg_ClassInfo as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ClassInfo {
    pub fn new() -> CSVCMsg_ClassInfo {
        ::std::default::Default::default()
    }

    // optional bool create_on_client = 1;

    pub fn create_on_client(&self) -> bool {
        self.create_on_client.unwrap_or(false)
    }

    pub fn clear_create_on_client(&mut self) {
        self.create_on_client = ::std::option::Option::None;
    }

    pub fn has_create_on_client(&self) -> bool {
        self.create_on_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_on_client(&mut self, v: bool) {
        self.create_on_client = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "create_on_client",
            |m: &CSVCMsg_ClassInfo| { &m.create_on_client },
            |m: &mut CSVCMsg_ClassInfo| { &mut m.create_on_client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "classes",
            |m: &CSVCMsg_ClassInfo| { &m.classes },
            |m: &mut CSVCMsg_ClassInfo| { &mut m.classes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_ClassInfo>(
            "CSVCMsg_ClassInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_ClassInfo {
    const NAME: &'static str = "CSVCMsg_ClassInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.create_on_client = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.classes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.create_on_client {
            my_size += 1 + 1;
        }
        for value in &self.classes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.create_on_client {
            os.write_bool(1, v)?;
        }
        for v in &self.classes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ClassInfo {
        CSVCMsg_ClassInfo::new()
    }

    fn clear(&mut self) {
        self.create_on_client = ::std::option::Option::None;
        self.classes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ClassInfo {
        static instance: CSVCMsg_ClassInfo = CSVCMsg_ClassInfo {
            create_on_client: ::std::option::Option::None,
            classes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_ClassInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_ClassInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_ClassInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_ClassInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_ClassInfo`
pub mod csvcmsg_class_info {
    // @@protoc_insertion_point(message:CSVCMsg_ClassInfo.class_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Class_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.class_t.class_id)
        pub class_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.class_t.class_name)
        pub class_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_ClassInfo.class_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Class_t {
        fn default() -> &'a Class_t {
            <Class_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Class_t {
        pub fn new() -> Class_t {
            ::std::default::Default::default()
        }

        // optional int32 class_id = 1;

        pub fn class_id(&self) -> i32 {
            self.class_id.unwrap_or(0)
        }

        pub fn clear_class_id(&mut self) {
            self.class_id = ::std::option::Option::None;
        }

        pub fn has_class_id(&self) -> bool {
            self.class_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_id(&mut self, v: i32) {
            self.class_id = ::std::option::Option::Some(v);
        }

        // optional string class_name = 3;

        pub fn class_name(&self) -> &str {
            match self.class_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_class_name(&mut self) {
            self.class_name = ::std::option::Option::None;
        }

        pub fn has_class_name(&self) -> bool {
            self.class_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_name(&mut self, v: ::std::string::String) {
            self.class_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
            if self.class_name.is_none() {
                self.class_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.class_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_class_name(&mut self) -> ::std::string::String {
            self.class_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "class_id",
                |m: &Class_t| { &m.class_id },
                |m: &mut Class_t| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "class_name",
                |m: &Class_t| { &m.class_name },
                |m: &mut Class_t| { &mut m.class_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Class_t>(
                "CSVCMsg_ClassInfo.class_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Class_t {
        const NAME: &'static str = "class_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.class_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.class_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.class_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.class_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.class_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.class_name.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Class_t {
            Class_t::new()
        }

        fn clear(&mut self) {
            self.class_id = ::std::option::Option::None;
            self.class_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Class_t {
            static instance: Class_t = Class_t {
                class_id: ::std::option::Option::None,
                class_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Class_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_ClassInfo.class_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Class_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Class_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_SetPause)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SetPause {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SetPause.paused)
    pub paused: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SetPause.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SetPause {
    fn default() -> &'a CSVCMsg_SetPause {
        <CSVCMsg_SetPause as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SetPause {
    pub fn new() -> CSVCMsg_SetPause {
        ::std::default::Default::default()
    }

    // optional bool paused = 1;

    pub fn paused(&self) -> bool {
        self.paused.unwrap_or(false)
    }

    pub fn clear_paused(&mut self) {
        self.paused = ::std::option::Option::None;
    }

    pub fn has_paused(&self) -> bool {
        self.paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paused(&mut self, v: bool) {
        self.paused = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paused",
            |m: &CSVCMsg_SetPause| { &m.paused },
            |m: &mut CSVCMsg_SetPause| { &mut m.paused },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SetPause>(
            "CSVCMsg_SetPause",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SetPause {
    const NAME: &'static str = "CSVCMsg_SetPause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.paused = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.paused {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.paused {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SetPause {
        CSVCMsg_SetPause::new()
    }

    fn clear(&mut self) {
        self.paused = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SetPause {
        static instance: CSVCMsg_SetPause = CSVCMsg_SetPause {
            paused: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SetPause {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SetPause").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SetPause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SetPause {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_VoiceInit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_VoiceInit {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.quality)
    pub quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.codec)
    pub codec: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.version)
    pub version: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_VoiceInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_VoiceInit {
    fn default() -> &'a CSVCMsg_VoiceInit {
        <CSVCMsg_VoiceInit as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_VoiceInit {
    pub fn new() -> CSVCMsg_VoiceInit {
        ::std::default::Default::default()
    }

    // optional int32 quality = 1;

    pub fn quality(&self) -> i32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional string codec = 2;

    pub fn codec(&self) -> &str {
        match self.codec.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: ::std::string::String) {
        self.codec = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec(&mut self) -> &mut ::std::string::String {
        if self.codec.is_none() {
            self.codec = ::std::option::Option::Some(::std::string::String::new());
        }
        self.codec.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec(&mut self) -> ::std::string::String {
        self.codec.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 version = 3;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0i32)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CSVCMsg_VoiceInit| { &m.quality },
            |m: &mut CSVCMsg_VoiceInit| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "codec",
            |m: &CSVCMsg_VoiceInit| { &m.codec },
            |m: &mut CSVCMsg_VoiceInit| { &mut m.codec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CSVCMsg_VoiceInit| { &m.version },
            |m: &mut CSVCMsg_VoiceInit| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_VoiceInit>(
            "CSVCMsg_VoiceInit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_VoiceInit {
    const NAME: &'static str = "CSVCMsg_VoiceInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quality = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.codec = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.codec.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.codec.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_VoiceInit {
        CSVCMsg_VoiceInit::new()
    }

    fn clear(&mut self) {
        self.quality = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_VoiceInit {
        static instance: CSVCMsg_VoiceInit = CSVCMsg_VoiceInit {
            quality: ::std::option::Option::None,
            codec: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_VoiceInit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_VoiceInit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_VoiceInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_VoiceInit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_Print)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Print {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Print.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Print.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Print {
    fn default() -> &'a CSVCMsg_Print {
        <CSVCMsg_Print as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Print {
    pub fn new() -> CSVCMsg_Print {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CSVCMsg_Print| { &m.text },
            |m: &mut CSVCMsg_Print| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Print>(
            "CSVCMsg_Print",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Print {
    const NAME: &'static str = "CSVCMsg_Print";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Print {
        CSVCMsg_Print::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Print {
        static instance: CSVCMsg_Print = CSVCMsg_Print {
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Print {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Print").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Print {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Print {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_Sounds)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Sounds {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Sounds.reliable_sound)
    pub reliable_sound: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounds)
    pub sounds: ::std::vec::Vec<csvcmsg_sounds::Sounddata_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Sounds.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Sounds {
    fn default() -> &'a CSVCMsg_Sounds {
        <CSVCMsg_Sounds as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Sounds {
    pub fn new() -> CSVCMsg_Sounds {
        ::std::default::Default::default()
    }

    // optional bool reliable_sound = 1;

    pub fn reliable_sound(&self) -> bool {
        self.reliable_sound.unwrap_or(false)
    }

    pub fn clear_reliable_sound(&mut self) {
        self.reliable_sound = ::std::option::Option::None;
    }

    pub fn has_reliable_sound(&self) -> bool {
        self.reliable_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_sound(&mut self, v: bool) {
        self.reliable_sound = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reliable_sound",
            |m: &CSVCMsg_Sounds| { &m.reliable_sound },
            |m: &mut CSVCMsg_Sounds| { &mut m.reliable_sound },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sounds",
            |m: &CSVCMsg_Sounds| { &m.sounds },
            |m: &mut CSVCMsg_Sounds| { &mut m.sounds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Sounds>(
            "CSVCMsg_Sounds",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Sounds {
    const NAME: &'static str = "CSVCMsg_Sounds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable_sound = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.sounds.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_sound {
            my_size += 1 + 1;
        }
        for value in &self.sounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reliable_sound {
            os.write_bool(1, v)?;
        }
        for v in &self.sounds {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Sounds {
        CSVCMsg_Sounds::new()
    }

    fn clear(&mut self) {
        self.reliable_sound = ::std::option::Option::None;
        self.sounds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Sounds {
        static instance: CSVCMsg_Sounds = CSVCMsg_Sounds {
            reliable_sound: ::std::option::Option::None,
            sounds: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Sounds {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Sounds").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Sounds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Sounds {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_Sounds`
pub mod csvcmsg_sounds {
    // @@protoc_insertion_point(message:CSVCMsg_Sounds.sounddata_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sounddata_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_x)
        pub origin_x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_y)
        pub origin_y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_z)
        pub origin_z: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.volume)
        pub volume: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.delay_value)
        pub delay_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sequence_number)
        pub sequence_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.entity_index)
        pub entity_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.channel)
        pub channel: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.pitch)
        pub pitch: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.flags)
        pub flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_num)
        pub sound_num: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_num_handle)
        pub sound_num_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.speaker_entity)
        pub speaker_entity: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.random_seed)
        pub random_seed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_level)
        pub sound_level: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.is_sentence)
        pub is_sentence: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.is_ambient)
        pub is_ambient: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.guid)
        pub guid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_resource_id)
        pub sound_resource_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_Sounds.sounddata_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sounddata_t {
        fn default() -> &'a Sounddata_t {
            <Sounddata_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Sounddata_t {
        pub fn new() -> Sounddata_t {
            ::std::default::Default::default()
        }

        // optional sint32 origin_x = 1;

        pub fn origin_x(&self) -> i32 {
            self.origin_x.unwrap_or(0)
        }

        pub fn clear_origin_x(&mut self) {
            self.origin_x = ::std::option::Option::None;
        }

        pub fn has_origin_x(&self) -> bool {
            self.origin_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_x(&mut self, v: i32) {
            self.origin_x = ::std::option::Option::Some(v);
        }

        // optional sint32 origin_y = 2;

        pub fn origin_y(&self) -> i32 {
            self.origin_y.unwrap_or(0)
        }

        pub fn clear_origin_y(&mut self) {
            self.origin_y = ::std::option::Option::None;
        }

        pub fn has_origin_y(&self) -> bool {
            self.origin_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_y(&mut self, v: i32) {
            self.origin_y = ::std::option::Option::Some(v);
        }

        // optional sint32 origin_z = 3;

        pub fn origin_z(&self) -> i32 {
            self.origin_z.unwrap_or(0)
        }

        pub fn clear_origin_z(&mut self) {
            self.origin_z = ::std::option::Option::None;
        }

        pub fn has_origin_z(&self) -> bool {
            self.origin_z.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_z(&mut self, v: i32) {
            self.origin_z = ::std::option::Option::Some(v);
        }

        // optional uint32 volume = 4;

        pub fn volume(&self) -> u32 {
            self.volume.unwrap_or(0)
        }

        pub fn clear_volume(&mut self) {
            self.volume = ::std::option::Option::None;
        }

        pub fn has_volume(&self) -> bool {
            self.volume.is_some()
        }

        // Param is passed by value, moved
        pub fn set_volume(&mut self, v: u32) {
            self.volume = ::std::option::Option::Some(v);
        }

        // optional float delay_value = 5;

        pub fn delay_value(&self) -> f32 {
            self.delay_value.unwrap_or(0.)
        }

        pub fn clear_delay_value(&mut self) {
            self.delay_value = ::std::option::Option::None;
        }

        pub fn has_delay_value(&self) -> bool {
            self.delay_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delay_value(&mut self, v: f32) {
            self.delay_value = ::std::option::Option::Some(v);
        }

        // optional int32 sequence_number = 6;

        pub fn sequence_number(&self) -> i32 {
            self.sequence_number.unwrap_or(0)
        }

        pub fn clear_sequence_number(&mut self) {
            self.sequence_number = ::std::option::Option::None;
        }

        pub fn has_sequence_number(&self) -> bool {
            self.sequence_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sequence_number(&mut self, v: i32) {
            self.sequence_number = ::std::option::Option::Some(v);
        }

        // optional int32 entity_index = 7;

        pub fn entity_index(&self) -> i32 {
            self.entity_index.unwrap_or(-1i32)
        }

        pub fn clear_entity_index(&mut self) {
            self.entity_index = ::std::option::Option::None;
        }

        pub fn has_entity_index(&self) -> bool {
            self.entity_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_index(&mut self, v: i32) {
            self.entity_index = ::std::option::Option::Some(v);
        }

        // optional int32 channel = 8;

        pub fn channel(&self) -> i32 {
            self.channel.unwrap_or(0)
        }

        pub fn clear_channel(&mut self) {
            self.channel = ::std::option::Option::None;
        }

        pub fn has_channel(&self) -> bool {
            self.channel.is_some()
        }

        // Param is passed by value, moved
        pub fn set_channel(&mut self, v: i32) {
            self.channel = ::std::option::Option::Some(v);
        }

        // optional int32 pitch = 9;

        pub fn pitch(&self) -> i32 {
            self.pitch.unwrap_or(0)
        }

        pub fn clear_pitch(&mut self) {
            self.pitch = ::std::option::Option::None;
        }

        pub fn has_pitch(&self) -> bool {
            self.pitch.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pitch(&mut self, v: i32) {
            self.pitch = ::std::option::Option::Some(v);
        }

        // optional int32 flags = 10;

        pub fn flags(&self) -> i32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: i32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 sound_num = 11;

        pub fn sound_num(&self) -> u32 {
            self.sound_num.unwrap_or(0)
        }

        pub fn clear_sound_num(&mut self) {
            self.sound_num = ::std::option::Option::None;
        }

        pub fn has_sound_num(&self) -> bool {
            self.sound_num.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_num(&mut self, v: u32) {
            self.sound_num = ::std::option::Option::Some(v);
        }

        // optional fixed32 sound_num_handle = 12;

        pub fn sound_num_handle(&self) -> u32 {
            self.sound_num_handle.unwrap_or(0)
        }

        pub fn clear_sound_num_handle(&mut self) {
            self.sound_num_handle = ::std::option::Option::None;
        }

        pub fn has_sound_num_handle(&self) -> bool {
            self.sound_num_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_num_handle(&mut self, v: u32) {
            self.sound_num_handle = ::std::option::Option::Some(v);
        }

        // optional int32 speaker_entity = 13;

        pub fn speaker_entity(&self) -> i32 {
            self.speaker_entity.unwrap_or(0)
        }

        pub fn clear_speaker_entity(&mut self) {
            self.speaker_entity = ::std::option::Option::None;
        }

        pub fn has_speaker_entity(&self) -> bool {
            self.speaker_entity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_speaker_entity(&mut self, v: i32) {
            self.speaker_entity = ::std::option::Option::Some(v);
        }

        // optional int32 random_seed = 14;

        pub fn random_seed(&self) -> i32 {
            self.random_seed.unwrap_or(0)
        }

        pub fn clear_random_seed(&mut self) {
            self.random_seed = ::std::option::Option::None;
        }

        pub fn has_random_seed(&self) -> bool {
            self.random_seed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_random_seed(&mut self, v: i32) {
            self.random_seed = ::std::option::Option::Some(v);
        }

        // optional int32 sound_level = 15;

        pub fn sound_level(&self) -> i32 {
            self.sound_level.unwrap_or(0)
        }

        pub fn clear_sound_level(&mut self) {
            self.sound_level = ::std::option::Option::None;
        }

        pub fn has_sound_level(&self) -> bool {
            self.sound_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_level(&mut self, v: i32) {
            self.sound_level = ::std::option::Option::Some(v);
        }

        // optional bool is_sentence = 16;

        pub fn is_sentence(&self) -> bool {
            self.is_sentence.unwrap_or(false)
        }

        pub fn clear_is_sentence(&mut self) {
            self.is_sentence = ::std::option::Option::None;
        }

        pub fn has_is_sentence(&self) -> bool {
            self.is_sentence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_sentence(&mut self, v: bool) {
            self.is_sentence = ::std::option::Option::Some(v);
        }

        // optional bool is_ambient = 17;

        pub fn is_ambient(&self) -> bool {
            self.is_ambient.unwrap_or(false)
        }

        pub fn clear_is_ambient(&mut self) {
            self.is_ambient = ::std::option::Option::None;
        }

        pub fn has_is_ambient(&self) -> bool {
            self.is_ambient.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_ambient(&mut self, v: bool) {
            self.is_ambient = ::std::option::Option::Some(v);
        }

        // optional uint32 guid = 18;

        pub fn guid(&self) -> u32 {
            self.guid.unwrap_or(0)
        }

        pub fn clear_guid(&mut self) {
            self.guid = ::std::option::Option::None;
        }

        pub fn has_guid(&self) -> bool {
            self.guid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guid(&mut self, v: u32) {
            self.guid = ::std::option::Option::Some(v);
        }

        // optional fixed64 sound_resource_id = 19;

        pub fn sound_resource_id(&self) -> u64 {
            self.sound_resource_id.unwrap_or(0)
        }

        pub fn clear_sound_resource_id(&mut self) {
            self.sound_resource_id = ::std::option::Option::None;
        }

        pub fn has_sound_resource_id(&self) -> bool {
            self.sound_resource_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_resource_id(&mut self, v: u64) {
            self.sound_resource_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(19);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_x",
                |m: &Sounddata_t| { &m.origin_x },
                |m: &mut Sounddata_t| { &mut m.origin_x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_y",
                |m: &Sounddata_t| { &m.origin_y },
                |m: &mut Sounddata_t| { &mut m.origin_y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_z",
                |m: &Sounddata_t| { &m.origin_z },
                |m: &mut Sounddata_t| { &mut m.origin_z },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "volume",
                |m: &Sounddata_t| { &m.volume },
                |m: &mut Sounddata_t| { &mut m.volume },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "delay_value",
                |m: &Sounddata_t| { &m.delay_value },
                |m: &mut Sounddata_t| { &mut m.delay_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sequence_number",
                |m: &Sounddata_t| { &m.sequence_number },
                |m: &mut Sounddata_t| { &mut m.sequence_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_index",
                |m: &Sounddata_t| { &m.entity_index },
                |m: &mut Sounddata_t| { &mut m.entity_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "channel",
                |m: &Sounddata_t| { &m.channel },
                |m: &mut Sounddata_t| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pitch",
                |m: &Sounddata_t| { &m.pitch },
                |m: &mut Sounddata_t| { &mut m.pitch },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &Sounddata_t| { &m.flags },
                |m: &mut Sounddata_t| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_num",
                |m: &Sounddata_t| { &m.sound_num },
                |m: &mut Sounddata_t| { &mut m.sound_num },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_num_handle",
                |m: &Sounddata_t| { &m.sound_num_handle },
                |m: &mut Sounddata_t| { &mut m.sound_num_handle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "speaker_entity",
                |m: &Sounddata_t| { &m.speaker_entity },
                |m: &mut Sounddata_t| { &mut m.speaker_entity },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "random_seed",
                |m: &Sounddata_t| { &m.random_seed },
                |m: &mut Sounddata_t| { &mut m.random_seed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_level",
                |m: &Sounddata_t| { &m.sound_level },
                |m: &mut Sounddata_t| { &mut m.sound_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_sentence",
                |m: &Sounddata_t| { &m.is_sentence },
                |m: &mut Sounddata_t| { &mut m.is_sentence },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_ambient",
                |m: &Sounddata_t| { &m.is_ambient },
                |m: &mut Sounddata_t| { &mut m.is_ambient },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guid",
                |m: &Sounddata_t| { &m.guid },
                |m: &mut Sounddata_t| { &mut m.guid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_resource_id",
                |m: &Sounddata_t| { &m.sound_resource_id },
                |m: &mut Sounddata_t| { &mut m.sound_resource_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sounddata_t>(
                "CSVCMsg_Sounds.sounddata_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sounddata_t {
        const NAME: &'static str = "sounddata_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.origin_x = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    16 => {
                        self.origin_y = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    24 => {
                        self.origin_z = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    32 => {
                        self.volume = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    45 => {
                        self.delay_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.sequence_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.channel = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.pitch = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.sound_num = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    101 => {
                        self.sound_num_handle = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    104 => {
                        self.speaker_entity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.random_seed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.sound_level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    128 => {
                        self.is_sentence = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.is_ambient = ::std::option::Option::Some(is.read_bool()?);
                    },
                    144 => {
                        self.guid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    153 => {
                        self.sound_resource_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.origin_x {
                my_size += ::protobuf::rt::sint32_size(1, v);
            }
            if let Some(v) = self.origin_y {
                my_size += ::protobuf::rt::sint32_size(2, v);
            }
            if let Some(v) = self.origin_z {
                my_size += ::protobuf::rt::sint32_size(3, v);
            }
            if let Some(v) = self.volume {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.delay_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.sequence_number {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.entity_index {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.channel {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.pitch {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.sound_num {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.sound_num_handle {
                my_size += 1 + 4;
            }
            if let Some(v) = self.speaker_entity {
                my_size += ::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.random_seed {
                my_size += ::protobuf::rt::int32_size(14, v);
            }
            if let Some(v) = self.sound_level {
                my_size += ::protobuf::rt::int32_size(15, v);
            }
            if let Some(v) = self.is_sentence {
                my_size += 2 + 1;
            }
            if let Some(v) = self.is_ambient {
                my_size += 2 + 1;
            }
            if let Some(v) = self.guid {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.sound_resource_id {
                my_size += 2 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.origin_x {
                os.write_sint32(1, v)?;
            }
            if let Some(v) = self.origin_y {
                os.write_sint32(2, v)?;
            }
            if let Some(v) = self.origin_z {
                os.write_sint32(3, v)?;
            }
            if let Some(v) = self.volume {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.delay_value {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.sequence_number {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.entity_index {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.channel {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.pitch {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.flags {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.sound_num {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.sound_num_handle {
                os.write_fixed32(12, v)?;
            }
            if let Some(v) = self.speaker_entity {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.random_seed {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.sound_level {
                os.write_int32(15, v)?;
            }
            if let Some(v) = self.is_sentence {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.is_ambient {
                os.write_bool(17, v)?;
            }
            if let Some(v) = self.guid {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.sound_resource_id {
                os.write_fixed64(19, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sounddata_t {
            Sounddata_t::new()
        }

        fn clear(&mut self) {
            self.origin_x = ::std::option::Option::None;
            self.origin_y = ::std::option::Option::None;
            self.origin_z = ::std::option::Option::None;
            self.volume = ::std::option::Option::None;
            self.delay_value = ::std::option::Option::None;
            self.sequence_number = ::std::option::Option::None;
            self.entity_index = ::std::option::Option::None;
            self.channel = ::std::option::Option::None;
            self.pitch = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.sound_num = ::std::option::Option::None;
            self.sound_num_handle = ::std::option::Option::None;
            self.speaker_entity = ::std::option::Option::None;
            self.random_seed = ::std::option::Option::None;
            self.sound_level = ::std::option::Option::None;
            self.is_sentence = ::std::option::Option::None;
            self.is_ambient = ::std::option::Option::None;
            self.guid = ::std::option::Option::None;
            self.sound_resource_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sounddata_t {
            static instance: Sounddata_t = Sounddata_t {
                origin_x: ::std::option::Option::None,
                origin_y: ::std::option::Option::None,
                origin_z: ::std::option::Option::None,
                volume: ::std::option::Option::None,
                delay_value: ::std::option::Option::None,
                sequence_number: ::std::option::Option::None,
                entity_index: ::std::option::Option::None,
                channel: ::std::option::Option::None,
                pitch: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                sound_num: ::std::option::Option::None,
                sound_num_handle: ::std::option::Option::None,
                speaker_entity: ::std::option::Option::None,
                random_seed: ::std::option::Option::None,
                sound_level: ::std::option::Option::None,
                is_sentence: ::std::option::Option::None,
                is_ambient: ::std::option::Option::None,
                guid: ::std::option::Option::None,
                sound_resource_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sounddata_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_Sounds.sounddata_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sounddata_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sounddata_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_Prefetch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Prefetch {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Prefetch.sound_index)
    pub sound_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_Prefetch.resource_type)
    pub resource_type: ::std::option::Option<::protobuf::EnumOrUnknown<PrefetchType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Prefetch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Prefetch {
    fn default() -> &'a CSVCMsg_Prefetch {
        <CSVCMsg_Prefetch as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Prefetch {
    pub fn new() -> CSVCMsg_Prefetch {
        ::std::default::Default::default()
    }

    // optional int32 sound_index = 1;

    pub fn sound_index(&self) -> i32 {
        self.sound_index.unwrap_or(0)
    }

    pub fn clear_sound_index(&mut self) {
        self.sound_index = ::std::option::Option::None;
    }

    pub fn has_sound_index(&self) -> bool {
        self.sound_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound_index(&mut self, v: i32) {
        self.sound_index = ::std::option::Option::Some(v);
    }

    // optional .PrefetchType resource_type = 2;

    pub fn resource_type(&self) -> PrefetchType {
        match self.resource_type {
            Some(e) => e.enum_value_or(PrefetchType::PFT_SOUND),
            None => PrefetchType::PFT_SOUND,
        }
    }

    pub fn clear_resource_type(&mut self) {
        self.resource_type = ::std::option::Option::None;
    }

    pub fn has_resource_type(&self) -> bool {
        self.resource_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource_type(&mut self, v: PrefetchType) {
        self.resource_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sound_index",
            |m: &CSVCMsg_Prefetch| { &m.sound_index },
            |m: &mut CSVCMsg_Prefetch| { &mut m.sound_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource_type",
            |m: &CSVCMsg_Prefetch| { &m.resource_type },
            |m: &mut CSVCMsg_Prefetch| { &mut m.resource_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Prefetch>(
            "CSVCMsg_Prefetch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Prefetch {
    const NAME: &'static str = "CSVCMsg_Prefetch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sound_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.resource_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sound_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.resource_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sound_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.resource_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Prefetch {
        CSVCMsg_Prefetch::new()
    }

    fn clear(&mut self) {
        self.sound_index = ::std::option::Option::None;
        self.resource_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Prefetch {
        static instance: CSVCMsg_Prefetch = CSVCMsg_Prefetch {
            sound_index: ::std::option::Option::None,
            resource_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Prefetch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Prefetch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Prefetch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Prefetch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_SetView)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SetView {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SetView.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_SetView.slot)
    pub slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SetView.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SetView {
    fn default() -> &'a CSVCMsg_SetView {
        <CSVCMsg_SetView as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SetView {
    pub fn new() -> CSVCMsg_SetView {
        ::std::default::Default::default()
    }

    // optional int32 entity_index = 1;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(-1i32)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional int32 slot = 2;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(-1i32)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_index",
            |m: &CSVCMsg_SetView| { &m.entity_index },
            |m: &mut CSVCMsg_SetView| { &mut m.entity_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CSVCMsg_SetView| { &m.slot },
            |m: &mut CSVCMsg_SetView| { &mut m.slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SetView>(
            "CSVCMsg_SetView",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SetView {
    const NAME: &'static str = "CSVCMsg_SetView";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slot {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SetView {
        CSVCMsg_SetView::new()
    }

    fn clear(&mut self) {
        self.entity_index = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SetView {
        static instance: CSVCMsg_SetView = CSVCMsg_SetView {
            entity_index: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SetView {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SetView").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SetView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SetView {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_FixAngle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_FixAngle {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_FixAngle.relative)
    pub relative: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_FixAngle.angle)
    pub angle: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_FixAngle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_FixAngle {
    fn default() -> &'a CSVCMsg_FixAngle {
        <CSVCMsg_FixAngle as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_FixAngle {
    pub fn new() -> CSVCMsg_FixAngle {
        ::std::default::Default::default()
    }

    // optional bool relative = 1;

    pub fn relative(&self) -> bool {
        self.relative.unwrap_or(false)
    }

    pub fn clear_relative(&mut self) {
        self.relative = ::std::option::Option::None;
    }

    pub fn has_relative(&self) -> bool {
        self.relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relative(&mut self, v: bool) {
        self.relative = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relative",
            |m: &CSVCMsg_FixAngle| { &m.relative },
            |m: &mut CSVCMsg_FixAngle| { &mut m.relative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "angle",
            |m: &CSVCMsg_FixAngle| { &m.angle },
            |m: &mut CSVCMsg_FixAngle| { &mut m.angle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_FixAngle>(
            "CSVCMsg_FixAngle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_FixAngle {
    const NAME: &'static str = "CSVCMsg_FixAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.relative = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.relative {
            my_size += 1 + 1;
        }
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.relative {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.angle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_FixAngle {
        CSVCMsg_FixAngle::new()
    }

    fn clear(&mut self) {
        self.relative = ::std::option::Option::None;
        self.angle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_FixAngle {
        static instance: CSVCMsg_FixAngle = CSVCMsg_FixAngle {
            relative: ::std::option::Option::None,
            angle: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_FixAngle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_FixAngle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_FixAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_FixAngle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_CrosshairAngle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_CrosshairAngle {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CrosshairAngle.angle)
    pub angle: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CrosshairAngle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CrosshairAngle {
    fn default() -> &'a CSVCMsg_CrosshairAngle {
        <CSVCMsg_CrosshairAngle as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CrosshairAngle {
    pub fn new() -> CSVCMsg_CrosshairAngle {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "angle",
            |m: &CSVCMsg_CrosshairAngle| { &m.angle },
            |m: &mut CSVCMsg_CrosshairAngle| { &mut m.angle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_CrosshairAngle>(
            "CSVCMsg_CrosshairAngle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_CrosshairAngle {
    const NAME: &'static str = "CSVCMsg_CrosshairAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.angle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CrosshairAngle {
        CSVCMsg_CrosshairAngle::new()
    }

    fn clear(&mut self) {
        self.angle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CrosshairAngle {
        static instance: CSVCMsg_CrosshairAngle = CSVCMsg_CrosshairAngle {
            angle: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_CrosshairAngle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_CrosshairAngle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_CrosshairAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_CrosshairAngle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_BSPDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_BSPDecal {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.pos)
    pub pos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.decal_texture_index)
    pub decal_texture_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.model_index)
    pub model_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.low_priority)
    pub low_priority: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_BSPDecal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_BSPDecal {
    fn default() -> &'a CSVCMsg_BSPDecal {
        <CSVCMsg_BSPDecal as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_BSPDecal {
    pub fn new() -> CSVCMsg_BSPDecal {
        ::std::default::Default::default()
    }

    // optional int32 decal_texture_index = 2;

    pub fn decal_texture_index(&self) -> i32 {
        self.decal_texture_index.unwrap_or(0)
    }

    pub fn clear_decal_texture_index(&mut self) {
        self.decal_texture_index = ::std::option::Option::None;
    }

    pub fn has_decal_texture_index(&self) -> bool {
        self.decal_texture_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decal_texture_index(&mut self, v: i32) {
        self.decal_texture_index = ::std::option::Option::Some(v);
    }

    // optional int32 entity_index = 3;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(-1i32)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional int32 model_index = 4;

    pub fn model_index(&self) -> i32 {
        self.model_index.unwrap_or(0)
    }

    pub fn clear_model_index(&mut self) {
        self.model_index = ::std::option::Option::None;
    }

    pub fn has_model_index(&self) -> bool {
        self.model_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_index(&mut self, v: i32) {
        self.model_index = ::std::option::Option::Some(v);
    }

    // optional bool low_priority = 5;

    pub fn low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "pos",
            |m: &CSVCMsg_BSPDecal| { &m.pos },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decal_texture_index",
            |m: &CSVCMsg_BSPDecal| { &m.decal_texture_index },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.decal_texture_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_index",
            |m: &CSVCMsg_BSPDecal| { &m.entity_index },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.entity_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "model_index",
            |m: &CSVCMsg_BSPDecal| { &m.model_index },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.model_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_priority",
            |m: &CSVCMsg_BSPDecal| { &m.low_priority },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.low_priority },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_BSPDecal>(
            "CSVCMsg_BSPDecal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_BSPDecal {
    const NAME: &'static str = "CSVCMsg_BSPDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                16 => {
                    self.decal_texture_index = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.model_index = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.decal_texture_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.model_index {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.low_priority {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.decal_texture_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity_index {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.model_index {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_BSPDecal {
        CSVCMsg_BSPDecal::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.decal_texture_index = ::std::option::Option::None;
        self.entity_index = ::std::option::Option::None;
        self.model_index = ::std::option::Option::None;
        self.low_priority = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_BSPDecal {
        static instance: CSVCMsg_BSPDecal = CSVCMsg_BSPDecal {
            pos: ::protobuf::MessageField::none(),
            decal_texture_index: ::std::option::Option::None,
            entity_index: ::std::option::Option::None,
            model_index: ::std::option::Option::None,
            low_priority: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_BSPDecal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_BSPDecal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_BSPDecal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_BSPDecal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_SplitScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SplitScreen {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ESplitScreenMessageType>>,
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.slot)
    pub slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.player_index)
    pub player_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SplitScreen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SplitScreen {
    fn default() -> &'a CSVCMsg_SplitScreen {
        <CSVCMsg_SplitScreen as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SplitScreen {
    pub fn new() -> CSVCMsg_SplitScreen {
        ::std::default::Default::default()
    }

    // optional .ESplitScreenMessageType type = 1;

    pub fn type_(&self) -> ESplitScreenMessageType {
        match self.type_ {
            Some(e) => e.enum_value_or(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            None => ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ESplitScreenMessageType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 slot = 2;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional int32 player_index = 3;

    pub fn player_index(&self) -> i32 {
        self.player_index.unwrap_or(-1i32)
    }

    pub fn clear_player_index(&mut self) {
        self.player_index = ::std::option::Option::None;
    }

    pub fn has_player_index(&self) -> bool {
        self.player_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_index(&mut self, v: i32) {
        self.player_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CSVCMsg_SplitScreen| { &m.type_ },
            |m: &mut CSVCMsg_SplitScreen| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CSVCMsg_SplitScreen| { &m.slot },
            |m: &mut CSVCMsg_SplitScreen| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_index",
            |m: &CSVCMsg_SplitScreen| { &m.player_index },
            |m: &mut CSVCMsg_SplitScreen| { &mut m.player_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SplitScreen>(
            "CSVCMsg_SplitScreen",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SplitScreen {
    const NAME: &'static str = "CSVCMsg_SplitScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.player_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.player_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.slot {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.player_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SplitScreen {
        CSVCMsg_SplitScreen::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.player_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SplitScreen {
        static instance: CSVCMsg_SplitScreen = CSVCMsg_SplitScreen {
            type_: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            player_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SplitScreen {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SplitScreen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SplitScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SplitScreen {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_GetCvarValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_GetCvarValue {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GetCvarValue.cookie)
    pub cookie: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_GetCvarValue.cvar_name)
    pub cvar_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GetCvarValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GetCvarValue {
    fn default() -> &'a CSVCMsg_GetCvarValue {
        <CSVCMsg_GetCvarValue as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GetCvarValue {
    pub fn new() -> CSVCMsg_GetCvarValue {
        ::std::default::Default::default()
    }

    // optional int32 cookie = 1;

    pub fn cookie(&self) -> i32 {
        self.cookie.unwrap_or(0)
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = ::std::option::Option::Some(v);
    }

    // optional string cvar_name = 2;

    pub fn cvar_name(&self) -> &str {
        match self.cvar_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cvar_name(&mut self) {
        self.cvar_name = ::std::option::Option::None;
    }

    pub fn has_cvar_name(&self) -> bool {
        self.cvar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cvar_name(&mut self, v: ::std::string::String) {
        self.cvar_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cvar_name(&mut self) -> &mut ::std::string::String {
        if self.cvar_name.is_none() {
            self.cvar_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cvar_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_cvar_name(&mut self) -> ::std::string::String {
        self.cvar_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cookie",
            |m: &CSVCMsg_GetCvarValue| { &m.cookie },
            |m: &mut CSVCMsg_GetCvarValue| { &mut m.cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cvar_name",
            |m: &CSVCMsg_GetCvarValue| { &m.cvar_name },
            |m: &mut CSVCMsg_GetCvarValue| { &mut m.cvar_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_GetCvarValue>(
            "CSVCMsg_GetCvarValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_GetCvarValue {
    const NAME: &'static str = "CSVCMsg_GetCvarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cookie = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.cvar_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cookie {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.cvar_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cookie {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.cvar_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GetCvarValue {
        CSVCMsg_GetCvarValue::new()
    }

    fn clear(&mut self) {
        self.cookie = ::std::option::Option::None;
        self.cvar_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GetCvarValue {
        static instance: CSVCMsg_GetCvarValue = CSVCMsg_GetCvarValue {
            cookie: ::std::option::Option::None,
            cvar_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_GetCvarValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_GetCvarValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_GetCvarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_GetCvarValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_Menu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Menu {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Menu.dialog_type)
    pub dialog_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_Menu.menu_key_values)
    pub menu_key_values: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Menu.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Menu {
    fn default() -> &'a CSVCMsg_Menu {
        <CSVCMsg_Menu as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Menu {
    pub fn new() -> CSVCMsg_Menu {
        ::std::default::Default::default()
    }

    // optional int32 dialog_type = 1;

    pub fn dialog_type(&self) -> i32 {
        self.dialog_type.unwrap_or(0)
    }

    pub fn clear_dialog_type(&mut self) {
        self.dialog_type = ::std::option::Option::None;
    }

    pub fn has_dialog_type(&self) -> bool {
        self.dialog_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dialog_type(&mut self, v: i32) {
        self.dialog_type = ::std::option::Option::Some(v);
    }

    // optional bytes menu_key_values = 2;

    pub fn menu_key_values(&self) -> &[u8] {
        match self.menu_key_values.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_menu_key_values(&mut self) {
        self.menu_key_values = ::std::option::Option::None;
    }

    pub fn has_menu_key_values(&self) -> bool {
        self.menu_key_values.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_key_values(&mut self, v: ::std::vec::Vec<u8>) {
        self.menu_key_values = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu_key_values(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.menu_key_values.is_none() {
            self.menu_key_values = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.menu_key_values.as_mut().unwrap()
    }

    // Take field
    pub fn take_menu_key_values(&mut self) -> ::std::vec::Vec<u8> {
        self.menu_key_values.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dialog_type",
            |m: &CSVCMsg_Menu| { &m.dialog_type },
            |m: &mut CSVCMsg_Menu| { &mut m.dialog_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "menu_key_values",
            |m: &CSVCMsg_Menu| { &m.menu_key_values },
            |m: &mut CSVCMsg_Menu| { &mut m.menu_key_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Menu>(
            "CSVCMsg_Menu",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Menu {
    const NAME: &'static str = "CSVCMsg_Menu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dialog_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.menu_key_values = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dialog_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.menu_key_values.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dialog_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.menu_key_values.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Menu {
        CSVCMsg_Menu::new()
    }

    fn clear(&mut self) {
        self.dialog_type = ::std::option::Option::None;
        self.menu_key_values = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Menu {
        static instance: CSVCMsg_Menu = CSVCMsg_Menu {
            dialog_type: ::std::option::Option::None,
            menu_key_values: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Menu {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Menu").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Menu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Menu {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_UserMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_UserMessage {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.msg_type)
    pub msg_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.msg_data)
    pub msg_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.passthrough)
    pub passthrough: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_UserMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_UserMessage {
    fn default() -> &'a CSVCMsg_UserMessage {
        <CSVCMsg_UserMessage as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_UserMessage {
    pub fn new() -> CSVCMsg_UserMessage {
        ::std::default::Default::default()
    }

    // optional int32 msg_type = 1;

    pub fn msg_type(&self) -> i32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: i32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes msg_data = 2;

    pub fn msg_data(&self) -> &[u8] {
        match self.msg_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_msg_data(&mut self) {
        self.msg_data = ::std::option::Option::None;
    }

    pub fn has_msg_data(&self) -> bool {
        self.msg_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.msg_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.msg_data.is_none() {
            self.msg_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.msg_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_data(&mut self) -> ::std::vec::Vec<u8> {
        self.msg_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 passthrough = 3;

    pub fn passthrough(&self) -> i32 {
        self.passthrough.unwrap_or(0)
    }

    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: i32) {
        self.passthrough = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CSVCMsg_UserMessage| { &m.msg_type },
            |m: &mut CSVCMsg_UserMessage| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_data",
            |m: &CSVCMsg_UserMessage| { &m.msg_data },
            |m: &mut CSVCMsg_UserMessage| { &mut m.msg_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passthrough",
            |m: &CSVCMsg_UserMessage| { &m.passthrough },
            |m: &mut CSVCMsg_UserMessage| { &mut m.passthrough },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_UserMessage>(
            "CSVCMsg_UserMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_UserMessage {
    const NAME: &'static str = "CSVCMsg_UserMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.msg_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.passthrough = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.msg_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.passthrough {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.msg_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.passthrough {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_UserMessage {
        CSVCMsg_UserMessage::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.msg_data = ::std::option::Option::None;
        self.passthrough = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_UserMessage {
        static instance: CSVCMsg_UserMessage = CSVCMsg_UserMessage {
            msg_type: ::std::option::Option::None,
            msg_data: ::std::option::Option::None,
            passthrough: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_UserMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_UserMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_UserMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_UserMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_SendTable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SendTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.is_end)
    pub is_end: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.net_table_name)
    pub net_table_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.needs_decoder)
    pub needs_decoder: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.props)
    pub props: ::std::vec::Vec<csvcmsg_send_table::Sendprop_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SendTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SendTable {
    fn default() -> &'a CSVCMsg_SendTable {
        <CSVCMsg_SendTable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SendTable {
    pub fn new() -> CSVCMsg_SendTable {
        ::std::default::Default::default()
    }

    // optional bool is_end = 1;

    pub fn is_end(&self) -> bool {
        self.is_end.unwrap_or(false)
    }

    pub fn clear_is_end(&mut self) {
        self.is_end = ::std::option::Option::None;
    }

    pub fn has_is_end(&self) -> bool {
        self.is_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_end(&mut self, v: bool) {
        self.is_end = ::std::option::Option::Some(v);
    }

    // optional string net_table_name = 2;

    pub fn net_table_name(&self) -> &str {
        match self.net_table_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_net_table_name(&mut self) {
        self.net_table_name = ::std::option::Option::None;
    }

    pub fn has_net_table_name(&self) -> bool {
        self.net_table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_table_name(&mut self, v: ::std::string::String) {
        self.net_table_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_table_name(&mut self) -> &mut ::std::string::String {
        if self.net_table_name.is_none() {
            self.net_table_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.net_table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_table_name(&mut self) -> ::std::string::String {
        self.net_table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool needs_decoder = 3;

    pub fn needs_decoder(&self) -> bool {
        self.needs_decoder.unwrap_or(false)
    }

    pub fn clear_needs_decoder(&mut self) {
        self.needs_decoder = ::std::option::Option::None;
    }

    pub fn has_needs_decoder(&self) -> bool {
        self.needs_decoder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_decoder(&mut self, v: bool) {
        self.needs_decoder = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_end",
            |m: &CSVCMsg_SendTable| { &m.is_end },
            |m: &mut CSVCMsg_SendTable| { &mut m.is_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_table_name",
            |m: &CSVCMsg_SendTable| { &m.net_table_name },
            |m: &mut CSVCMsg_SendTable| { &mut m.net_table_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_decoder",
            |m: &CSVCMsg_SendTable| { &m.needs_decoder },
            |m: &mut CSVCMsg_SendTable| { &mut m.needs_decoder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "props",
            |m: &CSVCMsg_SendTable| { &m.props },
            |m: &mut CSVCMsg_SendTable| { &mut m.props },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SendTable>(
            "CSVCMsg_SendTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SendTable {
    const NAME: &'static str = "CSVCMsg_SendTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_end = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.net_table_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.needs_decoder = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.props.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_end {
            my_size += 1 + 1;
        }
        if let Some(v) = self.net_table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.needs_decoder {
            my_size += 1 + 1;
        }
        for value in &self.props {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_end {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.net_table_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.needs_decoder {
            os.write_bool(3, v)?;
        }
        for v in &self.props {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SendTable {
        CSVCMsg_SendTable::new()
    }

    fn clear(&mut self) {
        self.is_end = ::std::option::Option::None;
        self.net_table_name = ::std::option::Option::None;
        self.needs_decoder = ::std::option::Option::None;
        self.props.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SendTable {
        static instance: CSVCMsg_SendTable = CSVCMsg_SendTable {
            is_end: ::std::option::Option::None,
            net_table_name: ::std::option::Option::None,
            needs_decoder: ::std::option::Option::None,
            props: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SendTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SendTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SendTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SendTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_SendTable`
pub mod csvcmsg_send_table {
    // @@protoc_insertion_point(message:CSVCMsg_SendTable.sendprop_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sendprop_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.var_name)
        pub var_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.flags)
        pub flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.priority)
        pub priority: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.dt_name)
        pub dt_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.num_elements)
        pub num_elements: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.low_value)
        pub low_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.high_value)
        pub high_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.num_bits)
        pub num_bits: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_SendTable.sendprop_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sendprop_t {
        fn default() -> &'a Sendprop_t {
            <Sendprop_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Sendprop_t {
        pub fn new() -> Sendprop_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string var_name = 2;

        pub fn var_name(&self) -> &str {
            match self.var_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_var_name(&mut self) {
            self.var_name = ::std::option::Option::None;
        }

        pub fn has_var_name(&self) -> bool {
            self.var_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_var_name(&mut self, v: ::std::string::String) {
            self.var_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_var_name(&mut self) -> &mut ::std::string::String {
            if self.var_name.is_none() {
                self.var_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.var_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_var_name(&mut self) -> ::std::string::String {
            self.var_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 flags = 3;

        pub fn flags(&self) -> i32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: i32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional int32 priority = 4;

        pub fn priority(&self) -> i32 {
            self.priority.unwrap_or(0)
        }

        pub fn clear_priority(&mut self) {
            self.priority = ::std::option::Option::None;
        }

        pub fn has_priority(&self) -> bool {
            self.priority.is_some()
        }

        // Param is passed by value, moved
        pub fn set_priority(&mut self, v: i32) {
            self.priority = ::std::option::Option::Some(v);
        }

        // optional string dt_name = 5;

        pub fn dt_name(&self) -> &str {
            match self.dt_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dt_name(&mut self) {
            self.dt_name = ::std::option::Option::None;
        }

        pub fn has_dt_name(&self) -> bool {
            self.dt_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dt_name(&mut self, v: ::std::string::String) {
            self.dt_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dt_name(&mut self) -> &mut ::std::string::String {
            if self.dt_name.is_none() {
                self.dt_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.dt_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_dt_name(&mut self) -> ::std::string::String {
            self.dt_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 num_elements = 6;

        pub fn num_elements(&self) -> i32 {
            self.num_elements.unwrap_or(0)
        }

        pub fn clear_num_elements(&mut self) {
            self.num_elements = ::std::option::Option::None;
        }

        pub fn has_num_elements(&self) -> bool {
            self.num_elements.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_elements(&mut self, v: i32) {
            self.num_elements = ::std::option::Option::Some(v);
        }

        // optional float low_value = 7;

        pub fn low_value(&self) -> f32 {
            self.low_value.unwrap_or(0.)
        }

        pub fn clear_low_value(&mut self) {
            self.low_value = ::std::option::Option::None;
        }

        pub fn has_low_value(&self) -> bool {
            self.low_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_low_value(&mut self, v: f32) {
            self.low_value = ::std::option::Option::Some(v);
        }

        // optional float high_value = 8;

        pub fn high_value(&self) -> f32 {
            self.high_value.unwrap_or(0.)
        }

        pub fn clear_high_value(&mut self) {
            self.high_value = ::std::option::Option::None;
        }

        pub fn has_high_value(&self) -> bool {
            self.high_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_high_value(&mut self, v: f32) {
            self.high_value = ::std::option::Option::Some(v);
        }

        // optional int32 num_bits = 9;

        pub fn num_bits(&self) -> i32 {
            self.num_bits.unwrap_or(0)
        }

        pub fn clear_num_bits(&mut self) {
            self.num_bits = ::std::option::Option::None;
        }

        pub fn has_num_bits(&self) -> bool {
            self.num_bits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_bits(&mut self, v: i32) {
            self.num_bits = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Sendprop_t| { &m.type_ },
                |m: &mut Sendprop_t| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "var_name",
                |m: &Sendprop_t| { &m.var_name },
                |m: &mut Sendprop_t| { &mut m.var_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &Sendprop_t| { &m.flags },
                |m: &mut Sendprop_t| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "priority",
                |m: &Sendprop_t| { &m.priority },
                |m: &mut Sendprop_t| { &mut m.priority },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dt_name",
                |m: &Sendprop_t| { &m.dt_name },
                |m: &mut Sendprop_t| { &mut m.dt_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_elements",
                |m: &Sendprop_t| { &m.num_elements },
                |m: &mut Sendprop_t| { &mut m.num_elements },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "low_value",
                |m: &Sendprop_t| { &m.low_value },
                |m: &mut Sendprop_t| { &mut m.low_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "high_value",
                |m: &Sendprop_t| { &m.high_value },
                |m: &mut Sendprop_t| { &mut m.high_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_bits",
                |m: &Sendprop_t| { &m.num_bits },
                |m: &mut Sendprop_t| { &mut m.num_bits },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sendprop_t>(
                "CSVCMsg_SendTable.sendprop_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sendprop_t {
        const NAME: &'static str = "sendprop_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.var_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.priority = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        self.dt_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.num_elements = ::std::option::Option::Some(is.read_int32()?);
                    },
                    61 => {
                        self.low_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    69 => {
                        self.high_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.num_bits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.var_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.priority {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.dt_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.num_elements {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.low_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.high_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.num_bits {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.var_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.flags {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.priority {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.dt_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.num_elements {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.low_value {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.high_value {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.num_bits {
                os.write_int32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sendprop_t {
            Sendprop_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.var_name = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.priority = ::std::option::Option::None;
            self.dt_name = ::std::option::Option::None;
            self.num_elements = ::std::option::Option::None;
            self.low_value = ::std::option::Option::None;
            self.high_value = ::std::option::Option::None;
            self.num_bits = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sendprop_t {
            static instance: Sendprop_t = Sendprop_t {
                type_: ::std::option::Option::None,
                var_name: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                priority: ::std::option::Option::None,
                dt_name: ::std::option::Option::None,
                num_elements: ::std::option::Option::None,
                low_value: ::std::option::Option::None,
                high_value: ::std::option::Option::None,
                num_bits: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sendprop_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_SendTable.sendprop_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sendprop_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sendprop_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_GameEventList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_GameEventList {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptors)
    pub descriptors: ::std::vec::Vec<csvcmsg_game_event_list::Descriptor_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GameEventList {
    fn default() -> &'a CSVCMsg_GameEventList {
        <CSVCMsg_GameEventList as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GameEventList {
    pub fn new() -> CSVCMsg_GameEventList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "descriptors",
            |m: &CSVCMsg_GameEventList| { &m.descriptors },
            |m: &mut CSVCMsg_GameEventList| { &mut m.descriptors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_GameEventList>(
            "CSVCMsg_GameEventList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_GameEventList {
    const NAME: &'static str = "CSVCMsg_GameEventList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.descriptors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.descriptors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.descriptors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GameEventList {
        CSVCMsg_GameEventList::new()
    }

    fn clear(&mut self) {
        self.descriptors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GameEventList {
        static instance: CSVCMsg_GameEventList = CSVCMsg_GameEventList {
            descriptors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_GameEventList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_GameEventList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_GameEventList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_GameEventList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_GameEventList`
pub mod csvcmsg_game_event_list {
    // @@protoc_insertion_point(message:CSVCMsg_GameEventList.key_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.key_t.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.key_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Key_t| { &m.type_ },
                |m: &mut Key_t| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Key_t| { &m.name },
                |m: &mut Key_t| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key_t>(
                "CSVCMsg_GameEventList.key_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Key_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_GameEventList.key_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Key_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Key_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CSVCMsg_GameEventList.descriptor_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Descriptor_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.eventid)
        pub eventid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.keys)
        pub keys: ::std::vec::Vec<Key_t>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.descriptor_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Descriptor_t {
        fn default() -> &'a Descriptor_t {
            <Descriptor_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Descriptor_t {
        pub fn new() -> Descriptor_t {
            ::std::default::Default::default()
        }

        // optional int32 eventid = 1;

        pub fn eventid(&self) -> i32 {
            self.eventid.unwrap_or(0)
        }

        pub fn clear_eventid(&mut self) {
            self.eventid = ::std::option::Option::None;
        }

        pub fn has_eventid(&self) -> bool {
            self.eventid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eventid(&mut self, v: i32) {
            self.eventid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eventid",
                |m: &Descriptor_t| { &m.eventid },
                |m: &mut Descriptor_t| { &mut m.eventid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Descriptor_t| { &m.name },
                |m: &mut Descriptor_t| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "keys",
                |m: &Descriptor_t| { &m.keys },
                |m: &mut Descriptor_t| { &mut m.keys },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Descriptor_t>(
                "CSVCMsg_GameEventList.descriptor_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Descriptor_t {
        const NAME: &'static str = "descriptor_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eventid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.keys.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eventid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            for value in &self.keys {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eventid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.keys {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Descriptor_t {
            Descriptor_t::new()
        }

        fn clear(&mut self) {
            self.eventid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.keys.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Descriptor_t {
            static instance: Descriptor_t = Descriptor_t {
                eventid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                keys: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Descriptor_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_GameEventList.descriptor_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Descriptor_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Descriptor_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_PacketEntities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_PacketEntities {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.max_entries)
    pub max_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.updated_entries)
    pub updated_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.is_delta)
    pub is_delta: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.update_baseline)
    pub update_baseline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.baseline)
    pub baseline: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.delta_from)
    pub delta_from: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.entity_data)
    pub entity_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.pending_full_frame)
    pub pending_full_frame: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.active_spawngroup_handle)
    pub active_spawngroup_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.max_spawngroup_creationsequence)
    pub max_spawngroup_creationsequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.last_cmd_number)
    pub last_cmd_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.server_tick)
    pub server_tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.serialized_entities)
    pub serialized_entities: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.command_queue_info)
    pub command_queue_info: ::protobuf::MessageField<csvcmsg_packet_entities::Command_queue_info_t>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.alternate_baselines)
    pub alternate_baselines: ::std::vec::Vec<csvcmsg_packet_entities::Alternate_baseline_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PacketEntities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PacketEntities {
    fn default() -> &'a CSVCMsg_PacketEntities {
        <CSVCMsg_PacketEntities as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PacketEntities {
    pub fn new() -> CSVCMsg_PacketEntities {
        ::std::default::Default::default()
    }

    // optional int32 max_entries = 1;

    pub fn max_entries(&self) -> i32 {
        self.max_entries.unwrap_or(0)
    }

    pub fn clear_max_entries(&mut self) {
        self.max_entries = ::std::option::Option::None;
    }

    pub fn has_max_entries(&self) -> bool {
        self.max_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_entries(&mut self, v: i32) {
        self.max_entries = ::std::option::Option::Some(v);
    }

    // optional int32 updated_entries = 2;

    pub fn updated_entries(&self) -> i32 {
        self.updated_entries.unwrap_or(0)
    }

    pub fn clear_updated_entries(&mut self) {
        self.updated_entries = ::std::option::Option::None;
    }

    pub fn has_updated_entries(&self) -> bool {
        self.updated_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_entries(&mut self, v: i32) {
        self.updated_entries = ::std::option::Option::Some(v);
    }

    // optional bool is_delta = 3;

    pub fn is_delta(&self) -> bool {
        self.is_delta.unwrap_or(false)
    }

    pub fn clear_is_delta(&mut self) {
        self.is_delta = ::std::option::Option::None;
    }

    pub fn has_is_delta(&self) -> bool {
        self.is_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_delta(&mut self, v: bool) {
        self.is_delta = ::std::option::Option::Some(v);
    }

    // optional bool update_baseline = 4;

    pub fn update_baseline(&self) -> bool {
        self.update_baseline.unwrap_or(false)
    }

    pub fn clear_update_baseline(&mut self) {
        self.update_baseline = ::std::option::Option::None;
    }

    pub fn has_update_baseline(&self) -> bool {
        self.update_baseline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_baseline(&mut self, v: bool) {
        self.update_baseline = ::std::option::Option::Some(v);
    }

    // optional int32 baseline = 5;

    pub fn baseline(&self) -> i32 {
        self.baseline.unwrap_or(0)
    }

    pub fn clear_baseline(&mut self) {
        self.baseline = ::std::option::Option::None;
    }

    pub fn has_baseline(&self) -> bool {
        self.baseline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline(&mut self, v: i32) {
        self.baseline = ::std::option::Option::Some(v);
    }

    // optional int32 delta_from = 6;

    pub fn delta_from(&self) -> i32 {
        self.delta_from.unwrap_or(0)
    }

    pub fn clear_delta_from(&mut self) {
        self.delta_from = ::std::option::Option::None;
    }

    pub fn has_delta_from(&self) -> bool {
        self.delta_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_from(&mut self, v: i32) {
        self.delta_from = ::std::option::Option::Some(v);
    }

    // optional bytes entity_data = 7;

    pub fn entity_data(&self) -> &[u8] {
        match self.entity_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entity_data(&mut self) {
        self.entity_data = ::std::option::Option::None;
    }

    pub fn has_entity_data(&self) -> bool {
        self.entity_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.entity_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entity_data.is_none() {
            self.entity_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.entity_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity_data(&mut self) -> ::std::vec::Vec<u8> {
        self.entity_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool pending_full_frame = 8;

    pub fn pending_full_frame(&self) -> bool {
        self.pending_full_frame.unwrap_or(false)
    }

    pub fn clear_pending_full_frame(&mut self) {
        self.pending_full_frame = ::std::option::Option::None;
    }

    pub fn has_pending_full_frame(&self) -> bool {
        self.pending_full_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_full_frame(&mut self, v: bool) {
        self.pending_full_frame = ::std::option::Option::Some(v);
    }

    // optional uint32 active_spawngroup_handle = 9;

    pub fn active_spawngroup_handle(&self) -> u32 {
        self.active_spawngroup_handle.unwrap_or(0)
    }

    pub fn clear_active_spawngroup_handle(&mut self) {
        self.active_spawngroup_handle = ::std::option::Option::None;
    }

    pub fn has_active_spawngroup_handle(&self) -> bool {
        self.active_spawngroup_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_spawngroup_handle(&mut self, v: u32) {
        self.active_spawngroup_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 max_spawngroup_creationsequence = 10;

    pub fn max_spawngroup_creationsequence(&self) -> u32 {
        self.max_spawngroup_creationsequence.unwrap_or(0)
    }

    pub fn clear_max_spawngroup_creationsequence(&mut self) {
        self.max_spawngroup_creationsequence = ::std::option::Option::None;
    }

    pub fn has_max_spawngroup_creationsequence(&self) -> bool {
        self.max_spawngroup_creationsequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_spawngroup_creationsequence(&mut self, v: u32) {
        self.max_spawngroup_creationsequence = ::std::option::Option::Some(v);
    }

    // optional uint32 last_cmd_number = 11;

    pub fn last_cmd_number(&self) -> u32 {
        self.last_cmd_number.unwrap_or(0)
    }

    pub fn clear_last_cmd_number(&mut self) {
        self.last_cmd_number = ::std::option::Option::None;
    }

    pub fn has_last_cmd_number(&self) -> bool {
        self.last_cmd_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_cmd_number(&mut self, v: u32) {
        self.last_cmd_number = ::std::option::Option::Some(v);
    }

    // optional uint32 server_tick = 12;

    pub fn server_tick(&self) -> u32 {
        self.server_tick.unwrap_or(0)
    }

    pub fn clear_server_tick(&mut self) {
        self.server_tick = ::std::option::Option::None;
    }

    pub fn has_server_tick(&self) -> bool {
        self.server_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tick(&mut self, v: u32) {
        self.server_tick = ::std::option::Option::Some(v);
    }

    // optional bytes serialized_entities = 13;

    pub fn serialized_entities(&self) -> &[u8] {
        match self.serialized_entities.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_entities(&mut self) {
        self.serialized_entities = ::std::option::Option::None;
    }

    pub fn has_serialized_entities(&self) -> bool {
        self.serialized_entities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_entities(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_entities = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_entities(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_entities.is_none() {
            self.serialized_entities = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_entities.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_entities(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_entities.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_entries",
            |m: &CSVCMsg_PacketEntities| { &m.max_entries },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.max_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updated_entries",
            |m: &CSVCMsg_PacketEntities| { &m.updated_entries },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.updated_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_delta",
            |m: &CSVCMsg_PacketEntities| { &m.is_delta },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.is_delta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_baseline",
            |m: &CSVCMsg_PacketEntities| { &m.update_baseline },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.update_baseline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseline",
            |m: &CSVCMsg_PacketEntities| { &m.baseline },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.baseline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta_from",
            |m: &CSVCMsg_PacketEntities| { &m.delta_from },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.delta_from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_data",
            |m: &CSVCMsg_PacketEntities| { &m.entity_data },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.entity_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pending_full_frame",
            |m: &CSVCMsg_PacketEntities| { &m.pending_full_frame },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.pending_full_frame },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_spawngroup_handle",
            |m: &CSVCMsg_PacketEntities| { &m.active_spawngroup_handle },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.active_spawngroup_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_spawngroup_creationsequence",
            |m: &CSVCMsg_PacketEntities| { &m.max_spawngroup_creationsequence },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.max_spawngroup_creationsequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_cmd_number",
            |m: &CSVCMsg_PacketEntities| { &m.last_cmd_number },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.last_cmd_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_tick",
            |m: &CSVCMsg_PacketEntities| { &m.server_tick },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.server_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_entities",
            |m: &CSVCMsg_PacketEntities| { &m.serialized_entities },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.serialized_entities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, csvcmsg_packet_entities::Command_queue_info_t>(
            "command_queue_info",
            |m: &CSVCMsg_PacketEntities| { &m.command_queue_info },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.command_queue_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "alternate_baselines",
            |m: &CSVCMsg_PacketEntities| { &m.alternate_baselines },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.alternate_baselines },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_PacketEntities>(
            "CSVCMsg_PacketEntities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_PacketEntities {
    const NAME: &'static str = "CSVCMsg_PacketEntities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.updated_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.is_delta = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.update_baseline = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.baseline = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.delta_from = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.entity_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.pending_full_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.active_spawngroup_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.max_spawngroup_creationsequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.last_cmd_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.server_tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.serialized_entities = ::std::option::Option::Some(is.read_bytes()?);
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command_queue_info)?;
                },
                122 => {
                    self.alternate_baselines.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.max_entries {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.updated_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.is_delta {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_baseline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.baseline {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.delta_from {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.entity_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.pending_full_frame {
            my_size += 1 + 1;
        }
        if let Some(v) = self.active_spawngroup_handle {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.max_spawngroup_creationsequence {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.last_cmd_number {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.server_tick {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.serialized_entities.as_ref() {
            my_size += ::protobuf::rt::bytes_size(13, &v);
        }
        if let Some(v) = self.command_queue_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.alternate_baselines {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.max_entries {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.updated_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.is_delta {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.update_baseline {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.baseline {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.delta_from {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.entity_data.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.pending_full_frame {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.active_spawngroup_handle {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.max_spawngroup_creationsequence {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.last_cmd_number {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.server_tick {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.serialized_entities.as_ref() {
            os.write_bytes(13, v)?;
        }
        if let Some(v) = self.command_queue_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        for v in &self.alternate_baselines {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PacketEntities {
        CSVCMsg_PacketEntities::new()
    }

    fn clear(&mut self) {
        self.max_entries = ::std::option::Option::None;
        self.updated_entries = ::std::option::Option::None;
        self.is_delta = ::std::option::Option::None;
        self.update_baseline = ::std::option::Option::None;
        self.baseline = ::std::option::Option::None;
        self.delta_from = ::std::option::Option::None;
        self.entity_data = ::std::option::Option::None;
        self.pending_full_frame = ::std::option::Option::None;
        self.active_spawngroup_handle = ::std::option::Option::None;
        self.max_spawngroup_creationsequence = ::std::option::Option::None;
        self.last_cmd_number = ::std::option::Option::None;
        self.server_tick = ::std::option::Option::None;
        self.serialized_entities = ::std::option::Option::None;
        self.command_queue_info.clear();
        self.alternate_baselines.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PacketEntities {
        static instance: CSVCMsg_PacketEntities = CSVCMsg_PacketEntities {
            max_entries: ::std::option::Option::None,
            updated_entries: ::std::option::Option::None,
            is_delta: ::std::option::Option::None,
            update_baseline: ::std::option::Option::None,
            baseline: ::std::option::Option::None,
            delta_from: ::std::option::Option::None,
            entity_data: ::std::option::Option::None,
            pending_full_frame: ::std::option::Option::None,
            active_spawngroup_handle: ::std::option::Option::None,
            max_spawngroup_creationsequence: ::std::option::Option::None,
            last_cmd_number: ::std::option::Option::None,
            server_tick: ::std::option::Option::None,
            serialized_entities: ::std::option::Option::None,
            command_queue_info: ::protobuf::MessageField::none(),
            alternate_baselines: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_PacketEntities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_PacketEntities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_PacketEntities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_PacketEntities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_PacketEntities`
pub mod csvcmsg_packet_entities {
    // @@protoc_insertion_point(message:CSVCMsg_PacketEntities.command_queue_info_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Command_queue_info_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.command_queue_info_t.commands_queued)
        pub commands_queued: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.command_queue_info_t.command_queue_desired_size)
        pub command_queue_desired_size: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.command_queue_info_t.starved_command_ticks)
        pub starved_command_ticks: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.command_queue_info_t.time_dilation_percent)
        pub time_dilation_percent: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.command_queue_info_t.discarded_command_ticks)
        pub discarded_command_ticks: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_PacketEntities.command_queue_info_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Command_queue_info_t {
        fn default() -> &'a Command_queue_info_t {
            <Command_queue_info_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Command_queue_info_t {
        pub fn new() -> Command_queue_info_t {
            ::std::default::Default::default()
        }

        // optional uint32 commands_queued = 1;

        pub fn commands_queued(&self) -> u32 {
            self.commands_queued.unwrap_or(0)
        }

        pub fn clear_commands_queued(&mut self) {
            self.commands_queued = ::std::option::Option::None;
        }

        pub fn has_commands_queued(&self) -> bool {
            self.commands_queued.is_some()
        }

        // Param is passed by value, moved
        pub fn set_commands_queued(&mut self, v: u32) {
            self.commands_queued = ::std::option::Option::Some(v);
        }

        // optional uint32 command_queue_desired_size = 2;

        pub fn command_queue_desired_size(&self) -> u32 {
            self.command_queue_desired_size.unwrap_or(0)
        }

        pub fn clear_command_queue_desired_size(&mut self) {
            self.command_queue_desired_size = ::std::option::Option::None;
        }

        pub fn has_command_queue_desired_size(&self) -> bool {
            self.command_queue_desired_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_command_queue_desired_size(&mut self, v: u32) {
            self.command_queue_desired_size = ::std::option::Option::Some(v);
        }

        // optional uint32 starved_command_ticks = 3;

        pub fn starved_command_ticks(&self) -> u32 {
            self.starved_command_ticks.unwrap_or(0)
        }

        pub fn clear_starved_command_ticks(&mut self) {
            self.starved_command_ticks = ::std::option::Option::None;
        }

        pub fn has_starved_command_ticks(&self) -> bool {
            self.starved_command_ticks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_starved_command_ticks(&mut self, v: u32) {
            self.starved_command_ticks = ::std::option::Option::Some(v);
        }

        // optional float time_dilation_percent = 4;

        pub fn time_dilation_percent(&self) -> f32 {
            self.time_dilation_percent.unwrap_or(0.)
        }

        pub fn clear_time_dilation_percent(&mut self) {
            self.time_dilation_percent = ::std::option::Option::None;
        }

        pub fn has_time_dilation_percent(&self) -> bool {
            self.time_dilation_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_dilation_percent(&mut self, v: f32) {
            self.time_dilation_percent = ::std::option::Option::Some(v);
        }

        // optional uint32 discarded_command_ticks = 5;

        pub fn discarded_command_ticks(&self) -> u32 {
            self.discarded_command_ticks.unwrap_or(0)
        }

        pub fn clear_discarded_command_ticks(&mut self) {
            self.discarded_command_ticks = ::std::option::Option::None;
        }

        pub fn has_discarded_command_ticks(&self) -> bool {
            self.discarded_command_ticks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_discarded_command_ticks(&mut self, v: u32) {
            self.discarded_command_ticks = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "commands_queued",
                |m: &Command_queue_info_t| { &m.commands_queued },
                |m: &mut Command_queue_info_t| { &mut m.commands_queued },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "command_queue_desired_size",
                |m: &Command_queue_info_t| { &m.command_queue_desired_size },
                |m: &mut Command_queue_info_t| { &mut m.command_queue_desired_size },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "starved_command_ticks",
                |m: &Command_queue_info_t| { &m.starved_command_ticks },
                |m: &mut Command_queue_info_t| { &mut m.starved_command_ticks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_dilation_percent",
                |m: &Command_queue_info_t| { &m.time_dilation_percent },
                |m: &mut Command_queue_info_t| { &mut m.time_dilation_percent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "discarded_command_ticks",
                |m: &Command_queue_info_t| { &m.discarded_command_ticks },
                |m: &mut Command_queue_info_t| { &mut m.discarded_command_ticks },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Command_queue_info_t>(
                "CSVCMsg_PacketEntities.command_queue_info_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Command_queue_info_t {
        const NAME: &'static str = "command_queue_info_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.commands_queued = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.command_queue_desired_size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.starved_command_ticks = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    37 => {
                        self.time_dilation_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    40 => {
                        self.discarded_command_ticks = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.commands_queued {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.command_queue_desired_size {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.starved_command_ticks {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.time_dilation_percent {
                my_size += 1 + 4;
            }
            if let Some(v) = self.discarded_command_ticks {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.commands_queued {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.command_queue_desired_size {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.starved_command_ticks {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.time_dilation_percent {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.discarded_command_ticks {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Command_queue_info_t {
            Command_queue_info_t::new()
        }

        fn clear(&mut self) {
            self.commands_queued = ::std::option::Option::None;
            self.command_queue_desired_size = ::std::option::Option::None;
            self.starved_command_ticks = ::std::option::Option::None;
            self.time_dilation_percent = ::std::option::Option::None;
            self.discarded_command_ticks = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Command_queue_info_t {
            static instance: Command_queue_info_t = Command_queue_info_t {
                commands_queued: ::std::option::Option::None,
                command_queue_desired_size: ::std::option::Option::None,
                starved_command_ticks: ::std::option::Option::None,
                time_dilation_percent: ::std::option::Option::None,
                discarded_command_ticks: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Command_queue_info_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_PacketEntities.command_queue_info_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Command_queue_info_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Command_queue_info_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CSVCMsg_PacketEntities.alternate_baseline_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Alternate_baseline_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.alternate_baseline_t.entity_index)
        pub entity_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.alternate_baseline_t.baseline_index)
        pub baseline_index: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_PacketEntities.alternate_baseline_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Alternate_baseline_t {
        fn default() -> &'a Alternate_baseline_t {
            <Alternate_baseline_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Alternate_baseline_t {
        pub fn new() -> Alternate_baseline_t {
            ::std::default::Default::default()
        }

        // optional int32 entity_index = 1;

        pub fn entity_index(&self) -> i32 {
            self.entity_index.unwrap_or(0)
        }

        pub fn clear_entity_index(&mut self) {
            self.entity_index = ::std::option::Option::None;
        }

        pub fn has_entity_index(&self) -> bool {
            self.entity_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_index(&mut self, v: i32) {
            self.entity_index = ::std::option::Option::Some(v);
        }

        // optional int32 baseline_index = 2;

        pub fn baseline_index(&self) -> i32 {
            self.baseline_index.unwrap_or(0)
        }

        pub fn clear_baseline_index(&mut self) {
            self.baseline_index = ::std::option::Option::None;
        }

        pub fn has_baseline_index(&self) -> bool {
            self.baseline_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_baseline_index(&mut self, v: i32) {
            self.baseline_index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_index",
                |m: &Alternate_baseline_t| { &m.entity_index },
                |m: &mut Alternate_baseline_t| { &mut m.entity_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "baseline_index",
                |m: &Alternate_baseline_t| { &m.baseline_index },
                |m: &mut Alternate_baseline_t| { &mut m.baseline_index },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Alternate_baseline_t>(
                "CSVCMsg_PacketEntities.alternate_baseline_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Alternate_baseline_t {
        const NAME: &'static str = "alternate_baseline_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.baseline_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entity_index {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.baseline_index {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.entity_index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.baseline_index {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Alternate_baseline_t {
            Alternate_baseline_t::new()
        }

        fn clear(&mut self) {
            self.entity_index = ::std::option::Option::None;
            self.baseline_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Alternate_baseline_t {
            static instance: Alternate_baseline_t = Alternate_baseline_t {
                entity_index: ::std::option::Option::None,
                baseline_index: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Alternate_baseline_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_PacketEntities.alternate_baseline_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Alternate_baseline_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Alternate_baseline_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_TempEntities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_TempEntities {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.reliable)
    pub reliable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.num_entries)
    pub num_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.entity_data)
    pub entity_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_TempEntities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_TempEntities {
    fn default() -> &'a CSVCMsg_TempEntities {
        <CSVCMsg_TempEntities as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_TempEntities {
    pub fn new() -> CSVCMsg_TempEntities {
        ::std::default::Default::default()
    }

    // optional bool reliable = 1;

    pub fn reliable(&self) -> bool {
        self.reliable.unwrap_or(false)
    }

    pub fn clear_reliable(&mut self) {
        self.reliable = ::std::option::Option::None;
    }

    pub fn has_reliable(&self) -> bool {
        self.reliable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable(&mut self, v: bool) {
        self.reliable = ::std::option::Option::Some(v);
    }

    // optional int32 num_entries = 2;

    pub fn num_entries(&self) -> i32 {
        self.num_entries.unwrap_or(0)
    }

    pub fn clear_num_entries(&mut self) {
        self.num_entries = ::std::option::Option::None;
    }

    pub fn has_num_entries(&self) -> bool {
        self.num_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries(&mut self, v: i32) {
        self.num_entries = ::std::option::Option::Some(v);
    }

    // optional bytes entity_data = 3;

    pub fn entity_data(&self) -> &[u8] {
        match self.entity_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entity_data(&mut self) {
        self.entity_data = ::std::option::Option::None;
    }

    pub fn has_entity_data(&self) -> bool {
        self.entity_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.entity_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.entity_data.is_none() {
            self.entity_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.entity_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity_data(&mut self) -> ::std::vec::Vec<u8> {
        self.entity_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reliable",
            |m: &CSVCMsg_TempEntities| { &m.reliable },
            |m: &mut CSVCMsg_TempEntities| { &mut m.reliable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_entries",
            |m: &CSVCMsg_TempEntities| { &m.num_entries },
            |m: &mut CSVCMsg_TempEntities| { &mut m.num_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_data",
            |m: &CSVCMsg_TempEntities| { &m.entity_data },
            |m: &mut CSVCMsg_TempEntities| { &mut m.entity_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_TempEntities>(
            "CSVCMsg_TempEntities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_TempEntities {
    const NAME: &'static str = "CSVCMsg_TempEntities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.num_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.entity_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.num_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entity_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reliable {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.num_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_TempEntities {
        CSVCMsg_TempEntities::new()
    }

    fn clear(&mut self) {
        self.reliable = ::std::option::Option::None;
        self.num_entries = ::std::option::Option::None;
        self.entity_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_TempEntities {
        static instance: CSVCMsg_TempEntities = CSVCMsg_TempEntities {
            reliable: ::std::option::Option::None,
            num_entries: ::std::option::Option::None,
            entity_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_TempEntities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_TempEntities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_TempEntities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_TempEntities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_CreateStringTable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_CreateStringTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.num_entries)
    pub num_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_fixed_size)
    pub user_data_fixed_size: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_size)
    pub user_data_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_size_bits)
    pub user_data_size_bits: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.flags)
    pub flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.string_data)
    pub string_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.uncompressed_size)
    pub uncompressed_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.data_compressed)
    pub data_compressed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.using_varint_bitcounts)
    pub using_varint_bitcounts: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CreateStringTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CreateStringTable {
    fn default() -> &'a CSVCMsg_CreateStringTable {
        <CSVCMsg_CreateStringTable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CreateStringTable {
    pub fn new() -> CSVCMsg_CreateStringTable {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 num_entries = 2;

    pub fn num_entries(&self) -> i32 {
        self.num_entries.unwrap_or(0)
    }

    pub fn clear_num_entries(&mut self) {
        self.num_entries = ::std::option::Option::None;
    }

    pub fn has_num_entries(&self) -> bool {
        self.num_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries(&mut self, v: i32) {
        self.num_entries = ::std::option::Option::Some(v);
    }

    // optional bool user_data_fixed_size = 3;

    pub fn user_data_fixed_size(&self) -> bool {
        self.user_data_fixed_size.unwrap_or(false)
    }

    pub fn clear_user_data_fixed_size(&mut self) {
        self.user_data_fixed_size = ::std::option::Option::None;
    }

    pub fn has_user_data_fixed_size(&self) -> bool {
        self.user_data_fixed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_fixed_size(&mut self, v: bool) {
        self.user_data_fixed_size = ::std::option::Option::Some(v);
    }

    // optional int32 user_data_size = 4;

    pub fn user_data_size(&self) -> i32 {
        self.user_data_size.unwrap_or(0)
    }

    pub fn clear_user_data_size(&mut self) {
        self.user_data_size = ::std::option::Option::None;
    }

    pub fn has_user_data_size(&self) -> bool {
        self.user_data_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_size(&mut self, v: i32) {
        self.user_data_size = ::std::option::Option::Some(v);
    }

    // optional int32 user_data_size_bits = 5;

    pub fn user_data_size_bits(&self) -> i32 {
        self.user_data_size_bits.unwrap_or(0)
    }

    pub fn clear_user_data_size_bits(&mut self) {
        self.user_data_size_bits = ::std::option::Option::None;
    }

    pub fn has_user_data_size_bits(&self) -> bool {
        self.user_data_size_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_size_bits(&mut self, v: i32) {
        self.user_data_size_bits = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 6;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes string_data = 7;

    pub fn string_data(&self) -> &[u8] {
        match self.string_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_data(&mut self) {
        self.string_data = ::std::option::Option::None;
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.string_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.string_data.is_none() {
            self.string_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.string_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::std::vec::Vec<u8> {
        self.string_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 uncompressed_size = 8;

    pub fn uncompressed_size(&self) -> i32 {
        self.uncompressed_size.unwrap_or(0)
    }

    pub fn clear_uncompressed_size(&mut self) {
        self.uncompressed_size = ::std::option::Option::None;
    }

    pub fn has_uncompressed_size(&self) -> bool {
        self.uncompressed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_size(&mut self, v: i32) {
        self.uncompressed_size = ::std::option::Option::Some(v);
    }

    // optional bool data_compressed = 9;

    pub fn data_compressed(&self) -> bool {
        self.data_compressed.unwrap_or(false)
    }

    pub fn clear_data_compressed(&mut self) {
        self.data_compressed = ::std::option::Option::None;
    }

    pub fn has_data_compressed(&self) -> bool {
        self.data_compressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_compressed(&mut self, v: bool) {
        self.data_compressed = ::std::option::Option::Some(v);
    }

    // optional bool using_varint_bitcounts = 10;

    pub fn using_varint_bitcounts(&self) -> bool {
        self.using_varint_bitcounts.unwrap_or(false)
    }

    pub fn clear_using_varint_bitcounts(&mut self) {
        self.using_varint_bitcounts = ::std::option::Option::None;
    }

    pub fn has_using_varint_bitcounts(&self) -> bool {
        self.using_varint_bitcounts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_using_varint_bitcounts(&mut self, v: bool) {
        self.using_varint_bitcounts = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSVCMsg_CreateStringTable| { &m.name },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_entries",
            |m: &CSVCMsg_CreateStringTable| { &m.num_entries },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.num_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_data_fixed_size",
            |m: &CSVCMsg_CreateStringTable| { &m.user_data_fixed_size },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.user_data_fixed_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_data_size",
            |m: &CSVCMsg_CreateStringTable| { &m.user_data_size },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.user_data_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_data_size_bits",
            |m: &CSVCMsg_CreateStringTable| { &m.user_data_size_bits },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.user_data_size_bits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CSVCMsg_CreateStringTable| { &m.flags },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_data",
            |m: &CSVCMsg_CreateStringTable| { &m.string_data },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.string_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uncompressed_size",
            |m: &CSVCMsg_CreateStringTable| { &m.uncompressed_size },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.uncompressed_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_compressed",
            |m: &CSVCMsg_CreateStringTable| { &m.data_compressed },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.data_compressed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "using_varint_bitcounts",
            |m: &CSVCMsg_CreateStringTable| { &m.using_varint_bitcounts },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.using_varint_bitcounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_CreateStringTable>(
            "CSVCMsg_CreateStringTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_CreateStringTable {
    const NAME: &'static str = "CSVCMsg_CreateStringTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.num_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.user_data_fixed_size = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.user_data_size = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.user_data_size_bits = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.string_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                64 => {
                    self.uncompressed_size = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.data_compressed = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.using_varint_bitcounts = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.num_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.user_data_fixed_size {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_data_size {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.user_data_size_bits {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.string_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.uncompressed_size {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.data_compressed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.using_varint_bitcounts {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.num_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.user_data_fixed_size {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.user_data_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.user_data_size_bits {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.string_data.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.uncompressed_size {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.data_compressed {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.using_varint_bitcounts {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CreateStringTable {
        CSVCMsg_CreateStringTable::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.num_entries = ::std::option::Option::None;
        self.user_data_fixed_size = ::std::option::Option::None;
        self.user_data_size = ::std::option::Option::None;
        self.user_data_size_bits = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.string_data = ::std::option::Option::None;
        self.uncompressed_size = ::std::option::Option::None;
        self.data_compressed = ::std::option::Option::None;
        self.using_varint_bitcounts = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CreateStringTable {
        static instance: CSVCMsg_CreateStringTable = CSVCMsg_CreateStringTable {
            name: ::std::option::Option::None,
            num_entries: ::std::option::Option::None,
            user_data_fixed_size: ::std::option::Option::None,
            user_data_size: ::std::option::Option::None,
            user_data_size_bits: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            string_data: ::std::option::Option::None,
            uncompressed_size: ::std::option::Option::None,
            data_compressed: ::std::option::Option::None,
            using_varint_bitcounts: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_CreateStringTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_CreateStringTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_CreateStringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_CreateStringTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_UpdateStringTable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_UpdateStringTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.table_id)
    pub table_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.num_changed_entries)
    pub num_changed_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.string_data)
    pub string_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_UpdateStringTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_UpdateStringTable {
    fn default() -> &'a CSVCMsg_UpdateStringTable {
        <CSVCMsg_UpdateStringTable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_UpdateStringTable {
    pub fn new() -> CSVCMsg_UpdateStringTable {
        ::std::default::Default::default()
    }

    // optional int32 table_id = 1;

    pub fn table_id(&self) -> i32 {
        self.table_id.unwrap_or(0)
    }

    pub fn clear_table_id(&mut self) {
        self.table_id = ::std::option::Option::None;
    }

    pub fn has_table_id(&self) -> bool {
        self.table_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_id(&mut self, v: i32) {
        self.table_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_changed_entries = 2;

    pub fn num_changed_entries(&self) -> i32 {
        self.num_changed_entries.unwrap_or(0)
    }

    pub fn clear_num_changed_entries(&mut self) {
        self.num_changed_entries = ::std::option::Option::None;
    }

    pub fn has_num_changed_entries(&self) -> bool {
        self.num_changed_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_changed_entries(&mut self, v: i32) {
        self.num_changed_entries = ::std::option::Option::Some(v);
    }

    // optional bytes string_data = 3;

    pub fn string_data(&self) -> &[u8] {
        match self.string_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_data(&mut self) {
        self.string_data = ::std::option::Option::None;
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.string_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.string_data.is_none() {
            self.string_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.string_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::std::vec::Vec<u8> {
        self.string_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "table_id",
            |m: &CSVCMsg_UpdateStringTable| { &m.table_id },
            |m: &mut CSVCMsg_UpdateStringTable| { &mut m.table_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_changed_entries",
            |m: &CSVCMsg_UpdateStringTable| { &m.num_changed_entries },
            |m: &mut CSVCMsg_UpdateStringTable| { &mut m.num_changed_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_data",
            |m: &CSVCMsg_UpdateStringTable| { &m.string_data },
            |m: &mut CSVCMsg_UpdateStringTable| { &mut m.string_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_UpdateStringTable>(
            "CSVCMsg_UpdateStringTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_UpdateStringTable {
    const NAME: &'static str = "CSVCMsg_UpdateStringTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.table_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.num_changed_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.string_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.table_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.num_changed_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.string_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.table_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.num_changed_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.string_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_UpdateStringTable {
        CSVCMsg_UpdateStringTable::new()
    }

    fn clear(&mut self) {
        self.table_id = ::std::option::Option::None;
        self.num_changed_entries = ::std::option::Option::None;
        self.string_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_UpdateStringTable {
        static instance: CSVCMsg_UpdateStringTable = CSVCMsg_UpdateStringTable {
            table_id: ::std::option::Option::None,
            num_changed_entries: ::std::option::Option::None,
            string_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_UpdateStringTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_UpdateStringTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_UpdateStringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_UpdateStringTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_VoiceData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_VoiceData {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.audio)
    pub audio: ::protobuf::MessageField<CMsgVoiceAudio>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.client)
    pub client: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.proximity)
    pub proximity: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.audible_mask)
    pub audible_mask: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.tick)
    pub tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.passthrough)
    pub passthrough: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_VoiceData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_VoiceData {
    fn default() -> &'a CSVCMsg_VoiceData {
        <CSVCMsg_VoiceData as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_VoiceData {
    pub fn new() -> CSVCMsg_VoiceData {
        ::std::default::Default::default()
    }

    // optional int32 client = 2;

    pub fn client(&self) -> i32 {
        self.client.unwrap_or(-1i32)
    }

    pub fn clear_client(&mut self) {
        self.client = ::std::option::Option::None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: i32) {
        self.client = ::std::option::Option::Some(v);
    }

    // optional bool proximity = 3;

    pub fn proximity(&self) -> bool {
        self.proximity.unwrap_or(false)
    }

    pub fn clear_proximity(&mut self) {
        self.proximity = ::std::option::Option::None;
    }

    pub fn has_proximity(&self) -> bool {
        self.proximity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proximity(&mut self, v: bool) {
        self.proximity = ::std::option::Option::Some(v);
    }

    // optional fixed64 xuid = 4;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 audible_mask = 5;

    pub fn audible_mask(&self) -> i32 {
        self.audible_mask.unwrap_or(0)
    }

    pub fn clear_audible_mask(&mut self) {
        self.audible_mask = ::std::option::Option::None;
    }

    pub fn has_audible_mask(&self) -> bool {
        self.audible_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audible_mask(&mut self, v: i32) {
        self.audible_mask = ::std::option::Option::Some(v);
    }

    // optional uint32 tick = 6;

    pub fn tick(&self) -> u32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: u32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional int32 passthrough = 7;

    pub fn passthrough(&self) -> i32 {
        self.passthrough.unwrap_or(0)
    }

    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: i32) {
        self.passthrough = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVoiceAudio>(
            "audio",
            |m: &CSVCMsg_VoiceData| { &m.audio },
            |m: &mut CSVCMsg_VoiceData| { &mut m.audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client",
            |m: &CSVCMsg_VoiceData| { &m.client },
            |m: &mut CSVCMsg_VoiceData| { &mut m.client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proximity",
            |m: &CSVCMsg_VoiceData| { &m.proximity },
            |m: &mut CSVCMsg_VoiceData| { &mut m.proximity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xuid",
            |m: &CSVCMsg_VoiceData| { &m.xuid },
            |m: &mut CSVCMsg_VoiceData| { &mut m.xuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audible_mask",
            |m: &CSVCMsg_VoiceData| { &m.audible_mask },
            |m: &mut CSVCMsg_VoiceData| { &mut m.audible_mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CSVCMsg_VoiceData| { &m.tick },
            |m: &mut CSVCMsg_VoiceData| { &mut m.tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passthrough",
            |m: &CSVCMsg_VoiceData| { &m.passthrough },
            |m: &mut CSVCMsg_VoiceData| { &mut m.passthrough },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_VoiceData>(
            "CSVCMsg_VoiceData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_VoiceData {
    const NAME: &'static str = "CSVCMsg_VoiceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audio)?;
                },
                16 => {
                    self.client = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.proximity = ::std::option::Option::Some(is.read_bool()?);
                },
                33 => {
                    self.xuid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.audible_mask = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.passthrough = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.audio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.proximity {
            my_size += 1 + 1;
        }
        if let Some(v) = self.xuid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.audible_mask {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.passthrough {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.audio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.client {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.proximity {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.xuid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.audible_mask {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.tick {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.passthrough {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_VoiceData {
        CSVCMsg_VoiceData::new()
    }

    fn clear(&mut self) {
        self.audio.clear();
        self.client = ::std::option::Option::None;
        self.proximity = ::std::option::Option::None;
        self.xuid = ::std::option::Option::None;
        self.audible_mask = ::std::option::Option::None;
        self.tick = ::std::option::Option::None;
        self.passthrough = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_VoiceData {
        static instance: CSVCMsg_VoiceData = CSVCMsg_VoiceData {
            audio: ::protobuf::MessageField::none(),
            client: ::std::option::Option::None,
            proximity: ::std::option::Option::None,
            xuid: ::std::option::Option::None,
            audible_mask: ::std::option::Option::None,
            tick: ::std::option::Option::None,
            passthrough: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_VoiceData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_VoiceData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_VoiceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_VoiceData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_PacketReliable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_PacketReliable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PacketReliable.tick)
    pub tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketReliable.messagessize)
    pub messagessize: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketReliable.state)
    pub state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PacketReliable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PacketReliable {
    fn default() -> &'a CSVCMsg_PacketReliable {
        <CSVCMsg_PacketReliable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PacketReliable {
    pub fn new() -> CSVCMsg_PacketReliable {
        ::std::default::Default::default()
    }

    // optional int32 tick = 1;

    pub fn tick(&self) -> i32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional int32 messagessize = 2;

    pub fn messagessize(&self) -> i32 {
        self.messagessize.unwrap_or(0)
    }

    pub fn clear_messagessize(&mut self) {
        self.messagessize = ::std::option::Option::None;
    }

    pub fn has_messagessize(&self) -> bool {
        self.messagessize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messagessize(&mut self, v: i32) {
        self.messagessize = ::std::option::Option::Some(v);
    }

    // optional bool state = 3;

    pub fn state(&self) -> bool {
        self.state.unwrap_or(false)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CSVCMsg_PacketReliable| { &m.tick },
            |m: &mut CSVCMsg_PacketReliable| { &mut m.tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messagessize",
            |m: &CSVCMsg_PacketReliable| { &m.messagessize },
            |m: &mut CSVCMsg_PacketReliable| { &mut m.messagessize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CSVCMsg_PacketReliable| { &m.state },
            |m: &mut CSVCMsg_PacketReliable| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_PacketReliable>(
            "CSVCMsg_PacketReliable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_PacketReliable {
    const NAME: &'static str = "CSVCMsg_PacketReliable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.messagessize = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.messagessize {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.state {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.messagessize {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PacketReliable {
        CSVCMsg_PacketReliable::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.messagessize = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PacketReliable {
        static instance: CSVCMsg_PacketReliable = CSVCMsg_PacketReliable {
            tick: ::std::option::Option::None,
            messagessize: ::std::option::Option::None,
            state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_PacketReliable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_PacketReliable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_PacketReliable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_PacketReliable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_FullFrameSplit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_FullFrameSplit {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.tick)
    pub tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.section)
    pub section: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.total)
    pub total: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_FullFrameSplit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_FullFrameSplit {
    fn default() -> &'a CSVCMsg_FullFrameSplit {
        <CSVCMsg_FullFrameSplit as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_FullFrameSplit {
    pub fn new() -> CSVCMsg_FullFrameSplit {
        ::std::default::Default::default()
    }

    // optional int32 tick = 1;

    pub fn tick(&self) -> i32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional int32 section = 2;

    pub fn section(&self) -> i32 {
        self.section.unwrap_or(0)
    }

    pub fn clear_section(&mut self) {
        self.section = ::std::option::Option::None;
    }

    pub fn has_section(&self) -> bool {
        self.section.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section(&mut self, v: i32) {
        self.section = ::std::option::Option::Some(v);
    }

    // optional int32 total = 3;

    pub fn total(&self) -> i32 {
        self.total.unwrap_or(0)
    }

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = ::std::option::Option::Some(v);
    }

    // optional bytes data = 4;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CSVCMsg_FullFrameSplit| { &m.tick },
            |m: &mut CSVCMsg_FullFrameSplit| { &mut m.tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "section",
            |m: &CSVCMsg_FullFrameSplit| { &m.section },
            |m: &mut CSVCMsg_FullFrameSplit| { &mut m.section },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total",
            |m: &CSVCMsg_FullFrameSplit| { &m.total },
            |m: &mut CSVCMsg_FullFrameSplit| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CSVCMsg_FullFrameSplit| { &m.data },
            |m: &mut CSVCMsg_FullFrameSplit| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_FullFrameSplit>(
            "CSVCMsg_FullFrameSplit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_FullFrameSplit {
    const NAME: &'static str = "CSVCMsg_FullFrameSplit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.section = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.total = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.section {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.section {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.total {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_FullFrameSplit {
        CSVCMsg_FullFrameSplit::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.section = ::std::option::Option::None;
        self.total = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_FullFrameSplit {
        static instance: CSVCMsg_FullFrameSplit = CSVCMsg_FullFrameSplit {
            tick: ::std::option::Option::None,
            section: ::std::option::Option::None,
            total: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_FullFrameSplit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_FullFrameSplit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_FullFrameSplit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_FullFrameSplit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_HLTVStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_HLTVStatus {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.master)
    pub master: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.clients)
    pub clients: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.slots)
    pub slots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.proxies)
    pub proxies: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_HLTVStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_HLTVStatus {
    fn default() -> &'a CSVCMsg_HLTVStatus {
        <CSVCMsg_HLTVStatus as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_HLTVStatus {
    pub fn new() -> CSVCMsg_HLTVStatus {
        ::std::default::Default::default()
    }

    // optional string master = 1;

    pub fn master(&self) -> &str {
        match self.master.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_master(&mut self) {
        self.master = ::std::option::Option::None;
    }

    pub fn has_master(&self) -> bool {
        self.master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_master(&mut self, v: ::std::string::String) {
        self.master = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_master(&mut self) -> &mut ::std::string::String {
        if self.master.is_none() {
            self.master = ::std::option::Option::Some(::std::string::String::new());
        }
        self.master.as_mut().unwrap()
    }

    // Take field
    pub fn take_master(&mut self) -> ::std::string::String {
        self.master.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 clients = 2;

    pub fn clients(&self) -> i32 {
        self.clients.unwrap_or(0)
    }

    pub fn clear_clients(&mut self) {
        self.clients = ::std::option::Option::None;
    }

    pub fn has_clients(&self) -> bool {
        self.clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clients(&mut self, v: i32) {
        self.clients = ::std::option::Option::Some(v);
    }

    // optional int32 slots = 3;

    pub fn slots(&self) -> i32 {
        self.slots.unwrap_or(0)
    }

    pub fn clear_slots(&mut self) {
        self.slots = ::std::option::Option::None;
    }

    pub fn has_slots(&self) -> bool {
        self.slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots(&mut self, v: i32) {
        self.slots = ::std::option::Option::Some(v);
    }

    // optional int32 proxies = 4;

    pub fn proxies(&self) -> i32 {
        self.proxies.unwrap_or(0)
    }

    pub fn clear_proxies(&mut self) {
        self.proxies = ::std::option::Option::None;
    }

    pub fn has_proxies(&self) -> bool {
        self.proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxies(&mut self, v: i32) {
        self.proxies = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "master",
            |m: &CSVCMsg_HLTVStatus| { &m.master },
            |m: &mut CSVCMsg_HLTVStatus| { &mut m.master },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clients",
            |m: &CSVCMsg_HLTVStatus| { &m.clients },
            |m: &mut CSVCMsg_HLTVStatus| { &mut m.clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slots",
            |m: &CSVCMsg_HLTVStatus| { &m.slots },
            |m: &mut CSVCMsg_HLTVStatus| { &mut m.slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proxies",
            |m: &CSVCMsg_HLTVStatus| { &m.proxies },
            |m: &mut CSVCMsg_HLTVStatus| { &mut m.proxies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_HLTVStatus>(
            "CSVCMsg_HLTVStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_HLTVStatus {
    const NAME: &'static str = "CSVCMsg_HLTVStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.master = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.clients = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.slots = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.proxies = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.master.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.clients {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.slots {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.proxies {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.master.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.clients {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.slots {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.proxies {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_HLTVStatus {
        CSVCMsg_HLTVStatus::new()
    }

    fn clear(&mut self) {
        self.master = ::std::option::Option::None;
        self.clients = ::std::option::Option::None;
        self.slots = ::std::option::Option::None;
        self.proxies = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_HLTVStatus {
        static instance: CSVCMsg_HLTVStatus = CSVCMsg_HLTVStatus {
            master: ::std::option::Option::None,
            clients: ::std::option::Option::None,
            slots: ::std::option::Option::None,
            proxies: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_HLTVStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_HLTVStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_HLTVStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_HLTVStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_ServerSteamID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ServerSteamID {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ServerSteamID.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ServerSteamID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ServerSteamID {
    fn default() -> &'a CSVCMsg_ServerSteamID {
        <CSVCMsg_ServerSteamID as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ServerSteamID {
    pub fn new() -> CSVCMsg_ServerSteamID {
        ::std::default::Default::default()
    }

    // optional uint64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CSVCMsg_ServerSteamID| { &m.steam_id },
            |m: &mut CSVCMsg_ServerSteamID| { &mut m.steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_ServerSteamID>(
            "CSVCMsg_ServerSteamID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_ServerSteamID {
    const NAME: &'static str = "CSVCMsg_ServerSteamID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ServerSteamID {
        CSVCMsg_ServerSteamID::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ServerSteamID {
        static instance: CSVCMsg_ServerSteamID = CSVCMsg_ServerSteamID {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_ServerSteamID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_ServerSteamID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_ServerSteamID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_ServerSteamID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_CmdKeyValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_CmdKeyValues {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CmdKeyValues.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CmdKeyValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CmdKeyValues {
    fn default() -> &'a CSVCMsg_CmdKeyValues {
        <CSVCMsg_CmdKeyValues as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CmdKeyValues {
    pub fn new() -> CSVCMsg_CmdKeyValues {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CSVCMsg_CmdKeyValues| { &m.data },
            |m: &mut CSVCMsg_CmdKeyValues| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_CmdKeyValues>(
            "CSVCMsg_CmdKeyValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_CmdKeyValues {
    const NAME: &'static str = "CSVCMsg_CmdKeyValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CmdKeyValues {
        CSVCMsg_CmdKeyValues::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CmdKeyValues {
        static instance: CSVCMsg_CmdKeyValues = CSVCMsg_CmdKeyValues {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_CmdKeyValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_CmdKeyValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_CmdKeyValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_CmdKeyValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_RconServerDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_RconServerDetails {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_RconServerDetails.token)
    pub token: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CSVCMsg_RconServerDetails.details)
    pub details: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_RconServerDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_RconServerDetails {
    fn default() -> &'a CSVCMsg_RconServerDetails {
        <CSVCMsg_RconServerDetails as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_RconServerDetails {
    pub fn new() -> CSVCMsg_RconServerDetails {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string details = 2;

    pub fn details(&self) -> &str {
        match self.details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::string::String) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::string::String {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::string::String::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::string::String {
        self.details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CSVCMsg_RconServerDetails| { &m.token },
            |m: &mut CSVCMsg_RconServerDetails| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &CSVCMsg_RconServerDetails| { &m.details },
            |m: &mut CSVCMsg_RconServerDetails| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_RconServerDetails>(
            "CSVCMsg_RconServerDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_RconServerDetails {
    const NAME: &'static str = "CSVCMsg_RconServerDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.details = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_RconServerDetails {
        CSVCMsg_RconServerDetails::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_RconServerDetails {
        static instance: CSVCMsg_RconServerDetails = CSVCMsg_RconServerDetails {
            token: ::std::option::Option::None,
            details: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_RconServerDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_RconServerDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_RconServerDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_RconServerDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgIPCAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgIPCAddress {
    // message fields
    // @@protoc_insertion_point(field:CMsgIPCAddress.computer_guid)
    pub computer_guid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgIPCAddress.process_id)
    pub process_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIPCAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIPCAddress {
    fn default() -> &'a CMsgIPCAddress {
        <CMsgIPCAddress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIPCAddress {
    pub fn new() -> CMsgIPCAddress {
        ::std::default::Default::default()
    }

    // optional fixed64 computer_guid = 1;

    pub fn computer_guid(&self) -> u64 {
        self.computer_guid.unwrap_or(0)
    }

    pub fn clear_computer_guid(&mut self) {
        self.computer_guid = ::std::option::Option::None;
    }

    pub fn has_computer_guid(&self) -> bool {
        self.computer_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_computer_guid(&mut self, v: u64) {
        self.computer_guid = ::std::option::Option::Some(v);
    }

    // optional uint32 process_id = 2;

    pub fn process_id(&self) -> u32 {
        self.process_id.unwrap_or(0)
    }

    pub fn clear_process_id(&mut self) {
        self.process_id = ::std::option::Option::None;
    }

    pub fn has_process_id(&self) -> bool {
        self.process_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_id(&mut self, v: u32) {
        self.process_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "computer_guid",
            |m: &CMsgIPCAddress| { &m.computer_guid },
            |m: &mut CMsgIPCAddress| { &mut m.computer_guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "process_id",
            |m: &CMsgIPCAddress| { &m.process_id },
            |m: &mut CMsgIPCAddress| { &mut m.process_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgIPCAddress>(
            "CMsgIPCAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgIPCAddress {
    const NAME: &'static str = "CMsgIPCAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.computer_guid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.computer_guid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.process_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.computer_guid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.process_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIPCAddress {
        CMsgIPCAddress::new()
    }

    fn clear(&mut self) {
        self.computer_guid = ::std::option::Option::None;
        self.process_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIPCAddress {
        static instance: CMsgIPCAddress = CMsgIPCAddress {
            computer_guid: ::std::option::Option::None,
            process_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgIPCAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgIPCAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgIPCAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIPCAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgServerPeer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerPeer {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerPeer.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerPeer.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerPeer.ipc)
    pub ipc: ::protobuf::MessageField<CMsgIPCAddress>,
    // @@protoc_insertion_point(field:CMsgServerPeer.they_hear_you)
    pub they_hear_you: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerPeer.you_hear_them)
    pub you_hear_them: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerPeer.is_listenserver_host)
    pub is_listenserver_host: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerPeer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerPeer {
    fn default() -> &'a CMsgServerPeer {
        <CMsgServerPeer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerPeer {
    pub fn new() -> CMsgServerPeer {
        ::std::default::Default::default()
    }

    // optional int32 player_slot = 1;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool they_hear_you = 4;

    pub fn they_hear_you(&self) -> bool {
        self.they_hear_you.unwrap_or(false)
    }

    pub fn clear_they_hear_you(&mut self) {
        self.they_hear_you = ::std::option::Option::None;
    }

    pub fn has_they_hear_you(&self) -> bool {
        self.they_hear_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_they_hear_you(&mut self, v: bool) {
        self.they_hear_you = ::std::option::Option::Some(v);
    }

    // optional bool you_hear_them = 5;

    pub fn you_hear_them(&self) -> bool {
        self.you_hear_them.unwrap_or(false)
    }

    pub fn clear_you_hear_them(&mut self) {
        self.you_hear_them = ::std::option::Option::None;
    }

    pub fn has_you_hear_them(&self) -> bool {
        self.you_hear_them.is_some()
    }

    // Param is passed by value, moved
    pub fn set_you_hear_them(&mut self, v: bool) {
        self.you_hear_them = ::std::option::Option::Some(v);
    }

    // optional bool is_listenserver_host = 6;

    pub fn is_listenserver_host(&self) -> bool {
        self.is_listenserver_host.unwrap_or(false)
    }

    pub fn clear_is_listenserver_host(&mut self) {
        self.is_listenserver_host = ::std::option::Option::None;
    }

    pub fn has_is_listenserver_host(&self) -> bool {
        self.is_listenserver_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_listenserver_host(&mut self, v: bool) {
        self.is_listenserver_host = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &CMsgServerPeer| { &m.player_slot },
            |m: &mut CMsgServerPeer| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgServerPeer| { &m.steamid },
            |m: &mut CMsgServerPeer| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgIPCAddress>(
            "ipc",
            |m: &CMsgServerPeer| { &m.ipc },
            |m: &mut CMsgServerPeer| { &mut m.ipc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "they_hear_you",
            |m: &CMsgServerPeer| { &m.they_hear_you },
            |m: &mut CMsgServerPeer| { &mut m.they_hear_you },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "you_hear_them",
            |m: &CMsgServerPeer| { &m.you_hear_them },
            |m: &mut CMsgServerPeer| { &mut m.you_hear_them },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_listenserver_host",
            |m: &CMsgServerPeer| { &m.is_listenserver_host },
            |m: &mut CMsgServerPeer| { &mut m.is_listenserver_host },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerPeer>(
            "CMsgServerPeer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerPeer {
    const NAME: &'static str = "CMsgServerPeer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ipc)?;
                },
                32 => {
                    self.they_hear_you = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.you_hear_them = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_listenserver_host = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ipc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.they_hear_you {
            my_size += 1 + 1;
        }
        if let Some(v) = self.you_hear_them {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_listenserver_host {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_slot {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.ipc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.they_hear_you {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.you_hear_them {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_listenserver_host {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerPeer {
        CMsgServerPeer::new()
    }

    fn clear(&mut self) {
        self.player_slot = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.ipc.clear();
        self.they_hear_you = ::std::option::Option::None;
        self.you_hear_them = ::std::option::Option::None;
        self.is_listenserver_host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerPeer {
        static instance: CMsgServerPeer = CMsgServerPeer {
            player_slot: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            ipc: ::protobuf::MessageField::none(),
            they_hear_you: ::std::option::Option::None,
            you_hear_them: ::std::option::Option::None,
            is_listenserver_host: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerPeer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerPeer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerPeer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_PeerList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_PeerList {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PeerList.peer)
    pub peer: ::std::vec::Vec<CMsgServerPeer>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PeerList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PeerList {
    fn default() -> &'a CSVCMsg_PeerList {
        <CSVCMsg_PeerList as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PeerList {
    pub fn new() -> CSVCMsg_PeerList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "peer",
            |m: &CSVCMsg_PeerList| { &m.peer },
            |m: &mut CSVCMsg_PeerList| { &mut m.peer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_PeerList>(
            "CSVCMsg_PeerList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_PeerList {
    const NAME: &'static str = "CSVCMsg_PeerList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.peer.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.peer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.peer {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PeerList {
        CSVCMsg_PeerList::new()
    }

    fn clear(&mut self) {
        self.peer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PeerList {
        static instance: CSVCMsg_PeerList = CSVCMsg_PeerList {
            peer: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_PeerList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_PeerList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_PeerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_PeerList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_ClearAllStringTables)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ClearAllStringTables {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ClearAllStringTables.mapname)
    pub mapname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ClearAllStringTables.create_tables_skipped)
    pub create_tables_skipped: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ClearAllStringTables.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ClearAllStringTables {
    fn default() -> &'a CSVCMsg_ClearAllStringTables {
        <CSVCMsg_ClearAllStringTables as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ClearAllStringTables {
    pub fn new() -> CSVCMsg_ClearAllStringTables {
        ::std::default::Default::default()
    }

    // optional string mapname = 1;

    pub fn mapname(&self) -> &str {
        match self.mapname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mapname(&mut self) {
        self.mapname = ::std::option::Option::None;
    }

    pub fn has_mapname(&self) -> bool {
        self.mapname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mapname(&mut self, v: ::std::string::String) {
        self.mapname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mapname(&mut self) -> &mut ::std::string::String {
        if self.mapname.is_none() {
            self.mapname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mapname.as_mut().unwrap()
    }

    // Take field
    pub fn take_mapname(&mut self) -> ::std::string::String {
        self.mapname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool create_tables_skipped = 3;

    pub fn create_tables_skipped(&self) -> bool {
        self.create_tables_skipped.unwrap_or(false)
    }

    pub fn clear_create_tables_skipped(&mut self) {
        self.create_tables_skipped = ::std::option::Option::None;
    }

    pub fn has_create_tables_skipped(&self) -> bool {
        self.create_tables_skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_tables_skipped(&mut self, v: bool) {
        self.create_tables_skipped = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mapname",
            |m: &CSVCMsg_ClearAllStringTables| { &m.mapname },
            |m: &mut CSVCMsg_ClearAllStringTables| { &mut m.mapname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "create_tables_skipped",
            |m: &CSVCMsg_ClearAllStringTables| { &m.create_tables_skipped },
            |m: &mut CSVCMsg_ClearAllStringTables| { &mut m.create_tables_skipped },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_ClearAllStringTables>(
            "CSVCMsg_ClearAllStringTables",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_ClearAllStringTables {
    const NAME: &'static str = "CSVCMsg_ClearAllStringTables";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mapname = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.create_tables_skipped = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mapname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.create_tables_skipped {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mapname.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.create_tables_skipped {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ClearAllStringTables {
        CSVCMsg_ClearAllStringTables::new()
    }

    fn clear(&mut self) {
        self.mapname = ::std::option::Option::None;
        self.create_tables_skipped = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ClearAllStringTables {
        static instance: CSVCMsg_ClearAllStringTables = CSVCMsg_ClearAllStringTables {
            mapname: ::std::option::Option::None,
            create_tables_skipped: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_ClearAllStringTables {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_ClearAllStringTables").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_ClearAllStringTables {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_ClearAllStringTables {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoFlattenedSerializerField_t)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoFlattenedSerializerField_t {
    // message fields
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_type_sym)
    pub var_type_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_name_sym)
    pub var_name_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.bit_count)
    pub bit_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.low_value)
    pub low_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.high_value)
    pub high_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.encode_flags)
    pub encode_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.field_serializer_name_sym)
    pub field_serializer_name_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.field_serializer_version)
    pub field_serializer_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.send_node_sym)
    pub send_node_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_encoder_sym)
    pub var_encoder_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.polymorphic_types)
    pub polymorphic_types: ::std::vec::Vec<proto_flattened_serializer_field_t::Polymorphic_field_t>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoFlattenedSerializerField_t.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoFlattenedSerializerField_t {
    fn default() -> &'a ProtoFlattenedSerializerField_t {
        <ProtoFlattenedSerializerField_t as ::protobuf::Message>::default_instance()
    }
}

impl ProtoFlattenedSerializerField_t {
    pub fn new() -> ProtoFlattenedSerializerField_t {
        ::std::default::Default::default()
    }

    // optional int32 var_type_sym = 1;

    pub fn var_type_sym(&self) -> i32 {
        self.var_type_sym.unwrap_or(0)
    }

    pub fn clear_var_type_sym(&mut self) {
        self.var_type_sym = ::std::option::Option::None;
    }

    pub fn has_var_type_sym(&self) -> bool {
        self.var_type_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_type_sym(&mut self, v: i32) {
        self.var_type_sym = ::std::option::Option::Some(v);
    }

    // optional int32 var_name_sym = 2;

    pub fn var_name_sym(&self) -> i32 {
        self.var_name_sym.unwrap_or(0)
    }

    pub fn clear_var_name_sym(&mut self) {
        self.var_name_sym = ::std::option::Option::None;
    }

    pub fn has_var_name_sym(&self) -> bool {
        self.var_name_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_name_sym(&mut self, v: i32) {
        self.var_name_sym = ::std::option::Option::Some(v);
    }

    // optional int32 bit_count = 3;

    pub fn bit_count(&self) -> i32 {
        self.bit_count.unwrap_or(0)
    }

    pub fn clear_bit_count(&mut self) {
        self.bit_count = ::std::option::Option::None;
    }

    pub fn has_bit_count(&self) -> bool {
        self.bit_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bit_count(&mut self, v: i32) {
        self.bit_count = ::std::option::Option::Some(v);
    }

    // optional float low_value = 4;

    pub fn low_value(&self) -> f32 {
        self.low_value.unwrap_or(0.)
    }

    pub fn clear_low_value(&mut self) {
        self.low_value = ::std::option::Option::None;
    }

    pub fn has_low_value(&self) -> bool {
        self.low_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_value(&mut self, v: f32) {
        self.low_value = ::std::option::Option::Some(v);
    }

    // optional float high_value = 5;

    pub fn high_value(&self) -> f32 {
        self.high_value.unwrap_or(0.)
    }

    pub fn clear_high_value(&mut self) {
        self.high_value = ::std::option::Option::None;
    }

    pub fn has_high_value(&self) -> bool {
        self.high_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_value(&mut self, v: f32) {
        self.high_value = ::std::option::Option::Some(v);
    }

    // optional int32 encode_flags = 6;

    pub fn encode_flags(&self) -> i32 {
        self.encode_flags.unwrap_or(0)
    }

    pub fn clear_encode_flags(&mut self) {
        self.encode_flags = ::std::option::Option::None;
    }

    pub fn has_encode_flags(&self) -> bool {
        self.encode_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encode_flags(&mut self, v: i32) {
        self.encode_flags = ::std::option::Option::Some(v);
    }

    // optional int32 field_serializer_name_sym = 7;

    pub fn field_serializer_name_sym(&self) -> i32 {
        self.field_serializer_name_sym.unwrap_or(0)
    }

    pub fn clear_field_serializer_name_sym(&mut self) {
        self.field_serializer_name_sym = ::std::option::Option::None;
    }

    pub fn has_field_serializer_name_sym(&self) -> bool {
        self.field_serializer_name_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_serializer_name_sym(&mut self, v: i32) {
        self.field_serializer_name_sym = ::std::option::Option::Some(v);
    }

    // optional int32 field_serializer_version = 8;

    pub fn field_serializer_version(&self) -> i32 {
        self.field_serializer_version.unwrap_or(0)
    }

    pub fn clear_field_serializer_version(&mut self) {
        self.field_serializer_version = ::std::option::Option::None;
    }

    pub fn has_field_serializer_version(&self) -> bool {
        self.field_serializer_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_serializer_version(&mut self, v: i32) {
        self.field_serializer_version = ::std::option::Option::Some(v);
    }

    // optional int32 send_node_sym = 9;

    pub fn send_node_sym(&self) -> i32 {
        self.send_node_sym.unwrap_or(0)
    }

    pub fn clear_send_node_sym(&mut self) {
        self.send_node_sym = ::std::option::Option::None;
    }

    pub fn has_send_node_sym(&self) -> bool {
        self.send_node_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_node_sym(&mut self, v: i32) {
        self.send_node_sym = ::std::option::Option::Some(v);
    }

    // optional int32 var_encoder_sym = 10;

    pub fn var_encoder_sym(&self) -> i32 {
        self.var_encoder_sym.unwrap_or(0)
    }

    pub fn clear_var_encoder_sym(&mut self) {
        self.var_encoder_sym = ::std::option::Option::None;
    }

    pub fn has_var_encoder_sym(&self) -> bool {
        self.var_encoder_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_encoder_sym(&mut self, v: i32) {
        self.var_encoder_sym = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "var_type_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.var_type_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.var_type_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "var_name_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.var_name_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.var_name_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bit_count",
            |m: &ProtoFlattenedSerializerField_t| { &m.bit_count },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.bit_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_value",
            |m: &ProtoFlattenedSerializerField_t| { &m.low_value },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.low_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "high_value",
            |m: &ProtoFlattenedSerializerField_t| { &m.high_value },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.high_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encode_flags",
            |m: &ProtoFlattenedSerializerField_t| { &m.encode_flags },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.encode_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "field_serializer_name_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.field_serializer_name_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.field_serializer_name_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "field_serializer_version",
            |m: &ProtoFlattenedSerializerField_t| { &m.field_serializer_version },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.field_serializer_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_node_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.send_node_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.send_node_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "var_encoder_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.var_encoder_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.var_encoder_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "polymorphic_types",
            |m: &ProtoFlattenedSerializerField_t| { &m.polymorphic_types },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.polymorphic_types },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoFlattenedSerializerField_t>(
            "ProtoFlattenedSerializerField_t",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoFlattenedSerializerField_t {
    const NAME: &'static str = "ProtoFlattenedSerializerField_t";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.var_type_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.var_name_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.bit_count = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.low_value = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.high_value = ::std::option::Option::Some(is.read_float()?);
                },
                48 => {
                    self.encode_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.field_serializer_name_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.field_serializer_version = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.send_node_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.var_encoder_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                90 => {
                    self.polymorphic_types.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.var_type_sym {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.var_name_sym {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.bit_count {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.low_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.high_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.encode_flags {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.field_serializer_name_sym {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.field_serializer_version {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.send_node_sym {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.var_encoder_sym {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        for value in &self.polymorphic_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.var_type_sym {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.var_name_sym {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.bit_count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.low_value {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.high_value {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.encode_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.field_serializer_name_sym {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.field_serializer_version {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.send_node_sym {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.var_encoder_sym {
            os.write_int32(10, v)?;
        }
        for v in &self.polymorphic_types {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoFlattenedSerializerField_t {
        ProtoFlattenedSerializerField_t::new()
    }

    fn clear(&mut self) {
        self.var_type_sym = ::std::option::Option::None;
        self.var_name_sym = ::std::option::Option::None;
        self.bit_count = ::std::option::Option::None;
        self.low_value = ::std::option::Option::None;
        self.high_value = ::std::option::Option::None;
        self.encode_flags = ::std::option::Option::None;
        self.field_serializer_name_sym = ::std::option::Option::None;
        self.field_serializer_version = ::std::option::Option::None;
        self.send_node_sym = ::std::option::Option::None;
        self.var_encoder_sym = ::std::option::Option::None;
        self.polymorphic_types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoFlattenedSerializerField_t {
        static instance: ProtoFlattenedSerializerField_t = ProtoFlattenedSerializerField_t {
            var_type_sym: ::std::option::Option::None,
            var_name_sym: ::std::option::Option::None,
            bit_count: ::std::option::Option::None,
            low_value: ::std::option::Option::None,
            high_value: ::std::option::Option::None,
            encode_flags: ::std::option::Option::None,
            field_serializer_name_sym: ::std::option::Option::None,
            field_serializer_version: ::std::option::Option::None,
            send_node_sym: ::std::option::Option::None,
            var_encoder_sym: ::std::option::Option::None,
            polymorphic_types: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoFlattenedSerializerField_t {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoFlattenedSerializerField_t").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoFlattenedSerializerField_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoFlattenedSerializerField_t {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProtoFlattenedSerializerField_t`
pub mod proto_flattened_serializer_field_t {
    // @@protoc_insertion_point(message:ProtoFlattenedSerializerField_t.polymorphic_field_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Polymorphic_field_t {
        // message fields
        // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.polymorphic_field_t.polymorphic_field_serializer_name_sym)
        pub polymorphic_field_serializer_name_sym: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.polymorphic_field_t.polymorphic_field_serializer_version)
        pub polymorphic_field_serializer_version: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:ProtoFlattenedSerializerField_t.polymorphic_field_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Polymorphic_field_t {
        fn default() -> &'a Polymorphic_field_t {
            <Polymorphic_field_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Polymorphic_field_t {
        pub fn new() -> Polymorphic_field_t {
            ::std::default::Default::default()
        }

        // optional int32 polymorphic_field_serializer_name_sym = 1;

        pub fn polymorphic_field_serializer_name_sym(&self) -> i32 {
            self.polymorphic_field_serializer_name_sym.unwrap_or(0)
        }

        pub fn clear_polymorphic_field_serializer_name_sym(&mut self) {
            self.polymorphic_field_serializer_name_sym = ::std::option::Option::None;
        }

        pub fn has_polymorphic_field_serializer_name_sym(&self) -> bool {
            self.polymorphic_field_serializer_name_sym.is_some()
        }

        // Param is passed by value, moved
        pub fn set_polymorphic_field_serializer_name_sym(&mut self, v: i32) {
            self.polymorphic_field_serializer_name_sym = ::std::option::Option::Some(v);
        }

        // optional int32 polymorphic_field_serializer_version = 2;

        pub fn polymorphic_field_serializer_version(&self) -> i32 {
            self.polymorphic_field_serializer_version.unwrap_or(0)
        }

        pub fn clear_polymorphic_field_serializer_version(&mut self) {
            self.polymorphic_field_serializer_version = ::std::option::Option::None;
        }

        pub fn has_polymorphic_field_serializer_version(&self) -> bool {
            self.polymorphic_field_serializer_version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_polymorphic_field_serializer_version(&mut self, v: i32) {
            self.polymorphic_field_serializer_version = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "polymorphic_field_serializer_name_sym",
                |m: &Polymorphic_field_t| { &m.polymorphic_field_serializer_name_sym },
                |m: &mut Polymorphic_field_t| { &mut m.polymorphic_field_serializer_name_sym },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "polymorphic_field_serializer_version",
                |m: &Polymorphic_field_t| { &m.polymorphic_field_serializer_version },
                |m: &mut Polymorphic_field_t| { &mut m.polymorphic_field_serializer_version },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Polymorphic_field_t>(
                "ProtoFlattenedSerializerField_t.polymorphic_field_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Polymorphic_field_t {
        const NAME: &'static str = "polymorphic_field_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.polymorphic_field_serializer_name_sym = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.polymorphic_field_serializer_version = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.polymorphic_field_serializer_name_sym {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.polymorphic_field_serializer_version {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.polymorphic_field_serializer_name_sym {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.polymorphic_field_serializer_version {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Polymorphic_field_t {
            Polymorphic_field_t::new()
        }

        fn clear(&mut self) {
            self.polymorphic_field_serializer_name_sym = ::std::option::Option::None;
            self.polymorphic_field_serializer_version = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Polymorphic_field_t {
            static instance: Polymorphic_field_t = Polymorphic_field_t {
                polymorphic_field_serializer_name_sym: ::std::option::Option::None,
                polymorphic_field_serializer_version: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Polymorphic_field_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ProtoFlattenedSerializerField_t.polymorphic_field_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Polymorphic_field_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Polymorphic_field_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:ProtoFlattenedSerializer_t)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoFlattenedSerializer_t {
    // message fields
    // @@protoc_insertion_point(field:ProtoFlattenedSerializer_t.serializer_name_sym)
    pub serializer_name_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializer_t.serializer_version)
    pub serializer_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializer_t.fields_index)
    pub fields_index: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoFlattenedSerializer_t.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoFlattenedSerializer_t {
    fn default() -> &'a ProtoFlattenedSerializer_t {
        <ProtoFlattenedSerializer_t as ::protobuf::Message>::default_instance()
    }
}

impl ProtoFlattenedSerializer_t {
    pub fn new() -> ProtoFlattenedSerializer_t {
        ::std::default::Default::default()
    }

    // optional int32 serializer_name_sym = 1;

    pub fn serializer_name_sym(&self) -> i32 {
        self.serializer_name_sym.unwrap_or(0)
    }

    pub fn clear_serializer_name_sym(&mut self) {
        self.serializer_name_sym = ::std::option::Option::None;
    }

    pub fn has_serializer_name_sym(&self) -> bool {
        self.serializer_name_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serializer_name_sym(&mut self, v: i32) {
        self.serializer_name_sym = ::std::option::Option::Some(v);
    }

    // optional int32 serializer_version = 2;

    pub fn serializer_version(&self) -> i32 {
        self.serializer_version.unwrap_or(0)
    }

    pub fn clear_serializer_version(&mut self) {
        self.serializer_version = ::std::option::Option::None;
    }

    pub fn has_serializer_version(&self) -> bool {
        self.serializer_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serializer_version(&mut self, v: i32) {
        self.serializer_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serializer_name_sym",
            |m: &ProtoFlattenedSerializer_t| { &m.serializer_name_sym },
            |m: &mut ProtoFlattenedSerializer_t| { &mut m.serializer_name_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serializer_version",
            |m: &ProtoFlattenedSerializer_t| { &m.serializer_version },
            |m: &mut ProtoFlattenedSerializer_t| { &mut m.serializer_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fields_index",
            |m: &ProtoFlattenedSerializer_t| { &m.fields_index },
            |m: &mut ProtoFlattenedSerializer_t| { &mut m.fields_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoFlattenedSerializer_t>(
            "ProtoFlattenedSerializer_t",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoFlattenedSerializer_t {
    const NAME: &'static str = "ProtoFlattenedSerializer_t";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.serializer_name_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.serializer_version = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.fields_index)?;
                },
                24 => {
                    self.fields_index.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serializer_name_sym {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.serializer_version {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.fields_index {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serializer_name_sym {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.serializer_version {
            os.write_int32(2, v)?;
        }
        for v in &self.fields_index {
            os.write_int32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoFlattenedSerializer_t {
        ProtoFlattenedSerializer_t::new()
    }

    fn clear(&mut self) {
        self.serializer_name_sym = ::std::option::Option::None;
        self.serializer_version = ::std::option::Option::None;
        self.fields_index.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoFlattenedSerializer_t {
        static instance: ProtoFlattenedSerializer_t = ProtoFlattenedSerializer_t {
            serializer_name_sym: ::std::option::Option::None,
            serializer_version: ::std::option::Option::None,
            fields_index: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoFlattenedSerializer_t {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoFlattenedSerializer_t").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoFlattenedSerializer_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoFlattenedSerializer_t {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_FlattenedSerializer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_FlattenedSerializer {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_FlattenedSerializer.serializers)
    pub serializers: ::std::vec::Vec<ProtoFlattenedSerializer_t>,
    // @@protoc_insertion_point(field:CSVCMsg_FlattenedSerializer.symbols)
    pub symbols: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_FlattenedSerializer.fields)
    pub fields: ::std::vec::Vec<ProtoFlattenedSerializerField_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_FlattenedSerializer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_FlattenedSerializer {
    fn default() -> &'a CSVCMsg_FlattenedSerializer {
        <CSVCMsg_FlattenedSerializer as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_FlattenedSerializer {
    pub fn new() -> CSVCMsg_FlattenedSerializer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "serializers",
            |m: &CSVCMsg_FlattenedSerializer| { &m.serializers },
            |m: &mut CSVCMsg_FlattenedSerializer| { &mut m.serializers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbols",
            |m: &CSVCMsg_FlattenedSerializer| { &m.symbols },
            |m: &mut CSVCMsg_FlattenedSerializer| { &mut m.symbols },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fields",
            |m: &CSVCMsg_FlattenedSerializer| { &m.fields },
            |m: &mut CSVCMsg_FlattenedSerializer| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_FlattenedSerializer>(
            "CSVCMsg_FlattenedSerializer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_FlattenedSerializer {
    const NAME: &'static str = "CSVCMsg_FlattenedSerializer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serializers.push(is.read_message()?);
                },
                18 => {
                    self.symbols.push(is.read_string()?);
                },
                26 => {
                    self.fields.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.serializers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.symbols {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.serializers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.symbols {
            os.write_string(2, &v)?;
        };
        for v in &self.fields {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_FlattenedSerializer {
        CSVCMsg_FlattenedSerializer::new()
    }

    fn clear(&mut self) {
        self.serializers.clear();
        self.symbols.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_FlattenedSerializer {
        static instance: CSVCMsg_FlattenedSerializer = CSVCMsg_FlattenedSerializer {
            serializers: ::std::vec::Vec::new(),
            symbols: ::std::vec::Vec::new(),
            fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_FlattenedSerializer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_FlattenedSerializer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_FlattenedSerializer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_FlattenedSerializer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_StopSound)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_StopSound {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_StopSound.guid)
    pub guid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_StopSound.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_StopSound {
    fn default() -> &'a CSVCMsg_StopSound {
        <CSVCMsg_StopSound as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_StopSound {
    pub fn new() -> CSVCMsg_StopSound {
        ::std::default::Default::default()
    }

    // optional fixed32 guid = 1;

    pub fn guid(&self) -> u32 {
        self.guid.unwrap_or(0)
    }

    pub fn clear_guid(&mut self) {
        self.guid = ::std::option::Option::None;
    }

    pub fn has_guid(&self) -> bool {
        self.guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid(&mut self, v: u32) {
        self.guid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guid",
            |m: &CSVCMsg_StopSound| { &m.guid },
            |m: &mut CSVCMsg_StopSound| { &mut m.guid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_StopSound>(
            "CSVCMsg_StopSound",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_StopSound {
    const NAME: &'static str = "CSVCMsg_StopSound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.guid = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guid {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guid {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_StopSound {
        CSVCMsg_StopSound::new()
    }

    fn clear(&mut self) {
        self.guid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_StopSound {
        static instance: CSVCMsg_StopSound = CSVCMsg_StopSound {
            guid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_StopSound {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_StopSound").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_StopSound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_StopSound {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CBidirMsg_RebroadcastGameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBidirMsg_RebroadcastGameEvent {
    // message fields
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.posttoserver)
    pub posttoserver: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.buftype)
    pub buftype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.clientbitcount)
    pub clientbitcount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.receivingclients)
    pub receivingclients: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBidirMsg_RebroadcastGameEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBidirMsg_RebroadcastGameEvent {
    fn default() -> &'a CBidirMsg_RebroadcastGameEvent {
        <CBidirMsg_RebroadcastGameEvent as ::protobuf::Message>::default_instance()
    }
}

impl CBidirMsg_RebroadcastGameEvent {
    pub fn new() -> CBidirMsg_RebroadcastGameEvent {
        ::std::default::Default::default()
    }

    // optional bool posttoserver = 1;

    pub fn posttoserver(&self) -> bool {
        self.posttoserver.unwrap_or(false)
    }

    pub fn clear_posttoserver(&mut self) {
        self.posttoserver = ::std::option::Option::None;
    }

    pub fn has_posttoserver(&self) -> bool {
        self.posttoserver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posttoserver(&mut self, v: bool) {
        self.posttoserver = ::std::option::Option::Some(v);
    }

    // optional int32 buftype = 2;

    pub fn buftype(&self) -> i32 {
        self.buftype.unwrap_or(0)
    }

    pub fn clear_buftype(&mut self) {
        self.buftype = ::std::option::Option::None;
    }

    pub fn has_buftype(&self) -> bool {
        self.buftype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buftype(&mut self, v: i32) {
        self.buftype = ::std::option::Option::Some(v);
    }

    // optional uint32 clientbitcount = 3;

    pub fn clientbitcount(&self) -> u32 {
        self.clientbitcount.unwrap_or(0)
    }

    pub fn clear_clientbitcount(&mut self) {
        self.clientbitcount = ::std::option::Option::None;
    }

    pub fn has_clientbitcount(&self) -> bool {
        self.clientbitcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientbitcount(&mut self, v: u32) {
        self.clientbitcount = ::std::option::Option::Some(v);
    }

    // optional uint64 receivingclients = 4;

    pub fn receivingclients(&self) -> u64 {
        self.receivingclients.unwrap_or(0)
    }

    pub fn clear_receivingclients(&mut self) {
        self.receivingclients = ::std::option::Option::None;
    }

    pub fn has_receivingclients(&self) -> bool {
        self.receivingclients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receivingclients(&mut self, v: u64) {
        self.receivingclients = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "posttoserver",
            |m: &CBidirMsg_RebroadcastGameEvent| { &m.posttoserver },
            |m: &mut CBidirMsg_RebroadcastGameEvent| { &mut m.posttoserver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buftype",
            |m: &CBidirMsg_RebroadcastGameEvent| { &m.buftype },
            |m: &mut CBidirMsg_RebroadcastGameEvent| { &mut m.buftype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientbitcount",
            |m: &CBidirMsg_RebroadcastGameEvent| { &m.clientbitcount },
            |m: &mut CBidirMsg_RebroadcastGameEvent| { &mut m.clientbitcount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receivingclients",
            |m: &CBidirMsg_RebroadcastGameEvent| { &m.receivingclients },
            |m: &mut CBidirMsg_RebroadcastGameEvent| { &mut m.receivingclients },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CBidirMsg_RebroadcastGameEvent>(
            "CBidirMsg_RebroadcastGameEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CBidirMsg_RebroadcastGameEvent {
    const NAME: &'static str = "CBidirMsg_RebroadcastGameEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.posttoserver = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.buftype = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.clientbitcount = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.receivingclients = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.posttoserver {
            my_size += 1 + 1;
        }
        if let Some(v) = self.buftype {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.clientbitcount {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.receivingclients {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.posttoserver {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.buftype {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.clientbitcount {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.receivingclients {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBidirMsg_RebroadcastGameEvent {
        CBidirMsg_RebroadcastGameEvent::new()
    }

    fn clear(&mut self) {
        self.posttoserver = ::std::option::Option::None;
        self.buftype = ::std::option::Option::None;
        self.clientbitcount = ::std::option::Option::None;
        self.receivingclients = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBidirMsg_RebroadcastGameEvent {
        static instance: CBidirMsg_RebroadcastGameEvent = CBidirMsg_RebroadcastGameEvent {
            posttoserver: ::std::option::Option::None,
            buftype: ::std::option::Option::None,
            clientbitcount: ::std::option::Option::None,
            receivingclients: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CBidirMsg_RebroadcastGameEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CBidirMsg_RebroadcastGameEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CBidirMsg_RebroadcastGameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBidirMsg_RebroadcastGameEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CBidirMsg_RebroadcastSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBidirMsg_RebroadcastSource {
    // message fields
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastSource.eventsource)
    pub eventsource: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBidirMsg_RebroadcastSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBidirMsg_RebroadcastSource {
    fn default() -> &'a CBidirMsg_RebroadcastSource {
        <CBidirMsg_RebroadcastSource as ::protobuf::Message>::default_instance()
    }
}

impl CBidirMsg_RebroadcastSource {
    pub fn new() -> CBidirMsg_RebroadcastSource {
        ::std::default::Default::default()
    }

    // optional int32 eventsource = 1;

    pub fn eventsource(&self) -> i32 {
        self.eventsource.unwrap_or(0)
    }

    pub fn clear_eventsource(&mut self) {
        self.eventsource = ::std::option::Option::None;
    }

    pub fn has_eventsource(&self) -> bool {
        self.eventsource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventsource(&mut self, v: i32) {
        self.eventsource = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventsource",
            |m: &CBidirMsg_RebroadcastSource| { &m.eventsource },
            |m: &mut CBidirMsg_RebroadcastSource| { &mut m.eventsource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CBidirMsg_RebroadcastSource>(
            "CBidirMsg_RebroadcastSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CBidirMsg_RebroadcastSource {
    const NAME: &'static str = "CBidirMsg_RebroadcastSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eventsource = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eventsource {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eventsource {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBidirMsg_RebroadcastSource {
        CBidirMsg_RebroadcastSource::new()
    }

    fn clear(&mut self) {
        self.eventsource = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBidirMsg_RebroadcastSource {
        static instance: CBidirMsg_RebroadcastSource = CBidirMsg_RebroadcastSource {
            eventsource: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CBidirMsg_RebroadcastSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CBidirMsg_RebroadcastSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CBidirMsg_RebroadcastSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBidirMsg_RebroadcastSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgServerNetworkStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerNetworkStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.dedicated)
    pub dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.cpu_usage)
    pub cpu_usage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.memory_used_mb)
    pub memory_used_mb: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.memory_free_mb)
    pub memory_free_mb: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.uptime)
    pub uptime: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.spawn_count)
    pub spawn_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_clients)
    pub num_clients: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_bots)
    pub num_bots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_spectators)
    pub num_spectators: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_tv_relays)
    pub num_tv_relays: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.fps)
    pub fps: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.ports)
    pub ports: ::std::vec::Vec<cmsg_server_network_stats::Port>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_latency_out)
    pub avg_latency_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_latency_in)
    pub avg_latency_in: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_packets_out)
    pub avg_packets_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_packets_in)
    pub avg_packets_in: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_loss_out)
    pub avg_loss_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_loss_in)
    pub avg_loss_in: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_data_out)
    pub avg_data_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_data_in)
    pub avg_data_in: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_data_in)
    pub total_data_in: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_packets_in)
    pub total_packets_in: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_data_out)
    pub total_data_out: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_packets_out)
    pub total_packets_out: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.players)
    pub players: ::std::vec::Vec<cmsg_server_network_stats::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerNetworkStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerNetworkStats {
    fn default() -> &'a CMsgServerNetworkStats {
        <CMsgServerNetworkStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerNetworkStats {
    pub fn new() -> CMsgServerNetworkStats {
        ::std::default::Default::default()
    }

    // optional bool dedicated = 1;

    pub fn dedicated(&self) -> bool {
        self.dedicated.unwrap_or(false)
    }

    pub fn clear_dedicated(&mut self) {
        self.dedicated = ::std::option::Option::None;
    }

    pub fn has_dedicated(&self) -> bool {
        self.dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dedicated(&mut self, v: bool) {
        self.dedicated = ::std::option::Option::Some(v);
    }

    // optional int32 cpu_usage = 2;

    pub fn cpu_usage(&self) -> i32 {
        self.cpu_usage.unwrap_or(0)
    }

    pub fn clear_cpu_usage(&mut self) {
        self.cpu_usage = ::std::option::Option::None;
    }

    pub fn has_cpu_usage(&self) -> bool {
        self.cpu_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_usage(&mut self, v: i32) {
        self.cpu_usage = ::std::option::Option::Some(v);
    }

    // optional int32 memory_used_mb = 3;

    pub fn memory_used_mb(&self) -> i32 {
        self.memory_used_mb.unwrap_or(0)
    }

    pub fn clear_memory_used_mb(&mut self) {
        self.memory_used_mb = ::std::option::Option::None;
    }

    pub fn has_memory_used_mb(&self) -> bool {
        self.memory_used_mb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_used_mb(&mut self, v: i32) {
        self.memory_used_mb = ::std::option::Option::Some(v);
    }

    // optional int32 memory_free_mb = 4;

    pub fn memory_free_mb(&self) -> i32 {
        self.memory_free_mb.unwrap_or(0)
    }

    pub fn clear_memory_free_mb(&mut self) {
        self.memory_free_mb = ::std::option::Option::None;
    }

    pub fn has_memory_free_mb(&self) -> bool {
        self.memory_free_mb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_free_mb(&mut self, v: i32) {
        self.memory_free_mb = ::std::option::Option::Some(v);
    }

    // optional int32 uptime = 5;

    pub fn uptime(&self) -> i32 {
        self.uptime.unwrap_or(0)
    }

    pub fn clear_uptime(&mut self) {
        self.uptime = ::std::option::Option::None;
    }

    pub fn has_uptime(&self) -> bool {
        self.uptime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: i32) {
        self.uptime = ::std::option::Option::Some(v);
    }

    // optional int32 spawn_count = 6;

    pub fn spawn_count(&self) -> i32 {
        self.spawn_count.unwrap_or(0)
    }

    pub fn clear_spawn_count(&mut self) {
        self.spawn_count = ::std::option::Option::None;
    }

    pub fn has_spawn_count(&self) -> bool {
        self.spawn_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawn_count(&mut self, v: i32) {
        self.spawn_count = ::std::option::Option::Some(v);
    }

    // optional int32 num_clients = 8;

    pub fn num_clients(&self) -> i32 {
        self.num_clients.unwrap_or(0)
    }

    pub fn clear_num_clients(&mut self) {
        self.num_clients = ::std::option::Option::None;
    }

    pub fn has_num_clients(&self) -> bool {
        self.num_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_clients(&mut self, v: i32) {
        self.num_clients = ::std::option::Option::Some(v);
    }

    // optional int32 num_bots = 9;

    pub fn num_bots(&self) -> i32 {
        self.num_bots.unwrap_or(0)
    }

    pub fn clear_num_bots(&mut self) {
        self.num_bots = ::std::option::Option::None;
    }

    pub fn has_num_bots(&self) -> bool {
        self.num_bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_bots(&mut self, v: i32) {
        self.num_bots = ::std::option::Option::Some(v);
    }

    // optional int32 num_spectators = 10;

    pub fn num_spectators(&self) -> i32 {
        self.num_spectators.unwrap_or(0)
    }

    pub fn clear_num_spectators(&mut self) {
        self.num_spectators = ::std::option::Option::None;
    }

    pub fn has_num_spectators(&self) -> bool {
        self.num_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_spectators(&mut self, v: i32) {
        self.num_spectators = ::std::option::Option::Some(v);
    }

    // optional int32 num_tv_relays = 11;

    pub fn num_tv_relays(&self) -> i32 {
        self.num_tv_relays.unwrap_or(0)
    }

    pub fn clear_num_tv_relays(&mut self) {
        self.num_tv_relays = ::std::option::Option::None;
    }

    pub fn has_num_tv_relays(&self) -> bool {
        self.num_tv_relays.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_tv_relays(&mut self, v: i32) {
        self.num_tv_relays = ::std::option::Option::Some(v);
    }

    // optional float fps = 12;

    pub fn fps(&self) -> f32 {
        self.fps.unwrap_or(0.)
    }

    pub fn clear_fps(&mut self) {
        self.fps = ::std::option::Option::None;
    }

    pub fn has_fps(&self) -> bool {
        self.fps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps(&mut self, v: f32) {
        self.fps = ::std::option::Option::Some(v);
    }

    // optional float avg_latency_out = 18;

    pub fn avg_latency_out(&self) -> f32 {
        self.avg_latency_out.unwrap_or(0.)
    }

    pub fn clear_avg_latency_out(&mut self) {
        self.avg_latency_out = ::std::option::Option::None;
    }

    pub fn has_avg_latency_out(&self) -> bool {
        self.avg_latency_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_latency_out(&mut self, v: f32) {
        self.avg_latency_out = ::std::option::Option::Some(v);
    }

    // optional float avg_latency_in = 19;

    pub fn avg_latency_in(&self) -> f32 {
        self.avg_latency_in.unwrap_or(0.)
    }

    pub fn clear_avg_latency_in(&mut self) {
        self.avg_latency_in = ::std::option::Option::None;
    }

    pub fn has_avg_latency_in(&self) -> bool {
        self.avg_latency_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_latency_in(&mut self, v: f32) {
        self.avg_latency_in = ::std::option::Option::Some(v);
    }

    // optional float avg_packets_out = 20;

    pub fn avg_packets_out(&self) -> f32 {
        self.avg_packets_out.unwrap_or(0.)
    }

    pub fn clear_avg_packets_out(&mut self) {
        self.avg_packets_out = ::std::option::Option::None;
    }

    pub fn has_avg_packets_out(&self) -> bool {
        self.avg_packets_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_packets_out(&mut self, v: f32) {
        self.avg_packets_out = ::std::option::Option::Some(v);
    }

    // optional float avg_packets_in = 21;

    pub fn avg_packets_in(&self) -> f32 {
        self.avg_packets_in.unwrap_or(0.)
    }

    pub fn clear_avg_packets_in(&mut self) {
        self.avg_packets_in = ::std::option::Option::None;
    }

    pub fn has_avg_packets_in(&self) -> bool {
        self.avg_packets_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_packets_in(&mut self, v: f32) {
        self.avg_packets_in = ::std::option::Option::Some(v);
    }

    // optional float avg_loss_out = 22;

    pub fn avg_loss_out(&self) -> f32 {
        self.avg_loss_out.unwrap_or(0.)
    }

    pub fn clear_avg_loss_out(&mut self) {
        self.avg_loss_out = ::std::option::Option::None;
    }

    pub fn has_avg_loss_out(&self) -> bool {
        self.avg_loss_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_loss_out(&mut self, v: f32) {
        self.avg_loss_out = ::std::option::Option::Some(v);
    }

    // optional float avg_loss_in = 23;

    pub fn avg_loss_in(&self) -> f32 {
        self.avg_loss_in.unwrap_or(0.)
    }

    pub fn clear_avg_loss_in(&mut self) {
        self.avg_loss_in = ::std::option::Option::None;
    }

    pub fn has_avg_loss_in(&self) -> bool {
        self.avg_loss_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_loss_in(&mut self, v: f32) {
        self.avg_loss_in = ::std::option::Option::Some(v);
    }

    // optional float avg_data_out = 24;

    pub fn avg_data_out(&self) -> f32 {
        self.avg_data_out.unwrap_or(0.)
    }

    pub fn clear_avg_data_out(&mut self) {
        self.avg_data_out = ::std::option::Option::None;
    }

    pub fn has_avg_data_out(&self) -> bool {
        self.avg_data_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_data_out(&mut self, v: f32) {
        self.avg_data_out = ::std::option::Option::Some(v);
    }

    // optional float avg_data_in = 25;

    pub fn avg_data_in(&self) -> f32 {
        self.avg_data_in.unwrap_or(0.)
    }

    pub fn clear_avg_data_in(&mut self) {
        self.avg_data_in = ::std::option::Option::None;
    }

    pub fn has_avg_data_in(&self) -> bool {
        self.avg_data_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_data_in(&mut self, v: f32) {
        self.avg_data_in = ::std::option::Option::Some(v);
    }

    // optional uint64 total_data_in = 26;

    pub fn total_data_in(&self) -> u64 {
        self.total_data_in.unwrap_or(0)
    }

    pub fn clear_total_data_in(&mut self) {
        self.total_data_in = ::std::option::Option::None;
    }

    pub fn has_total_data_in(&self) -> bool {
        self.total_data_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_data_in(&mut self, v: u64) {
        self.total_data_in = ::std::option::Option::Some(v);
    }

    // optional uint64 total_packets_in = 27;

    pub fn total_packets_in(&self) -> u64 {
        self.total_packets_in.unwrap_or(0)
    }

    pub fn clear_total_packets_in(&mut self) {
        self.total_packets_in = ::std::option::Option::None;
    }

    pub fn has_total_packets_in(&self) -> bool {
        self.total_packets_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_packets_in(&mut self, v: u64) {
        self.total_packets_in = ::std::option::Option::Some(v);
    }

    // optional uint64 total_data_out = 28;

    pub fn total_data_out(&self) -> u64 {
        self.total_data_out.unwrap_or(0)
    }

    pub fn clear_total_data_out(&mut self) {
        self.total_data_out = ::std::option::Option::None;
    }

    pub fn has_total_data_out(&self) -> bool {
        self.total_data_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_data_out(&mut self, v: u64) {
        self.total_data_out = ::std::option::Option::Some(v);
    }

    // optional uint64 total_packets_out = 29;

    pub fn total_packets_out(&self) -> u64 {
        self.total_packets_out.unwrap_or(0)
    }

    pub fn clear_total_packets_out(&mut self) {
        self.total_packets_out = ::std::option::Option::None;
    }

    pub fn has_total_packets_out(&self) -> bool {
        self.total_packets_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_packets_out(&mut self, v: u64) {
        self.total_packets_out = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dedicated",
            |m: &CMsgServerNetworkStats| { &m.dedicated },
            |m: &mut CMsgServerNetworkStats| { &mut m.dedicated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_usage",
            |m: &CMsgServerNetworkStats| { &m.cpu_usage },
            |m: &mut CMsgServerNetworkStats| { &mut m.cpu_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "memory_used_mb",
            |m: &CMsgServerNetworkStats| { &m.memory_used_mb },
            |m: &mut CMsgServerNetworkStats| { &mut m.memory_used_mb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "memory_free_mb",
            |m: &CMsgServerNetworkStats| { &m.memory_free_mb },
            |m: &mut CMsgServerNetworkStats| { &mut m.memory_free_mb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uptime",
            |m: &CMsgServerNetworkStats| { &m.uptime },
            |m: &mut CMsgServerNetworkStats| { &mut m.uptime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawn_count",
            |m: &CMsgServerNetworkStats| { &m.spawn_count },
            |m: &mut CMsgServerNetworkStats| { &mut m.spawn_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_clients",
            |m: &CMsgServerNetworkStats| { &m.num_clients },
            |m: &mut CMsgServerNetworkStats| { &mut m.num_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_bots",
            |m: &CMsgServerNetworkStats| { &m.num_bots },
            |m: &mut CMsgServerNetworkStats| { &mut m.num_bots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_spectators",
            |m: &CMsgServerNetworkStats| { &m.num_spectators },
            |m: &mut CMsgServerNetworkStats| { &mut m.num_spectators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_tv_relays",
            |m: &CMsgServerNetworkStats| { &m.num_tv_relays },
            |m: &mut CMsgServerNetworkStats| { &mut m.num_tv_relays },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fps",
            |m: &CMsgServerNetworkStats| { &m.fps },
            |m: &mut CMsgServerNetworkStats| { &mut m.fps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &CMsgServerNetworkStats| { &m.ports },
            |m: &mut CMsgServerNetworkStats| { &mut m.ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_latency_out",
            |m: &CMsgServerNetworkStats| { &m.avg_latency_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_latency_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_latency_in",
            |m: &CMsgServerNetworkStats| { &m.avg_latency_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_latency_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_packets_out",
            |m: &CMsgServerNetworkStats| { &m.avg_packets_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_packets_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_packets_in",
            |m: &CMsgServerNetworkStats| { &m.avg_packets_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_packets_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_loss_out",
            |m: &CMsgServerNetworkStats| { &m.avg_loss_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_loss_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_loss_in",
            |m: &CMsgServerNetworkStats| { &m.avg_loss_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_loss_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_data_out",
            |m: &CMsgServerNetworkStats| { &m.avg_data_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_data_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_data_in",
            |m: &CMsgServerNetworkStats| { &m.avg_data_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_data_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_data_in",
            |m: &CMsgServerNetworkStats| { &m.total_data_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.total_data_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_packets_in",
            |m: &CMsgServerNetworkStats| { &m.total_packets_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.total_packets_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_data_out",
            |m: &CMsgServerNetworkStats| { &m.total_data_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.total_data_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_packets_out",
            |m: &CMsgServerNetworkStats| { &m.total_packets_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.total_packets_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgServerNetworkStats| { &m.players },
            |m: &mut CMsgServerNetworkStats| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerNetworkStats>(
            "CMsgServerNetworkStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerNetworkStats {
    const NAME: &'static str = "CMsgServerNetworkStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.cpu_usage = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.memory_used_mb = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.memory_free_mb = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.uptime = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.spawn_count = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.num_clients = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.num_bots = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.num_spectators = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.num_tv_relays = ::std::option::Option::Some(is.read_int32()?);
                },
                101 => {
                    self.fps = ::std::option::Option::Some(is.read_float()?);
                },
                138 => {
                    self.ports.push(is.read_message()?);
                },
                149 => {
                    self.avg_latency_out = ::std::option::Option::Some(is.read_float()?);
                },
                157 => {
                    self.avg_latency_in = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.avg_packets_out = ::std::option::Option::Some(is.read_float()?);
                },
                173 => {
                    self.avg_packets_in = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.avg_loss_out = ::std::option::Option::Some(is.read_float()?);
                },
                189 => {
                    self.avg_loss_in = ::std::option::Option::Some(is.read_float()?);
                },
                197 => {
                    self.avg_data_out = ::std::option::Option::Some(is.read_float()?);
                },
                205 => {
                    self.avg_data_in = ::std::option::Option::Some(is.read_float()?);
                },
                208 => {
                    self.total_data_in = ::std::option::Option::Some(is.read_uint64()?);
                },
                216 => {
                    self.total_packets_in = ::std::option::Option::Some(is.read_uint64()?);
                },
                224 => {
                    self.total_data_out = ::std::option::Option::Some(is.read_uint64()?);
                },
                232 => {
                    self.total_packets_out = ::std::option::Option::Some(is.read_uint64()?);
                },
                242 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dedicated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cpu_usage {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.memory_used_mb {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.memory_free_mb {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.uptime {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.spawn_count {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.num_clients {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.num_bots {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.num_spectators {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.num_tv_relays {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.fps {
            my_size += 1 + 4;
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.avg_latency_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_latency_in {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_packets_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_packets_in {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_loss_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_loss_in {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_data_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_data_in {
            my_size += 2 + 4;
        }
        if let Some(v) = self.total_data_in {
            my_size += ::protobuf::rt::uint64_size(26, v);
        }
        if let Some(v) = self.total_packets_in {
            my_size += ::protobuf::rt::uint64_size(27, v);
        }
        if let Some(v) = self.total_data_out {
            my_size += ::protobuf::rt::uint64_size(28, v);
        }
        if let Some(v) = self.total_packets_out {
            my_size += ::protobuf::rt::uint64_size(29, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dedicated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.cpu_usage {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.memory_used_mb {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.memory_free_mb {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.uptime {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.spawn_count {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.num_clients {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.num_bots {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.num_spectators {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.num_tv_relays {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.fps {
            os.write_float(12, v)?;
        }
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.avg_latency_out {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.avg_latency_in {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.avg_packets_out {
            os.write_float(20, v)?;
        }
        if let Some(v) = self.avg_packets_in {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.avg_loss_out {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.avg_loss_in {
            os.write_float(23, v)?;
        }
        if let Some(v) = self.avg_data_out {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.avg_data_in {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.total_data_in {
            os.write_uint64(26, v)?;
        }
        if let Some(v) = self.total_packets_in {
            os.write_uint64(27, v)?;
        }
        if let Some(v) = self.total_data_out {
            os.write_uint64(28, v)?;
        }
        if let Some(v) = self.total_packets_out {
            os.write_uint64(29, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerNetworkStats {
        CMsgServerNetworkStats::new()
    }

    fn clear(&mut self) {
        self.dedicated = ::std::option::Option::None;
        self.cpu_usage = ::std::option::Option::None;
        self.memory_used_mb = ::std::option::Option::None;
        self.memory_free_mb = ::std::option::Option::None;
        self.uptime = ::std::option::Option::None;
        self.spawn_count = ::std::option::Option::None;
        self.num_clients = ::std::option::Option::None;
        self.num_bots = ::std::option::Option::None;
        self.num_spectators = ::std::option::Option::None;
        self.num_tv_relays = ::std::option::Option::None;
        self.fps = ::std::option::Option::None;
        self.ports.clear();
        self.avg_latency_out = ::std::option::Option::None;
        self.avg_latency_in = ::std::option::Option::None;
        self.avg_packets_out = ::std::option::Option::None;
        self.avg_packets_in = ::std::option::Option::None;
        self.avg_loss_out = ::std::option::Option::None;
        self.avg_loss_in = ::std::option::Option::None;
        self.avg_data_out = ::std::option::Option::None;
        self.avg_data_in = ::std::option::Option::None;
        self.total_data_in = ::std::option::Option::None;
        self.total_packets_in = ::std::option::Option::None;
        self.total_data_out = ::std::option::Option::None;
        self.total_packets_out = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerNetworkStats {
        static instance: CMsgServerNetworkStats = CMsgServerNetworkStats {
            dedicated: ::std::option::Option::None,
            cpu_usage: ::std::option::Option::None,
            memory_used_mb: ::std::option::Option::None,
            memory_free_mb: ::std::option::Option::None,
            uptime: ::std::option::Option::None,
            spawn_count: ::std::option::Option::None,
            num_clients: ::std::option::Option::None,
            num_bots: ::std::option::Option::None,
            num_spectators: ::std::option::Option::None,
            num_tv_relays: ::std::option::Option::None,
            fps: ::std::option::Option::None,
            ports: ::std::vec::Vec::new(),
            avg_latency_out: ::std::option::Option::None,
            avg_latency_in: ::std::option::Option::None,
            avg_packets_out: ::std::option::Option::None,
            avg_packets_in: ::std::option::Option::None,
            avg_loss_out: ::std::option::Option::None,
            avg_loss_in: ::std::option::Option::None,
            avg_data_out: ::std::option::Option::None,
            avg_data_in: ::std::option::Option::None,
            total_data_in: ::std::option::Option::None,
            total_packets_in: ::std::option::Option::None,
            total_data_out: ::std::option::Option::None,
            total_packets_out: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerNetworkStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerNetworkStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerNetworkStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerNetworkStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerNetworkStats`
pub mod cmsg_server_network_stats {
    // @@protoc_insertion_point(message:CMsgServerNetworkStats.Port)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Port {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Port.port)
        pub port: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Port.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerNetworkStats.Port.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Port {
        fn default() -> &'a Port {
            <Port as ::protobuf::Message>::default_instance()
        }
    }

    impl Port {
        pub fn new() -> Port {
            ::std::default::Default::default()
        }

        // optional int32 port = 1;

        pub fn port(&self) -> i32 {
            self.port.unwrap_or(0)
        }

        pub fn clear_port(&mut self) {
            self.port = ::std::option::Option::None;
        }

        pub fn has_port(&self) -> bool {
            self.port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_port(&mut self, v: i32) {
            self.port = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "port",
                |m: &Port| { &m.port },
                |m: &mut Port| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Port| { &m.name },
                |m: &mut Port| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Port>(
                "CMsgServerNetworkStats.Port",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Port {
        const NAME: &'static str = "Port";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.port = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.port {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.port {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Port {
            Port::new()
        }

        fn clear(&mut self) {
            self.port = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Port {
            static instance: Port = Port {
                port: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Port {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerNetworkStats.Port").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Port {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Port {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgServerNetworkStats.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.remote_addr)
        pub remote_addr: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.ping_stddev_ms)
        pub ping_stddev_ms: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.ping_avg_ms)
        pub ping_avg_ms: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.packet_loss_pct)
        pub packet_loss_pct: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.is_bot)
        pub is_bot: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerNetworkStats.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional string remote_addr = 2;

        pub fn remote_addr(&self) -> &str {
            match self.remote_addr.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_remote_addr(&mut self) {
            self.remote_addr = ::std::option::Option::None;
        }

        pub fn has_remote_addr(&self) -> bool {
            self.remote_addr.is_some()
        }

        // Param is passed by value, moved
        pub fn set_remote_addr(&mut self, v: ::std::string::String) {
            self.remote_addr = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_remote_addr(&mut self) -> &mut ::std::string::String {
            if self.remote_addr.is_none() {
                self.remote_addr = ::std::option::Option::Some(::std::string::String::new());
            }
            self.remote_addr.as_mut().unwrap()
        }

        // Take field
        pub fn take_remote_addr(&mut self) -> ::std::string::String {
            self.remote_addr.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 ping_stddev_ms = 3;

        pub fn ping_stddev_ms(&self) -> i32 {
            self.ping_stddev_ms.unwrap_or(0)
        }

        pub fn clear_ping_stddev_ms(&mut self) {
            self.ping_stddev_ms = ::std::option::Option::None;
        }

        pub fn has_ping_stddev_ms(&self) -> bool {
            self.ping_stddev_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_stddev_ms(&mut self, v: i32) {
            self.ping_stddev_ms = ::std::option::Option::Some(v);
        }

        // optional int32 ping_avg_ms = 4;

        pub fn ping_avg_ms(&self) -> i32 {
            self.ping_avg_ms.unwrap_or(0)
        }

        pub fn clear_ping_avg_ms(&mut self) {
            self.ping_avg_ms = ::std::option::Option::None;
        }

        pub fn has_ping_avg_ms(&self) -> bool {
            self.ping_avg_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_avg_ms(&mut self, v: i32) {
            self.ping_avg_ms = ::std::option::Option::Some(v);
        }

        // optional float packet_loss_pct = 5;

        pub fn packet_loss_pct(&self) -> f32 {
            self.packet_loss_pct.unwrap_or(0.)
        }

        pub fn clear_packet_loss_pct(&mut self) {
            self.packet_loss_pct = ::std::option::Option::None;
        }

        pub fn has_packet_loss_pct(&self) -> bool {
            self.packet_loss_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packet_loss_pct(&mut self, v: f32) {
            self.packet_loss_pct = ::std::option::Option::Some(v);
        }

        // optional bool is_bot = 6;

        pub fn is_bot(&self) -> bool {
            self.is_bot.unwrap_or(false)
        }

        pub fn clear_is_bot(&mut self) {
            self.is_bot = ::std::option::Option::None;
        }

        pub fn has_is_bot(&self) -> bool {
            self.is_bot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_bot(&mut self, v: bool) {
            self.is_bot = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &Player| { &m.steamid },
                |m: &mut Player| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "remote_addr",
                |m: &Player| { &m.remote_addr },
                |m: &mut Player| { &mut m.remote_addr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping_stddev_ms",
                |m: &Player| { &m.ping_stddev_ms },
                |m: &mut Player| { &mut m.ping_stddev_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping_avg_ms",
                |m: &Player| { &m.ping_avg_ms },
                |m: &mut Player| { &mut m.ping_avg_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "packet_loss_pct",
                |m: &Player| { &m.packet_loss_pct },
                |m: &mut Player| { &mut m.packet_loss_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_bot",
                |m: &Player| { &m.is_bot },
                |m: &mut Player| { &mut m.is_bot },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgServerNetworkStats.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.remote_addr = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.ping_stddev_ms = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.ping_avg_ms = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.packet_loss_pct = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.is_bot = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.remote_addr.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.ping_stddev_ms {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.ping_avg_ms {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.packet_loss_pct {
                my_size += 1 + 4;
            }
            if let Some(v) = self.is_bot {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.remote_addr.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.ping_stddev_ms {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.ping_avg_ms {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.packet_loss_pct {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.is_bot {
                os.write_bool(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.remote_addr = ::std::option::Option::None;
            self.ping_stddev_ms = ::std::option::Option::None;
            self.ping_avg_ms = ::std::option::Option::None;
            self.packet_loss_pct = ::std::option::Option::None;
            self.is_bot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steamid: ::std::option::Option::None,
                remote_addr: ::std::option::Option::None,
                ping_stddev_ms: ::std::option::Option::None,
                ping_avg_ms: ::std::option::Option::None,
                packet_loss_pct: ::std::option::Option::None,
                is_bot: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerNetworkStats.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_HltvReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_HltvReplay {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.delay)
    pub delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.primary_target)
    pub primary_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_stop_at)
    pub replay_stop_at: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_start_at)
    pub replay_start_at: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_begin)
    pub replay_slowdown_begin: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_end)
    pub replay_slowdown_end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_rate)
    pub replay_slowdown_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.reason)
    pub reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_HltvReplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_HltvReplay {
    fn default() -> &'a CSVCMsg_HltvReplay {
        <CSVCMsg_HltvReplay as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_HltvReplay {
    pub fn new() -> CSVCMsg_HltvReplay {
        ::std::default::Default::default()
    }

    // optional int32 delay = 1;

    pub fn delay(&self) -> i32 {
        self.delay.unwrap_or(0)
    }

    pub fn clear_delay(&mut self) {
        self.delay = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: i32) {
        self.delay = ::std::option::Option::Some(v);
    }

    // optional int32 primary_target = 2;

    pub fn primary_target(&self) -> i32 {
        self.primary_target.unwrap_or(-1i32)
    }

    pub fn clear_primary_target(&mut self) {
        self.primary_target = ::std::option::Option::None;
    }

    pub fn has_primary_target(&self) -> bool {
        self.primary_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_target(&mut self, v: i32) {
        self.primary_target = ::std::option::Option::Some(v);
    }

    // optional int32 replay_stop_at = 3;

    pub fn replay_stop_at(&self) -> i32 {
        self.replay_stop_at.unwrap_or(0)
    }

    pub fn clear_replay_stop_at(&mut self) {
        self.replay_stop_at = ::std::option::Option::None;
    }

    pub fn has_replay_stop_at(&self) -> bool {
        self.replay_stop_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_stop_at(&mut self, v: i32) {
        self.replay_stop_at = ::std::option::Option::Some(v);
    }

    // optional int32 replay_start_at = 4;

    pub fn replay_start_at(&self) -> i32 {
        self.replay_start_at.unwrap_or(0)
    }

    pub fn clear_replay_start_at(&mut self) {
        self.replay_start_at = ::std::option::Option::None;
    }

    pub fn has_replay_start_at(&self) -> bool {
        self.replay_start_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_start_at(&mut self, v: i32) {
        self.replay_start_at = ::std::option::Option::Some(v);
    }

    // optional int32 replay_slowdown_begin = 5;

    pub fn replay_slowdown_begin(&self) -> i32 {
        self.replay_slowdown_begin.unwrap_or(0)
    }

    pub fn clear_replay_slowdown_begin(&mut self) {
        self.replay_slowdown_begin = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_begin(&self) -> bool {
        self.replay_slowdown_begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_begin(&mut self, v: i32) {
        self.replay_slowdown_begin = ::std::option::Option::Some(v);
    }

    // optional int32 replay_slowdown_end = 6;

    pub fn replay_slowdown_end(&self) -> i32 {
        self.replay_slowdown_end.unwrap_or(0)
    }

    pub fn clear_replay_slowdown_end(&mut self) {
        self.replay_slowdown_end = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_end(&self) -> bool {
        self.replay_slowdown_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_end(&mut self, v: i32) {
        self.replay_slowdown_end = ::std::option::Option::Some(v);
    }

    // optional float replay_slowdown_rate = 7;

    pub fn replay_slowdown_rate(&self) -> f32 {
        self.replay_slowdown_rate.unwrap_or(0.)
    }

    pub fn clear_replay_slowdown_rate(&mut self) {
        self.replay_slowdown_rate = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_rate(&self) -> bool {
        self.replay_slowdown_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_rate(&mut self, v: f32) {
        self.replay_slowdown_rate = ::std::option::Option::Some(v);
    }

    // optional int32 reason = 8;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delay",
            |m: &CSVCMsg_HltvReplay| { &m.delay },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_target",
            |m: &CSVCMsg_HltvReplay| { &m.primary_target },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.primary_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_stop_at",
            |m: &CSVCMsg_HltvReplay| { &m.replay_stop_at },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_stop_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_start_at",
            |m: &CSVCMsg_HltvReplay| { &m.replay_start_at },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_start_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_slowdown_begin",
            |m: &CSVCMsg_HltvReplay| { &m.replay_slowdown_begin },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_slowdown_begin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_slowdown_end",
            |m: &CSVCMsg_HltvReplay| { &m.replay_slowdown_end },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_slowdown_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_slowdown_rate",
            |m: &CSVCMsg_HltvReplay| { &m.replay_slowdown_rate },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_slowdown_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CSVCMsg_HltvReplay| { &m.reason },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_HltvReplay>(
            "CSVCMsg_HltvReplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_HltvReplay {
    const NAME: &'static str = "CSVCMsg_HltvReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.delay = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.primary_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.replay_stop_at = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.replay_start_at = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.replay_slowdown_begin = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.replay_slowdown_end = ::std::option::Option::Some(is.read_int32()?);
                },
                61 => {
                    self.replay_slowdown_rate = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.delay {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.primary_target {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.replay_stop_at {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.replay_start_at {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.replay_slowdown_begin {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.replay_slowdown_end {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.replay_slowdown_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.delay {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.primary_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.replay_stop_at {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.replay_start_at {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.replay_slowdown_begin {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.replay_slowdown_end {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.replay_slowdown_rate {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_HltvReplay {
        CSVCMsg_HltvReplay::new()
    }

    fn clear(&mut self) {
        self.delay = ::std::option::Option::None;
        self.primary_target = ::std::option::Option::None;
        self.replay_stop_at = ::std::option::Option::None;
        self.replay_start_at = ::std::option::Option::None;
        self.replay_slowdown_begin = ::std::option::Option::None;
        self.replay_slowdown_end = ::std::option::Option::None;
        self.replay_slowdown_rate = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_HltvReplay {
        static instance: CSVCMsg_HltvReplay = CSVCMsg_HltvReplay {
            delay: ::std::option::Option::None,
            primary_target: ::std::option::Option::None,
            replay_stop_at: ::std::option::Option::None,
            replay_start_at: ::std::option::Option::None,
            replay_slowdown_begin: ::std::option::Option::None,
            replay_slowdown_end: ::std::option::Option::None,
            replay_slowdown_rate: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_HltvReplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_HltvReplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_HltvReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_HltvReplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_HltvReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_HltvReplay {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.request)
    pub request: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.slowdown_length)
    pub slowdown_length: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.slowdown_rate)
    pub slowdown_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.primary_target)
    pub primary_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.event_time)
    pub event_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_HltvReplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_HltvReplay {
    fn default() -> &'a CCLCMsg_HltvReplay {
        <CCLCMsg_HltvReplay as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_HltvReplay {
    pub fn new() -> CCLCMsg_HltvReplay {
        ::std::default::Default::default()
    }

    // optional int32 request = 1;

    pub fn request(&self) -> i32 {
        self.request.unwrap_or(0)
    }

    pub fn clear_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: i32) {
        self.request = ::std::option::Option::Some(v);
    }

    // optional float slowdown_length = 2;

    pub fn slowdown_length(&self) -> f32 {
        self.slowdown_length.unwrap_or(0.)
    }

    pub fn clear_slowdown_length(&mut self) {
        self.slowdown_length = ::std::option::Option::None;
    }

    pub fn has_slowdown_length(&self) -> bool {
        self.slowdown_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slowdown_length(&mut self, v: f32) {
        self.slowdown_length = ::std::option::Option::Some(v);
    }

    // optional float slowdown_rate = 3;

    pub fn slowdown_rate(&self) -> f32 {
        self.slowdown_rate.unwrap_or(0.)
    }

    pub fn clear_slowdown_rate(&mut self) {
        self.slowdown_rate = ::std::option::Option::None;
    }

    pub fn has_slowdown_rate(&self) -> bool {
        self.slowdown_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slowdown_rate(&mut self, v: f32) {
        self.slowdown_rate = ::std::option::Option::Some(v);
    }

    // optional int32 primary_target = 4;

    pub fn primary_target(&self) -> i32 {
        self.primary_target.unwrap_or(-1i32)
    }

    pub fn clear_primary_target(&mut self) {
        self.primary_target = ::std::option::Option::None;
    }

    pub fn has_primary_target(&self) -> bool {
        self.primary_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_target(&mut self, v: i32) {
        self.primary_target = ::std::option::Option::Some(v);
    }

    // optional float event_time = 5;

    pub fn event_time(&self) -> f32 {
        self.event_time.unwrap_or(0.)
    }

    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: f32) {
        self.event_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request",
            |m: &CCLCMsg_HltvReplay| { &m.request },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slowdown_length",
            |m: &CCLCMsg_HltvReplay| { &m.slowdown_length },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.slowdown_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slowdown_rate",
            |m: &CCLCMsg_HltvReplay| { &m.slowdown_rate },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.slowdown_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_target",
            |m: &CCLCMsg_HltvReplay| { &m.primary_target },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.primary_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_time",
            |m: &CCLCMsg_HltvReplay| { &m.event_time },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.event_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_HltvReplay>(
            "CCLCMsg_HltvReplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_HltvReplay {
    const NAME: &'static str = "CCLCMsg_HltvReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.slowdown_length = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.slowdown_rate = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.primary_target = ::std::option::Option::Some(is.read_int32()?);
                },
                45 => {
                    self.event_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.slowdown_length {
            my_size += 1 + 4;
        }
        if let Some(v) = self.slowdown_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.primary_target {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.event_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slowdown_length {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.slowdown_rate {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.primary_target {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_HltvReplay {
        CCLCMsg_HltvReplay::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.slowdown_length = ::std::option::Option::None;
        self.slowdown_rate = ::std::option::Option::None;
        self.primary_target = ::std::option::Option::None;
        self.event_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_HltvReplay {
        static instance: CCLCMsg_HltvReplay = CCLCMsg_HltvReplay {
            request: ::std::option::Option::None,
            slowdown_length: ::std::option::Option::None,
            slowdown_rate: ::std::option::Option::None,
            primary_target: ::std::option::Option::None,
            event_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_HltvReplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_HltvReplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_HltvReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_HltvReplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_Broadcast_Command)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Broadcast_Command {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Broadcast_Command.cmd)
    pub cmd: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Broadcast_Command.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Broadcast_Command {
    fn default() -> &'a CSVCMsg_Broadcast_Command {
        <CSVCMsg_Broadcast_Command as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Broadcast_Command {
    pub fn new() -> CSVCMsg_Broadcast_Command {
        ::std::default::Default::default()
    }

    // optional string cmd = 1;

    pub fn cmd(&self) -> &str {
        match self.cmd.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: ::std::string::String) {
        self.cmd = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd(&mut self) -> &mut ::std::string::String {
        if self.cmd.is_none() {
            self.cmd = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_cmd(&mut self) -> ::std::string::String {
        self.cmd.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd",
            |m: &CSVCMsg_Broadcast_Command| { &m.cmd },
            |m: &mut CSVCMsg_Broadcast_Command| { &mut m.cmd },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Broadcast_Command>(
            "CSVCMsg_Broadcast_Command",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Broadcast_Command {
    const NAME: &'static str = "CSVCMsg_Broadcast_Command";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cmd = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cmd.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cmd.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Broadcast_Command {
        CSVCMsg_Broadcast_Command::new()
    }

    fn clear(&mut self) {
        self.cmd = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Broadcast_Command {
        static instance: CSVCMsg_Broadcast_Command = CSVCMsg_Broadcast_Command {
            cmd: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Broadcast_Command {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Broadcast_Command").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Broadcast_Command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Broadcast_Command {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_HltvFixupOperatorTick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_HltvFixupOperatorTick {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.tick)
    pub tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.props_data)
    pub props_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.eye_angles)
    pub eye_angles: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.observer_mode)
    pub observer_mode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.cameraman_scoreboard)
    pub cameraman_scoreboard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.observer_target)
    pub observer_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.view_offset)
    pub view_offset: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_HltvFixupOperatorTick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_HltvFixupOperatorTick {
    fn default() -> &'a CCLCMsg_HltvFixupOperatorTick {
        <CCLCMsg_HltvFixupOperatorTick as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_HltvFixupOperatorTick {
    pub fn new() -> CCLCMsg_HltvFixupOperatorTick {
        ::std::default::Default::default()
    }

    // optional int32 tick = 1;

    pub fn tick(&self) -> i32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional bytes props_data = 2;

    pub fn props_data(&self) -> &[u8] {
        match self.props_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_props_data(&mut self) {
        self.props_data = ::std::option::Option::None;
    }

    pub fn has_props_data(&self) -> bool {
        self.props_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_props_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.props_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_props_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.props_data.is_none() {
            self.props_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.props_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_props_data(&mut self) -> ::std::vec::Vec<u8> {
        self.props_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 observer_mode = 5;

    pub fn observer_mode(&self) -> i32 {
        self.observer_mode.unwrap_or(0)
    }

    pub fn clear_observer_mode(&mut self) {
        self.observer_mode = ::std::option::Option::None;
    }

    pub fn has_observer_mode(&self) -> bool {
        self.observer_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observer_mode(&mut self, v: i32) {
        self.observer_mode = ::std::option::Option::Some(v);
    }

    // optional bool cameraman_scoreboard = 6;

    pub fn cameraman_scoreboard(&self) -> bool {
        self.cameraman_scoreboard.unwrap_or(false)
    }

    pub fn clear_cameraman_scoreboard(&mut self) {
        self.cameraman_scoreboard = ::std::option::Option::None;
    }

    pub fn has_cameraman_scoreboard(&self) -> bool {
        self.cameraman_scoreboard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cameraman_scoreboard(&mut self, v: bool) {
        self.cameraman_scoreboard = ::std::option::Option::Some(v);
    }

    // optional int32 observer_target = 7;

    pub fn observer_target(&self) -> i32 {
        self.observer_target.unwrap_or(0)
    }

    pub fn clear_observer_target(&mut self) {
        self.observer_target = ::std::option::Option::None;
    }

    pub fn has_observer_target(&self) -> bool {
        self.observer_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observer_target(&mut self, v: i32) {
        self.observer_target = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.tick },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "props_data",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.props_data },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.props_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.origin },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "eye_angles",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.eye_angles },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.eye_angles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observer_mode",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.observer_mode },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.observer_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cameraman_scoreboard",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.cameraman_scoreboard },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.cameraman_scoreboard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observer_target",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.observer_target },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.observer_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "view_offset",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.view_offset },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.view_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_HltvFixupOperatorTick>(
            "CCLCMsg_HltvFixupOperatorTick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_HltvFixupOperatorTick {
    const NAME: &'static str = "CCLCMsg_HltvFixupOperatorTick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.props_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eye_angles)?;
                },
                40 => {
                    self.observer_mode = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.cameraman_scoreboard = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.observer_target = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.view_offset)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.props_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eye_angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.observer_mode {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.cameraman_scoreboard {
            my_size += 1 + 1;
        }
        if let Some(v) = self.observer_target {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.view_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.props_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.eye_angles.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.observer_mode {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.cameraman_scoreboard {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.observer_target {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.view_offset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_HltvFixupOperatorTick {
        CCLCMsg_HltvFixupOperatorTick::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.props_data = ::std::option::Option::None;
        self.origin.clear();
        self.eye_angles.clear();
        self.observer_mode = ::std::option::Option::None;
        self.cameraman_scoreboard = ::std::option::Option::None;
        self.observer_target = ::std::option::Option::None;
        self.view_offset.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_HltvFixupOperatorTick {
        static instance: CCLCMsg_HltvFixupOperatorTick = CCLCMsg_HltvFixupOperatorTick {
            tick: ::std::option::Option::None,
            props_data: ::std::option::Option::None,
            origin: ::protobuf::MessageField::none(),
            eye_angles: ::protobuf::MessageField::none(),
            observer_mode: ::std::option::Option::None,
            cameraman_scoreboard: ::std::option::Option::None,
            observer_target: ::std::option::Option::None,
            view_offset: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_HltvFixupOperatorTick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_HltvFixupOperatorTick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_HltvFixupOperatorTick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_HltvFixupOperatorTick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_HltvFixupOperatorStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_HltvFixupOperatorStatus {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_HltvFixupOperatorStatus.mode)
    pub mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvFixupOperatorStatus.override_operator_name)
    pub override_operator_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_HltvFixupOperatorStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_HltvFixupOperatorStatus {
    fn default() -> &'a CSVCMsg_HltvFixupOperatorStatus {
        <CSVCMsg_HltvFixupOperatorStatus as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_HltvFixupOperatorStatus {
    pub fn new() -> CSVCMsg_HltvFixupOperatorStatus {
        ::std::default::Default::default()
    }

    // optional uint32 mode = 1;

    pub fn mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional string override_operator_name = 2;

    pub fn override_operator_name(&self) -> &str {
        match self.override_operator_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_override_operator_name(&mut self) {
        self.override_operator_name = ::std::option::Option::None;
    }

    pub fn has_override_operator_name(&self) -> bool {
        self.override_operator_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_operator_name(&mut self, v: ::std::string::String) {
        self.override_operator_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_override_operator_name(&mut self) -> &mut ::std::string::String {
        if self.override_operator_name.is_none() {
            self.override_operator_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.override_operator_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_override_operator_name(&mut self) -> ::std::string::String {
        self.override_operator_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &CSVCMsg_HltvFixupOperatorStatus| { &m.mode },
            |m: &mut CSVCMsg_HltvFixupOperatorStatus| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_operator_name",
            |m: &CSVCMsg_HltvFixupOperatorStatus| { &m.override_operator_name },
            |m: &mut CSVCMsg_HltvFixupOperatorStatus| { &mut m.override_operator_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_HltvFixupOperatorStatus>(
            "CSVCMsg_HltvFixupOperatorStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_HltvFixupOperatorStatus {
    const NAME: &'static str = "CSVCMsg_HltvFixupOperatorStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.override_operator_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.override_operator_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.override_operator_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_HltvFixupOperatorStatus {
        CSVCMsg_HltvFixupOperatorStatus::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.override_operator_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_HltvFixupOperatorStatus {
        static instance: CSVCMsg_HltvFixupOperatorStatus = CSVCMsg_HltvFixupOperatorStatus {
            mode: ::std::option::Option::None,
            override_operator_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_HltvFixupOperatorStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_HltvFixupOperatorStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_HltvFixupOperatorStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_HltvFixupOperatorStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CLC_Messages)
pub enum CLC_Messages {
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ClientInfo)
    clc_ClientInfo = 20,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_Move)
    clc_Move = 21,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_VoiceData)
    clc_VoiceData = 22,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_BaselineAck)
    clc_BaselineAck = 23,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ListenEvents)
    clc_ListenEvents = 24,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_RespondCvarValue)
    clc_RespondCvarValue = 25,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_FileCRCCheck)
    clc_FileCRCCheck = 26,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_LoadingProgress)
    clc_LoadingProgress = 27,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_SplitPlayerConnect)
    clc_SplitPlayerConnect = 28,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ClientMessage)
    clc_ClientMessage = 29,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_SplitPlayerDisconnect)
    clc_SplitPlayerDisconnect = 30,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ServerStatus)
    clc_ServerStatus = 31,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ServerPing)
    clc_ServerPing = 32,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_RequestPause)
    clc_RequestPause = 33,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_CmdKeyValues)
    clc_CmdKeyValues = 34,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_RconServerDetails)
    clc_RconServerDetails = 35,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_HltvReplay)
    clc_HltvReplay = 36,
}

impl ::protobuf::Enum for CLC_Messages {
    const NAME: &'static str = "CLC_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CLC_Messages> {
        match value {
            20 => ::std::option::Option::Some(CLC_Messages::clc_ClientInfo),
            21 => ::std::option::Option::Some(CLC_Messages::clc_Move),
            22 => ::std::option::Option::Some(CLC_Messages::clc_VoiceData),
            23 => ::std::option::Option::Some(CLC_Messages::clc_BaselineAck),
            24 => ::std::option::Option::Some(CLC_Messages::clc_ListenEvents),
            25 => ::std::option::Option::Some(CLC_Messages::clc_RespondCvarValue),
            26 => ::std::option::Option::Some(CLC_Messages::clc_FileCRCCheck),
            27 => ::std::option::Option::Some(CLC_Messages::clc_LoadingProgress),
            28 => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerConnect),
            29 => ::std::option::Option::Some(CLC_Messages::clc_ClientMessage),
            30 => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerDisconnect),
            31 => ::std::option::Option::Some(CLC_Messages::clc_ServerStatus),
            32 => ::std::option::Option::Some(CLC_Messages::clc_ServerPing),
            33 => ::std::option::Option::Some(CLC_Messages::clc_RequestPause),
            34 => ::std::option::Option::Some(CLC_Messages::clc_CmdKeyValues),
            35 => ::std::option::Option::Some(CLC_Messages::clc_RconServerDetails),
            36 => ::std::option::Option::Some(CLC_Messages::clc_HltvReplay),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CLC_Messages> {
        match str {
            "clc_ClientInfo" => ::std::option::Option::Some(CLC_Messages::clc_ClientInfo),
            "clc_Move" => ::std::option::Option::Some(CLC_Messages::clc_Move),
            "clc_VoiceData" => ::std::option::Option::Some(CLC_Messages::clc_VoiceData),
            "clc_BaselineAck" => ::std::option::Option::Some(CLC_Messages::clc_BaselineAck),
            "clc_ListenEvents" => ::std::option::Option::Some(CLC_Messages::clc_ListenEvents),
            "clc_RespondCvarValue" => ::std::option::Option::Some(CLC_Messages::clc_RespondCvarValue),
            "clc_FileCRCCheck" => ::std::option::Option::Some(CLC_Messages::clc_FileCRCCheck),
            "clc_LoadingProgress" => ::std::option::Option::Some(CLC_Messages::clc_LoadingProgress),
            "clc_SplitPlayerConnect" => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerConnect),
            "clc_ClientMessage" => ::std::option::Option::Some(CLC_Messages::clc_ClientMessage),
            "clc_SplitPlayerDisconnect" => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerDisconnect),
            "clc_ServerStatus" => ::std::option::Option::Some(CLC_Messages::clc_ServerStatus),
            "clc_ServerPing" => ::std::option::Option::Some(CLC_Messages::clc_ServerPing),
            "clc_RequestPause" => ::std::option::Option::Some(CLC_Messages::clc_RequestPause),
            "clc_CmdKeyValues" => ::std::option::Option::Some(CLC_Messages::clc_CmdKeyValues),
            "clc_RconServerDetails" => ::std::option::Option::Some(CLC_Messages::clc_RconServerDetails),
            "clc_HltvReplay" => ::std::option::Option::Some(CLC_Messages::clc_HltvReplay),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CLC_Messages] = &[
        CLC_Messages::clc_ClientInfo,
        CLC_Messages::clc_Move,
        CLC_Messages::clc_VoiceData,
        CLC_Messages::clc_BaselineAck,
        CLC_Messages::clc_ListenEvents,
        CLC_Messages::clc_RespondCvarValue,
        CLC_Messages::clc_FileCRCCheck,
        CLC_Messages::clc_LoadingProgress,
        CLC_Messages::clc_SplitPlayerConnect,
        CLC_Messages::clc_ClientMessage,
        CLC_Messages::clc_SplitPlayerDisconnect,
        CLC_Messages::clc_ServerStatus,
        CLC_Messages::clc_ServerPing,
        CLC_Messages::clc_RequestPause,
        CLC_Messages::clc_CmdKeyValues,
        CLC_Messages::clc_RconServerDetails,
        CLC_Messages::clc_HltvReplay,
    ];
}

impl ::protobuf::EnumFull for CLC_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CLC_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CLC_Messages::clc_ClientInfo => 0,
            CLC_Messages::clc_Move => 1,
            CLC_Messages::clc_VoiceData => 2,
            CLC_Messages::clc_BaselineAck => 3,
            CLC_Messages::clc_ListenEvents => 4,
            CLC_Messages::clc_RespondCvarValue => 5,
            CLC_Messages::clc_FileCRCCheck => 6,
            CLC_Messages::clc_LoadingProgress => 7,
            CLC_Messages::clc_SplitPlayerConnect => 8,
            CLC_Messages::clc_ClientMessage => 9,
            CLC_Messages::clc_SplitPlayerDisconnect => 10,
            CLC_Messages::clc_ServerStatus => 11,
            CLC_Messages::clc_ServerPing => 12,
            CLC_Messages::clc_RequestPause => 13,
            CLC_Messages::clc_CmdKeyValues => 14,
            CLC_Messages::clc_RconServerDetails => 15,
            CLC_Messages::clc_HltvReplay => 16,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CLC_Messages {
    fn default() -> Self {
        CLC_Messages::clc_ClientInfo
    }
}

impl CLC_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CLC_Messages>("CLC_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SVC_Messages)
pub enum SVC_Messages {
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ServerInfo)
    svc_ServerInfo = 40,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_FlattenedSerializer)
    svc_FlattenedSerializer = 41,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ClassInfo)
    svc_ClassInfo = 42,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SetPause)
    svc_SetPause = 43,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_CreateStringTable)
    svc_CreateStringTable = 44,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_UpdateStringTable)
    svc_UpdateStringTable = 45,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_VoiceInit)
    svc_VoiceInit = 46,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_VoiceData)
    svc_VoiceData = 47,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Print)
    svc_Print = 48,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Sounds)
    svc_Sounds = 49,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SetView)
    svc_SetView = 50,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ClearAllStringTables)
    svc_ClearAllStringTables = 51,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_CmdKeyValues)
    svc_CmdKeyValues = 52,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_BSPDecal)
    svc_BSPDecal = 53,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SplitScreen)
    svc_SplitScreen = 54,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PacketEntities)
    svc_PacketEntities = 55,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Prefetch)
    svc_Prefetch = 56,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Menu)
    svc_Menu = 57,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_GetCvarValue)
    svc_GetCvarValue = 58,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_StopSound)
    svc_StopSound = 59,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PeerList)
    svc_PeerList = 60,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PacketReliable)
    svc_PacketReliable = 61,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_HLTVStatus)
    svc_HLTVStatus = 62,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ServerSteamID)
    svc_ServerSteamID = 63,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_FullFrameSplit)
    svc_FullFrameSplit = 70,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_RconServerDetails)
    svc_RconServerDetails = 71,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_UserMessage)
    svc_UserMessage = 72,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_HltvReplay)
    svc_HltvReplay = 73,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Broadcast_Command)
    svc_Broadcast_Command = 74,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_HltvFixupOperatorStatus)
    svc_HltvFixupOperatorStatus = 75,
}

impl ::protobuf::Enum for SVC_Messages {
    const NAME: &'static str = "SVC_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SVC_Messages> {
        match value {
            40 => ::std::option::Option::Some(SVC_Messages::svc_ServerInfo),
            41 => ::std::option::Option::Some(SVC_Messages::svc_FlattenedSerializer),
            42 => ::std::option::Option::Some(SVC_Messages::svc_ClassInfo),
            43 => ::std::option::Option::Some(SVC_Messages::svc_SetPause),
            44 => ::std::option::Option::Some(SVC_Messages::svc_CreateStringTable),
            45 => ::std::option::Option::Some(SVC_Messages::svc_UpdateStringTable),
            46 => ::std::option::Option::Some(SVC_Messages::svc_VoiceInit),
            47 => ::std::option::Option::Some(SVC_Messages::svc_VoiceData),
            48 => ::std::option::Option::Some(SVC_Messages::svc_Print),
            49 => ::std::option::Option::Some(SVC_Messages::svc_Sounds),
            50 => ::std::option::Option::Some(SVC_Messages::svc_SetView),
            51 => ::std::option::Option::Some(SVC_Messages::svc_ClearAllStringTables),
            52 => ::std::option::Option::Some(SVC_Messages::svc_CmdKeyValues),
            53 => ::std::option::Option::Some(SVC_Messages::svc_BSPDecal),
            54 => ::std::option::Option::Some(SVC_Messages::svc_SplitScreen),
            55 => ::std::option::Option::Some(SVC_Messages::svc_PacketEntities),
            56 => ::std::option::Option::Some(SVC_Messages::svc_Prefetch),
            57 => ::std::option::Option::Some(SVC_Messages::svc_Menu),
            58 => ::std::option::Option::Some(SVC_Messages::svc_GetCvarValue),
            59 => ::std::option::Option::Some(SVC_Messages::svc_StopSound),
            60 => ::std::option::Option::Some(SVC_Messages::svc_PeerList),
            61 => ::std::option::Option::Some(SVC_Messages::svc_PacketReliable),
            62 => ::std::option::Option::Some(SVC_Messages::svc_HLTVStatus),
            63 => ::std::option::Option::Some(SVC_Messages::svc_ServerSteamID),
            70 => ::std::option::Option::Some(SVC_Messages::svc_FullFrameSplit),
            71 => ::std::option::Option::Some(SVC_Messages::svc_RconServerDetails),
            72 => ::std::option::Option::Some(SVC_Messages::svc_UserMessage),
            73 => ::std::option::Option::Some(SVC_Messages::svc_HltvReplay),
            74 => ::std::option::Option::Some(SVC_Messages::svc_Broadcast_Command),
            75 => ::std::option::Option::Some(SVC_Messages::svc_HltvFixupOperatorStatus),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SVC_Messages> {
        match str {
            "svc_ServerInfo" => ::std::option::Option::Some(SVC_Messages::svc_ServerInfo),
            "svc_FlattenedSerializer" => ::std::option::Option::Some(SVC_Messages::svc_FlattenedSerializer),
            "svc_ClassInfo" => ::std::option::Option::Some(SVC_Messages::svc_ClassInfo),
            "svc_SetPause" => ::std::option::Option::Some(SVC_Messages::svc_SetPause),
            "svc_CreateStringTable" => ::std::option::Option::Some(SVC_Messages::svc_CreateStringTable),
            "svc_UpdateStringTable" => ::std::option::Option::Some(SVC_Messages::svc_UpdateStringTable),
            "svc_VoiceInit" => ::std::option::Option::Some(SVC_Messages::svc_VoiceInit),
            "svc_VoiceData" => ::std::option::Option::Some(SVC_Messages::svc_VoiceData),
            "svc_Print" => ::std::option::Option::Some(SVC_Messages::svc_Print),
            "svc_Sounds" => ::std::option::Option::Some(SVC_Messages::svc_Sounds),
            "svc_SetView" => ::std::option::Option::Some(SVC_Messages::svc_SetView),
            "svc_ClearAllStringTables" => ::std::option::Option::Some(SVC_Messages::svc_ClearAllStringTables),
            "svc_CmdKeyValues" => ::std::option::Option::Some(SVC_Messages::svc_CmdKeyValues),
            "svc_BSPDecal" => ::std::option::Option::Some(SVC_Messages::svc_BSPDecal),
            "svc_SplitScreen" => ::std::option::Option::Some(SVC_Messages::svc_SplitScreen),
            "svc_PacketEntities" => ::std::option::Option::Some(SVC_Messages::svc_PacketEntities),
            "svc_Prefetch" => ::std::option::Option::Some(SVC_Messages::svc_Prefetch),
            "svc_Menu" => ::std::option::Option::Some(SVC_Messages::svc_Menu),
            "svc_GetCvarValue" => ::std::option::Option::Some(SVC_Messages::svc_GetCvarValue),
            "svc_StopSound" => ::std::option::Option::Some(SVC_Messages::svc_StopSound),
            "svc_PeerList" => ::std::option::Option::Some(SVC_Messages::svc_PeerList),
            "svc_PacketReliable" => ::std::option::Option::Some(SVC_Messages::svc_PacketReliable),
            "svc_HLTVStatus" => ::std::option::Option::Some(SVC_Messages::svc_HLTVStatus),
            "svc_ServerSteamID" => ::std::option::Option::Some(SVC_Messages::svc_ServerSteamID),
            "svc_FullFrameSplit" => ::std::option::Option::Some(SVC_Messages::svc_FullFrameSplit),
            "svc_RconServerDetails" => ::std::option::Option::Some(SVC_Messages::svc_RconServerDetails),
            "svc_UserMessage" => ::std::option::Option::Some(SVC_Messages::svc_UserMessage),
            "svc_HltvReplay" => ::std::option::Option::Some(SVC_Messages::svc_HltvReplay),
            "svc_Broadcast_Command" => ::std::option::Option::Some(SVC_Messages::svc_Broadcast_Command),
            "svc_HltvFixupOperatorStatus" => ::std::option::Option::Some(SVC_Messages::svc_HltvFixupOperatorStatus),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SVC_Messages] = &[
        SVC_Messages::svc_ServerInfo,
        SVC_Messages::svc_FlattenedSerializer,
        SVC_Messages::svc_ClassInfo,
        SVC_Messages::svc_SetPause,
        SVC_Messages::svc_CreateStringTable,
        SVC_Messages::svc_UpdateStringTable,
        SVC_Messages::svc_VoiceInit,
        SVC_Messages::svc_VoiceData,
        SVC_Messages::svc_Print,
        SVC_Messages::svc_Sounds,
        SVC_Messages::svc_SetView,
        SVC_Messages::svc_ClearAllStringTables,
        SVC_Messages::svc_CmdKeyValues,
        SVC_Messages::svc_BSPDecal,
        SVC_Messages::svc_SplitScreen,
        SVC_Messages::svc_PacketEntities,
        SVC_Messages::svc_Prefetch,
        SVC_Messages::svc_Menu,
        SVC_Messages::svc_GetCvarValue,
        SVC_Messages::svc_StopSound,
        SVC_Messages::svc_PeerList,
        SVC_Messages::svc_PacketReliable,
        SVC_Messages::svc_HLTVStatus,
        SVC_Messages::svc_ServerSteamID,
        SVC_Messages::svc_FullFrameSplit,
        SVC_Messages::svc_RconServerDetails,
        SVC_Messages::svc_UserMessage,
        SVC_Messages::svc_HltvReplay,
        SVC_Messages::svc_Broadcast_Command,
        SVC_Messages::svc_HltvFixupOperatorStatus,
    ];
}

impl ::protobuf::EnumFull for SVC_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SVC_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SVC_Messages::svc_ServerInfo => 0,
            SVC_Messages::svc_FlattenedSerializer => 1,
            SVC_Messages::svc_ClassInfo => 2,
            SVC_Messages::svc_SetPause => 3,
            SVC_Messages::svc_CreateStringTable => 4,
            SVC_Messages::svc_UpdateStringTable => 5,
            SVC_Messages::svc_VoiceInit => 6,
            SVC_Messages::svc_VoiceData => 7,
            SVC_Messages::svc_Print => 8,
            SVC_Messages::svc_Sounds => 9,
            SVC_Messages::svc_SetView => 10,
            SVC_Messages::svc_ClearAllStringTables => 11,
            SVC_Messages::svc_CmdKeyValues => 12,
            SVC_Messages::svc_BSPDecal => 13,
            SVC_Messages::svc_SplitScreen => 14,
            SVC_Messages::svc_PacketEntities => 15,
            SVC_Messages::svc_Prefetch => 16,
            SVC_Messages::svc_Menu => 17,
            SVC_Messages::svc_GetCvarValue => 18,
            SVC_Messages::svc_StopSound => 19,
            SVC_Messages::svc_PeerList => 20,
            SVC_Messages::svc_PacketReliable => 21,
            SVC_Messages::svc_HLTVStatus => 22,
            SVC_Messages::svc_ServerSteamID => 23,
            SVC_Messages::svc_FullFrameSplit => 24,
            SVC_Messages::svc_RconServerDetails => 25,
            SVC_Messages::svc_UserMessage => 26,
            SVC_Messages::svc_HltvReplay => 27,
            SVC_Messages::svc_Broadcast_Command => 28,
            SVC_Messages::svc_HltvFixupOperatorStatus => 29,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SVC_Messages {
    fn default() -> Self {
        SVC_Messages::svc_ServerInfo
    }
}

impl SVC_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SVC_Messages>("SVC_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VoiceDataFormat_t)
pub enum VoiceDataFormat_t {
    // @@protoc_insertion_point(enum_value:VoiceDataFormat_t.VOICEDATA_FORMAT_STEAM)
    VOICEDATA_FORMAT_STEAM = 0,
    // @@protoc_insertion_point(enum_value:VoiceDataFormat_t.VOICEDATA_FORMAT_ENGINE)
    VOICEDATA_FORMAT_ENGINE = 1,
}

impl ::protobuf::Enum for VoiceDataFormat_t {
    const NAME: &'static str = "VoiceDataFormat_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoiceDataFormat_t> {
        match value {
            0 => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM),
            1 => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VoiceDataFormat_t> {
        match str {
            "VOICEDATA_FORMAT_STEAM" => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM),
            "VOICEDATA_FORMAT_ENGINE" => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VoiceDataFormat_t] = &[
        VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM,
        VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE,
    ];
}

impl ::protobuf::EnumFull for VoiceDataFormat_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VoiceDataFormat_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VoiceDataFormat_t {
    fn default() -> Self {
        VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM
    }
}

impl VoiceDataFormat_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VoiceDataFormat_t>("VoiceDataFormat_t")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RequestPause_t)
pub enum RequestPause_t {
    // @@protoc_insertion_point(enum_value:RequestPause_t.RP_PAUSE)
    RP_PAUSE = 0,
    // @@protoc_insertion_point(enum_value:RequestPause_t.RP_UNPAUSE)
    RP_UNPAUSE = 1,
    // @@protoc_insertion_point(enum_value:RequestPause_t.RP_TOGGLEPAUSE)
    RP_TOGGLEPAUSE = 2,
}

impl ::protobuf::Enum for RequestPause_t {
    const NAME: &'static str = "RequestPause_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestPause_t> {
        match value {
            0 => ::std::option::Option::Some(RequestPause_t::RP_PAUSE),
            1 => ::std::option::Option::Some(RequestPause_t::RP_UNPAUSE),
            2 => ::std::option::Option::Some(RequestPause_t::RP_TOGGLEPAUSE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RequestPause_t> {
        match str {
            "RP_PAUSE" => ::std::option::Option::Some(RequestPause_t::RP_PAUSE),
            "RP_UNPAUSE" => ::std::option::Option::Some(RequestPause_t::RP_UNPAUSE),
            "RP_TOGGLEPAUSE" => ::std::option::Option::Some(RequestPause_t::RP_TOGGLEPAUSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RequestPause_t] = &[
        RequestPause_t::RP_PAUSE,
        RequestPause_t::RP_UNPAUSE,
        RequestPause_t::RP_TOGGLEPAUSE,
    ];
}

impl ::protobuf::EnumFull for RequestPause_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RequestPause_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RequestPause_t {
    fn default() -> Self {
        RequestPause_t::RP_PAUSE
    }
}

impl RequestPause_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RequestPause_t>("RequestPause_t")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PrefetchType)
pub enum PrefetchType {
    // @@protoc_insertion_point(enum_value:PrefetchType.PFT_SOUND)
    PFT_SOUND = 0,
}

impl ::protobuf::Enum for PrefetchType {
    const NAME: &'static str = "PrefetchType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrefetchType> {
        match value {
            0 => ::std::option::Option::Some(PrefetchType::PFT_SOUND),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PrefetchType> {
        match str {
            "PFT_SOUND" => ::std::option::Option::Some(PrefetchType::PFT_SOUND),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PrefetchType] = &[
        PrefetchType::PFT_SOUND,
    ];
}

impl ::protobuf::EnumFull for PrefetchType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PrefetchType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PrefetchType {
    fn default() -> Self {
        PrefetchType::PFT_SOUND
    }
}

impl PrefetchType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PrefetchType>("PrefetchType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESplitScreenMessageType)
pub enum ESplitScreenMessageType {
    // @@protoc_insertion_point(enum_value:ESplitScreenMessageType.MSG_SPLITSCREEN_ADDUSER)
    MSG_SPLITSCREEN_ADDUSER = 0,
    // @@protoc_insertion_point(enum_value:ESplitScreenMessageType.MSG_SPLITSCREEN_REMOVEUSER)
    MSG_SPLITSCREEN_REMOVEUSER = 1,
}

impl ::protobuf::Enum for ESplitScreenMessageType {
    const NAME: &'static str = "ESplitScreenMessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESplitScreenMessageType> {
        match value {
            0 => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            1 => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESplitScreenMessageType> {
        match str {
            "MSG_SPLITSCREEN_ADDUSER" => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            "MSG_SPLITSCREEN_REMOVEUSER" => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESplitScreenMessageType] = &[
        ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER,
        ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER,
    ];
}

impl ::protobuf::EnumFull for ESplitScreenMessageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESplitScreenMessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESplitScreenMessageType {
    fn default() -> Self {
        ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER
    }
}

impl ESplitScreenMessageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESplitScreenMessageType>("ESplitScreenMessageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EQueryCvarValueStatus)
pub enum EQueryCvarValueStatus {
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_ValueIntact)
    eQueryCvarValueStatus_ValueIntact = 0,
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_CvarNotFound)
    eQueryCvarValueStatus_CvarNotFound = 1,
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_NotACvar)
    eQueryCvarValueStatus_NotACvar = 2,
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_CvarProtected)
    eQueryCvarValueStatus_CvarProtected = 3,
}

impl ::protobuf::Enum for EQueryCvarValueStatus {
    const NAME: &'static str = "EQueryCvarValueStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EQueryCvarValueStatus> {
        match value {
            0 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact),
            1 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarNotFound),
            2 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_NotACvar),
            3 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarProtected),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EQueryCvarValueStatus> {
        match str {
            "eQueryCvarValueStatus_ValueIntact" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact),
            "eQueryCvarValueStatus_CvarNotFound" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarNotFound),
            "eQueryCvarValueStatus_NotACvar" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_NotACvar),
            "eQueryCvarValueStatus_CvarProtected" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarProtected),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EQueryCvarValueStatus] = &[
        EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact,
        EQueryCvarValueStatus::eQueryCvarValueStatus_CvarNotFound,
        EQueryCvarValueStatus::eQueryCvarValueStatus_NotACvar,
        EQueryCvarValueStatus::eQueryCvarValueStatus_CvarProtected,
    ];
}

impl ::protobuf::EnumFull for EQueryCvarValueStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EQueryCvarValueStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EQueryCvarValueStatus {
    fn default() -> Self {
        EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact
    }
}

impl EQueryCvarValueStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EQueryCvarValueStatus>("EQueryCvarValueStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DIALOG_TYPE)
pub enum DIALOG_TYPE {
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_MSG)
    DIALOG_MSG = 0,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_MENU)
    DIALOG_MENU = 1,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_TEXT)
    DIALOG_TEXT = 2,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_ENTRY)
    DIALOG_ENTRY = 3,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_ASKCONNECT)
    DIALOG_ASKCONNECT = 4,
}

impl ::protobuf::Enum for DIALOG_TYPE {
    const NAME: &'static str = "DIALOG_TYPE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DIALOG_TYPE> {
        match value {
            0 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MSG),
            1 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MENU),
            2 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_TEXT),
            3 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ENTRY),
            4 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ASKCONNECT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DIALOG_TYPE> {
        match str {
            "DIALOG_MSG" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MSG),
            "DIALOG_MENU" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MENU),
            "DIALOG_TEXT" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_TEXT),
            "DIALOG_ENTRY" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ENTRY),
            "DIALOG_ASKCONNECT" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ASKCONNECT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DIALOG_TYPE] = &[
        DIALOG_TYPE::DIALOG_MSG,
        DIALOG_TYPE::DIALOG_MENU,
        DIALOG_TYPE::DIALOG_TEXT,
        DIALOG_TYPE::DIALOG_ENTRY,
        DIALOG_TYPE::DIALOG_ASKCONNECT,
    ];
}

impl ::protobuf::EnumFull for DIALOG_TYPE {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DIALOG_TYPE").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DIALOG_TYPE {
    fn default() -> Self {
        DIALOG_TYPE::DIALOG_MSG
    }
}

impl DIALOG_TYPE {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DIALOG_TYPE>("DIALOG_TYPE")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SVC_Messages_LowFrequency)
pub enum SVC_Messages_LowFrequency {
    // @@protoc_insertion_point(enum_value:SVC_Messages_LowFrequency.svc_dummy)
    svc_dummy = 600,
}

impl ::protobuf::Enum for SVC_Messages_LowFrequency {
    const NAME: &'static str = "SVC_Messages_LowFrequency";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SVC_Messages_LowFrequency> {
        match value {
            600 => ::std::option::Option::Some(SVC_Messages_LowFrequency::svc_dummy),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SVC_Messages_LowFrequency> {
        match str {
            "svc_dummy" => ::std::option::Option::Some(SVC_Messages_LowFrequency::svc_dummy),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SVC_Messages_LowFrequency] = &[
        SVC_Messages_LowFrequency::svc_dummy,
    ];
}

impl ::protobuf::EnumFull for SVC_Messages_LowFrequency {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SVC_Messages_LowFrequency").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SVC_Messages_LowFrequency::svc_dummy => 0,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SVC_Messages_LowFrequency {
    fn default() -> Self {
        SVC_Messages_LowFrequency::svc_dummy
    }
}

impl SVC_Messages_LowFrequency {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SVC_Messages_LowFrequency>("SVC_Messages_LowFrequency")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Bidirectional_Messages)
pub enum Bidirectional_Messages {
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages.bi_RebroadcastGameEvent)
    bi_RebroadcastGameEvent = 16,
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages.bi_RebroadcastSource)
    bi_RebroadcastSource = 17,
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages.bi_GameEvent)
    bi_GameEvent = 18,
}

impl ::protobuf::Enum for Bidirectional_Messages {
    const NAME: &'static str = "Bidirectional_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Bidirectional_Messages> {
        match value {
            16 => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastGameEvent),
            17 => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastSource),
            18 => ::std::option::Option::Some(Bidirectional_Messages::bi_GameEvent),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Bidirectional_Messages> {
        match str {
            "bi_RebroadcastGameEvent" => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastGameEvent),
            "bi_RebroadcastSource" => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastSource),
            "bi_GameEvent" => ::std::option::Option::Some(Bidirectional_Messages::bi_GameEvent),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Bidirectional_Messages] = &[
        Bidirectional_Messages::bi_RebroadcastGameEvent,
        Bidirectional_Messages::bi_RebroadcastSource,
        Bidirectional_Messages::bi_GameEvent,
    ];
}

impl ::protobuf::EnumFull for Bidirectional_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Bidirectional_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Bidirectional_Messages::bi_RebroadcastGameEvent => 0,
            Bidirectional_Messages::bi_RebroadcastSource => 1,
            Bidirectional_Messages::bi_GameEvent => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Bidirectional_Messages {
    fn default() -> Self {
        Bidirectional_Messages::bi_RebroadcastGameEvent
    }
}

impl Bidirectional_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Bidirectional_Messages>("Bidirectional_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Bidirectional_Messages_LowFrequency)
pub enum Bidirectional_Messages_LowFrequency {
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages_LowFrequency.bi_RelayInfo)
    bi_RelayInfo = 700,
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages_LowFrequency.bi_RelayPacket)
    bi_RelayPacket = 701,
}

impl ::protobuf::Enum for Bidirectional_Messages_LowFrequency {
    const NAME: &'static str = "Bidirectional_Messages_LowFrequency";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Bidirectional_Messages_LowFrequency> {
        match value {
            700 => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayInfo),
            701 => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayPacket),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Bidirectional_Messages_LowFrequency> {
        match str {
            "bi_RelayInfo" => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayInfo),
            "bi_RelayPacket" => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayPacket),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Bidirectional_Messages_LowFrequency] = &[
        Bidirectional_Messages_LowFrequency::bi_RelayInfo,
        Bidirectional_Messages_LowFrequency::bi_RelayPacket,
    ];
}

impl ::protobuf::EnumFull for Bidirectional_Messages_LowFrequency {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Bidirectional_Messages_LowFrequency").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Bidirectional_Messages_LowFrequency::bi_RelayInfo => 0,
            Bidirectional_Messages_LowFrequency::bi_RelayPacket => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Bidirectional_Messages_LowFrequency {
    fn default() -> Self {
        Bidirectional_Messages_LowFrequency::bi_RelayInfo
    }
}

impl Bidirectional_Messages_LowFrequency {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Bidirectional_Messages_LowFrequency>("Bidirectional_Messages_LowFrequency")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ReplayEventType_t)
pub enum ReplayEventType_t {
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_CANCEL)
    REPLAY_EVENT_CANCEL = 0,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_DEATH)
    REPLAY_EVENT_DEATH = 1,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_GENERIC)
    REPLAY_EVENT_GENERIC = 2,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_STUCK_NEED_FULL_UPDATE)
    REPLAY_EVENT_STUCK_NEED_FULL_UPDATE = 3,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_VICTORY)
    REPLAY_EVENT_VICTORY = 4,
}

impl ::protobuf::Enum for ReplayEventType_t {
    const NAME: &'static str = "ReplayEventType_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReplayEventType_t> {
        match value {
            0 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_CANCEL),
            1 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_DEATH),
            2 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_GENERIC),
            3 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE),
            4 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_VICTORY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ReplayEventType_t> {
        match str {
            "REPLAY_EVENT_CANCEL" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_CANCEL),
            "REPLAY_EVENT_DEATH" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_DEATH),
            "REPLAY_EVENT_GENERIC" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_GENERIC),
            "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE),
            "REPLAY_EVENT_VICTORY" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_VICTORY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ReplayEventType_t] = &[
        ReplayEventType_t::REPLAY_EVENT_CANCEL,
        ReplayEventType_t::REPLAY_EVENT_DEATH,
        ReplayEventType_t::REPLAY_EVENT_GENERIC,
        ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE,
        ReplayEventType_t::REPLAY_EVENT_VICTORY,
    ];
}

impl ::protobuf::EnumFull for ReplayEventType_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ReplayEventType_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ReplayEventType_t {
    fn default() -> Self {
        ReplayEventType_t::REPLAY_EVENT_CANCEL
    }
}

impl ReplayEventType_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ReplayEventType_t>("ReplayEventType_t")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11netmessages.proto\x1a\x16networkbasetypes.proto\"\xb8\x01\n\x12CCL\
    CMsg_ClientInfo\x12$\n\x0esend_table_crc\x18\x01\x20\x01(\x07R\x0csendTa\
    bleCrc\x12!\n\x0cserver_count\x18\x02\x20\x01(\rR\x0bserverCount\x12\x17\
    \n\x07is_hltv\x18\x03\x20\x01(\x08R\x06isHltv\x12\x1d\n\nfriends_id\x18\
    \x05\x20\x01(\rR\tfriendsId\x12!\n\x0cfriends_name\x18\x06\x20\x01(\tR\
    \x0bfriendsName\"l\n\x0cCCLCMsg_Move\x12\x12\n\x04data\x18\x03\x20\x01(\
    \x0cR\x04data\x12%\n\x0ecommand_number\x18\x04\x20\x01(\rR\rcommandNumbe\
    r\x12!\n\x0cnum_commands\x18\x05\x20\x01(\rR\x0bnumCommands\"\xa0\x02\n\
    \x0eCMsgVoiceAudio\x12B\n\x06format\x18\x01\x20\x01(\x0e2\x12.VoiceDataF\
    ormat_t:\x16VOICEDATA_FORMAT_STEAMR\x06format\x12\x1d\n\nvoice_data\x18\
    \x02\x20\x01(\x0cR\tvoiceData\x12%\n\x0esequence_bytes\x18\x03\x20\x01(\
    \x05R\rsequenceBytes\x12%\n\x0esection_number\x18\x04\x20\x01(\rR\rsecti\
    onNumber\x12\x1f\n\x0bsample_rate\x18\x05\x20\x01(\rR\nsampleRate\x12<\n\
    \x1auncompressed_sample_offset\x18\x06\x20\x01(\rR\x18uncompressedSample\
    Offset\"b\n\x11CCLCMsg_VoiceData\x12%\n\x05audio\x18\x01\x20\x01(\x0b2\
    \x0f.CMsgVoiceAudioR\x05audio\x12\x12\n\x04xuid\x18\x02\x20\x01(\x06R\
    \x04xuid\x12\x12\n\x04tick\x18\x03\x20\x01(\rR\x04tick\"[\n\x13CCLCMsg_B\
    aselineAck\x12#\n\rbaseline_tick\x18\x01\x20\x01(\x05R\x0cbaselineTick\
    \x12\x1f\n\x0bbaseline_nr\x18\x02\x20\x01(\x05R\nbaselineNr\"5\n\x14CCLC\
    Msg_ListenEvents\x12\x1d\n\nevent_mask\x18\x01\x20\x03(\x07R\teventMask\
    \"}\n\x18CCLCMsg_RespondCvarValue\x12\x16\n\x06cookie\x18\x01\x20\x01(\
    \x05R\x06cookie\x12\x1f\n\x0bstatus_code\x18\x02\x20\x01(\x05R\nstatusCo\
    de\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\
    \x04\x20\x01(\tR\x05value\"\x9a\x01\n\x14CCLCMsg_FileCRCCheck\x12\x1b\n\
    \tcode_path\x18\x01\x20\x01(\x05R\x08codePath\x12\x12\n\x04path\x18\x02\
    \x20\x01(\tR\x04path\x12#\n\rcode_filename\x18\x03\x20\x01(\x05R\x0ccode\
    Filename\x12\x1a\n\x08filename\x18\x04\x20\x01(\tR\x08filename\x12\x10\n\
    \x03crc\x18\x05\x20\x01(\x07R\x03crc\"5\n\x17CCLCMsg_LoadingProgress\x12\
    \x1a\n\x08progress\x18\x01\x20\x01(\x05R\x08progress\"<\n\x1aCCLCMsg_Spl\
    itPlayerConnect\x12\x1e\n\nplayername\x18\x01\x20\x01(\tR\nplayername\"F\
    \n\x15CCLCMsg_ClientMessage\x12\x19\n\x08msg_type\x18\x01\x20\x01(\x05R\
    \x07msgType\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\"3\n\x1dCCLC\
    Msg_SplitPlayerDisconnect\x12\x12\n\x04slot\x18\x01\x20\x01(\x05R\x04slo\
    t\"6\n\x14CCLCMsg_ServerStatus\x12\x1e\n\nsimplified\x18\x01\x20\x01(\
    \x08R\nsimplified\"\x14\n\x12CCLCMsg_ServerPing\"q\n\x14CCLCMsg_RequestP\
    ause\x128\n\npause_type\x18\x01\x20\x01(\x0e2\x0f.RequestPause_t:\x08RP_\
    PAUSER\tpauseType\x12\x1f\n\x0bpause_group\x18\x02\x20\x01(\x05R\npauseG\
    roup\"*\n\x14CCLCMsg_CmdKeyValues\x12\x12\n\x04data\x18\x01\x20\x01(\x0c\
    R\x04data\"1\n\x19CCLCMsg_RconServerDetails\x12\x14\n\x05token\x18\x01\
    \x20\x01(\x0cR\x05token\"\xc2\x04\n\x12CSVCMsg_ServerInfo\x12\x1a\n\x08p\
    rotocol\x18\x01\x20\x01(\x05R\x08protocol\x12!\n\x0cserver_count\x18\x02\
    \x20\x01(\x05R\x0bserverCount\x12!\n\x0cis_dedicated\x18\x03\x20\x01(\
    \x08R\x0bisDedicated\x12\x17\n\x07is_hltv\x18\x04\x20\x01(\x08R\x06isHlt\
    v\x12\x11\n\x04c_os\x18\x06\x20\x01(\x05R\x03cOs\x12\x1f\n\x0bmax_client\
    s\x18\n\x20\x01(\x05R\nmaxClients\x12\x1f\n\x0bmax_classes\x18\x0b\x20\
    \x01(\x05R\nmaxClasses\x12#\n\x0bplayer_slot\x18\x0c\x20\x01(\x05:\x02-1\
    R\nplayerSlot\x12#\n\rtick_interval\x18\r\x20\x01(\x02R\x0ctickInterval\
    \x12\x19\n\x08game_dir\x18\x0e\x20\x01(\tR\x07gameDir\x12\x19\n\x08map_n\
    ame\x18\x0f\x20\x01(\tR\x07mapName\x12\x19\n\x08sky_name\x18\x10\x20\x01\
    (\tR\x07skyName\x12\x1b\n\thost_name\x18\x11\x20\x01(\tR\x08hostName\x12\
    \x1d\n\naddon_name\x18\x12\x20\x01(\tR\taddonName\x12Q\n\x13game_session\
    _config\x18\x13\x20\x01(\x0b2!.CSVCMsg_GameSessionConfigurationR\x11game\
    SessionConfig\x122\n\x15game_session_manifest\x18\x14\x20\x01(\x0cR\x13g\
    ameSessionManifest\"\xb8\x01\n\x11CSVCMsg_ClassInfo\x12(\n\x10create_on_\
    client\x18\x01\x20\x01(\x08R\x0ecreateOnClient\x124\n\x07classes\x18\x02\
    \x20\x03(\x0b2\x1a.CSVCMsg_ClassInfo.class_tR\x07classes\x1aC\n\x07class\
    _t\x12\x19\n\x08class_id\x18\x01\x20\x01(\x05R\x07classId\x12\x1d\n\ncla\
    ss_name\x18\x03\x20\x01(\tR\tclassName\"*\n\x10CSVCMsg_SetPause\x12\x16\
    \n\x06paused\x18\x01\x20\x01(\x08R\x06paused\"`\n\x11CSVCMsg_VoiceInit\
    \x12\x18\n\x07quality\x18\x01\x20\x01(\x05R\x07quality\x12\x14\n\x05code\
    c\x18\x02\x20\x01(\tR\x05codec\x12\x1b\n\x07version\x18\x03\x20\x01(\x05\
    :\x010R\x07version\"#\n\rCSVCMsg_Print\x12\x12\n\x04text\x18\x01\x20\x01\
    (\tR\x04text\"\xcc\x05\n\x0eCSVCMsg_Sounds\x12%\n\x0ereliable_sound\x18\
    \x01\x20\x01(\x08R\rreliableSound\x123\n\x06sounds\x18\x02\x20\x03(\x0b2\
    \x1b.CSVCMsg_Sounds.sounddata_tR\x06sounds\x1a\xdd\x04\n\x0bsounddata_t\
    \x12\x19\n\x08origin_x\x18\x01\x20\x01(\x11R\x07originX\x12\x19\n\x08ori\
    gin_y\x18\x02\x20\x01(\x11R\x07originY\x12\x19\n\x08origin_z\x18\x03\x20\
    \x01(\x11R\x07originZ\x12\x16\n\x06volume\x18\x04\x20\x01(\rR\x06volume\
    \x12\x1f\n\x0bdelay_value\x18\x05\x20\x01(\x02R\ndelayValue\x12'\n\x0fse\
    quence_number\x18\x06\x20\x01(\x05R\x0esequenceNumber\x12%\n\x0centity_i\
    ndex\x18\x07\x20\x01(\x05:\x02-1R\x0bentityIndex\x12\x18\n\x07channel\
    \x18\x08\x20\x01(\x05R\x07channel\x12\x14\n\x05pitch\x18\t\x20\x01(\x05R\
    \x05pitch\x12\x14\n\x05flags\x18\n\x20\x01(\x05R\x05flags\x12\x1b\n\tsou\
    nd_num\x18\x0b\x20\x01(\rR\x08soundNum\x12(\n\x10sound_num_handle\x18\
    \x0c\x20\x01(\x07R\x0esoundNumHandle\x12%\n\x0espeaker_entity\x18\r\x20\
    \x01(\x05R\rspeakerEntity\x12\x1f\n\x0brandom_seed\x18\x0e\x20\x01(\x05R\
    \nrandomSeed\x12\x1f\n\x0bsound_level\x18\x0f\x20\x01(\x05R\nsoundLevel\
    \x12\x1f\n\x0bis_sentence\x18\x10\x20\x01(\x08R\nisSentence\x12\x1d\n\ni\
    s_ambient\x18\x11\x20\x01(\x08R\tisAmbient\x12\x12\n\x04guid\x18\x12\x20\
    \x01(\rR\x04guid\x12*\n\x11sound_resource_id\x18\x13\x20\x01(\x06R\x0fso\
    undResourceId\"r\n\x10CSVCMsg_Prefetch\x12\x1f\n\x0bsound_index\x18\x01\
    \x20\x01(\x05R\nsoundIndex\x12=\n\rresource_type\x18\x02\x20\x01(\x0e2\r\
    .PrefetchType:\tPFT_SOUNDR\x0cresourceType\"P\n\x0fCSVCMsg_SetView\x12%\
    \n\x0centity_index\x18\x01\x20\x01(\x05:\x02-1R\x0bentityIndex\x12\x16\n\
    \x04slot\x18\x02\x20\x01(\x05:\x02-1R\x04slot\"Q\n\x10CSVCMsg_FixAngle\
    \x12\x1a\n\x08relative\x18\x01\x20\x01(\x08R\x08relative\x12!\n\x05angle\
    \x18\x02\x20\x01(\x0b2\x0b.CMsgQAngleR\x05angle\";\n\x16CSVCMsg_Crosshai\
    rAngle\x12!\n\x05angle\x18\x01\x20\x01(\x0b2\x0b.CMsgQAngleR\x05angle\"\
    \xcc\x01\n\x10CSVCMsg_BSPDecal\x12\x1d\n\x03pos\x18\x01\x20\x01(\x0b2\
    \x0b.CMsgVectorR\x03pos\x12.\n\x13decal_texture_index\x18\x02\x20\x01(\
    \x05R\x11decalTextureIndex\x12%\n\x0centity_index\x18\x03\x20\x01(\x05:\
    \x02-1R\x0bentityIndex\x12\x1f\n\x0bmodel_index\x18\x04\x20\x01(\x05R\nm\
    odelIndex\x12!\n\x0clow_priority\x18\x05\x20\x01(\x08R\x0blowPriority\"\
    \x97\x01\n\x13CSVCMsg_SplitScreen\x12E\n\x04type\x18\x01\x20\x01(\x0e2\
    \x18.ESplitScreenMessageType:\x17MSG_SPLITSCREEN_ADDUSERR\x04type\x12\
    \x12\n\x04slot\x18\x02\x20\x01(\x05R\x04slot\x12%\n\x0cplayer_index\x18\
    \x03\x20\x01(\x05:\x02-1R\x0bplayerIndex\"K\n\x14CSVCMsg_GetCvarValue\
    \x12\x16\n\x06cookie\x18\x01\x20\x01(\x05R\x06cookie\x12\x1b\n\tcvar_nam\
    e\x18\x02\x20\x01(\tR\x08cvarName\"W\n\x0cCSVCMsg_Menu\x12\x1f\n\x0bdial\
    og_type\x18\x01\x20\x01(\x05R\ndialogType\x12&\n\x0fmenu_key_values\x18\
    \x02\x20\x01(\x0cR\rmenuKeyValues\"m\n\x13CSVCMsg_UserMessage\x12\x19\n\
    \x08msg_type\x18\x01\x20\x01(\x05R\x07msgType\x12\x19\n\x08msg_data\x18\
    \x02\x20\x01(\x0cR\x07msgData\x12\x20\n\x0bpassthrough\x18\x03\x20\x01(\
    \x05R\x0bpassthrough\"\xad\x03\n\x11CSVCMsg_SendTable\x12\x15\n\x06is_en\
    d\x18\x01\x20\x01(\x08R\x05isEnd\x12$\n\x0enet_table_name\x18\x02\x20\
    \x01(\tR\x0cnetTableName\x12#\n\rneeds_decoder\x18\x03\x20\x01(\x08R\x0c\
    needsDecoder\x123\n\x05props\x18\x04\x20\x03(\x0b2\x1d.CSVCMsg_SendTable\
    .sendprop_tR\x05props\x1a\x80\x02\n\nsendprop_t\x12\x12\n\x04type\x18\
    \x01\x20\x01(\x05R\x04type\x12\x19\n\x08var_name\x18\x02\x20\x01(\tR\x07\
    varName\x12\x14\n\x05flags\x18\x03\x20\x01(\x05R\x05flags\x12\x1a\n\x08p\
    riority\x18\x04\x20\x01(\x05R\x08priority\x12\x17\n\x07dt_name\x18\x05\
    \x20\x01(\tR\x06dtName\x12!\n\x0cnum_elements\x18\x06\x20\x01(\x05R\x0bn\
    umElements\x12\x1b\n\tlow_value\x18\x07\x20\x01(\x02R\x08lowValue\x12\
    \x1d\n\nhigh_value\x18\x08\x20\x01(\x02R\thighValue\x12\x19\n\x08num_bit\
    s\x18\t\x20\x01(\x05R\x07numBits\"\xff\x01\n\x15CSVCMsg_GameEventList\
    \x12E\n\x0bdescriptors\x18\x01\x20\x03(\x0b2#.CSVCMsg_GameEventList.desc\
    riptor_tR\x0bdescriptors\x1a/\n\x05key_t\x12\x12\n\x04type\x18\x01\x20\
    \x01(\x05R\x04type\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x1an\n\
    \x0cdescriptor_t\x12\x18\n\x07eventid\x18\x01\x20\x01(\x05R\x07eventid\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x120\n\x04keys\x18\x03\
    \x20\x03(\x0b2\x1c.CSVCMsg_GameEventList.key_tR\x04keys\"\xe8\x08\n\x16C\
    SVCMsg_PacketEntities\x12\x1f\n\x0bmax_entries\x18\x01\x20\x01(\x05R\nma\
    xEntries\x12'\n\x0fupdated_entries\x18\x02\x20\x01(\x05R\x0eupdatedEntri\
    es\x12\x19\n\x08is_delta\x18\x03\x20\x01(\x08R\x07isDelta\x12'\n\x0fupda\
    te_baseline\x18\x04\x20\x01(\x08R\x0eupdateBaseline\x12\x1a\n\x08baselin\
    e\x18\x05\x20\x01(\x05R\x08baseline\x12\x1d\n\ndelta_from\x18\x06\x20\
    \x01(\x05R\tdeltaFrom\x12\x1f\n\x0bentity_data\x18\x07\x20\x01(\x0cR\nen\
    tityData\x12,\n\x12pending_full_frame\x18\x08\x20\x01(\x08R\x10pendingFu\
    llFrame\x128\n\x18active_spawngroup_handle\x18\t\x20\x01(\rR\x16activeSp\
    awngroupHandle\x12F\n\x1fmax_spawngroup_creationsequence\x18\n\x20\x01(\
    \rR\x1dmaxSpawngroupCreationsequence\x12&\n\x0flast_cmd_number\x18\x0b\
    \x20\x01(\rR\rlastCmdNumber\x12\x1f\n\x0bserver_tick\x18\x0c\x20\x01(\rR\
    \nserverTick\x12/\n\x13serialized_entities\x18\r\x20\x01(\x0cR\x12serial\
    izedEntities\x12Z\n\x12command_queue_info\x18\x0e\x20\x01(\x0b2,.CSVCMsg\
    _PacketEntities.command_queue_info_tR\x10commandQueueInfo\x12]\n\x13alte\
    rnate_baselines\x18\x0f\x20\x03(\x0b2,.CSVCMsg_PacketEntities.alternate_\
    baseline_tR\x12alternateBaselines\x1a\x9c\x02\n\x14command_queue_info_t\
    \x12'\n\x0fcommands_queued\x18\x01\x20\x01(\rR\x0ecommandsQueued\x12;\n\
    \x1acommand_queue_desired_size\x18\x02\x20\x01(\rR\x17commandQueueDesire\
    dSize\x122\n\x15starved_command_ticks\x18\x03\x20\x01(\rR\x13starvedComm\
    andTicks\x122\n\x15time_dilation_percent\x18\x04\x20\x01(\x02R\x13timeDi\
    lationPercent\x126\n\x17discarded_command_ticks\x18\x05\x20\x01(\rR\x15d\
    iscardedCommandTicks\x1a`\n\x14alternate_baseline_t\x12!\n\x0centity_ind\
    ex\x18\x01\x20\x01(\x05R\x0bentityIndex\x12%\n\x0ebaseline_index\x18\x02\
    \x20\x01(\x05R\rbaselineIndex\"t\n\x14CSVCMsg_TempEntities\x12\x1a\n\x08\
    reliable\x18\x01\x20\x01(\x08R\x08reliable\x12\x1f\n\x0bnum_entries\x18\
    \x02\x20\x01(\x05R\nnumEntries\x12\x1f\n\x0bentity_data\x18\x03\x20\x01(\
    \x0cR\nentityData\"\x99\x03\n\x19CSVCMsg_CreateStringTable\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x12\x1f\n\x0bnum_entries\x18\x02\x20\
    \x01(\x05R\nnumEntries\x12/\n\x14user_data_fixed_size\x18\x03\x20\x01(\
    \x08R\x11userDataFixedSize\x12$\n\x0euser_data_size\x18\x04\x20\x01(\x05\
    R\x0cuserDataSize\x12-\n\x13user_data_size_bits\x18\x05\x20\x01(\x05R\
    \x10userDataSizeBits\x12\x14\n\x05flags\x18\x06\x20\x01(\x05R\x05flags\
    \x12\x1f\n\x0bstring_data\x18\x07\x20\x01(\x0cR\nstringData\x12+\n\x11un\
    compressed_size\x18\x08\x20\x01(\x05R\x10uncompressedSize\x12'\n\x0fdata\
    _compressed\x18\t\x20\x01(\x08R\x0edataCompressed\x124\n\x16using_varint\
    _bitcounts\x18\n\x20\x01(\x08R\x14usingVarintBitcounts\"\x87\x01\n\x19CS\
    VCMsg_UpdateStringTable\x12\x19\n\x08table_id\x18\x01\x20\x01(\x05R\x07t\
    ableId\x12.\n\x13num_changed_entries\x18\x02\x20\x01(\x05R\x11numChanged\
    Entries\x12\x1f\n\x0bstring_data\x18\x03\x20\x01(\x0cR\nstringData\"\xe1\
    \x01\n\x11CSVCMsg_VoiceData\x12%\n\x05audio\x18\x01\x20\x01(\x0b2\x0f.CM\
    sgVoiceAudioR\x05audio\x12\x1a\n\x06client\x18\x02\x20\x01(\x05:\x02-1R\
    \x06client\x12\x1c\n\tproximity\x18\x03\x20\x01(\x08R\tproximity\x12\x12\
    \n\x04xuid\x18\x04\x20\x01(\x06R\x04xuid\x12!\n\x0caudible_mask\x18\x05\
    \x20\x01(\x05R\x0baudibleMask\x12\x12\n\x04tick\x18\x06\x20\x01(\rR\x04t\
    ick\x12\x20\n\x0bpassthrough\x18\x07\x20\x01(\x05R\x0bpassthrough\"f\n\
    \x16CSVCMsg_PacketReliable\x12\x12\n\x04tick\x18\x01\x20\x01(\x05R\x04ti\
    ck\x12\"\n\x0cmessagessize\x18\x02\x20\x01(\x05R\x0cmessagessize\x12\x14\
    \n\x05state\x18\x03\x20\x01(\x08R\x05state\"p\n\x16CSVCMsg_FullFrameSpli\
    t\x12\x12\n\x04tick\x18\x01\x20\x01(\x05R\x04tick\x12\x18\n\x07section\
    \x18\x02\x20\x01(\x05R\x07section\x12\x14\n\x05total\x18\x03\x20\x01(\
    \x05R\x05total\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04data\"v\n\x12C\
    SVCMsg_HLTVStatus\x12\x16\n\x06master\x18\x01\x20\x01(\tR\x06master\x12\
    \x18\n\x07clients\x18\x02\x20\x01(\x05R\x07clients\x12\x14\n\x05slots\
    \x18\x03\x20\x01(\x05R\x05slots\x12\x18\n\x07proxies\x18\x04\x20\x01(\
    \x05R\x07proxies\"2\n\x15CSVCMsg_ServerSteamID\x12\x19\n\x08steam_id\x18\
    \x01\x20\x01(\x04R\x07steamId\"*\n\x14CSVCMsg_CmdKeyValues\x12\x12\n\x04\
    data\x18\x01\x20\x01(\x0cR\x04data\"K\n\x19CSVCMsg_RconServerDetails\x12\
    \x14\n\x05token\x18\x01\x20\x01(\x0cR\x05token\x12\x18\n\x07details\x18\
    \x02\x20\x01(\tR\x07details\"T\n\x0eCMsgIPCAddress\x12#\n\rcomputer_guid\
    \x18\x01\x20\x01(\x06R\x0ccomputerGuid\x12\x1d\n\nprocess_id\x18\x02\x20\
    \x01(\rR\tprocessId\"\xec\x01\n\x0eCMsgServerPeer\x12#\n\x0bplayer_slot\
    \x18\x01\x20\x01(\x05:\x02-1R\nplayerSlot\x12\x18\n\x07steamid\x18\x02\
    \x20\x01(\x06R\x07steamid\x12!\n\x03ipc\x18\x03\x20\x01(\x0b2\x0f.CMsgIP\
    CAddressR\x03ipc\x12\"\n\rthey_hear_you\x18\x04\x20\x01(\x08R\x0btheyHea\
    rYou\x12\"\n\ryou_hear_them\x18\x05\x20\x01(\x08R\x0byouHearThem\x120\n\
    \x14is_listenserver_host\x18\x06\x20\x01(\x08R\x12isListenserverHost\"7\
    \n\x10CSVCMsg_PeerList\x12#\n\x04peer\x18\x01\x20\x03(\x0b2\x0f.CMsgServ\
    erPeerR\x04peer\"l\n\x1cCSVCMsg_ClearAllStringTables\x12\x18\n\x07mapnam\
    e\x18\x01\x20\x01(\tR\x07mapname\x122\n\x15create_tables_skipped\x18\x03\
    \x20\x01(\x08R\x13createTablesSkipped\"\xc0\x05\n\x1fProtoFlattenedSeria\
    lizerField_t\x12\x20\n\x0cvar_type_sym\x18\x01\x20\x01(\x05R\nvarTypeSym\
    \x12\x20\n\x0cvar_name_sym\x18\x02\x20\x01(\x05R\nvarNameSym\x12\x1b\n\t\
    bit_count\x18\x03\x20\x01(\x05R\x08bitCount\x12\x1b\n\tlow_value\x18\x04\
    \x20\x01(\x02R\x08lowValue\x12\x1d\n\nhigh_value\x18\x05\x20\x01(\x02R\t\
    highValue\x12!\n\x0cencode_flags\x18\x06\x20\x01(\x05R\x0bencodeFlags\
    \x129\n\x19field_serializer_name_sym\x18\x07\x20\x01(\x05R\x16fieldSeria\
    lizerNameSym\x128\n\x18field_serializer_version\x18\x08\x20\x01(\x05R\
    \x16fieldSerializerVersion\x12\"\n\rsend_node_sym\x18\t\x20\x01(\x05R\
    \x0bsendNodeSym\x12&\n\x0fvar_encoder_sym\x18\n\x20\x01(\x05R\rvarEncode\
    rSym\x12a\n\x11polymorphic_types\x18\x0b\x20\x03(\x0b24.ProtoFlattenedSe\
    rializerField_t.polymorphic_field_tR\x10polymorphicTypes\x1a\xb8\x01\n\
    \x13polymorphic_field_t\x12P\n%polymorphic_field_serializer_name_sym\x18\
    \x01\x20\x01(\x05R!polymorphicFieldSerializerNameSym\x12O\n$polymorphic_\
    field_serializer_version\x18\x02\x20\x01(\x05R!polymorphicFieldSerialize\
    rVersion\"\x9e\x01\n\x1aProtoFlattenedSerializer_t\x12.\n\x13serializer_\
    name_sym\x18\x01\x20\x01(\x05R\x11serializerNameSym\x12-\n\x12serializer\
    _version\x18\x02\x20\x01(\x05R\x11serializerVersion\x12!\n\x0cfields_ind\
    ex\x18\x03\x20\x03(\x05R\x0bfieldsIndex\"\xb0\x01\n\x1bCSVCMsg_Flattened\
    Serializer\x12=\n\x0bserializers\x18\x01\x20\x03(\x0b2\x1b.ProtoFlattene\
    dSerializer_tR\x0bserializers\x12\x18\n\x07symbols\x18\x02\x20\x03(\tR\
    \x07symbols\x128\n\x06fields\x18\x03\x20\x03(\x0b2\x20.ProtoFlattenedSer\
    ializerField_tR\x06fields\"'\n\x11CSVCMsg_StopSound\x12\x12\n\x04guid\
    \x18\x01\x20\x01(\x07R\x04guid\"\xb2\x01\n\x1eCBidirMsg_RebroadcastGameE\
    vent\x12\"\n\x0cposttoserver\x18\x01\x20\x01(\x08R\x0cposttoserver\x12\
    \x18\n\x07buftype\x18\x02\x20\x01(\x05R\x07buftype\x12&\n\x0eclientbitco\
    unt\x18\x03\x20\x01(\rR\x0eclientbitcount\x12*\n\x10receivingclients\x18\
    \x04\x20\x01(\x04R\x10receivingclients\"?\n\x1bCBidirMsg_RebroadcastSour\
    ce\x12\x20\n\x0beventsource\x18\x01\x20\x01(\x05R\x0beventsource\"\x9a\t\
    \n\x16CMsgServerNetworkStats\x12\x1c\n\tdedicated\x18\x01\x20\x01(\x08R\
    \tdedicated\x12\x1b\n\tcpu_usage\x18\x02\x20\x01(\x05R\x08cpuUsage\x12$\
    \n\x0ememory_used_mb\x18\x03\x20\x01(\x05R\x0cmemoryUsedMb\x12$\n\x0emem\
    ory_free_mb\x18\x04\x20\x01(\x05R\x0cmemoryFreeMb\x12\x16\n\x06uptime\
    \x18\x05\x20\x01(\x05R\x06uptime\x12\x1f\n\x0bspawn_count\x18\x06\x20\
    \x01(\x05R\nspawnCount\x12\x1f\n\x0bnum_clients\x18\x08\x20\x01(\x05R\nn\
    umClients\x12\x19\n\x08num_bots\x18\t\x20\x01(\x05R\x07numBots\x12%\n\
    \x0enum_spectators\x18\n\x20\x01(\x05R\rnumSpectators\x12\"\n\rnum_tv_re\
    lays\x18\x0b\x20\x01(\x05R\x0bnumTvRelays\x12\x10\n\x03fps\x18\x0c\x20\
    \x01(\x02R\x03fps\x122\n\x05ports\x18\x11\x20\x03(\x0b2\x1c.CMsgServerNe\
    tworkStats.PortR\x05ports\x12&\n\x0favg_latency_out\x18\x12\x20\x01(\x02\
    R\ravgLatencyOut\x12$\n\x0eavg_latency_in\x18\x13\x20\x01(\x02R\x0cavgLa\
    tencyIn\x12&\n\x0favg_packets_out\x18\x14\x20\x01(\x02R\ravgPacketsOut\
    \x12$\n\x0eavg_packets_in\x18\x15\x20\x01(\x02R\x0cavgPacketsIn\x12\x20\
    \n\x0cavg_loss_out\x18\x16\x20\x01(\x02R\navgLossOut\x12\x1e\n\x0bavg_lo\
    ss_in\x18\x17\x20\x01(\x02R\tavgLossIn\x12\x20\n\x0cavg_data_out\x18\x18\
    \x20\x01(\x02R\navgDataOut\x12\x1e\n\x0bavg_data_in\x18\x19\x20\x01(\x02\
    R\tavgDataIn\x12\"\n\rtotal_data_in\x18\x1a\x20\x01(\x04R\x0btotalDataIn\
    \x12(\n\x10total_packets_in\x18\x1b\x20\x01(\x04R\x0etotalPacketsIn\x12$\
    \n\x0etotal_data_out\x18\x1c\x20\x01(\x04R\x0ctotalDataOut\x12*\n\x11tot\
    al_packets_out\x18\x1d\x20\x01(\x04R\x0ftotalPacketsOut\x128\n\x07player\
    s\x18\x1e\x20\x03(\x0b2\x1e.CMsgServerNetworkStats.PlayerR\x07players\
    \x1a.\n\x04Port\x12\x12\n\x04port\x18\x01\x20\x01(\x05R\x04port\x12\x12\
    \n\x04name\x18\x02\x20\x01(\tR\x04name\x1a\xc8\x01\n\x06Player\x12\x18\n\
    \x07steamid\x18\x01\x20\x01(\x04R\x07steamid\x12\x1f\n\x0bremote_addr\
    \x18\x02\x20\x01(\tR\nremoteAddr\x12$\n\x0eping_stddev_ms\x18\x03\x20\
    \x01(\x05R\x0cpingStddevMs\x12\x1e\n\x0bping_avg_ms\x18\x04\x20\x01(\x05\
    R\tpingAvgMs\x12&\n\x0fpacket_loss_pct\x18\x05\x20\x01(\x02R\rpacketLoss\
    Pct\x12\x15\n\x06is_bot\x18\x06\x20\x01(\x08R\x05isBot\"\xd1\x02\n\x12CS\
    VCMsg_HltvReplay\x12\x14\n\x05delay\x18\x01\x20\x01(\x05R\x05delay\x12)\
    \n\x0eprimary_target\x18\x02\x20\x01(\x05:\x02-1R\rprimaryTarget\x12$\n\
    \x0ereplay_stop_at\x18\x03\x20\x01(\x05R\x0creplayStopAt\x12&\n\x0frepla\
    y_start_at\x18\x04\x20\x01(\x05R\rreplayStartAt\x122\n\x15replay_slowdow\
    n_begin\x18\x05\x20\x01(\x05R\x13replaySlowdownBegin\x12.\n\x13replay_sl\
    owdown_end\x18\x06\x20\x01(\x05R\x11replaySlowdownEnd\x120\n\x14replay_s\
    lowdown_rate\x18\x07\x20\x01(\x02R\x12replaySlowdownRate\x12\x16\n\x06re\
    ason\x18\x08\x20\x01(\x05R\x06reason\"\xc6\x01\n\x12CCLCMsg_HltvReplay\
    \x12\x18\n\x07request\x18\x01\x20\x01(\x05R\x07request\x12'\n\x0fslowdow\
    n_length\x18\x02\x20\x01(\x02R\x0eslowdownLength\x12#\n\rslowdown_rate\
    \x18\x03\x20\x01(\x02R\x0cslowdownRate\x12)\n\x0eprimary_target\x18\x04\
    \x20\x01(\x05:\x02-1R\rprimaryTarget\x12\x1d\n\nevent_time\x18\x05\x20\
    \x01(\x02R\teventTime\"-\n\x19CSVCMsg_Broadcast_Command\x12\x10\n\x03cmd\
    \x18\x01\x20\x01(\tR\x03cmd\"\xd2\x02\n\x1dCCLCMsg_HltvFixupOperatorTick\
    \x12\x12\n\x04tick\x18\x01\x20\x01(\x05R\x04tick\x12\x1d\n\nprops_data\
    \x18\x02\x20\x01(\x0cR\tpropsData\x12#\n\x06origin\x18\x03\x20\x01(\x0b2\
    \x0b.CMsgVectorR\x06origin\x12*\n\neye_angles\x18\x04\x20\x01(\x0b2\x0b.\
    CMsgQAngleR\teyeAngles\x12#\n\robserver_mode\x18\x05\x20\x01(\x05R\x0cob\
    serverMode\x121\n\x14cameraman_scoreboard\x18\x06\x20\x01(\x08R\x13camer\
    amanScoreboard\x12'\n\x0fobserver_target\x18\x07\x20\x01(\x05R\x0eobserv\
    erTarget\x12,\n\x0bview_offset\x18\x08\x20\x01(\x0b2\x0b.CMsgVectorR\nvi\
    ewOffset\"k\n\x1fCSVCMsg_HltvFixupOperatorStatus\x12\x12\n\x04mode\x18\
    \x01\x20\x01(\rR\x04mode\x124\n\x16override_operator_name\x18\x02\x20\
    \x01(\tR\x14overrideOperatorName*\x8e\x03\n\x0cCLC_Messages\x12\x12\n\
    \x0eclc_ClientInfo\x10\x14\x12\x0c\n\x08clc_Move\x10\x15\x12\x11\n\rclc_\
    VoiceData\x10\x16\x12\x13\n\x0fclc_BaselineAck\x10\x17\x12\x14\n\x10clc_\
    ListenEvents\x10\x18\x12\x18\n\x14clc_RespondCvarValue\x10\x19\x12\x14\n\
    \x10clc_FileCRCCheck\x10\x1a\x12\x17\n\x13clc_LoadingProgress\x10\x1b\
    \x12\x1a\n\x16clc_SplitPlayerConnect\x10\x1c\x12\x15\n\x11clc_ClientMess\
    age\x10\x1d\x12\x1d\n\x19clc_SplitPlayerDisconnect\x10\x1e\x12\x14\n\x10\
    clc_ServerStatus\x10\x1f\x12\x12\n\x0eclc_ServerPing\x10\x20\x12\x14\n\
    \x10clc_RequestPause\x10!\x12\x14\n\x10clc_CmdKeyValues\x10\"\x12\x19\n\
    \x15clc_RconServerDetails\x10#\x12\x12\n\x0eclc_HltvReplay\x10$*\x99\x05\
    \n\x0cSVC_Messages\x12\x12\n\x0esvc_ServerInfo\x10(\x12\x1b\n\x17svc_Fla\
    ttenedSerializer\x10)\x12\x11\n\rsvc_ClassInfo\x10*\x12\x10\n\x0csvc_Set\
    Pause\x10+\x12\x19\n\x15svc_CreateStringTable\x10,\x12\x19\n\x15svc_Upda\
    teStringTable\x10-\x12\x11\n\rsvc_VoiceInit\x10.\x12\x11\n\rsvc_VoiceDat\
    a\x10/\x12\r\n\tsvc_Print\x100\x12\x0e\n\nsvc_Sounds\x101\x12\x0f\n\x0bs\
    vc_SetView\x102\x12\x1c\n\x18svc_ClearAllStringTables\x103\x12\x14\n\x10\
    svc_CmdKeyValues\x104\x12\x10\n\x0csvc_BSPDecal\x105\x12\x13\n\x0fsvc_Sp\
    litScreen\x106\x12\x16\n\x12svc_PacketEntities\x107\x12\x10\n\x0csvc_Pre\
    fetch\x108\x12\x0c\n\x08svc_Menu\x109\x12\x14\n\x10svc_GetCvarValue\x10:\
    \x12\x11\n\rsvc_StopSound\x10;\x12\x10\n\x0csvc_PeerList\x10<\x12\x16\n\
    \x12svc_PacketReliable\x10=\x12\x12\n\x0esvc_HLTVStatus\x10>\x12\x15\n\
    \x11svc_ServerSteamID\x10?\x12\x16\n\x12svc_FullFrameSplit\x10F\x12\x19\
    \n\x15svc_RconServerDetails\x10G\x12\x13\n\x0fsvc_UserMessage\x10H\x12\
    \x12\n\x0esvc_HltvReplay\x10I\x12\x19\n\x15svc_Broadcast_Command\x10J\
    \x12\x1f\n\x1bsvc_HltvFixupOperatorStatus\x10K*L\n\x11VoiceDataFormat_t\
    \x12\x1a\n\x16VOICEDATA_FORMAT_STEAM\x10\0\x12\x1b\n\x17VOICEDATA_FORMAT\
    _ENGINE\x10\x01*B\n\x0eRequestPause_t\x12\x0c\n\x08RP_PAUSE\x10\0\x12\
    \x0e\n\nRP_UNPAUSE\x10\x01\x12\x12\n\x0eRP_TOGGLEPAUSE\x10\x02*\x1d\n\
    \x0cPrefetchType\x12\r\n\tPFT_SOUND\x10\0*V\n\x17ESplitScreenMessageType\
    \x12\x1b\n\x17MSG_SPLITSCREEN_ADDUSER\x10\0\x12\x1e\n\x1aMSG_SPLITSCREEN\
    _REMOVEUSER\x10\x01*\xb3\x01\n\x15EQueryCvarValueStatus\x12%\n!eQueryCva\
    rValueStatus_ValueIntact\x10\0\x12&\n\"eQueryCvarValueStatus_CvarNotFoun\
    d\x10\x01\x12\"\n\x1eeQueryCvarValueStatus_NotACvar\x10\x02\x12'\n#eQuer\
    yCvarValueStatus_CvarProtected\x10\x03*h\n\x0bDIALOG_TYPE\x12\x0e\n\nDIA\
    LOG_MSG\x10\0\x12\x0f\n\x0bDIALOG_MENU\x10\x01\x12\x0f\n\x0bDIALOG_TEXT\
    \x10\x02\x12\x10\n\x0cDIALOG_ENTRY\x10\x03\x12\x15\n\x11DIALOG_ASKCONNEC\
    T\x10\x04*+\n\x19SVC_Messages_LowFrequency\x12\x0e\n\tsvc_dummy\x10\xd8\
    \x04*a\n\x16Bidirectional_Messages\x12\x1b\n\x17bi_RebroadcastGameEvent\
    \x10\x10\x12\x18\n\x14bi_RebroadcastSource\x10\x11\x12\x10\n\x0cbi_GameE\
    vent\x10\x12*M\n#Bidirectional_Messages_LowFrequency\x12\x11\n\x0cbi_Rel\
    ayInfo\x10\xbc\x05\x12\x13\n\x0ebi_RelayPacket\x10\xbd\x05*\xa1\x01\n\
    \x11ReplayEventType_t\x12\x17\n\x13REPLAY_EVENT_CANCEL\x10\0\x12\x16\n\
    \x12REPLAY_EVENT_DEATH\x10\x01\x12\x18\n\x14REPLAY_EVENT_GENERIC\x10\x02\
    \x12'\n#REPLAY_EVENT_STUCK_NEED_FULL_UPDATE\x10\x03\x12\x18\n\x14REPLAY_\
    EVENT_VICTORY\x10\x04\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::networkbasetypes::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(71);
            messages.push(CCLCMsg_ClientInfo::generated_message_descriptor_data());
            messages.push(CCLCMsg_Move::generated_message_descriptor_data());
            messages.push(CMsgVoiceAudio::generated_message_descriptor_data());
            messages.push(CCLCMsg_VoiceData::generated_message_descriptor_data());
            messages.push(CCLCMsg_BaselineAck::generated_message_descriptor_data());
            messages.push(CCLCMsg_ListenEvents::generated_message_descriptor_data());
            messages.push(CCLCMsg_RespondCvarValue::generated_message_descriptor_data());
            messages.push(CCLCMsg_FileCRCCheck::generated_message_descriptor_data());
            messages.push(CCLCMsg_LoadingProgress::generated_message_descriptor_data());
            messages.push(CCLCMsg_SplitPlayerConnect::generated_message_descriptor_data());
            messages.push(CCLCMsg_ClientMessage::generated_message_descriptor_data());
            messages.push(CCLCMsg_SplitPlayerDisconnect::generated_message_descriptor_data());
            messages.push(CCLCMsg_ServerStatus::generated_message_descriptor_data());
            messages.push(CCLCMsg_ServerPing::generated_message_descriptor_data());
            messages.push(CCLCMsg_RequestPause::generated_message_descriptor_data());
            messages.push(CCLCMsg_CmdKeyValues::generated_message_descriptor_data());
            messages.push(CCLCMsg_RconServerDetails::generated_message_descriptor_data());
            messages.push(CSVCMsg_ServerInfo::generated_message_descriptor_data());
            messages.push(CSVCMsg_ClassInfo::generated_message_descriptor_data());
            messages.push(CSVCMsg_SetPause::generated_message_descriptor_data());
            messages.push(CSVCMsg_VoiceInit::generated_message_descriptor_data());
            messages.push(CSVCMsg_Print::generated_message_descriptor_data());
            messages.push(CSVCMsg_Sounds::generated_message_descriptor_data());
            messages.push(CSVCMsg_Prefetch::generated_message_descriptor_data());
            messages.push(CSVCMsg_SetView::generated_message_descriptor_data());
            messages.push(CSVCMsg_FixAngle::generated_message_descriptor_data());
            messages.push(CSVCMsg_CrosshairAngle::generated_message_descriptor_data());
            messages.push(CSVCMsg_BSPDecal::generated_message_descriptor_data());
            messages.push(CSVCMsg_SplitScreen::generated_message_descriptor_data());
            messages.push(CSVCMsg_GetCvarValue::generated_message_descriptor_data());
            messages.push(CSVCMsg_Menu::generated_message_descriptor_data());
            messages.push(CSVCMsg_UserMessage::generated_message_descriptor_data());
            messages.push(CSVCMsg_SendTable::generated_message_descriptor_data());
            messages.push(CSVCMsg_GameEventList::generated_message_descriptor_data());
            messages.push(CSVCMsg_PacketEntities::generated_message_descriptor_data());
            messages.push(CSVCMsg_TempEntities::generated_message_descriptor_data());
            messages.push(CSVCMsg_CreateStringTable::generated_message_descriptor_data());
            messages.push(CSVCMsg_UpdateStringTable::generated_message_descriptor_data());
            messages.push(CSVCMsg_VoiceData::generated_message_descriptor_data());
            messages.push(CSVCMsg_PacketReliable::generated_message_descriptor_data());
            messages.push(CSVCMsg_FullFrameSplit::generated_message_descriptor_data());
            messages.push(CSVCMsg_HLTVStatus::generated_message_descriptor_data());
            messages.push(CSVCMsg_ServerSteamID::generated_message_descriptor_data());
            messages.push(CSVCMsg_CmdKeyValues::generated_message_descriptor_data());
            messages.push(CSVCMsg_RconServerDetails::generated_message_descriptor_data());
            messages.push(CMsgIPCAddress::generated_message_descriptor_data());
            messages.push(CMsgServerPeer::generated_message_descriptor_data());
            messages.push(CSVCMsg_PeerList::generated_message_descriptor_data());
            messages.push(CSVCMsg_ClearAllStringTables::generated_message_descriptor_data());
            messages.push(ProtoFlattenedSerializerField_t::generated_message_descriptor_data());
            messages.push(ProtoFlattenedSerializer_t::generated_message_descriptor_data());
            messages.push(CSVCMsg_FlattenedSerializer::generated_message_descriptor_data());
            messages.push(CSVCMsg_StopSound::generated_message_descriptor_data());
            messages.push(CBidirMsg_RebroadcastGameEvent::generated_message_descriptor_data());
            messages.push(CBidirMsg_RebroadcastSource::generated_message_descriptor_data());
            messages.push(CMsgServerNetworkStats::generated_message_descriptor_data());
            messages.push(CSVCMsg_HltvReplay::generated_message_descriptor_data());
            messages.push(CCLCMsg_HltvReplay::generated_message_descriptor_data());
            messages.push(CSVCMsg_Broadcast_Command::generated_message_descriptor_data());
            messages.push(CCLCMsg_HltvFixupOperatorTick::generated_message_descriptor_data());
            messages.push(CSVCMsg_HltvFixupOperatorStatus::generated_message_descriptor_data());
            messages.push(csvcmsg_class_info::Class_t::generated_message_descriptor_data());
            messages.push(csvcmsg_sounds::Sounddata_t::generated_message_descriptor_data());
            messages.push(csvcmsg_send_table::Sendprop_t::generated_message_descriptor_data());
            messages.push(csvcmsg_game_event_list::Key_t::generated_message_descriptor_data());
            messages.push(csvcmsg_game_event_list::Descriptor_t::generated_message_descriptor_data());
            messages.push(csvcmsg_packet_entities::Command_queue_info_t::generated_message_descriptor_data());
            messages.push(csvcmsg_packet_entities::Alternate_baseline_t::generated_message_descriptor_data());
            messages.push(proto_flattened_serializer_field_t::Polymorphic_field_t::generated_message_descriptor_data());
            messages.push(cmsg_server_network_stats::Port::generated_message_descriptor_data());
            messages.push(cmsg_server_network_stats::Player::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(12);
            enums.push(CLC_Messages::generated_enum_descriptor_data());
            enums.push(SVC_Messages::generated_enum_descriptor_data());
            enums.push(VoiceDataFormat_t::generated_enum_descriptor_data());
            enums.push(RequestPause_t::generated_enum_descriptor_data());
            enums.push(PrefetchType::generated_enum_descriptor_data());
            enums.push(ESplitScreenMessageType::generated_enum_descriptor_data());
            enums.push(EQueryCvarValueStatus::generated_enum_descriptor_data());
            enums.push(DIALOG_TYPE::generated_enum_descriptor_data());
            enums.push(SVC_Messages_LowFrequency::generated_enum_descriptor_data());
            enums.push(Bidirectional_Messages::generated_enum_descriptor_data());
            enums.push(Bidirectional_Messages_LowFrequency::generated_enum_descriptor_data());
            enums.push(ReplayEventType_t::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
