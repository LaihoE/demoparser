// This file is generated by rust-protobuf 3.5.0. Do not edit
// .proto file is parsed by protoc 3.12.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `netmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_0;

// @@protoc_insertion_point(message:CCLCMsg_ClientInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ClientInfo {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.send_table_crc)
    pub send_table_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.server_count)
    pub server_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.is_hltv)
    pub is_hltv: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.friends_id)
    pub friends_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.friends_name)
    pub friends_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ClientInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ClientInfo {
    fn default() -> &'a CCLCMsg_ClientInfo {
        <CCLCMsg_ClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ClientInfo {
    pub fn new() -> CCLCMsg_ClientInfo {
        ::std::default::Default::default()
    }

    // optional fixed32 send_table_crc = 1;

    pub fn send_table_crc(&self) -> u32 {
        self.send_table_crc.unwrap_or(0)
    }

    pub fn clear_send_table_crc(&mut self) {
        self.send_table_crc = ::std::option::Option::None;
    }

    pub fn has_send_table_crc(&self) -> bool {
        self.send_table_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_table_crc(&mut self, v: u32) {
        self.send_table_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 server_count = 2;

    pub fn server_count(&self) -> u32 {
        self.server_count.unwrap_or(0)
    }

    pub fn clear_server_count(&mut self) {
        self.server_count = ::std::option::Option::None;
    }

    pub fn has_server_count(&self) -> bool {
        self.server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_count(&mut self, v: u32) {
        self.server_count = ::std::option::Option::Some(v);
    }

    // optional bool is_hltv = 3;

    pub fn is_hltv(&self) -> bool {
        self.is_hltv.unwrap_or(false)
    }

    pub fn clear_is_hltv(&mut self) {
        self.is_hltv = ::std::option::Option::None;
    }

    pub fn has_is_hltv(&self) -> bool {
        self.is_hltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hltv(&mut self, v: bool) {
        self.is_hltv = ::std::option::Option::Some(v);
    }

    // optional uint32 friends_id = 5;

    pub fn friends_id(&self) -> u32 {
        self.friends_id.unwrap_or(0)
    }

    pub fn clear_friends_id(&mut self) {
        self.friends_id = ::std::option::Option::None;
    }

    pub fn has_friends_id(&self) -> bool {
        self.friends_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_id(&mut self, v: u32) {
        self.friends_id = ::std::option::Option::Some(v);
    }

    // optional string friends_name = 6;

    pub fn friends_name(&self) -> &str {
        match self.friends_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_friends_name(&mut self) {
        self.friends_name = ::std::option::Option::None;
    }

    pub fn has_friends_name(&self) -> bool {
        self.friends_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_name(&mut self, v: ::std::string::String) {
        self.friends_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_friends_name(&mut self) -> &mut ::std::string::String {
        if self.friends_name.is_none() {
            self.friends_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.friends_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_friends_name(&mut self) -> ::std::string::String {
        self.friends_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_table_crc",
            |m: &CCLCMsg_ClientInfo| { &m.send_table_crc },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.send_table_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_count",
            |m: &CCLCMsg_ClientInfo| { &m.server_count },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.server_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hltv",
            |m: &CCLCMsg_ClientInfo| { &m.is_hltv },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.is_hltv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friends_id",
            |m: &CCLCMsg_ClientInfo| { &m.friends_id },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.friends_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friends_name",
            |m: &CCLCMsg_ClientInfo| { &m.friends_name },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.friends_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ClientInfo>(
            "CCLCMsg_ClientInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ClientInfo {
    const NAME: &'static str = "CCLCMsg_ClientInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.send_table_crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.server_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_hltv = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.friends_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.friends_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.send_table_crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_hltv {
            my_size += 1 + 1;
        }
        if let Some(v) = self.friends_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.friends_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.send_table_crc {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_hltv {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.friends_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.friends_name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ClientInfo {
        CCLCMsg_ClientInfo::new()
    }

    fn clear(&mut self) {
        self.send_table_crc = ::std::option::Option::None;
        self.server_count = ::std::option::Option::None;
        self.is_hltv = ::std::option::Option::None;
        self.friends_id = ::std::option::Option::None;
        self.friends_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ClientInfo {
        static instance: CCLCMsg_ClientInfo = CCLCMsg_ClientInfo {
            send_table_crc: ::std::option::Option::None,
            server_count: ::std::option::Option::None,
            is_hltv: ::std::option::Option::None,
            friends_id: ::std::option::Option::None,
            friends_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ClientInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ClientInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ClientInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_Move)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_Move {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_Move.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CCLCMsg_Move.last_command_number)
    pub last_command_number: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_Move.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_Move {
    fn default() -> &'a CCLCMsg_Move {
        <CCLCMsg_Move as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_Move {
    pub fn new() -> CCLCMsg_Move {
        ::std::default::Default::default()
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 last_command_number = 4;

    pub fn last_command_number(&self) -> u32 {
        self.last_command_number.unwrap_or(0)
    }

    pub fn clear_last_command_number(&mut self) {
        self.last_command_number = ::std::option::Option::None;
    }

    pub fn has_last_command_number(&self) -> bool {
        self.last_command_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_command_number(&mut self, v: u32) {
        self.last_command_number = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CCLCMsg_Move| { &m.data },
            |m: &mut CCLCMsg_Move| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_command_number",
            |m: &CCLCMsg_Move| { &m.last_command_number },
            |m: &mut CCLCMsg_Move| { &mut m.last_command_number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_Move>(
            "CCLCMsg_Move",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_Move {
    const NAME: &'static str = "CCLCMsg_Move";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                32 => {
                    self.last_command_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.last_command_number {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.last_command_number {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_Move {
        CCLCMsg_Move::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.last_command_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_Move {
        static instance: CCLCMsg_Move = CCLCMsg_Move {
            data: ::std::option::Option::None,
            last_command_number: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_Move {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_Move").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_Move {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_Move {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgVoiceAudio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVoiceAudio {
    // message fields
    // @@protoc_insertion_point(field:CMsgVoiceAudio.format)
    pub format: ::std::option::Option<::protobuf::EnumOrUnknown<VoiceDataFormat_t>>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.voice_data)
    pub voice_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.sequence_bytes)
    pub sequence_bytes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.section_number)
    pub section_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.sample_rate)
    pub sample_rate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.uncompressed_sample_offset)
    pub uncompressed_sample_offset: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.num_packets)
    pub num_packets: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.packet_offsets)
    pub packet_offsets: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgVoiceAudio.voice_level)
    pub voice_level: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVoiceAudio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVoiceAudio {
    fn default() -> &'a CMsgVoiceAudio {
        <CMsgVoiceAudio as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVoiceAudio {
    pub fn new() -> CMsgVoiceAudio {
        ::std::default::Default::default()
    }

    // optional .VoiceDataFormat_t format = 1;

    pub fn format(&self) -> VoiceDataFormat_t {
        match self.format {
            Some(e) => e.enum_value_or(VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM),
            None => VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: VoiceDataFormat_t) {
        self.format = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes voice_data = 2;

    pub fn voice_data(&self) -> &[u8] {
        match self.voice_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_voice_data(&mut self) {
        self.voice_data = ::std::option::Option::None;
    }

    pub fn has_voice_data(&self) -> bool {
        self.voice_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_data(&mut self, v: ::bytes::Bytes) {
        self.voice_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_data(&mut self) -> &mut ::bytes::Bytes {
        if self.voice_data.is_none() {
            self.voice_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.voice_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_data(&mut self) -> ::bytes::Bytes {
        self.voice_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional int32 sequence_bytes = 3;

    pub fn sequence_bytes(&self) -> i32 {
        self.sequence_bytes.unwrap_or(0)
    }

    pub fn clear_sequence_bytes(&mut self) {
        self.sequence_bytes = ::std::option::Option::None;
    }

    pub fn has_sequence_bytes(&self) -> bool {
        self.sequence_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_bytes(&mut self, v: i32) {
        self.sequence_bytes = ::std::option::Option::Some(v);
    }

    // optional uint32 section_number = 4;

    pub fn section_number(&self) -> u32 {
        self.section_number.unwrap_or(0)
    }

    pub fn clear_section_number(&mut self) {
        self.section_number = ::std::option::Option::None;
    }

    pub fn has_section_number(&self) -> bool {
        self.section_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_number(&mut self, v: u32) {
        self.section_number = ::std::option::Option::Some(v);
    }

    // optional uint32 sample_rate = 5;

    pub fn sample_rate(&self) -> u32 {
        self.sample_rate.unwrap_or(0)
    }

    pub fn clear_sample_rate(&mut self) {
        self.sample_rate = ::std::option::Option::None;
    }

    pub fn has_sample_rate(&self) -> bool {
        self.sample_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sample_rate(&mut self, v: u32) {
        self.sample_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 uncompressed_sample_offset = 6;

    pub fn uncompressed_sample_offset(&self) -> u32 {
        self.uncompressed_sample_offset.unwrap_or(0)
    }

    pub fn clear_uncompressed_sample_offset(&mut self) {
        self.uncompressed_sample_offset = ::std::option::Option::None;
    }

    pub fn has_uncompressed_sample_offset(&self) -> bool {
        self.uncompressed_sample_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_sample_offset(&mut self, v: u32) {
        self.uncompressed_sample_offset = ::std::option::Option::Some(v);
    }

    // optional uint32 num_packets = 7;

    pub fn num_packets(&self) -> u32 {
        self.num_packets.unwrap_or(0)
    }

    pub fn clear_num_packets(&mut self) {
        self.num_packets = ::std::option::Option::None;
    }

    pub fn has_num_packets(&self) -> bool {
        self.num_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_packets(&mut self, v: u32) {
        self.num_packets = ::std::option::Option::Some(v);
    }

    // optional float voice_level = 9;

    pub fn voice_level(&self) -> f32 {
        self.voice_level.unwrap_or(0.)
    }

    pub fn clear_voice_level(&mut self) {
        self.voice_level = ::std::option::Option::None;
    }

    pub fn has_voice_level(&self) -> bool {
        self.voice_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_level(&mut self, v: f32) {
        self.voice_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &CMsgVoiceAudio| { &m.format },
            |m: &mut CMsgVoiceAudio| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_data",
            |m: &CMsgVoiceAudio| { &m.voice_data },
            |m: &mut CMsgVoiceAudio| { &mut m.voice_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_bytes",
            |m: &CMsgVoiceAudio| { &m.sequence_bytes },
            |m: &mut CMsgVoiceAudio| { &mut m.sequence_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "section_number",
            |m: &CMsgVoiceAudio| { &m.section_number },
            |m: &mut CMsgVoiceAudio| { &mut m.section_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sample_rate",
            |m: &CMsgVoiceAudio| { &m.sample_rate },
            |m: &mut CMsgVoiceAudio| { &mut m.sample_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uncompressed_sample_offset",
            |m: &CMsgVoiceAudio| { &m.uncompressed_sample_offset },
            |m: &mut CMsgVoiceAudio| { &mut m.uncompressed_sample_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_packets",
            |m: &CMsgVoiceAudio| { &m.num_packets },
            |m: &mut CMsgVoiceAudio| { &mut m.num_packets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packet_offsets",
            |m: &CMsgVoiceAudio| { &m.packet_offsets },
            |m: &mut CMsgVoiceAudio| { &mut m.packet_offsets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_level",
            |m: &CMsgVoiceAudio| { &m.voice_level },
            |m: &mut CMsgVoiceAudio| { &mut m.voice_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVoiceAudio>(
            "CMsgVoiceAudio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVoiceAudio {
    const NAME: &'static str = "CMsgVoiceAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.voice_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                24 => {
                    self.sequence_bytes = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.section_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.sample_rate = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.uncompressed_sample_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.num_packets = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.packet_offsets)?;
                },
                64 => {
                    self.packet_offsets.push(is.read_uint32()?);
                },
                77 => {
                    self.voice_level = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.voice_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.sequence_bytes {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.section_number {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.sample_rate {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.uncompressed_sample_offset {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.num_packets {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(8, &self.packet_offsets);
        if let Some(v) = self.voice_level {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.format {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.voice_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.sequence_bytes {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.section_number {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sample_rate {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.uncompressed_sample_offset {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.num_packets {
            os.write_uint32(7, v)?;
        }
        os.write_repeated_packed_uint32(8, &self.packet_offsets)?;
        if let Some(v) = self.voice_level {
            os.write_float(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVoiceAudio {
        CMsgVoiceAudio::new()
    }

    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.voice_data = ::std::option::Option::None;
        self.sequence_bytes = ::std::option::Option::None;
        self.section_number = ::std::option::Option::None;
        self.sample_rate = ::std::option::Option::None;
        self.uncompressed_sample_offset = ::std::option::Option::None;
        self.num_packets = ::std::option::Option::None;
        self.packet_offsets.clear();
        self.voice_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVoiceAudio {
        static instance: CMsgVoiceAudio = CMsgVoiceAudio {
            format: ::std::option::Option::None,
            voice_data: ::std::option::Option::None,
            sequence_bytes: ::std::option::Option::None,
            section_number: ::std::option::Option::None,
            sample_rate: ::std::option::Option::None,
            uncompressed_sample_offset: ::std::option::Option::None,
            num_packets: ::std::option::Option::None,
            packet_offsets: ::std::vec::Vec::new(),
            voice_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVoiceAudio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVoiceAudio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVoiceAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVoiceAudio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_VoiceData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_VoiceData {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.audio)
    pub audio: ::protobuf::MessageField<CMsgVoiceAudio>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.tick)
    pub tick: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_VoiceData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_VoiceData {
    fn default() -> &'a CCLCMsg_VoiceData {
        <CCLCMsg_VoiceData as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_VoiceData {
    pub fn new() -> CCLCMsg_VoiceData {
        ::std::default::Default::default()
    }

    // optional fixed64 xuid = 2;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional uint32 tick = 3;

    pub fn tick(&self) -> u32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: u32) {
        self.tick = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVoiceAudio>(
            "audio",
            |m: &CCLCMsg_VoiceData| { &m.audio },
            |m: &mut CCLCMsg_VoiceData| { &mut m.audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xuid",
            |m: &CCLCMsg_VoiceData| { &m.xuid },
            |m: &mut CCLCMsg_VoiceData| { &mut m.xuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CCLCMsg_VoiceData| { &m.tick },
            |m: &mut CCLCMsg_VoiceData| { &mut m.tick },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_VoiceData>(
            "CCLCMsg_VoiceData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_VoiceData {
    const NAME: &'static str = "CCLCMsg_VoiceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audio)?;
                },
                17 => {
                    self.xuid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.audio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.xuid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.audio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.xuid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.tick {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_VoiceData {
        CCLCMsg_VoiceData::new()
    }

    fn clear(&mut self) {
        self.audio.clear();
        self.xuid = ::std::option::Option::None;
        self.tick = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_VoiceData {
        static instance: CCLCMsg_VoiceData = CCLCMsg_VoiceData {
            audio: ::protobuf::MessageField::none(),
            xuid: ::std::option::Option::None,
            tick: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_VoiceData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_VoiceData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_VoiceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_VoiceData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_BaselineAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_BaselineAck {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_BaselineAck.baseline_tick)
    pub baseline_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_BaselineAck.baseline_nr)
    pub baseline_nr: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_BaselineAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_BaselineAck {
    fn default() -> &'a CCLCMsg_BaselineAck {
        <CCLCMsg_BaselineAck as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_BaselineAck {
    pub fn new() -> CCLCMsg_BaselineAck {
        ::std::default::Default::default()
    }

    // optional int32 baseline_tick = 1;

    pub fn baseline_tick(&self) -> i32 {
        self.baseline_tick.unwrap_or(0)
    }

    pub fn clear_baseline_tick(&mut self) {
        self.baseline_tick = ::std::option::Option::None;
    }

    pub fn has_baseline_tick(&self) -> bool {
        self.baseline_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline_tick(&mut self, v: i32) {
        self.baseline_tick = ::std::option::Option::Some(v);
    }

    // optional int32 baseline_nr = 2;

    pub fn baseline_nr(&self) -> i32 {
        self.baseline_nr.unwrap_or(0)
    }

    pub fn clear_baseline_nr(&mut self) {
        self.baseline_nr = ::std::option::Option::None;
    }

    pub fn has_baseline_nr(&self) -> bool {
        self.baseline_nr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline_nr(&mut self, v: i32) {
        self.baseline_nr = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseline_tick",
            |m: &CCLCMsg_BaselineAck| { &m.baseline_tick },
            |m: &mut CCLCMsg_BaselineAck| { &mut m.baseline_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseline_nr",
            |m: &CCLCMsg_BaselineAck| { &m.baseline_nr },
            |m: &mut CCLCMsg_BaselineAck| { &mut m.baseline_nr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_BaselineAck>(
            "CCLCMsg_BaselineAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_BaselineAck {
    const NAME: &'static str = "CCLCMsg_BaselineAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.baseline_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.baseline_nr = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.baseline_tick {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.baseline_nr {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.baseline_tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.baseline_nr {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_BaselineAck {
        CCLCMsg_BaselineAck::new()
    }

    fn clear(&mut self) {
        self.baseline_tick = ::std::option::Option::None;
        self.baseline_nr = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_BaselineAck {
        static instance: CCLCMsg_BaselineAck = CCLCMsg_BaselineAck {
            baseline_tick: ::std::option::Option::None,
            baseline_nr: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_BaselineAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_BaselineAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_BaselineAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_BaselineAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_ListenEvents)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ListenEvents {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ListenEvents.event_mask)
    pub event_mask: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ListenEvents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ListenEvents {
    fn default() -> &'a CCLCMsg_ListenEvents {
        <CCLCMsg_ListenEvents as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ListenEvents {
    pub fn new() -> CCLCMsg_ListenEvents {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_mask",
            |m: &CCLCMsg_ListenEvents| { &m.event_mask },
            |m: &mut CCLCMsg_ListenEvents| { &mut m.event_mask },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ListenEvents>(
            "CCLCMsg_ListenEvents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ListenEvents {
    const NAME: &'static str = "CCLCMsg_ListenEvents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed32_into(&mut self.event_mask)?;
                },
                13 => {
                    self.event_mask.push(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.event_mask.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.event_mask {
            os.write_fixed32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ListenEvents {
        CCLCMsg_ListenEvents::new()
    }

    fn clear(&mut self) {
        self.event_mask.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ListenEvents {
        static instance: CCLCMsg_ListenEvents = CCLCMsg_ListenEvents {
            event_mask: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ListenEvents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ListenEvents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ListenEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ListenEvents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_RespondCvarValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_RespondCvarValue {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.cookie)
    pub cookie: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.status_code)
    pub status_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_RespondCvarValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_RespondCvarValue {
    fn default() -> &'a CCLCMsg_RespondCvarValue {
        <CCLCMsg_RespondCvarValue as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_RespondCvarValue {
    pub fn new() -> CCLCMsg_RespondCvarValue {
        ::std::default::Default::default()
    }

    // optional int32 cookie = 1;

    pub fn cookie(&self) -> i32 {
        self.cookie.unwrap_or(0)
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = ::std::option::Option::Some(v);
    }

    // optional int32 status_code = 2;

    pub fn status_code(&self) -> i32 {
        self.status_code.unwrap_or(0)
    }

    pub fn clear_status_code(&mut self) {
        self.status_code = ::std::option::Option::None;
    }

    pub fn has_status_code(&self) -> bool {
        self.status_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: i32) {
        self.status_code = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 4;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cookie",
            |m: &CCLCMsg_RespondCvarValue| { &m.cookie },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_code",
            |m: &CCLCMsg_RespondCvarValue| { &m.status_code },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.status_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CCLCMsg_RespondCvarValue| { &m.name },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CCLCMsg_RespondCvarValue| { &m.value },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_RespondCvarValue>(
            "CCLCMsg_RespondCvarValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_RespondCvarValue {
    const NAME: &'static str = "CCLCMsg_RespondCvarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cookie = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.status_code = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cookie {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.status_code {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cookie {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.status_code {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_RespondCvarValue {
        CCLCMsg_RespondCvarValue::new()
    }

    fn clear(&mut self) {
        self.cookie = ::std::option::Option::None;
        self.status_code = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_RespondCvarValue {
        static instance: CCLCMsg_RespondCvarValue = CCLCMsg_RespondCvarValue {
            cookie: ::std::option::Option::None,
            status_code: ::std::option::Option::None,
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_RespondCvarValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_RespondCvarValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_RespondCvarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_RespondCvarValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_FileCRCCheck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_FileCRCCheck {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.code_path)
    pub code_path: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.code_filename)
    pub code_filename: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.crc)
    pub crc: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_FileCRCCheck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_FileCRCCheck {
    fn default() -> &'a CCLCMsg_FileCRCCheck {
        <CCLCMsg_FileCRCCheck as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_FileCRCCheck {
    pub fn new() -> CCLCMsg_FileCRCCheck {
        ::std::default::Default::default()
    }

    // optional int32 code_path = 1;

    pub fn code_path(&self) -> i32 {
        self.code_path.unwrap_or(0)
    }

    pub fn clear_code_path(&mut self) {
        self.code_path = ::std::option::Option::None;
    }

    pub fn has_code_path(&self) -> bool {
        self.code_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_path(&mut self, v: i32) {
        self.code_path = ::std::option::Option::Some(v);
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 code_filename = 3;

    pub fn code_filename(&self) -> i32 {
        self.code_filename.unwrap_or(0)
    }

    pub fn clear_code_filename(&mut self) {
        self.code_filename = ::std::option::Option::None;
    }

    pub fn has_code_filename(&self) -> bool {
        self.code_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_filename(&mut self, v: i32) {
        self.code_filename = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 crc = 5;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code_path",
            |m: &CCLCMsg_FileCRCCheck| { &m.code_path },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.code_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CCLCMsg_FileCRCCheck| { &m.path },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code_filename",
            |m: &CCLCMsg_FileCRCCheck| { &m.code_filename },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.code_filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CCLCMsg_FileCRCCheck| { &m.filename },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc",
            |m: &CCLCMsg_FileCRCCheck| { &m.crc },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.crc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_FileCRCCheck>(
            "CCLCMsg_FileCRCCheck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_FileCRCCheck {
    const NAME: &'static str = "CCLCMsg_FileCRCCheck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code_path = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.code_filename = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                45 => {
                    self.crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code_path {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.code_filename {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.crc {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.code_path {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.code_filename {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.crc {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_FileCRCCheck {
        CCLCMsg_FileCRCCheck::new()
    }

    fn clear(&mut self) {
        self.code_path = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.code_filename = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_FileCRCCheck {
        static instance: CCLCMsg_FileCRCCheck = CCLCMsg_FileCRCCheck {
            code_path: ::std::option::Option::None,
            path: ::std::option::Option::None,
            code_filename: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            crc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_FileCRCCheck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_FileCRCCheck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_FileCRCCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_FileCRCCheck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_LoadingProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_LoadingProgress {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_LoadingProgress.progress)
    pub progress: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_LoadingProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_LoadingProgress {
    fn default() -> &'a CCLCMsg_LoadingProgress {
        <CCLCMsg_LoadingProgress as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_LoadingProgress {
    pub fn new() -> CCLCMsg_LoadingProgress {
        ::std::default::Default::default()
    }

    // optional int32 progress = 1;

    pub fn progress(&self) -> i32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &CCLCMsg_LoadingProgress| { &m.progress },
            |m: &mut CCLCMsg_LoadingProgress| { &mut m.progress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_LoadingProgress>(
            "CCLCMsg_LoadingProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_LoadingProgress {
    const NAME: &'static str = "CCLCMsg_LoadingProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.progress = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.progress {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_LoadingProgress {
        CCLCMsg_LoadingProgress::new()
    }

    fn clear(&mut self) {
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_LoadingProgress {
        static instance: CCLCMsg_LoadingProgress = CCLCMsg_LoadingProgress {
            progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_LoadingProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_LoadingProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_LoadingProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_LoadingProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_SplitPlayerConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_SplitPlayerConnect {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_SplitPlayerConnect.playername)
    pub playername: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_SplitPlayerConnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_SplitPlayerConnect {
    fn default() -> &'a CCLCMsg_SplitPlayerConnect {
        <CCLCMsg_SplitPlayerConnect as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_SplitPlayerConnect {
    pub fn new() -> CCLCMsg_SplitPlayerConnect {
        ::std::default::Default::default()
    }

    // optional string playername = 1;

    pub fn playername(&self) -> &str {
        match self.playername.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_playername(&mut self) {
        self.playername = ::std::option::Option::None;
    }

    pub fn has_playername(&self) -> bool {
        self.playername.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playername(&mut self, v: ::std::string::String) {
        self.playername = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_playername(&mut self) -> &mut ::std::string::String {
        if self.playername.is_none() {
            self.playername = ::std::option::Option::Some(::std::string::String::new());
        }
        self.playername.as_mut().unwrap()
    }

    // Take field
    pub fn take_playername(&mut self) -> ::std::string::String {
        self.playername.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playername",
            |m: &CCLCMsg_SplitPlayerConnect| { &m.playername },
            |m: &mut CCLCMsg_SplitPlayerConnect| { &mut m.playername },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_SplitPlayerConnect>(
            "CCLCMsg_SplitPlayerConnect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_SplitPlayerConnect {
    const NAME: &'static str = "CCLCMsg_SplitPlayerConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.playername = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playername.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.playername.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_SplitPlayerConnect {
        CCLCMsg_SplitPlayerConnect::new()
    }

    fn clear(&mut self) {
        self.playername = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_SplitPlayerConnect {
        static instance: CCLCMsg_SplitPlayerConnect = CCLCMsg_SplitPlayerConnect {
            playername: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_SplitPlayerConnect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_SplitPlayerConnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_SplitPlayerConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_SplitPlayerConnect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_ClientMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ClientMessage {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ClientMessage.msg_type)
    pub msg_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientMessage.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ClientMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ClientMessage {
    fn default() -> &'a CCLCMsg_ClientMessage {
        <CCLCMsg_ClientMessage as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ClientMessage {
    pub fn new() -> CCLCMsg_ClientMessage {
        ::std::default::Default::default()
    }

    // optional int32 msg_type = 1;

    pub fn msg_type(&self) -> i32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: i32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CCLCMsg_ClientMessage| { &m.msg_type },
            |m: &mut CCLCMsg_ClientMessage| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CCLCMsg_ClientMessage| { &m.data },
            |m: &mut CCLCMsg_ClientMessage| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ClientMessage>(
            "CCLCMsg_ClientMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ClientMessage {
    const NAME: &'static str = "CCLCMsg_ClientMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ClientMessage {
        CCLCMsg_ClientMessage::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ClientMessage {
        static instance: CCLCMsg_ClientMessage = CCLCMsg_ClientMessage {
            msg_type: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ClientMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ClientMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ClientMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ClientMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_SplitPlayerDisconnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_SplitPlayerDisconnect {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_SplitPlayerDisconnect.slot)
    pub slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_SplitPlayerDisconnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_SplitPlayerDisconnect {
    fn default() -> &'a CCLCMsg_SplitPlayerDisconnect {
        <CCLCMsg_SplitPlayerDisconnect as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_SplitPlayerDisconnect {
    pub fn new() -> CCLCMsg_SplitPlayerDisconnect {
        ::std::default::Default::default()
    }

    // optional int32 slot = 1;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CCLCMsg_SplitPlayerDisconnect| { &m.slot },
            |m: &mut CCLCMsg_SplitPlayerDisconnect| { &mut m.slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_SplitPlayerDisconnect>(
            "CCLCMsg_SplitPlayerDisconnect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_SplitPlayerDisconnect {
    const NAME: &'static str = "CCLCMsg_SplitPlayerDisconnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.slot {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_SplitPlayerDisconnect {
        CCLCMsg_SplitPlayerDisconnect::new()
    }

    fn clear(&mut self) {
        self.slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_SplitPlayerDisconnect {
        static instance: CCLCMsg_SplitPlayerDisconnect = CCLCMsg_SplitPlayerDisconnect {
            slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_SplitPlayerDisconnect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_SplitPlayerDisconnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_SplitPlayerDisconnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_SplitPlayerDisconnect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_ServerStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_ServerStatus {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ServerStatus.simplified)
    pub simplified: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ServerStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ServerStatus {
    fn default() -> &'a CCLCMsg_ServerStatus {
        <CCLCMsg_ServerStatus as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ServerStatus {
    pub fn new() -> CCLCMsg_ServerStatus {
        ::std::default::Default::default()
    }

    // optional bool simplified = 1;

    pub fn simplified(&self) -> bool {
        self.simplified.unwrap_or(false)
    }

    pub fn clear_simplified(&mut self) {
        self.simplified = ::std::option::Option::None;
    }

    pub fn has_simplified(&self) -> bool {
        self.simplified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_simplified(&mut self, v: bool) {
        self.simplified = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "simplified",
            |m: &CCLCMsg_ServerStatus| { &m.simplified },
            |m: &mut CCLCMsg_ServerStatus| { &mut m.simplified },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ServerStatus>(
            "CCLCMsg_ServerStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ServerStatus {
    const NAME: &'static str = "CCLCMsg_ServerStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.simplified = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.simplified {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.simplified {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ServerStatus {
        CCLCMsg_ServerStatus::new()
    }

    fn clear(&mut self) {
        self.simplified = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ServerStatus {
        static instance: CCLCMsg_ServerStatus = CCLCMsg_ServerStatus {
            simplified: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ServerStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ServerStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ServerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ServerStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_RequestPause)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_RequestPause {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_RequestPause.pause_type)
    pub pause_type: ::std::option::Option<::protobuf::EnumOrUnknown<RequestPause_t>>,
    // @@protoc_insertion_point(field:CCLCMsg_RequestPause.pause_group)
    pub pause_group: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_RequestPause.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_RequestPause {
    fn default() -> &'a CCLCMsg_RequestPause {
        <CCLCMsg_RequestPause as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_RequestPause {
    pub fn new() -> CCLCMsg_RequestPause {
        ::std::default::Default::default()
    }

    // optional .RequestPause_t pause_type = 1;

    pub fn pause_type(&self) -> RequestPause_t {
        match self.pause_type {
            Some(e) => e.enum_value_or(RequestPause_t::RP_PAUSE),
            None => RequestPause_t::RP_PAUSE,
        }
    }

    pub fn clear_pause_type(&mut self) {
        self.pause_type = ::std::option::Option::None;
    }

    pub fn has_pause_type(&self) -> bool {
        self.pause_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pause_type(&mut self, v: RequestPause_t) {
        self.pause_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 pause_group = 2;

    pub fn pause_group(&self) -> i32 {
        self.pause_group.unwrap_or(0)
    }

    pub fn clear_pause_group(&mut self) {
        self.pause_group = ::std::option::Option::None;
    }

    pub fn has_pause_group(&self) -> bool {
        self.pause_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pause_group(&mut self, v: i32) {
        self.pause_group = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pause_type",
            |m: &CCLCMsg_RequestPause| { &m.pause_type },
            |m: &mut CCLCMsg_RequestPause| { &mut m.pause_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pause_group",
            |m: &CCLCMsg_RequestPause| { &m.pause_group },
            |m: &mut CCLCMsg_RequestPause| { &mut m.pause_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_RequestPause>(
            "CCLCMsg_RequestPause",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_RequestPause {
    const NAME: &'static str = "CCLCMsg_RequestPause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pause_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.pause_group = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pause_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.pause_group {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pause_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.pause_group {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_RequestPause {
        CCLCMsg_RequestPause::new()
    }

    fn clear(&mut self) {
        self.pause_type = ::std::option::Option::None;
        self.pause_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_RequestPause {
        static instance: CCLCMsg_RequestPause = CCLCMsg_RequestPause {
            pause_type: ::std::option::Option::None,
            pause_group: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_RequestPause {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_RequestPause").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_RequestPause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_RequestPause {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_CmdKeyValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_CmdKeyValues {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_CmdKeyValues.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_CmdKeyValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_CmdKeyValues {
    fn default() -> &'a CCLCMsg_CmdKeyValues {
        <CCLCMsg_CmdKeyValues as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_CmdKeyValues {
    pub fn new() -> CCLCMsg_CmdKeyValues {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CCLCMsg_CmdKeyValues| { &m.data },
            |m: &mut CCLCMsg_CmdKeyValues| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_CmdKeyValues>(
            "CCLCMsg_CmdKeyValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_CmdKeyValues {
    const NAME: &'static str = "CCLCMsg_CmdKeyValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_CmdKeyValues {
        CCLCMsg_CmdKeyValues::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_CmdKeyValues {
        static instance: CCLCMsg_CmdKeyValues = CCLCMsg_CmdKeyValues {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_CmdKeyValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_CmdKeyValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_CmdKeyValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_CmdKeyValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_RconServerDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_RconServerDetails {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_RconServerDetails.token)
    pub token: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_RconServerDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_RconServerDetails {
    fn default() -> &'a CCLCMsg_RconServerDetails {
        <CCLCMsg_RconServerDetails as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_RconServerDetails {
    pub fn new() -> CCLCMsg_RconServerDetails {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::bytes::Bytes) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::bytes::Bytes {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::bytes::Bytes {
        self.token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CCLCMsg_RconServerDetails| { &m.token },
            |m: &mut CCLCMsg_RconServerDetails| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_RconServerDetails>(
            "CCLCMsg_RconServerDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_RconServerDetails {
    const NAME: &'static str = "CCLCMsg_RconServerDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_RconServerDetails {
        CCLCMsg_RconServerDetails::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_RconServerDetails {
        static instance: CCLCMsg_RconServerDetails = CCLCMsg_RconServerDetails {
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_RconServerDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_RconServerDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_RconServerDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_RconServerDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSource2SystemSpecs)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource2SystemSpecs {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.cpu_id)
    pub cpu_id: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.cpu_brand)
    pub cpu_brand: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.cpu_model)
    pub cpu_model: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.cpu_num_physical)
    pub cpu_num_physical: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.ram_physical_total_mb)
    pub ram_physical_total_mb: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_rendersystem_dll_name)
    pub gpu_rendersystem_dll_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_vendor_id)
    pub gpu_vendor_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_driver_name)
    pub gpu_driver_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_driver_version_high)
    pub gpu_driver_version_high: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_driver_version_low)
    pub gpu_driver_version_low: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_dx_support_level)
    pub gpu_dx_support_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2SystemSpecs.gpu_texture_memory_size_mb)
    pub gpu_texture_memory_size_mb: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource2SystemSpecs.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource2SystemSpecs {
    fn default() -> &'a CMsgSource2SystemSpecs {
        <CMsgSource2SystemSpecs as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSource2SystemSpecs {
    pub fn new() -> CMsgSource2SystemSpecs {
        ::std::default::Default::default()
    }

    // optional string cpu_id = 1;

    pub fn cpu_id(&self) -> &str {
        match self.cpu_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cpu_id(&mut self) {
        self.cpu_id = ::std::option::Option::None;
    }

    pub fn has_cpu_id(&self) -> bool {
        self.cpu_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_id(&mut self, v: ::std::string::String) {
        self.cpu_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_id(&mut self) -> &mut ::std::string::String {
        if self.cpu_id.is_none() {
            self.cpu_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cpu_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu_id(&mut self) -> ::std::string::String {
        self.cpu_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cpu_brand = 2;

    pub fn cpu_brand(&self) -> &str {
        match self.cpu_brand.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cpu_brand(&mut self) {
        self.cpu_brand = ::std::option::Option::None;
    }

    pub fn has_cpu_brand(&self) -> bool {
        self.cpu_brand.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_brand(&mut self, v: ::std::string::String) {
        self.cpu_brand = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cpu_brand(&mut self) -> &mut ::std::string::String {
        if self.cpu_brand.is_none() {
            self.cpu_brand = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cpu_brand.as_mut().unwrap()
    }

    // Take field
    pub fn take_cpu_brand(&mut self) -> ::std::string::String {
        self.cpu_brand.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 cpu_model = 3;

    pub fn cpu_model(&self) -> u32 {
        self.cpu_model.unwrap_or(0)
    }

    pub fn clear_cpu_model(&mut self) {
        self.cpu_model = ::std::option::Option::None;
    }

    pub fn has_cpu_model(&self) -> bool {
        self.cpu_model.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_model(&mut self, v: u32) {
        self.cpu_model = ::std::option::Option::Some(v);
    }

    // optional uint32 cpu_num_physical = 4;

    pub fn cpu_num_physical(&self) -> u32 {
        self.cpu_num_physical.unwrap_or(0)
    }

    pub fn clear_cpu_num_physical(&mut self) {
        self.cpu_num_physical = ::std::option::Option::None;
    }

    pub fn has_cpu_num_physical(&self) -> bool {
        self.cpu_num_physical.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_num_physical(&mut self, v: u32) {
        self.cpu_num_physical = ::std::option::Option::Some(v);
    }

    // optional uint32 ram_physical_total_mb = 21;

    pub fn ram_physical_total_mb(&self) -> u32 {
        self.ram_physical_total_mb.unwrap_or(0)
    }

    pub fn clear_ram_physical_total_mb(&mut self) {
        self.ram_physical_total_mb = ::std::option::Option::None;
    }

    pub fn has_ram_physical_total_mb(&self) -> bool {
        self.ram_physical_total_mb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ram_physical_total_mb(&mut self, v: u32) {
        self.ram_physical_total_mb = ::std::option::Option::Some(v);
    }

    // optional string gpu_rendersystem_dll_name = 41;

    pub fn gpu_rendersystem_dll_name(&self) -> &str {
        match self.gpu_rendersystem_dll_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gpu_rendersystem_dll_name(&mut self) {
        self.gpu_rendersystem_dll_name = ::std::option::Option::None;
    }

    pub fn has_gpu_rendersystem_dll_name(&self) -> bool {
        self.gpu_rendersystem_dll_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_rendersystem_dll_name(&mut self, v: ::std::string::String) {
        self.gpu_rendersystem_dll_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gpu_rendersystem_dll_name(&mut self) -> &mut ::std::string::String {
        if self.gpu_rendersystem_dll_name.is_none() {
            self.gpu_rendersystem_dll_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gpu_rendersystem_dll_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_gpu_rendersystem_dll_name(&mut self) -> ::std::string::String {
        self.gpu_rendersystem_dll_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gpu_vendor_id = 42;

    pub fn gpu_vendor_id(&self) -> u32 {
        self.gpu_vendor_id.unwrap_or(0)
    }

    pub fn clear_gpu_vendor_id(&mut self) {
        self.gpu_vendor_id = ::std::option::Option::None;
    }

    pub fn has_gpu_vendor_id(&self) -> bool {
        self.gpu_vendor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_vendor_id(&mut self, v: u32) {
        self.gpu_vendor_id = ::std::option::Option::Some(v);
    }

    // optional string gpu_driver_name = 43;

    pub fn gpu_driver_name(&self) -> &str {
        match self.gpu_driver_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gpu_driver_name(&mut self) {
        self.gpu_driver_name = ::std::option::Option::None;
    }

    pub fn has_gpu_driver_name(&self) -> bool {
        self.gpu_driver_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_driver_name(&mut self, v: ::std::string::String) {
        self.gpu_driver_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gpu_driver_name(&mut self) -> &mut ::std::string::String {
        if self.gpu_driver_name.is_none() {
            self.gpu_driver_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gpu_driver_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_gpu_driver_name(&mut self) -> ::std::string::String {
        self.gpu_driver_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 gpu_driver_version_high = 44;

    pub fn gpu_driver_version_high(&self) -> u32 {
        self.gpu_driver_version_high.unwrap_or(0)
    }

    pub fn clear_gpu_driver_version_high(&mut self) {
        self.gpu_driver_version_high = ::std::option::Option::None;
    }

    pub fn has_gpu_driver_version_high(&self) -> bool {
        self.gpu_driver_version_high.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_driver_version_high(&mut self, v: u32) {
        self.gpu_driver_version_high = ::std::option::Option::Some(v);
    }

    // optional uint32 gpu_driver_version_low = 45;

    pub fn gpu_driver_version_low(&self) -> u32 {
        self.gpu_driver_version_low.unwrap_or(0)
    }

    pub fn clear_gpu_driver_version_low(&mut self) {
        self.gpu_driver_version_low = ::std::option::Option::None;
    }

    pub fn has_gpu_driver_version_low(&self) -> bool {
        self.gpu_driver_version_low.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_driver_version_low(&mut self, v: u32) {
        self.gpu_driver_version_low = ::std::option::Option::Some(v);
    }

    // optional uint32 gpu_dx_support_level = 46;

    pub fn gpu_dx_support_level(&self) -> u32 {
        self.gpu_dx_support_level.unwrap_or(0)
    }

    pub fn clear_gpu_dx_support_level(&mut self) {
        self.gpu_dx_support_level = ::std::option::Option::None;
    }

    pub fn has_gpu_dx_support_level(&self) -> bool {
        self.gpu_dx_support_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_dx_support_level(&mut self, v: u32) {
        self.gpu_dx_support_level = ::std::option::Option::Some(v);
    }

    // optional uint32 gpu_texture_memory_size_mb = 47;

    pub fn gpu_texture_memory_size_mb(&self) -> u32 {
        self.gpu_texture_memory_size_mb.unwrap_or(0)
    }

    pub fn clear_gpu_texture_memory_size_mb(&mut self) {
        self.gpu_texture_memory_size_mb = ::std::option::Option::None;
    }

    pub fn has_gpu_texture_memory_size_mb(&self) -> bool {
        self.gpu_texture_memory_size_mb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpu_texture_memory_size_mb(&mut self, v: u32) {
        self.gpu_texture_memory_size_mb = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_id",
            |m: &CMsgSource2SystemSpecs| { &m.cpu_id },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.cpu_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_brand",
            |m: &CMsgSource2SystemSpecs| { &m.cpu_brand },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.cpu_brand },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_model",
            |m: &CMsgSource2SystemSpecs| { &m.cpu_model },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.cpu_model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_num_physical",
            |m: &CMsgSource2SystemSpecs| { &m.cpu_num_physical },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.cpu_num_physical },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ram_physical_total_mb",
            |m: &CMsgSource2SystemSpecs| { &m.ram_physical_total_mb },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.ram_physical_total_mb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_rendersystem_dll_name",
            |m: &CMsgSource2SystemSpecs| { &m.gpu_rendersystem_dll_name },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.gpu_rendersystem_dll_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_vendor_id",
            |m: &CMsgSource2SystemSpecs| { &m.gpu_vendor_id },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.gpu_vendor_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_driver_name",
            |m: &CMsgSource2SystemSpecs| { &m.gpu_driver_name },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.gpu_driver_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_driver_version_high",
            |m: &CMsgSource2SystemSpecs| { &m.gpu_driver_version_high },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.gpu_driver_version_high },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_driver_version_low",
            |m: &CMsgSource2SystemSpecs| { &m.gpu_driver_version_low },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.gpu_driver_version_low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_dx_support_level",
            |m: &CMsgSource2SystemSpecs| { &m.gpu_dx_support_level },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.gpu_dx_support_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gpu_texture_memory_size_mb",
            |m: &CMsgSource2SystemSpecs| { &m.gpu_texture_memory_size_mb },
            |m: &mut CMsgSource2SystemSpecs| { &mut m.gpu_texture_memory_size_mb },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSource2SystemSpecs>(
            "CMsgSource2SystemSpecs",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSource2SystemSpecs {
    const NAME: &'static str = "CMsgSource2SystemSpecs";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cpu_id = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.cpu_brand = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.cpu_model = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.cpu_num_physical = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.ram_physical_total_mb = ::std::option::Option::Some(is.read_uint32()?);
                },
                330 => {
                    self.gpu_rendersystem_dll_name = ::std::option::Option::Some(is.read_string()?);
                },
                336 => {
                    self.gpu_vendor_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                346 => {
                    self.gpu_driver_name = ::std::option::Option::Some(is.read_string()?);
                },
                352 => {
                    self.gpu_driver_version_high = ::std::option::Option::Some(is.read_uint32()?);
                },
                360 => {
                    self.gpu_driver_version_low = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.gpu_dx_support_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                376 => {
                    self.gpu_texture_memory_size_mb = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cpu_id.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.cpu_brand.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.cpu_model {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.cpu_num_physical {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ram_physical_total_mb {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.gpu_rendersystem_dll_name.as_ref() {
            my_size += ::protobuf::rt::string_size(41, &v);
        }
        if let Some(v) = self.gpu_vendor_id {
            my_size += ::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.gpu_driver_name.as_ref() {
            my_size += ::protobuf::rt::string_size(43, &v);
        }
        if let Some(v) = self.gpu_driver_version_high {
            my_size += ::protobuf::rt::uint32_size(44, v);
        }
        if let Some(v) = self.gpu_driver_version_low {
            my_size += ::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.gpu_dx_support_level {
            my_size += ::protobuf::rt::uint32_size(46, v);
        }
        if let Some(v) = self.gpu_texture_memory_size_mb {
            my_size += ::protobuf::rt::uint32_size(47, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cpu_id.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.cpu_brand.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.cpu_model {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.cpu_num_physical {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ram_physical_total_mb {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.gpu_rendersystem_dll_name.as_ref() {
            os.write_string(41, v)?;
        }
        if let Some(v) = self.gpu_vendor_id {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.gpu_driver_name.as_ref() {
            os.write_string(43, v)?;
        }
        if let Some(v) = self.gpu_driver_version_high {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.gpu_driver_version_low {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.gpu_dx_support_level {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.gpu_texture_memory_size_mb {
            os.write_uint32(47, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource2SystemSpecs {
        CMsgSource2SystemSpecs::new()
    }

    fn clear(&mut self) {
        self.cpu_id = ::std::option::Option::None;
        self.cpu_brand = ::std::option::Option::None;
        self.cpu_model = ::std::option::Option::None;
        self.cpu_num_physical = ::std::option::Option::None;
        self.ram_physical_total_mb = ::std::option::Option::None;
        self.gpu_rendersystem_dll_name = ::std::option::Option::None;
        self.gpu_vendor_id = ::std::option::Option::None;
        self.gpu_driver_name = ::std::option::Option::None;
        self.gpu_driver_version_high = ::std::option::Option::None;
        self.gpu_driver_version_low = ::std::option::Option::None;
        self.gpu_dx_support_level = ::std::option::Option::None;
        self.gpu_texture_memory_size_mb = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource2SystemSpecs {
        static instance: CMsgSource2SystemSpecs = CMsgSource2SystemSpecs {
            cpu_id: ::std::option::Option::None,
            cpu_brand: ::std::option::Option::None,
            cpu_model: ::std::option::Option::None,
            cpu_num_physical: ::std::option::Option::None,
            ram_physical_total_mb: ::std::option::Option::None,
            gpu_rendersystem_dll_name: ::std::option::Option::None,
            gpu_vendor_id: ::std::option::Option::None,
            gpu_driver_name: ::std::option::Option::None,
            gpu_driver_version_high: ::std::option::Option::None,
            gpu_driver_version_low: ::std::option::Option::None,
            gpu_dx_support_level: ::std::option::Option::None,
            gpu_texture_memory_size_mb: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSource2SystemSpecs {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSource2SystemSpecs").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSource2SystemSpecs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSource2SystemSpecs {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSource2VProfLiteReportItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource2VProfLiteReportItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.active_samples)
    pub active_samples: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_max)
    pub usec_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_avg_active)
    pub usec_avg_active: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_p50_active)
    pub usec_p50_active: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_p99_active)
    pub usec_p99_active: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_avg_all)
    pub usec_avg_all: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_p50_all)
    pub usec_p50_all: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReportItem.usec_p99_all)
    pub usec_p99_all: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource2VProfLiteReportItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource2VProfLiteReportItem {
    fn default() -> &'a CMsgSource2VProfLiteReportItem {
        <CMsgSource2VProfLiteReportItem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSource2VProfLiteReportItem {
    pub fn new() -> CMsgSource2VProfLiteReportItem {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 active_samples = 2;

    pub fn active_samples(&self) -> u32 {
        self.active_samples.unwrap_or(0)
    }

    pub fn clear_active_samples(&mut self) {
        self.active_samples = ::std::option::Option::None;
    }

    pub fn has_active_samples(&self) -> bool {
        self.active_samples.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_samples(&mut self, v: u32) {
        self.active_samples = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_max = 3;

    pub fn usec_max(&self) -> u32 {
        self.usec_max.unwrap_or(0)
    }

    pub fn clear_usec_max(&mut self) {
        self.usec_max = ::std::option::Option::None;
    }

    pub fn has_usec_max(&self) -> bool {
        self.usec_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_max(&mut self, v: u32) {
        self.usec_max = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_avg_active = 11;

    pub fn usec_avg_active(&self) -> u32 {
        self.usec_avg_active.unwrap_or(0)
    }

    pub fn clear_usec_avg_active(&mut self) {
        self.usec_avg_active = ::std::option::Option::None;
    }

    pub fn has_usec_avg_active(&self) -> bool {
        self.usec_avg_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_avg_active(&mut self, v: u32) {
        self.usec_avg_active = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_p50_active = 12;

    pub fn usec_p50_active(&self) -> u32 {
        self.usec_p50_active.unwrap_or(0)
    }

    pub fn clear_usec_p50_active(&mut self) {
        self.usec_p50_active = ::std::option::Option::None;
    }

    pub fn has_usec_p50_active(&self) -> bool {
        self.usec_p50_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_p50_active(&mut self, v: u32) {
        self.usec_p50_active = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_p99_active = 13;

    pub fn usec_p99_active(&self) -> u32 {
        self.usec_p99_active.unwrap_or(0)
    }

    pub fn clear_usec_p99_active(&mut self) {
        self.usec_p99_active = ::std::option::Option::None;
    }

    pub fn has_usec_p99_active(&self) -> bool {
        self.usec_p99_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_p99_active(&mut self, v: u32) {
        self.usec_p99_active = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_avg_all = 21;

    pub fn usec_avg_all(&self) -> u32 {
        self.usec_avg_all.unwrap_or(0)
    }

    pub fn clear_usec_avg_all(&mut self) {
        self.usec_avg_all = ::std::option::Option::None;
    }

    pub fn has_usec_avg_all(&self) -> bool {
        self.usec_avg_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_avg_all(&mut self, v: u32) {
        self.usec_avg_all = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_p50_all = 22;

    pub fn usec_p50_all(&self) -> u32 {
        self.usec_p50_all.unwrap_or(0)
    }

    pub fn clear_usec_p50_all(&mut self) {
        self.usec_p50_all = ::std::option::Option::None;
    }

    pub fn has_usec_p50_all(&self) -> bool {
        self.usec_p50_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_p50_all(&mut self, v: u32) {
        self.usec_p50_all = ::std::option::Option::Some(v);
    }

    // optional uint32 usec_p99_all = 23;

    pub fn usec_p99_all(&self) -> u32 {
        self.usec_p99_all.unwrap_or(0)
    }

    pub fn clear_usec_p99_all(&mut self) {
        self.usec_p99_all = ::std::option::Option::None;
    }

    pub fn has_usec_p99_all(&self) -> bool {
        self.usec_p99_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usec_p99_all(&mut self, v: u32) {
        self.usec_p99_all = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgSource2VProfLiteReportItem| { &m.name },
            |m: &mut CMsgSource2VProfLiteReportItem| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_samples",
            |m: &CMsgSource2VProfLiteReportItem| { &m.active_samples },
            |m: &mut CMsgSource2VProfLiteReportItem| { &mut m.active_samples },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usec_max",
            |m: &CMsgSource2VProfLiteReportItem| { &m.usec_max },
            |m: &mut CMsgSource2VProfLiteReportItem| { &mut m.usec_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usec_avg_active",
            |m: &CMsgSource2VProfLiteReportItem| { &m.usec_avg_active },
            |m: &mut CMsgSource2VProfLiteReportItem| { &mut m.usec_avg_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usec_p50_active",
            |m: &CMsgSource2VProfLiteReportItem| { &m.usec_p50_active },
            |m: &mut CMsgSource2VProfLiteReportItem| { &mut m.usec_p50_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usec_p99_active",
            |m: &CMsgSource2VProfLiteReportItem| { &m.usec_p99_active },
            |m: &mut CMsgSource2VProfLiteReportItem| { &mut m.usec_p99_active },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usec_avg_all",
            |m: &CMsgSource2VProfLiteReportItem| { &m.usec_avg_all },
            |m: &mut CMsgSource2VProfLiteReportItem| { &mut m.usec_avg_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usec_p50_all",
            |m: &CMsgSource2VProfLiteReportItem| { &m.usec_p50_all },
            |m: &mut CMsgSource2VProfLiteReportItem| { &mut m.usec_p50_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usec_p99_all",
            |m: &CMsgSource2VProfLiteReportItem| { &m.usec_p99_all },
            |m: &mut CMsgSource2VProfLiteReportItem| { &mut m.usec_p99_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSource2VProfLiteReportItem>(
            "CMsgSource2VProfLiteReportItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSource2VProfLiteReportItem {
    const NAME: &'static str = "CMsgSource2VProfLiteReportItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.active_samples = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.usec_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.usec_avg_active = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.usec_p50_active = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.usec_p99_active = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.usec_avg_all = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.usec_p50_all = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.usec_p99_all = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.active_samples {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.usec_max {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.usec_avg_active {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.usec_p50_active {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.usec_p99_active {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.usec_avg_all {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.usec_p50_all {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.usec_p99_all {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.active_samples {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.usec_max {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.usec_avg_active {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.usec_p50_active {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.usec_p99_active {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.usec_avg_all {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.usec_p50_all {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.usec_p99_all {
            os.write_uint32(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource2VProfLiteReportItem {
        CMsgSource2VProfLiteReportItem::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.active_samples = ::std::option::Option::None;
        self.usec_max = ::std::option::Option::None;
        self.usec_avg_active = ::std::option::Option::None;
        self.usec_p50_active = ::std::option::Option::None;
        self.usec_p99_active = ::std::option::Option::None;
        self.usec_avg_all = ::std::option::Option::None;
        self.usec_p50_all = ::std::option::Option::None;
        self.usec_p99_all = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource2VProfLiteReportItem {
        static instance: CMsgSource2VProfLiteReportItem = CMsgSource2VProfLiteReportItem {
            name: ::std::option::Option::None,
            active_samples: ::std::option::Option::None,
            usec_max: ::std::option::Option::None,
            usec_avg_active: ::std::option::Option::None,
            usec_p50_active: ::std::option::Option::None,
            usec_p99_active: ::std::option::Option::None,
            usec_avg_all: ::std::option::Option::None,
            usec_p50_all: ::std::option::Option::None,
            usec_p99_all: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSource2VProfLiteReportItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSource2VProfLiteReportItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSource2VProfLiteReportItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSource2VProfLiteReportItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSource2VProfLiteReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource2VProfLiteReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReport.total)
    pub total: ::protobuf::MessageField<CMsgSource2VProfLiteReportItem>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReport.items)
    pub items: ::std::vec::Vec<CMsgSource2VProfLiteReportItem>,
    // @@protoc_insertion_point(field:CMsgSource2VProfLiteReport.discarded_frames)
    pub discarded_frames: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource2VProfLiteReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource2VProfLiteReport {
    fn default() -> &'a CMsgSource2VProfLiteReport {
        <CMsgSource2VProfLiteReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSource2VProfLiteReport {
    pub fn new() -> CMsgSource2VProfLiteReport {
        ::std::default::Default::default()
    }

    // optional uint32 discarded_frames = 3;

    pub fn discarded_frames(&self) -> u32 {
        self.discarded_frames.unwrap_or(0)
    }

    pub fn clear_discarded_frames(&mut self) {
        self.discarded_frames = ::std::option::Option::None;
    }

    pub fn has_discarded_frames(&self) -> bool {
        self.discarded_frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discarded_frames(&mut self, v: u32) {
        self.discarded_frames = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSource2VProfLiteReportItem>(
            "total",
            |m: &CMsgSource2VProfLiteReport| { &m.total },
            |m: &mut CMsgSource2VProfLiteReport| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMsgSource2VProfLiteReport| { &m.items },
            |m: &mut CMsgSource2VProfLiteReport| { &mut m.items },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "discarded_frames",
            |m: &CMsgSource2VProfLiteReport| { &m.discarded_frames },
            |m: &mut CMsgSource2VProfLiteReport| { &mut m.discarded_frames },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSource2VProfLiteReport>(
            "CMsgSource2VProfLiteReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSource2VProfLiteReport {
    const NAME: &'static str = "CMsgSource2VProfLiteReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total)?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                24 => {
                    self.discarded_frames = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.total.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.discarded_frames {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.total.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.discarded_frames {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource2VProfLiteReport {
        CMsgSource2VProfLiteReport::new()
    }

    fn clear(&mut self) {
        self.total.clear();
        self.items.clear();
        self.discarded_frames = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource2VProfLiteReport {
        static instance: CMsgSource2VProfLiteReport = CMsgSource2VProfLiteReport {
            total: ::protobuf::MessageField::none(),
            items: ::std::vec::Vec::new(),
            discarded_frames: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSource2VProfLiteReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSource2VProfLiteReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSource2VProfLiteReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSource2VProfLiteReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_Diagnostic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_Diagnostic {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_Diagnostic.system_specs)
    pub system_specs: ::protobuf::MessageField<CMsgSource2SystemSpecs>,
    // @@protoc_insertion_point(field:CCLCMsg_Diagnostic.vprof_report)
    pub vprof_report: ::protobuf::MessageField<CMsgSource2VProfLiteReport>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_Diagnostic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_Diagnostic {
    fn default() -> &'a CCLCMsg_Diagnostic {
        <CCLCMsg_Diagnostic as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_Diagnostic {
    pub fn new() -> CCLCMsg_Diagnostic {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSource2SystemSpecs>(
            "system_specs",
            |m: &CCLCMsg_Diagnostic| { &m.system_specs },
            |m: &mut CCLCMsg_Diagnostic| { &mut m.system_specs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSource2VProfLiteReport>(
            "vprof_report",
            |m: &CCLCMsg_Diagnostic| { &m.vprof_report },
            |m: &mut CCLCMsg_Diagnostic| { &mut m.vprof_report },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_Diagnostic>(
            "CCLCMsg_Diagnostic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_Diagnostic {
    const NAME: &'static str = "CCLCMsg_Diagnostic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.system_specs)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.vprof_report)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.system_specs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vprof_report.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.system_specs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.vprof_report.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_Diagnostic {
        CCLCMsg_Diagnostic::new()
    }

    fn clear(&mut self) {
        self.system_specs.clear();
        self.vprof_report.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_Diagnostic {
        static instance: CCLCMsg_Diagnostic = CCLCMsg_Diagnostic {
            system_specs: ::protobuf::MessageField::none(),
            vprof_report: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_Diagnostic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_Diagnostic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_Diagnostic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_Diagnostic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSource2Metrics_MatchPerfSummary_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSource2Metrics_MatchPerfSummary_Notification {
    // message fields
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.game_mode)
    pub game_mode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.server_build_id)
    pub server_build_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.server_profile)
    pub server_profile: ::protobuf::MessageField<CMsgSource2VProfLiteReport>,
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.clients)
    pub clients: ::std::vec::Vec<csource2metrics_match_perf_summary_notification::Client>,
    // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.map)
    pub map: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSource2Metrics_MatchPerfSummary_Notification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSource2Metrics_MatchPerfSummary_Notification {
    fn default() -> &'a CSource2Metrics_MatchPerfSummary_Notification {
        <CSource2Metrics_MatchPerfSummary_Notification as ::protobuf::Message>::default_instance()
    }
}

impl CSource2Metrics_MatchPerfSummary_Notification {
    pub fn new() -> CSource2Metrics_MatchPerfSummary_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string game_mode = 2;

    pub fn game_mode(&self) -> &str {
        match self.game_mode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: ::std::string::String) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mode(&mut self) -> &mut ::std::string::String {
        if self.game_mode.is_none() {
            self.game_mode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mode(&mut self) -> ::std::string::String {
        self.game_mode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 server_build_id = 3;

    pub fn server_build_id(&self) -> u32 {
        self.server_build_id.unwrap_or(0)
    }

    pub fn clear_server_build_id(&mut self) {
        self.server_build_id = ::std::option::Option::None;
    }

    pub fn has_server_build_id(&self) -> bool {
        self.server_build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_build_id(&mut self, v: u32) {
        self.server_build_id = ::std::option::Option::Some(v);
    }

    // optional string map = 20;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSource2Metrics_MatchPerfSummary_Notification| { &m.appid },
            |m: &mut CSource2Metrics_MatchPerfSummary_Notification| { &mut m.appid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mode",
            |m: &CSource2Metrics_MatchPerfSummary_Notification| { &m.game_mode },
            |m: &mut CSource2Metrics_MatchPerfSummary_Notification| { &mut m.game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_build_id",
            |m: &CSource2Metrics_MatchPerfSummary_Notification| { &m.server_build_id },
            |m: &mut CSource2Metrics_MatchPerfSummary_Notification| { &mut m.server_build_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSource2VProfLiteReport>(
            "server_profile",
            |m: &CSource2Metrics_MatchPerfSummary_Notification| { &m.server_profile },
            |m: &mut CSource2Metrics_MatchPerfSummary_Notification| { &mut m.server_profile },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "clients",
            |m: &CSource2Metrics_MatchPerfSummary_Notification| { &m.clients },
            |m: &mut CSource2Metrics_MatchPerfSummary_Notification| { &mut m.clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &CSource2Metrics_MatchPerfSummary_Notification| { &m.map },
            |m: &mut CSource2Metrics_MatchPerfSummary_Notification| { &mut m.map },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSource2Metrics_MatchPerfSummary_Notification>(
            "CSource2Metrics_MatchPerfSummary_Notification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSource2Metrics_MatchPerfSummary_Notification {
    const NAME: &'static str = "CSource2Metrics_MatchPerfSummary_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_mode = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.server_build_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_profile)?;
                },
                90 => {
                    self.clients.push(is.read_message()?);
                },
                162 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_mode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.server_build_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.server_profile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.clients {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_mode.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.server_build_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_profile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for v in &self.clients {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.map.as_ref() {
            os.write_string(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSource2Metrics_MatchPerfSummary_Notification {
        CSource2Metrics_MatchPerfSummary_Notification::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.server_build_id = ::std::option::Option::None;
        self.server_profile.clear();
        self.clients.clear();
        self.map = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSource2Metrics_MatchPerfSummary_Notification {
        static instance: CSource2Metrics_MatchPerfSummary_Notification = CSource2Metrics_MatchPerfSummary_Notification {
            appid: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            server_build_id: ::std::option::Option::None,
            server_profile: ::protobuf::MessageField::none(),
            clients: ::std::vec::Vec::new(),
            map: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSource2Metrics_MatchPerfSummary_Notification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSource2Metrics_MatchPerfSummary_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSource2Metrics_MatchPerfSummary_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSource2Metrics_MatchPerfSummary_Notification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSource2Metrics_MatchPerfSummary_Notification`
pub mod csource2metrics_match_perf_summary_notification {
    // @@protoc_insertion_point(message:CSource2Metrics_MatchPerfSummary_Notification.Client)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Client {
        // message fields
        // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.Client.system_specs)
        pub system_specs: ::protobuf::MessageField<super::CMsgSource2SystemSpecs>,
        // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.Client.profile)
        pub profile: ::protobuf::MessageField<super::CMsgSource2VProfLiteReport>,
        // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.Client.build_id)
        pub build_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSource2Metrics_MatchPerfSummary_Notification.Client.steamid)
        pub steamid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CSource2Metrics_MatchPerfSummary_Notification.Client.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Client {
        fn default() -> &'a Client {
            <Client as ::protobuf::Message>::default_instance()
        }
    }

    impl Client {
        pub fn new() -> Client {
            ::std::default::Default::default()
        }

        // optional uint32 build_id = 3;

        pub fn build_id(&self) -> u32 {
            self.build_id.unwrap_or(0)
        }

        pub fn clear_build_id(&mut self) {
            self.build_id = ::std::option::Option::None;
        }

        pub fn has_build_id(&self) -> bool {
            self.build_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_build_id(&mut self, v: u32) {
            self.build_id = ::std::option::Option::Some(v);
        }

        // optional fixed64 steamid = 10;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgSource2SystemSpecs>(
                "system_specs",
                |m: &Client| { &m.system_specs },
                |m: &mut Client| { &mut m.system_specs },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgSource2VProfLiteReport>(
                "profile",
                |m: &Client| { &m.profile },
                |m: &mut Client| { &mut m.profile },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "build_id",
                |m: &Client| { &m.build_id },
                |m: &mut Client| { &mut m.build_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &Client| { &m.steamid },
                |m: &mut Client| { &mut m.steamid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Client>(
                "CSource2Metrics_MatchPerfSummary_Notification.Client",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Client {
        const NAME: &'static str = "Client";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.system_specs)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.profile)?;
                    },
                    24 => {
                        self.build_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    81 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.system_specs.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.profile.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.build_id {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.system_specs.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.profile.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.build_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.steamid {
                os.write_fixed64(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Client {
            Client::new()
        }

        fn clear(&mut self) {
            self.system_specs.clear();
            self.profile.clear();
            self.build_id = ::std::option::Option::None;
            self.steamid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Client {
            static instance: Client = Client {
                system_specs: ::protobuf::MessageField::none(),
                profile: ::protobuf::MessageField::none(),
                build_id: ::std::option::Option::None,
                steamid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Client {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSource2Metrics_MatchPerfSummary_Notification.Client").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Client {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Client {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_ServerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ServerInfo {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.protocol)
    pub protocol: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.server_count)
    pub server_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_dedicated)
    pub is_dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_hltv)
    pub is_hltv: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.c_os)
    pub c_os: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.max_clients)
    pub max_clients: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.max_classes)
    pub max_classes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.tick_interval)
    pub tick_interval: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.game_dir)
    pub game_dir: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.sky_name)
    pub sky_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.host_name)
    pub host_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.addon_name)
    pub addon_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.game_session_config)
    pub game_session_config: ::protobuf::MessageField<super::networkbasetypes::CSVCMsg_GameSessionConfiguration>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.game_session_manifest)
    pub game_session_manifest: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ServerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ServerInfo {
    fn default() -> &'a CSVCMsg_ServerInfo {
        <CSVCMsg_ServerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ServerInfo {
    pub fn new() -> CSVCMsg_ServerInfo {
        ::std::default::Default::default()
    }

    // optional int32 protocol = 1;

    pub fn protocol(&self) -> i32 {
        self.protocol.unwrap_or(0)
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: i32) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // optional int32 server_count = 2;

    pub fn server_count(&self) -> i32 {
        self.server_count.unwrap_or(0)
    }

    pub fn clear_server_count(&mut self) {
        self.server_count = ::std::option::Option::None;
    }

    pub fn has_server_count(&self) -> bool {
        self.server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_count(&mut self, v: i32) {
        self.server_count = ::std::option::Option::Some(v);
    }

    // optional bool is_dedicated = 3;

    pub fn is_dedicated(&self) -> bool {
        self.is_dedicated.unwrap_or(false)
    }

    pub fn clear_is_dedicated(&mut self) {
        self.is_dedicated = ::std::option::Option::None;
    }

    pub fn has_is_dedicated(&self) -> bool {
        self.is_dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dedicated(&mut self, v: bool) {
        self.is_dedicated = ::std::option::Option::Some(v);
    }

    // optional bool is_hltv = 4;

    pub fn is_hltv(&self) -> bool {
        self.is_hltv.unwrap_or(false)
    }

    pub fn clear_is_hltv(&mut self) {
        self.is_hltv = ::std::option::Option::None;
    }

    pub fn has_is_hltv(&self) -> bool {
        self.is_hltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hltv(&mut self, v: bool) {
        self.is_hltv = ::std::option::Option::Some(v);
    }

    // optional int32 c_os = 6;

    pub fn c_os(&self) -> i32 {
        self.c_os.unwrap_or(0)
    }

    pub fn clear_c_os(&mut self) {
        self.c_os = ::std::option::Option::None;
    }

    pub fn has_c_os(&self) -> bool {
        self.c_os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c_os(&mut self, v: i32) {
        self.c_os = ::std::option::Option::Some(v);
    }

    // optional int32 max_clients = 10;

    pub fn max_clients(&self) -> i32 {
        self.max_clients.unwrap_or(0)
    }

    pub fn clear_max_clients(&mut self) {
        self.max_clients = ::std::option::Option::None;
    }

    pub fn has_max_clients(&self) -> bool {
        self.max_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_clients(&mut self, v: i32) {
        self.max_clients = ::std::option::Option::Some(v);
    }

    // optional int32 max_classes = 11;

    pub fn max_classes(&self) -> i32 {
        self.max_classes.unwrap_or(0)
    }

    pub fn clear_max_classes(&mut self) {
        self.max_classes = ::std::option::Option::None;
    }

    pub fn has_max_classes(&self) -> bool {
        self.max_classes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_classes(&mut self, v: i32) {
        self.max_classes = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot = 12;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional float tick_interval = 13;

    pub fn tick_interval(&self) -> f32 {
        self.tick_interval.unwrap_or(0.)
    }

    pub fn clear_tick_interval(&mut self) {
        self.tick_interval = ::std::option::Option::None;
    }

    pub fn has_tick_interval(&self) -> bool {
        self.tick_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_interval(&mut self, v: f32) {
        self.tick_interval = ::std::option::Option::Some(v);
    }

    // optional string game_dir = 14;

    pub fn game_dir(&self) -> &str {
        match self.game_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_dir(&mut self) {
        self.game_dir = ::std::option::Option::None;
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: ::std::string::String) {
        self.game_dir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir(&mut self) -> &mut ::std::string::String {
        if self.game_dir.is_none() {
            self.game_dir = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_dir(&mut self) -> ::std::string::String {
        self.game_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map_name = 15;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string sky_name = 16;

    pub fn sky_name(&self) -> &str {
        match self.sky_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sky_name(&mut self) {
        self.sky_name = ::std::option::Option::None;
    }

    pub fn has_sky_name(&self) -> bool {
        self.sky_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sky_name(&mut self, v: ::std::string::String) {
        self.sky_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sky_name(&mut self) -> &mut ::std::string::String {
        if self.sky_name.is_none() {
            self.sky_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sky_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sky_name(&mut self) -> ::std::string::String {
        self.sky_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host_name = 17;

    pub fn host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host_name(&mut self) {
        self.host_name = ::std::option::Option::None;
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.host_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if self.host_name.is_none() {
            self.host_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        self.host_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string addon_name = 18;

    pub fn addon_name(&self) -> &str {
        match self.addon_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_addon_name(&mut self) {
        self.addon_name = ::std::option::Option::None;
    }

    pub fn has_addon_name(&self) -> bool {
        self.addon_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addon_name(&mut self, v: ::std::string::String) {
        self.addon_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addon_name(&mut self) -> &mut ::std::string::String {
        if self.addon_name.is_none() {
            self.addon_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.addon_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_addon_name(&mut self) -> ::std::string::String {
        self.addon_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes game_session_manifest = 20;

    pub fn game_session_manifest(&self) -> &[u8] {
        match self.game_session_manifest.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_session_manifest(&mut self) {
        self.game_session_manifest = ::std::option::Option::None;
    }

    pub fn has_game_session_manifest(&self) -> bool {
        self.game_session_manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_session_manifest(&mut self, v: ::bytes::Bytes) {
        self.game_session_manifest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_session_manifest(&mut self) -> &mut ::bytes::Bytes {
        if self.game_session_manifest.is_none() {
            self.game_session_manifest = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.game_session_manifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_session_manifest(&mut self) -> ::bytes::Bytes {
        self.game_session_manifest.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &CSVCMsg_ServerInfo| { &m.protocol },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_count",
            |m: &CSVCMsg_ServerInfo| { &m.server_count },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.server_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_dedicated",
            |m: &CSVCMsg_ServerInfo| { &m.is_dedicated },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.is_dedicated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hltv",
            |m: &CSVCMsg_ServerInfo| { &m.is_hltv },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.is_hltv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "c_os",
            |m: &CSVCMsg_ServerInfo| { &m.c_os },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.c_os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_clients",
            |m: &CSVCMsg_ServerInfo| { &m.max_clients },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.max_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_classes",
            |m: &CSVCMsg_ServerInfo| { &m.max_classes },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.max_classes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &CSVCMsg_ServerInfo| { &m.player_slot },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick_interval",
            |m: &CSVCMsg_ServerInfo| { &m.tick_interval },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.tick_interval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_dir",
            |m: &CSVCMsg_ServerInfo| { &m.game_dir },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.game_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &CSVCMsg_ServerInfo| { &m.map_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sky_name",
            |m: &CSVCMsg_ServerInfo| { &m.sky_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.sky_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_name",
            |m: &CSVCMsg_ServerInfo| { &m.host_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.host_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "addon_name",
            |m: &CSVCMsg_ServerInfo| { &m.addon_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.addon_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CSVCMsg_GameSessionConfiguration>(
            "game_session_config",
            |m: &CSVCMsg_ServerInfo| { &m.game_session_config },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.game_session_config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_session_manifest",
            |m: &CSVCMsg_ServerInfo| { &m.game_session_manifest },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.game_session_manifest },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_ServerInfo>(
            "CSVCMsg_ServerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_ServerInfo {
    const NAME: &'static str = "CSVCMsg_ServerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.server_count = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.is_dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_hltv = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.c_os = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.max_clients = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.max_classes = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                109 => {
                    self.tick_interval = ::std::option::Option::Some(is.read_float()?);
                },
                114 => {
                    self.game_dir = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.sky_name = ::std::option::Option::Some(is.read_string()?);
                },
                138 => {
                    self.host_name = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.addon_name = ::std::option::Option::Some(is.read_string()?);
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_session_config)?;
                },
                162 => {
                    self.game_session_manifest = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.server_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.is_dedicated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_hltv {
            my_size += 1 + 1;
        }
        if let Some(v) = self.c_os {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.max_clients {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.max_classes {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.tick_interval {
            my_size += 1 + 4;
        }
        if let Some(v) = self.game_dir.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.sky_name.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.host_name.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.addon_name.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.game_session_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_session_manifest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.server_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.is_dedicated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_hltv {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.c_os {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.max_clients {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.max_classes {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.tick_interval {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.game_dir.as_ref() {
            os.write_string(14, v)?;
        }
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.sky_name.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.host_name.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.addon_name.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.game_session_config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.game_session_manifest.as_ref() {
            os.write_bytes(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ServerInfo {
        CSVCMsg_ServerInfo::new()
    }

    fn clear(&mut self) {
        self.protocol = ::std::option::Option::None;
        self.server_count = ::std::option::Option::None;
        self.is_dedicated = ::std::option::Option::None;
        self.is_hltv = ::std::option::Option::None;
        self.c_os = ::std::option::Option::None;
        self.max_clients = ::std::option::Option::None;
        self.max_classes = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.tick_interval = ::std::option::Option::None;
        self.game_dir = ::std::option::Option::None;
        self.map_name = ::std::option::Option::None;
        self.sky_name = ::std::option::Option::None;
        self.host_name = ::std::option::Option::None;
        self.addon_name = ::std::option::Option::None;
        self.game_session_config.clear();
        self.game_session_manifest = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ServerInfo {
        static instance: CSVCMsg_ServerInfo = CSVCMsg_ServerInfo {
            protocol: ::std::option::Option::None,
            server_count: ::std::option::Option::None,
            is_dedicated: ::std::option::Option::None,
            is_hltv: ::std::option::Option::None,
            c_os: ::std::option::Option::None,
            max_clients: ::std::option::Option::None,
            max_classes: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            tick_interval: ::std::option::Option::None,
            game_dir: ::std::option::Option::None,
            map_name: ::std::option::Option::None,
            sky_name: ::std::option::Option::None,
            host_name: ::std::option::Option::None,
            addon_name: ::std::option::Option::None,
            game_session_config: ::protobuf::MessageField::none(),
            game_session_manifest: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_ServerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_ServerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_ServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_ServerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_ClassInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ClassInfo {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.create_on_client)
    pub create_on_client: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.classes)
    pub classes: ::std::vec::Vec<csvcmsg_class_info::Class_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ClassInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ClassInfo {
    fn default() -> &'a CSVCMsg_ClassInfo {
        <CSVCMsg_ClassInfo as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ClassInfo {
    pub fn new() -> CSVCMsg_ClassInfo {
        ::std::default::Default::default()
    }

    // optional bool create_on_client = 1;

    pub fn create_on_client(&self) -> bool {
        self.create_on_client.unwrap_or(false)
    }

    pub fn clear_create_on_client(&mut self) {
        self.create_on_client = ::std::option::Option::None;
    }

    pub fn has_create_on_client(&self) -> bool {
        self.create_on_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_on_client(&mut self, v: bool) {
        self.create_on_client = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "create_on_client",
            |m: &CSVCMsg_ClassInfo| { &m.create_on_client },
            |m: &mut CSVCMsg_ClassInfo| { &mut m.create_on_client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "classes",
            |m: &CSVCMsg_ClassInfo| { &m.classes },
            |m: &mut CSVCMsg_ClassInfo| { &mut m.classes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_ClassInfo>(
            "CSVCMsg_ClassInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_ClassInfo {
    const NAME: &'static str = "CSVCMsg_ClassInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.create_on_client = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.classes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.create_on_client {
            my_size += 1 + 1;
        }
        for value in &self.classes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.create_on_client {
            os.write_bool(1, v)?;
        }
        for v in &self.classes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ClassInfo {
        CSVCMsg_ClassInfo::new()
    }

    fn clear(&mut self) {
        self.create_on_client = ::std::option::Option::None;
        self.classes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ClassInfo {
        static instance: CSVCMsg_ClassInfo = CSVCMsg_ClassInfo {
            create_on_client: ::std::option::Option::None,
            classes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_ClassInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_ClassInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_ClassInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_ClassInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_ClassInfo`
pub mod csvcmsg_class_info {
    // @@protoc_insertion_point(message:CSVCMsg_ClassInfo.class_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Class_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.class_t.class_id)
        pub class_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.class_t.class_name)
        pub class_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_ClassInfo.class_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Class_t {
        fn default() -> &'a Class_t {
            <Class_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Class_t {
        pub fn new() -> Class_t {
            ::std::default::Default::default()
        }

        // optional int32 class_id = 1;

        pub fn class_id(&self) -> i32 {
            self.class_id.unwrap_or(0)
        }

        pub fn clear_class_id(&mut self) {
            self.class_id = ::std::option::Option::None;
        }

        pub fn has_class_id(&self) -> bool {
            self.class_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_id(&mut self, v: i32) {
            self.class_id = ::std::option::Option::Some(v);
        }

        // optional string class_name = 3;

        pub fn class_name(&self) -> &str {
            match self.class_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_class_name(&mut self) {
            self.class_name = ::std::option::Option::None;
        }

        pub fn has_class_name(&self) -> bool {
            self.class_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_name(&mut self, v: ::std::string::String) {
            self.class_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_class_name(&mut self) -> &mut ::std::string::String {
            if self.class_name.is_none() {
                self.class_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.class_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_class_name(&mut self) -> ::std::string::String {
            self.class_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "class_id",
                |m: &Class_t| { &m.class_id },
                |m: &mut Class_t| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "class_name",
                |m: &Class_t| { &m.class_name },
                |m: &mut Class_t| { &mut m.class_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Class_t>(
                "CSVCMsg_ClassInfo.class_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Class_t {
        const NAME: &'static str = "class_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.class_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.class_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.class_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.class_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.class_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.class_name.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Class_t {
            Class_t::new()
        }

        fn clear(&mut self) {
            self.class_id = ::std::option::Option::None;
            self.class_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Class_t {
            static instance: Class_t = Class_t {
                class_id: ::std::option::Option::None,
                class_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Class_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_ClassInfo.class_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Class_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Class_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_SetPause)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SetPause {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SetPause.paused)
    pub paused: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SetPause.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SetPause {
    fn default() -> &'a CSVCMsg_SetPause {
        <CSVCMsg_SetPause as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SetPause {
    pub fn new() -> CSVCMsg_SetPause {
        ::std::default::Default::default()
    }

    // optional bool paused = 1;

    pub fn paused(&self) -> bool {
        self.paused.unwrap_or(false)
    }

    pub fn clear_paused(&mut self) {
        self.paused = ::std::option::Option::None;
    }

    pub fn has_paused(&self) -> bool {
        self.paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paused(&mut self, v: bool) {
        self.paused = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paused",
            |m: &CSVCMsg_SetPause| { &m.paused },
            |m: &mut CSVCMsg_SetPause| { &mut m.paused },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SetPause>(
            "CSVCMsg_SetPause",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SetPause {
    const NAME: &'static str = "CSVCMsg_SetPause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.paused = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.paused {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.paused {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SetPause {
        CSVCMsg_SetPause::new()
    }

    fn clear(&mut self) {
        self.paused = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SetPause {
        static instance: CSVCMsg_SetPause = CSVCMsg_SetPause {
            paused: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SetPause {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SetPause").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SetPause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SetPause {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_VoiceInit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_VoiceInit {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.quality)
    pub quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.codec)
    pub codec: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.version)
    pub version: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_VoiceInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_VoiceInit {
    fn default() -> &'a CSVCMsg_VoiceInit {
        <CSVCMsg_VoiceInit as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_VoiceInit {
    pub fn new() -> CSVCMsg_VoiceInit {
        ::std::default::Default::default()
    }

    // optional int32 quality = 1;

    pub fn quality(&self) -> i32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional string codec = 2;

    pub fn codec(&self) -> &str {
        match self.codec.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: ::std::string::String) {
        self.codec = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec(&mut self) -> &mut ::std::string::String {
        if self.codec.is_none() {
            self.codec = ::std::option::Option::Some(::std::string::String::new());
        }
        self.codec.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec(&mut self) -> ::std::string::String {
        self.codec.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 version = 3;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0i32)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CSVCMsg_VoiceInit| { &m.quality },
            |m: &mut CSVCMsg_VoiceInit| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "codec",
            |m: &CSVCMsg_VoiceInit| { &m.codec },
            |m: &mut CSVCMsg_VoiceInit| { &mut m.codec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CSVCMsg_VoiceInit| { &m.version },
            |m: &mut CSVCMsg_VoiceInit| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_VoiceInit>(
            "CSVCMsg_VoiceInit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_VoiceInit {
    const NAME: &'static str = "CSVCMsg_VoiceInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quality = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.codec = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.codec.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.codec.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_VoiceInit {
        CSVCMsg_VoiceInit::new()
    }

    fn clear(&mut self) {
        self.quality = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_VoiceInit {
        static instance: CSVCMsg_VoiceInit = CSVCMsg_VoiceInit {
            quality: ::std::option::Option::None,
            codec: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_VoiceInit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_VoiceInit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_VoiceInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_VoiceInit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_Print)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Print {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Print.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Print.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Print {
    fn default() -> &'a CSVCMsg_Print {
        <CSVCMsg_Print as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Print {
    pub fn new() -> CSVCMsg_Print {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CSVCMsg_Print| { &m.text },
            |m: &mut CSVCMsg_Print| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Print>(
            "CSVCMsg_Print",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Print {
    const NAME: &'static str = "CSVCMsg_Print";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Print {
        CSVCMsg_Print::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Print {
        static instance: CSVCMsg_Print = CSVCMsg_Print {
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Print {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Print").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Print {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Print {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_Sounds)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Sounds {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Sounds.reliable_sound)
    pub reliable_sound: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounds)
    pub sounds: ::std::vec::Vec<csvcmsg_sounds::Sounddata_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Sounds.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Sounds {
    fn default() -> &'a CSVCMsg_Sounds {
        <CSVCMsg_Sounds as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Sounds {
    pub fn new() -> CSVCMsg_Sounds {
        ::std::default::Default::default()
    }

    // optional bool reliable_sound = 1;

    pub fn reliable_sound(&self) -> bool {
        self.reliable_sound.unwrap_or(false)
    }

    pub fn clear_reliable_sound(&mut self) {
        self.reliable_sound = ::std::option::Option::None;
    }

    pub fn has_reliable_sound(&self) -> bool {
        self.reliable_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_sound(&mut self, v: bool) {
        self.reliable_sound = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reliable_sound",
            |m: &CSVCMsg_Sounds| { &m.reliable_sound },
            |m: &mut CSVCMsg_Sounds| { &mut m.reliable_sound },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sounds",
            |m: &CSVCMsg_Sounds| { &m.sounds },
            |m: &mut CSVCMsg_Sounds| { &mut m.sounds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Sounds>(
            "CSVCMsg_Sounds",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Sounds {
    const NAME: &'static str = "CSVCMsg_Sounds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable_sound = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.sounds.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_sound {
            my_size += 1 + 1;
        }
        for value in &self.sounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reliable_sound {
            os.write_bool(1, v)?;
        }
        for v in &self.sounds {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Sounds {
        CSVCMsg_Sounds::new()
    }

    fn clear(&mut self) {
        self.reliable_sound = ::std::option::Option::None;
        self.sounds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Sounds {
        static instance: CSVCMsg_Sounds = CSVCMsg_Sounds {
            reliable_sound: ::std::option::Option::None,
            sounds: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Sounds {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Sounds").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Sounds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Sounds {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_Sounds`
pub mod csvcmsg_sounds {
    // @@protoc_insertion_point(message:CSVCMsg_Sounds.sounddata_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sounddata_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_x)
        pub origin_x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_y)
        pub origin_y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_z)
        pub origin_z: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.volume)
        pub volume: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.delay_value)
        pub delay_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sequence_number)
        pub sequence_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.entity_index)
        pub entity_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.channel)
        pub channel: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.pitch)
        pub pitch: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.flags)
        pub flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_num)
        pub sound_num: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_num_handle)
        pub sound_num_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.speaker_entity)
        pub speaker_entity: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.random_seed)
        pub random_seed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_level)
        pub sound_level: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.is_sentence)
        pub is_sentence: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.is_ambient)
        pub is_ambient: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.guid)
        pub guid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_resource_id)
        pub sound_resource_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_Sounds.sounddata_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sounddata_t {
        fn default() -> &'a Sounddata_t {
            <Sounddata_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Sounddata_t {
        pub fn new() -> Sounddata_t {
            ::std::default::Default::default()
        }

        // optional sint32 origin_x = 1;

        pub fn origin_x(&self) -> i32 {
            self.origin_x.unwrap_or(0)
        }

        pub fn clear_origin_x(&mut self) {
            self.origin_x = ::std::option::Option::None;
        }

        pub fn has_origin_x(&self) -> bool {
            self.origin_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_x(&mut self, v: i32) {
            self.origin_x = ::std::option::Option::Some(v);
        }

        // optional sint32 origin_y = 2;

        pub fn origin_y(&self) -> i32 {
            self.origin_y.unwrap_or(0)
        }

        pub fn clear_origin_y(&mut self) {
            self.origin_y = ::std::option::Option::None;
        }

        pub fn has_origin_y(&self) -> bool {
            self.origin_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_y(&mut self, v: i32) {
            self.origin_y = ::std::option::Option::Some(v);
        }

        // optional sint32 origin_z = 3;

        pub fn origin_z(&self) -> i32 {
            self.origin_z.unwrap_or(0)
        }

        pub fn clear_origin_z(&mut self) {
            self.origin_z = ::std::option::Option::None;
        }

        pub fn has_origin_z(&self) -> bool {
            self.origin_z.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_z(&mut self, v: i32) {
            self.origin_z = ::std::option::Option::Some(v);
        }

        // optional uint32 volume = 4;

        pub fn volume(&self) -> u32 {
            self.volume.unwrap_or(0)
        }

        pub fn clear_volume(&mut self) {
            self.volume = ::std::option::Option::None;
        }

        pub fn has_volume(&self) -> bool {
            self.volume.is_some()
        }

        // Param is passed by value, moved
        pub fn set_volume(&mut self, v: u32) {
            self.volume = ::std::option::Option::Some(v);
        }

        // optional float delay_value = 5;

        pub fn delay_value(&self) -> f32 {
            self.delay_value.unwrap_or(0.)
        }

        pub fn clear_delay_value(&mut self) {
            self.delay_value = ::std::option::Option::None;
        }

        pub fn has_delay_value(&self) -> bool {
            self.delay_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delay_value(&mut self, v: f32) {
            self.delay_value = ::std::option::Option::Some(v);
        }

        // optional int32 sequence_number = 6;

        pub fn sequence_number(&self) -> i32 {
            self.sequence_number.unwrap_or(0)
        }

        pub fn clear_sequence_number(&mut self) {
            self.sequence_number = ::std::option::Option::None;
        }

        pub fn has_sequence_number(&self) -> bool {
            self.sequence_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sequence_number(&mut self, v: i32) {
            self.sequence_number = ::std::option::Option::Some(v);
        }

        // optional int32 entity_index = 7;

        pub fn entity_index(&self) -> i32 {
            self.entity_index.unwrap_or(-1i32)
        }

        pub fn clear_entity_index(&mut self) {
            self.entity_index = ::std::option::Option::None;
        }

        pub fn has_entity_index(&self) -> bool {
            self.entity_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_index(&mut self, v: i32) {
            self.entity_index = ::std::option::Option::Some(v);
        }

        // optional int32 channel = 8;

        pub fn channel(&self) -> i32 {
            self.channel.unwrap_or(0)
        }

        pub fn clear_channel(&mut self) {
            self.channel = ::std::option::Option::None;
        }

        pub fn has_channel(&self) -> bool {
            self.channel.is_some()
        }

        // Param is passed by value, moved
        pub fn set_channel(&mut self, v: i32) {
            self.channel = ::std::option::Option::Some(v);
        }

        // optional int32 pitch = 9;

        pub fn pitch(&self) -> i32 {
            self.pitch.unwrap_or(0)
        }

        pub fn clear_pitch(&mut self) {
            self.pitch = ::std::option::Option::None;
        }

        pub fn has_pitch(&self) -> bool {
            self.pitch.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pitch(&mut self, v: i32) {
            self.pitch = ::std::option::Option::Some(v);
        }

        // optional int32 flags = 10;

        pub fn flags(&self) -> i32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: i32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 sound_num = 11;

        pub fn sound_num(&self) -> u32 {
            self.sound_num.unwrap_or(0)
        }

        pub fn clear_sound_num(&mut self) {
            self.sound_num = ::std::option::Option::None;
        }

        pub fn has_sound_num(&self) -> bool {
            self.sound_num.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_num(&mut self, v: u32) {
            self.sound_num = ::std::option::Option::Some(v);
        }

        // optional fixed32 sound_num_handle = 12;

        pub fn sound_num_handle(&self) -> u32 {
            self.sound_num_handle.unwrap_or(0)
        }

        pub fn clear_sound_num_handle(&mut self) {
            self.sound_num_handle = ::std::option::Option::None;
        }

        pub fn has_sound_num_handle(&self) -> bool {
            self.sound_num_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_num_handle(&mut self, v: u32) {
            self.sound_num_handle = ::std::option::Option::Some(v);
        }

        // optional int32 speaker_entity = 13;

        pub fn speaker_entity(&self) -> i32 {
            self.speaker_entity.unwrap_or(0)
        }

        pub fn clear_speaker_entity(&mut self) {
            self.speaker_entity = ::std::option::Option::None;
        }

        pub fn has_speaker_entity(&self) -> bool {
            self.speaker_entity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_speaker_entity(&mut self, v: i32) {
            self.speaker_entity = ::std::option::Option::Some(v);
        }

        // optional int32 random_seed = 14;

        pub fn random_seed(&self) -> i32 {
            self.random_seed.unwrap_or(0)
        }

        pub fn clear_random_seed(&mut self) {
            self.random_seed = ::std::option::Option::None;
        }

        pub fn has_random_seed(&self) -> bool {
            self.random_seed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_random_seed(&mut self, v: i32) {
            self.random_seed = ::std::option::Option::Some(v);
        }

        // optional int32 sound_level = 15;

        pub fn sound_level(&self) -> i32 {
            self.sound_level.unwrap_or(0)
        }

        pub fn clear_sound_level(&mut self) {
            self.sound_level = ::std::option::Option::None;
        }

        pub fn has_sound_level(&self) -> bool {
            self.sound_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_level(&mut self, v: i32) {
            self.sound_level = ::std::option::Option::Some(v);
        }

        // optional bool is_sentence = 16;

        pub fn is_sentence(&self) -> bool {
            self.is_sentence.unwrap_or(false)
        }

        pub fn clear_is_sentence(&mut self) {
            self.is_sentence = ::std::option::Option::None;
        }

        pub fn has_is_sentence(&self) -> bool {
            self.is_sentence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_sentence(&mut self, v: bool) {
            self.is_sentence = ::std::option::Option::Some(v);
        }

        // optional bool is_ambient = 17;

        pub fn is_ambient(&self) -> bool {
            self.is_ambient.unwrap_or(false)
        }

        pub fn clear_is_ambient(&mut self) {
            self.is_ambient = ::std::option::Option::None;
        }

        pub fn has_is_ambient(&self) -> bool {
            self.is_ambient.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_ambient(&mut self, v: bool) {
            self.is_ambient = ::std::option::Option::Some(v);
        }

        // optional uint32 guid = 18;

        pub fn guid(&self) -> u32 {
            self.guid.unwrap_or(0)
        }

        pub fn clear_guid(&mut self) {
            self.guid = ::std::option::Option::None;
        }

        pub fn has_guid(&self) -> bool {
            self.guid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guid(&mut self, v: u32) {
            self.guid = ::std::option::Option::Some(v);
        }

        // optional fixed64 sound_resource_id = 19;

        pub fn sound_resource_id(&self) -> u64 {
            self.sound_resource_id.unwrap_or(0)
        }

        pub fn clear_sound_resource_id(&mut self) {
            self.sound_resource_id = ::std::option::Option::None;
        }

        pub fn has_sound_resource_id(&self) -> bool {
            self.sound_resource_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_resource_id(&mut self, v: u64) {
            self.sound_resource_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(19);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_x",
                |m: &Sounddata_t| { &m.origin_x },
                |m: &mut Sounddata_t| { &mut m.origin_x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_y",
                |m: &Sounddata_t| { &m.origin_y },
                |m: &mut Sounddata_t| { &mut m.origin_y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_z",
                |m: &Sounddata_t| { &m.origin_z },
                |m: &mut Sounddata_t| { &mut m.origin_z },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "volume",
                |m: &Sounddata_t| { &m.volume },
                |m: &mut Sounddata_t| { &mut m.volume },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "delay_value",
                |m: &Sounddata_t| { &m.delay_value },
                |m: &mut Sounddata_t| { &mut m.delay_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sequence_number",
                |m: &Sounddata_t| { &m.sequence_number },
                |m: &mut Sounddata_t| { &mut m.sequence_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_index",
                |m: &Sounddata_t| { &m.entity_index },
                |m: &mut Sounddata_t| { &mut m.entity_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "channel",
                |m: &Sounddata_t| { &m.channel },
                |m: &mut Sounddata_t| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pitch",
                |m: &Sounddata_t| { &m.pitch },
                |m: &mut Sounddata_t| { &mut m.pitch },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &Sounddata_t| { &m.flags },
                |m: &mut Sounddata_t| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_num",
                |m: &Sounddata_t| { &m.sound_num },
                |m: &mut Sounddata_t| { &mut m.sound_num },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_num_handle",
                |m: &Sounddata_t| { &m.sound_num_handle },
                |m: &mut Sounddata_t| { &mut m.sound_num_handle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "speaker_entity",
                |m: &Sounddata_t| { &m.speaker_entity },
                |m: &mut Sounddata_t| { &mut m.speaker_entity },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "random_seed",
                |m: &Sounddata_t| { &m.random_seed },
                |m: &mut Sounddata_t| { &mut m.random_seed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_level",
                |m: &Sounddata_t| { &m.sound_level },
                |m: &mut Sounddata_t| { &mut m.sound_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_sentence",
                |m: &Sounddata_t| { &m.is_sentence },
                |m: &mut Sounddata_t| { &mut m.is_sentence },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_ambient",
                |m: &Sounddata_t| { &m.is_ambient },
                |m: &mut Sounddata_t| { &mut m.is_ambient },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "guid",
                |m: &Sounddata_t| { &m.guid },
                |m: &mut Sounddata_t| { &mut m.guid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_resource_id",
                |m: &Sounddata_t| { &m.sound_resource_id },
                |m: &mut Sounddata_t| { &mut m.sound_resource_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sounddata_t>(
                "CSVCMsg_Sounds.sounddata_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sounddata_t {
        const NAME: &'static str = "sounddata_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.origin_x = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    16 => {
                        self.origin_y = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    24 => {
                        self.origin_z = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    32 => {
                        self.volume = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    45 => {
                        self.delay_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.sequence_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.channel = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.pitch = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.sound_num = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    101 => {
                        self.sound_num_handle = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    104 => {
                        self.speaker_entity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.random_seed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.sound_level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    128 => {
                        self.is_sentence = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.is_ambient = ::std::option::Option::Some(is.read_bool()?);
                    },
                    144 => {
                        self.guid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    153 => {
                        self.sound_resource_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.origin_x {
                my_size += ::protobuf::rt::sint32_size(1, v);
            }
            if let Some(v) = self.origin_y {
                my_size += ::protobuf::rt::sint32_size(2, v);
            }
            if let Some(v) = self.origin_z {
                my_size += ::protobuf::rt::sint32_size(3, v);
            }
            if let Some(v) = self.volume {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.delay_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.sequence_number {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.entity_index {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.channel {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.pitch {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.sound_num {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.sound_num_handle {
                my_size += 1 + 4;
            }
            if let Some(v) = self.speaker_entity {
                my_size += ::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.random_seed {
                my_size += ::protobuf::rt::int32_size(14, v);
            }
            if let Some(v) = self.sound_level {
                my_size += ::protobuf::rt::int32_size(15, v);
            }
            if let Some(v) = self.is_sentence {
                my_size += 2 + 1;
            }
            if let Some(v) = self.is_ambient {
                my_size += 2 + 1;
            }
            if let Some(v) = self.guid {
                my_size += ::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.sound_resource_id {
                my_size += 2 + 8;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.origin_x {
                os.write_sint32(1, v)?;
            }
            if let Some(v) = self.origin_y {
                os.write_sint32(2, v)?;
            }
            if let Some(v) = self.origin_z {
                os.write_sint32(3, v)?;
            }
            if let Some(v) = self.volume {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.delay_value {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.sequence_number {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.entity_index {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.channel {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.pitch {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.flags {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.sound_num {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.sound_num_handle {
                os.write_fixed32(12, v)?;
            }
            if let Some(v) = self.speaker_entity {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.random_seed {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.sound_level {
                os.write_int32(15, v)?;
            }
            if let Some(v) = self.is_sentence {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.is_ambient {
                os.write_bool(17, v)?;
            }
            if let Some(v) = self.guid {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.sound_resource_id {
                os.write_fixed64(19, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sounddata_t {
            Sounddata_t::new()
        }

        fn clear(&mut self) {
            self.origin_x = ::std::option::Option::None;
            self.origin_y = ::std::option::Option::None;
            self.origin_z = ::std::option::Option::None;
            self.volume = ::std::option::Option::None;
            self.delay_value = ::std::option::Option::None;
            self.sequence_number = ::std::option::Option::None;
            self.entity_index = ::std::option::Option::None;
            self.channel = ::std::option::Option::None;
            self.pitch = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.sound_num = ::std::option::Option::None;
            self.sound_num_handle = ::std::option::Option::None;
            self.speaker_entity = ::std::option::Option::None;
            self.random_seed = ::std::option::Option::None;
            self.sound_level = ::std::option::Option::None;
            self.is_sentence = ::std::option::Option::None;
            self.is_ambient = ::std::option::Option::None;
            self.guid = ::std::option::Option::None;
            self.sound_resource_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sounddata_t {
            static instance: Sounddata_t = Sounddata_t {
                origin_x: ::std::option::Option::None,
                origin_y: ::std::option::Option::None,
                origin_z: ::std::option::Option::None,
                volume: ::std::option::Option::None,
                delay_value: ::std::option::Option::None,
                sequence_number: ::std::option::Option::None,
                entity_index: ::std::option::Option::None,
                channel: ::std::option::Option::None,
                pitch: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                sound_num: ::std::option::Option::None,
                sound_num_handle: ::std::option::Option::None,
                speaker_entity: ::std::option::Option::None,
                random_seed: ::std::option::Option::None,
                sound_level: ::std::option::Option::None,
                is_sentence: ::std::option::Option::None,
                is_ambient: ::std::option::Option::None,
                guid: ::std::option::Option::None,
                sound_resource_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sounddata_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_Sounds.sounddata_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sounddata_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sounddata_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_Prefetch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Prefetch {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Prefetch.sound_index)
    pub sound_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_Prefetch.resource_type)
    pub resource_type: ::std::option::Option<::protobuf::EnumOrUnknown<PrefetchType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Prefetch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Prefetch {
    fn default() -> &'a CSVCMsg_Prefetch {
        <CSVCMsg_Prefetch as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Prefetch {
    pub fn new() -> CSVCMsg_Prefetch {
        ::std::default::Default::default()
    }

    // optional int32 sound_index = 1;

    pub fn sound_index(&self) -> i32 {
        self.sound_index.unwrap_or(0)
    }

    pub fn clear_sound_index(&mut self) {
        self.sound_index = ::std::option::Option::None;
    }

    pub fn has_sound_index(&self) -> bool {
        self.sound_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound_index(&mut self, v: i32) {
        self.sound_index = ::std::option::Option::Some(v);
    }

    // optional .PrefetchType resource_type = 2;

    pub fn resource_type(&self) -> PrefetchType {
        match self.resource_type {
            Some(e) => e.enum_value_or(PrefetchType::PFT_SOUND),
            None => PrefetchType::PFT_SOUND,
        }
    }

    pub fn clear_resource_type(&mut self) {
        self.resource_type = ::std::option::Option::None;
    }

    pub fn has_resource_type(&self) -> bool {
        self.resource_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource_type(&mut self, v: PrefetchType) {
        self.resource_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sound_index",
            |m: &CSVCMsg_Prefetch| { &m.sound_index },
            |m: &mut CSVCMsg_Prefetch| { &mut m.sound_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "resource_type",
            |m: &CSVCMsg_Prefetch| { &m.resource_type },
            |m: &mut CSVCMsg_Prefetch| { &mut m.resource_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Prefetch>(
            "CSVCMsg_Prefetch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Prefetch {
    const NAME: &'static str = "CSVCMsg_Prefetch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sound_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.resource_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sound_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.resource_type {
            my_size += ::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sound_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.resource_type {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Prefetch {
        CSVCMsg_Prefetch::new()
    }

    fn clear(&mut self) {
        self.sound_index = ::std::option::Option::None;
        self.resource_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Prefetch {
        static instance: CSVCMsg_Prefetch = CSVCMsg_Prefetch {
            sound_index: ::std::option::Option::None,
            resource_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Prefetch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Prefetch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Prefetch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Prefetch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_SetView)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SetView {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SetView.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_SetView.slot)
    pub slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SetView.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SetView {
    fn default() -> &'a CSVCMsg_SetView {
        <CSVCMsg_SetView as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SetView {
    pub fn new() -> CSVCMsg_SetView {
        ::std::default::Default::default()
    }

    // optional int32 entity_index = 1;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(-1i32)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional int32 slot = 2;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(-1i32)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_index",
            |m: &CSVCMsg_SetView| { &m.entity_index },
            |m: &mut CSVCMsg_SetView| { &mut m.entity_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CSVCMsg_SetView| { &m.slot },
            |m: &mut CSVCMsg_SetView| { &mut m.slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SetView>(
            "CSVCMsg_SetView",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SetView {
    const NAME: &'static str = "CSVCMsg_SetView";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slot {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SetView {
        CSVCMsg_SetView::new()
    }

    fn clear(&mut self) {
        self.entity_index = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SetView {
        static instance: CSVCMsg_SetView = CSVCMsg_SetView {
            entity_index: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SetView {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SetView").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SetView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SetView {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_FixAngle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_FixAngle {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_FixAngle.relative)
    pub relative: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_FixAngle.angle)
    pub angle: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_FixAngle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_FixAngle {
    fn default() -> &'a CSVCMsg_FixAngle {
        <CSVCMsg_FixAngle as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_FixAngle {
    pub fn new() -> CSVCMsg_FixAngle {
        ::std::default::Default::default()
    }

    // optional bool relative = 1;

    pub fn relative(&self) -> bool {
        self.relative.unwrap_or(false)
    }

    pub fn clear_relative(&mut self) {
        self.relative = ::std::option::Option::None;
    }

    pub fn has_relative(&self) -> bool {
        self.relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relative(&mut self, v: bool) {
        self.relative = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relative",
            |m: &CSVCMsg_FixAngle| { &m.relative },
            |m: &mut CSVCMsg_FixAngle| { &mut m.relative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "angle",
            |m: &CSVCMsg_FixAngle| { &m.angle },
            |m: &mut CSVCMsg_FixAngle| { &mut m.angle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_FixAngle>(
            "CSVCMsg_FixAngle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_FixAngle {
    const NAME: &'static str = "CSVCMsg_FixAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.relative = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.relative {
            my_size += 1 + 1;
        }
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.relative {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.angle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_FixAngle {
        CSVCMsg_FixAngle::new()
    }

    fn clear(&mut self) {
        self.relative = ::std::option::Option::None;
        self.angle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_FixAngle {
        static instance: CSVCMsg_FixAngle = CSVCMsg_FixAngle {
            relative: ::std::option::Option::None,
            angle: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_FixAngle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_FixAngle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_FixAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_FixAngle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_CrosshairAngle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_CrosshairAngle {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CrosshairAngle.angle)
    pub angle: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CrosshairAngle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CrosshairAngle {
    fn default() -> &'a CSVCMsg_CrosshairAngle {
        <CSVCMsg_CrosshairAngle as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CrosshairAngle {
    pub fn new() -> CSVCMsg_CrosshairAngle {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "angle",
            |m: &CSVCMsg_CrosshairAngle| { &m.angle },
            |m: &mut CSVCMsg_CrosshairAngle| { &mut m.angle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_CrosshairAngle>(
            "CSVCMsg_CrosshairAngle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_CrosshairAngle {
    const NAME: &'static str = "CSVCMsg_CrosshairAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.angle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CrosshairAngle {
        CSVCMsg_CrosshairAngle::new()
    }

    fn clear(&mut self) {
        self.angle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CrosshairAngle {
        static instance: CSVCMsg_CrosshairAngle = CSVCMsg_CrosshairAngle {
            angle: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_CrosshairAngle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_CrosshairAngle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_CrosshairAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_CrosshairAngle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_BSPDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_BSPDecal {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.pos)
    pub pos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.decal_texture_index)
    pub decal_texture_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.model_index)
    pub model_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.low_priority)
    pub low_priority: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_BSPDecal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_BSPDecal {
    fn default() -> &'a CSVCMsg_BSPDecal {
        <CSVCMsg_BSPDecal as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_BSPDecal {
    pub fn new() -> CSVCMsg_BSPDecal {
        ::std::default::Default::default()
    }

    // optional int32 decal_texture_index = 2;

    pub fn decal_texture_index(&self) -> i32 {
        self.decal_texture_index.unwrap_or(0)
    }

    pub fn clear_decal_texture_index(&mut self) {
        self.decal_texture_index = ::std::option::Option::None;
    }

    pub fn has_decal_texture_index(&self) -> bool {
        self.decal_texture_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decal_texture_index(&mut self, v: i32) {
        self.decal_texture_index = ::std::option::Option::Some(v);
    }

    // optional int32 entity_index = 3;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(-1i32)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional int32 model_index = 4;

    pub fn model_index(&self) -> i32 {
        self.model_index.unwrap_or(0)
    }

    pub fn clear_model_index(&mut self) {
        self.model_index = ::std::option::Option::None;
    }

    pub fn has_model_index(&self) -> bool {
        self.model_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_index(&mut self, v: i32) {
        self.model_index = ::std::option::Option::Some(v);
    }

    // optional bool low_priority = 5;

    pub fn low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "pos",
            |m: &CSVCMsg_BSPDecal| { &m.pos },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decal_texture_index",
            |m: &CSVCMsg_BSPDecal| { &m.decal_texture_index },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.decal_texture_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_index",
            |m: &CSVCMsg_BSPDecal| { &m.entity_index },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.entity_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "model_index",
            |m: &CSVCMsg_BSPDecal| { &m.model_index },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.model_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_priority",
            |m: &CSVCMsg_BSPDecal| { &m.low_priority },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.low_priority },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_BSPDecal>(
            "CSVCMsg_BSPDecal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_BSPDecal {
    const NAME: &'static str = "CSVCMsg_BSPDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                16 => {
                    self.decal_texture_index = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.model_index = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.decal_texture_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.model_index {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.low_priority {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.decal_texture_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity_index {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.model_index {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_BSPDecal {
        CSVCMsg_BSPDecal::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.decal_texture_index = ::std::option::Option::None;
        self.entity_index = ::std::option::Option::None;
        self.model_index = ::std::option::Option::None;
        self.low_priority = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_BSPDecal {
        static instance: CSVCMsg_BSPDecal = CSVCMsg_BSPDecal {
            pos: ::protobuf::MessageField::none(),
            decal_texture_index: ::std::option::Option::None,
            entity_index: ::std::option::Option::None,
            model_index: ::std::option::Option::None,
            low_priority: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_BSPDecal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_BSPDecal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_BSPDecal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_BSPDecal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_SplitScreen)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SplitScreen {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ESplitScreenMessageType>>,
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.slot)
    pub slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.player_index)
    pub player_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SplitScreen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SplitScreen {
    fn default() -> &'a CSVCMsg_SplitScreen {
        <CSVCMsg_SplitScreen as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SplitScreen {
    pub fn new() -> CSVCMsg_SplitScreen {
        ::std::default::Default::default()
    }

    // optional .ESplitScreenMessageType type = 1;

    pub fn type_(&self) -> ESplitScreenMessageType {
        match self.type_ {
            Some(e) => e.enum_value_or(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            None => ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ESplitScreenMessageType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 slot = 2;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional int32 player_index = 3;

    pub fn player_index(&self) -> i32 {
        self.player_index.unwrap_or(-1i32)
    }

    pub fn clear_player_index(&mut self) {
        self.player_index = ::std::option::Option::None;
    }

    pub fn has_player_index(&self) -> bool {
        self.player_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_index(&mut self, v: i32) {
        self.player_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CSVCMsg_SplitScreen| { &m.type_ },
            |m: &mut CSVCMsg_SplitScreen| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CSVCMsg_SplitScreen| { &m.slot },
            |m: &mut CSVCMsg_SplitScreen| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_index",
            |m: &CSVCMsg_SplitScreen| { &m.player_index },
            |m: &mut CSVCMsg_SplitScreen| { &mut m.player_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SplitScreen>(
            "CSVCMsg_SplitScreen",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SplitScreen {
    const NAME: &'static str = "CSVCMsg_SplitScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.player_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.player_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.slot {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.player_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SplitScreen {
        CSVCMsg_SplitScreen::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.player_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SplitScreen {
        static instance: CSVCMsg_SplitScreen = CSVCMsg_SplitScreen {
            type_: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            player_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SplitScreen {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SplitScreen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SplitScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SplitScreen {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_GetCvarValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_GetCvarValue {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GetCvarValue.cookie)
    pub cookie: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_GetCvarValue.cvar_name)
    pub cvar_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GetCvarValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GetCvarValue {
    fn default() -> &'a CSVCMsg_GetCvarValue {
        <CSVCMsg_GetCvarValue as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GetCvarValue {
    pub fn new() -> CSVCMsg_GetCvarValue {
        ::std::default::Default::default()
    }

    // optional int32 cookie = 1;

    pub fn cookie(&self) -> i32 {
        self.cookie.unwrap_or(0)
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = ::std::option::Option::Some(v);
    }

    // optional string cvar_name = 2;

    pub fn cvar_name(&self) -> &str {
        match self.cvar_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cvar_name(&mut self) {
        self.cvar_name = ::std::option::Option::None;
    }

    pub fn has_cvar_name(&self) -> bool {
        self.cvar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cvar_name(&mut self, v: ::std::string::String) {
        self.cvar_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cvar_name(&mut self) -> &mut ::std::string::String {
        if self.cvar_name.is_none() {
            self.cvar_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cvar_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_cvar_name(&mut self) -> ::std::string::String {
        self.cvar_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cookie",
            |m: &CSVCMsg_GetCvarValue| { &m.cookie },
            |m: &mut CSVCMsg_GetCvarValue| { &mut m.cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cvar_name",
            |m: &CSVCMsg_GetCvarValue| { &m.cvar_name },
            |m: &mut CSVCMsg_GetCvarValue| { &mut m.cvar_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_GetCvarValue>(
            "CSVCMsg_GetCvarValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_GetCvarValue {
    const NAME: &'static str = "CSVCMsg_GetCvarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cookie = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.cvar_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cookie {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.cvar_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cookie {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.cvar_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GetCvarValue {
        CSVCMsg_GetCvarValue::new()
    }

    fn clear(&mut self) {
        self.cookie = ::std::option::Option::None;
        self.cvar_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GetCvarValue {
        static instance: CSVCMsg_GetCvarValue = CSVCMsg_GetCvarValue {
            cookie: ::std::option::Option::None,
            cvar_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_GetCvarValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_GetCvarValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_GetCvarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_GetCvarValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_Menu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Menu {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Menu.dialog_type)
    pub dialog_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_Menu.menu_key_values)
    pub menu_key_values: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Menu.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Menu {
    fn default() -> &'a CSVCMsg_Menu {
        <CSVCMsg_Menu as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Menu {
    pub fn new() -> CSVCMsg_Menu {
        ::std::default::Default::default()
    }

    // optional int32 dialog_type = 1;

    pub fn dialog_type(&self) -> i32 {
        self.dialog_type.unwrap_or(0)
    }

    pub fn clear_dialog_type(&mut self) {
        self.dialog_type = ::std::option::Option::None;
    }

    pub fn has_dialog_type(&self) -> bool {
        self.dialog_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dialog_type(&mut self, v: i32) {
        self.dialog_type = ::std::option::Option::Some(v);
    }

    // optional bytes menu_key_values = 2;

    pub fn menu_key_values(&self) -> &[u8] {
        match self.menu_key_values.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_menu_key_values(&mut self) {
        self.menu_key_values = ::std::option::Option::None;
    }

    pub fn has_menu_key_values(&self) -> bool {
        self.menu_key_values.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_key_values(&mut self, v: ::bytes::Bytes) {
        self.menu_key_values = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu_key_values(&mut self) -> &mut ::bytes::Bytes {
        if self.menu_key_values.is_none() {
            self.menu_key_values = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.menu_key_values.as_mut().unwrap()
    }

    // Take field
    pub fn take_menu_key_values(&mut self) -> ::bytes::Bytes {
        self.menu_key_values.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dialog_type",
            |m: &CSVCMsg_Menu| { &m.dialog_type },
            |m: &mut CSVCMsg_Menu| { &mut m.dialog_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "menu_key_values",
            |m: &CSVCMsg_Menu| { &m.menu_key_values },
            |m: &mut CSVCMsg_Menu| { &mut m.menu_key_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Menu>(
            "CSVCMsg_Menu",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Menu {
    const NAME: &'static str = "CSVCMsg_Menu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dialog_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.menu_key_values = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dialog_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.menu_key_values.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dialog_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.menu_key_values.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Menu {
        CSVCMsg_Menu::new()
    }

    fn clear(&mut self) {
        self.dialog_type = ::std::option::Option::None;
        self.menu_key_values = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Menu {
        static instance: CSVCMsg_Menu = CSVCMsg_Menu {
            dialog_type: ::std::option::Option::None,
            menu_key_values: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Menu {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Menu").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Menu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Menu {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_UserMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_UserMessage {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.msg_type)
    pub msg_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.msg_data)
    pub msg_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.passthrough)
    pub passthrough: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_UserMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_UserMessage {
    fn default() -> &'a CSVCMsg_UserMessage {
        <CSVCMsg_UserMessage as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_UserMessage {
    pub fn new() -> CSVCMsg_UserMessage {
        ::std::default::Default::default()
    }

    // optional int32 msg_type = 1;

    pub fn msg_type(&self) -> i32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: i32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes msg_data = 2;

    pub fn msg_data(&self) -> &[u8] {
        match self.msg_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_msg_data(&mut self) {
        self.msg_data = ::std::option::Option::None;
    }

    pub fn has_msg_data(&self) -> bool {
        self.msg_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_data(&mut self, v: ::bytes::Bytes) {
        self.msg_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_data(&mut self) -> &mut ::bytes::Bytes {
        if self.msg_data.is_none() {
            self.msg_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.msg_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_data(&mut self) -> ::bytes::Bytes {
        self.msg_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional int32 passthrough = 3;

    pub fn passthrough(&self) -> i32 {
        self.passthrough.unwrap_or(0)
    }

    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: i32) {
        self.passthrough = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CSVCMsg_UserMessage| { &m.msg_type },
            |m: &mut CSVCMsg_UserMessage| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_data",
            |m: &CSVCMsg_UserMessage| { &m.msg_data },
            |m: &mut CSVCMsg_UserMessage| { &mut m.msg_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passthrough",
            |m: &CSVCMsg_UserMessage| { &m.passthrough },
            |m: &mut CSVCMsg_UserMessage| { &mut m.passthrough },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_UserMessage>(
            "CSVCMsg_UserMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_UserMessage {
    const NAME: &'static str = "CSVCMsg_UserMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.msg_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                24 => {
                    self.passthrough = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.msg_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.passthrough {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.msg_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.passthrough {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_UserMessage {
        CSVCMsg_UserMessage::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.msg_data = ::std::option::Option::None;
        self.passthrough = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_UserMessage {
        static instance: CSVCMsg_UserMessage = CSVCMsg_UserMessage {
            msg_type: ::std::option::Option::None,
            msg_data: ::std::option::Option::None,
            passthrough: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_UserMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_UserMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_UserMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_UserMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_SendTable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_SendTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.is_end)
    pub is_end: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.net_table_name)
    pub net_table_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.needs_decoder)
    pub needs_decoder: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.props)
    pub props: ::std::vec::Vec<csvcmsg_send_table::Sendprop_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SendTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SendTable {
    fn default() -> &'a CSVCMsg_SendTable {
        <CSVCMsg_SendTable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SendTable {
    pub fn new() -> CSVCMsg_SendTable {
        ::std::default::Default::default()
    }

    // optional bool is_end = 1;

    pub fn is_end(&self) -> bool {
        self.is_end.unwrap_or(false)
    }

    pub fn clear_is_end(&mut self) {
        self.is_end = ::std::option::Option::None;
    }

    pub fn has_is_end(&self) -> bool {
        self.is_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_end(&mut self, v: bool) {
        self.is_end = ::std::option::Option::Some(v);
    }

    // optional string net_table_name = 2;

    pub fn net_table_name(&self) -> &str {
        match self.net_table_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_net_table_name(&mut self) {
        self.net_table_name = ::std::option::Option::None;
    }

    pub fn has_net_table_name(&self) -> bool {
        self.net_table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_table_name(&mut self, v: ::std::string::String) {
        self.net_table_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_table_name(&mut self) -> &mut ::std::string::String {
        if self.net_table_name.is_none() {
            self.net_table_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.net_table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_table_name(&mut self) -> ::std::string::String {
        self.net_table_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool needs_decoder = 3;

    pub fn needs_decoder(&self) -> bool {
        self.needs_decoder.unwrap_or(false)
    }

    pub fn clear_needs_decoder(&mut self) {
        self.needs_decoder = ::std::option::Option::None;
    }

    pub fn has_needs_decoder(&self) -> bool {
        self.needs_decoder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_decoder(&mut self, v: bool) {
        self.needs_decoder = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_end",
            |m: &CSVCMsg_SendTable| { &m.is_end },
            |m: &mut CSVCMsg_SendTable| { &mut m.is_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_table_name",
            |m: &CSVCMsg_SendTable| { &m.net_table_name },
            |m: &mut CSVCMsg_SendTable| { &mut m.net_table_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_decoder",
            |m: &CSVCMsg_SendTable| { &m.needs_decoder },
            |m: &mut CSVCMsg_SendTable| { &mut m.needs_decoder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "props",
            |m: &CSVCMsg_SendTable| { &m.props },
            |m: &mut CSVCMsg_SendTable| { &mut m.props },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SendTable>(
            "CSVCMsg_SendTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SendTable {
    const NAME: &'static str = "CSVCMsg_SendTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_end = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.net_table_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.needs_decoder = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.props.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_end {
            my_size += 1 + 1;
        }
        if let Some(v) = self.net_table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.needs_decoder {
            my_size += 1 + 1;
        }
        for value in &self.props {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_end {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.net_table_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.needs_decoder {
            os.write_bool(3, v)?;
        }
        for v in &self.props {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SendTable {
        CSVCMsg_SendTable::new()
    }

    fn clear(&mut self) {
        self.is_end = ::std::option::Option::None;
        self.net_table_name = ::std::option::Option::None;
        self.needs_decoder = ::std::option::Option::None;
        self.props.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SendTable {
        static instance: CSVCMsg_SendTable = CSVCMsg_SendTable {
            is_end: ::std::option::Option::None,
            net_table_name: ::std::option::Option::None,
            needs_decoder: ::std::option::Option::None,
            props: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SendTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SendTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SendTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SendTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_SendTable`
pub mod csvcmsg_send_table {
    // @@protoc_insertion_point(message:CSVCMsg_SendTable.sendprop_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sendprop_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.var_name)
        pub var_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.flags)
        pub flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.priority)
        pub priority: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.dt_name)
        pub dt_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.num_elements)
        pub num_elements: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.low_value)
        pub low_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.high_value)
        pub high_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.num_bits)
        pub num_bits: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_SendTable.sendprop_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sendprop_t {
        fn default() -> &'a Sendprop_t {
            <Sendprop_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Sendprop_t {
        pub fn new() -> Sendprop_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string var_name = 2;

        pub fn var_name(&self) -> &str {
            match self.var_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_var_name(&mut self) {
            self.var_name = ::std::option::Option::None;
        }

        pub fn has_var_name(&self) -> bool {
            self.var_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_var_name(&mut self, v: ::std::string::String) {
            self.var_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_var_name(&mut self) -> &mut ::std::string::String {
            if self.var_name.is_none() {
                self.var_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.var_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_var_name(&mut self) -> ::std::string::String {
            self.var_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 flags = 3;

        pub fn flags(&self) -> i32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: i32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional int32 priority = 4;

        pub fn priority(&self) -> i32 {
            self.priority.unwrap_or(0)
        }

        pub fn clear_priority(&mut self) {
            self.priority = ::std::option::Option::None;
        }

        pub fn has_priority(&self) -> bool {
            self.priority.is_some()
        }

        // Param is passed by value, moved
        pub fn set_priority(&mut self, v: i32) {
            self.priority = ::std::option::Option::Some(v);
        }

        // optional string dt_name = 5;

        pub fn dt_name(&self) -> &str {
            match self.dt_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dt_name(&mut self) {
            self.dt_name = ::std::option::Option::None;
        }

        pub fn has_dt_name(&self) -> bool {
            self.dt_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dt_name(&mut self, v: ::std::string::String) {
            self.dt_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dt_name(&mut self) -> &mut ::std::string::String {
            if self.dt_name.is_none() {
                self.dt_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.dt_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_dt_name(&mut self) -> ::std::string::String {
            self.dt_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 num_elements = 6;

        pub fn num_elements(&self) -> i32 {
            self.num_elements.unwrap_or(0)
        }

        pub fn clear_num_elements(&mut self) {
            self.num_elements = ::std::option::Option::None;
        }

        pub fn has_num_elements(&self) -> bool {
            self.num_elements.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_elements(&mut self, v: i32) {
            self.num_elements = ::std::option::Option::Some(v);
        }

        // optional float low_value = 7;

        pub fn low_value(&self) -> f32 {
            self.low_value.unwrap_or(0.)
        }

        pub fn clear_low_value(&mut self) {
            self.low_value = ::std::option::Option::None;
        }

        pub fn has_low_value(&self) -> bool {
            self.low_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_low_value(&mut self, v: f32) {
            self.low_value = ::std::option::Option::Some(v);
        }

        // optional float high_value = 8;

        pub fn high_value(&self) -> f32 {
            self.high_value.unwrap_or(0.)
        }

        pub fn clear_high_value(&mut self) {
            self.high_value = ::std::option::Option::None;
        }

        pub fn has_high_value(&self) -> bool {
            self.high_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_high_value(&mut self, v: f32) {
            self.high_value = ::std::option::Option::Some(v);
        }

        // optional int32 num_bits = 9;

        pub fn num_bits(&self) -> i32 {
            self.num_bits.unwrap_or(0)
        }

        pub fn clear_num_bits(&mut self) {
            self.num_bits = ::std::option::Option::None;
        }

        pub fn has_num_bits(&self) -> bool {
            self.num_bits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_bits(&mut self, v: i32) {
            self.num_bits = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Sendprop_t| { &m.type_ },
                |m: &mut Sendprop_t| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "var_name",
                |m: &Sendprop_t| { &m.var_name },
                |m: &mut Sendprop_t| { &mut m.var_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &Sendprop_t| { &m.flags },
                |m: &mut Sendprop_t| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "priority",
                |m: &Sendprop_t| { &m.priority },
                |m: &mut Sendprop_t| { &mut m.priority },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dt_name",
                |m: &Sendprop_t| { &m.dt_name },
                |m: &mut Sendprop_t| { &mut m.dt_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_elements",
                |m: &Sendprop_t| { &m.num_elements },
                |m: &mut Sendprop_t| { &mut m.num_elements },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "low_value",
                |m: &Sendprop_t| { &m.low_value },
                |m: &mut Sendprop_t| { &mut m.low_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "high_value",
                |m: &Sendprop_t| { &m.high_value },
                |m: &mut Sendprop_t| { &mut m.high_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_bits",
                |m: &Sendprop_t| { &m.num_bits },
                |m: &mut Sendprop_t| { &mut m.num_bits },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sendprop_t>(
                "CSVCMsg_SendTable.sendprop_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sendprop_t {
        const NAME: &'static str = "sendprop_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.var_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.priority = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        self.dt_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.num_elements = ::std::option::Option::Some(is.read_int32()?);
                    },
                    61 => {
                        self.low_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    69 => {
                        self.high_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.num_bits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.var_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.priority {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.dt_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.num_elements {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.low_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.high_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.num_bits {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.var_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.flags {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.priority {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.dt_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.num_elements {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.low_value {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.high_value {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.num_bits {
                os.write_int32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sendprop_t {
            Sendprop_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.var_name = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.priority = ::std::option::Option::None;
            self.dt_name = ::std::option::Option::None;
            self.num_elements = ::std::option::Option::None;
            self.low_value = ::std::option::Option::None;
            self.high_value = ::std::option::Option::None;
            self.num_bits = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sendprop_t {
            static instance: Sendprop_t = Sendprop_t {
                type_: ::std::option::Option::None,
                var_name: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                priority: ::std::option::Option::None,
                dt_name: ::std::option::Option::None,
                num_elements: ::std::option::Option::None,
                low_value: ::std::option::Option::None,
                high_value: ::std::option::Option::None,
                num_bits: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sendprop_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_SendTable.sendprop_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sendprop_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sendprop_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_GameEventList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_GameEventList {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptors)
    pub descriptors: ::std::vec::Vec<csvcmsg_game_event_list::Descriptor_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GameEventList {
    fn default() -> &'a CSVCMsg_GameEventList {
        <CSVCMsg_GameEventList as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GameEventList {
    pub fn new() -> CSVCMsg_GameEventList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "descriptors",
            |m: &CSVCMsg_GameEventList| { &m.descriptors },
            |m: &mut CSVCMsg_GameEventList| { &mut m.descriptors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_GameEventList>(
            "CSVCMsg_GameEventList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_GameEventList {
    const NAME: &'static str = "CSVCMsg_GameEventList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.descriptors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.descriptors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.descriptors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GameEventList {
        CSVCMsg_GameEventList::new()
    }

    fn clear(&mut self) {
        self.descriptors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GameEventList {
        static instance: CSVCMsg_GameEventList = CSVCMsg_GameEventList {
            descriptors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_GameEventList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_GameEventList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_GameEventList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_GameEventList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_GameEventList`
pub mod csvcmsg_game_event_list {
    // @@protoc_insertion_point(message:CSVCMsg_GameEventList.key_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.key_t.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.key_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Key_t| { &m.type_ },
                |m: &mut Key_t| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Key_t| { &m.name },
                |m: &mut Key_t| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key_t>(
                "CSVCMsg_GameEventList.key_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Key_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_GameEventList.key_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Key_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Key_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CSVCMsg_GameEventList.descriptor_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Descriptor_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.eventid)
        pub eventid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.keys)
        pub keys: ::std::vec::Vec<Key_t>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.descriptor_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Descriptor_t {
        fn default() -> &'a Descriptor_t {
            <Descriptor_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Descriptor_t {
        pub fn new() -> Descriptor_t {
            ::std::default::Default::default()
        }

        // optional int32 eventid = 1;

        pub fn eventid(&self) -> i32 {
            self.eventid.unwrap_or(0)
        }

        pub fn clear_eventid(&mut self) {
            self.eventid = ::std::option::Option::None;
        }

        pub fn has_eventid(&self) -> bool {
            self.eventid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eventid(&mut self, v: i32) {
            self.eventid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eventid",
                |m: &Descriptor_t| { &m.eventid },
                |m: &mut Descriptor_t| { &mut m.eventid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Descriptor_t| { &m.name },
                |m: &mut Descriptor_t| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "keys",
                |m: &Descriptor_t| { &m.keys },
                |m: &mut Descriptor_t| { &mut m.keys },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Descriptor_t>(
                "CSVCMsg_GameEventList.descriptor_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Descriptor_t {
        const NAME: &'static str = "descriptor_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eventid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.keys.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eventid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            for value in &self.keys {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eventid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.keys {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Descriptor_t {
            Descriptor_t::new()
        }

        fn clear(&mut self) {
            self.eventid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.keys.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Descriptor_t {
            static instance: Descriptor_t = Descriptor_t {
                eventid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                keys: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Descriptor_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_GameEventList.descriptor_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Descriptor_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Descriptor_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_PacketEntities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_PacketEntities {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.max_entries)
    pub max_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.updated_entries)
    pub updated_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.legacy_is_delta)
    pub legacy_is_delta: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.update_baseline)
    pub update_baseline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.baseline)
    pub baseline: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.delta_from)
    pub delta_from: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.entity_data)
    pub entity_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.pending_full_frame)
    pub pending_full_frame: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.active_spawngroup_handle)
    pub active_spawngroup_handle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.max_spawngroup_creationsequence)
    pub max_spawngroup_creationsequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.last_cmd_number_executed)
    pub last_cmd_number_executed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.last_cmd_number_recv_delta)
    pub last_cmd_number_recv_delta: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.server_tick)
    pub server_tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.serialized_entities)
    pub serialized_entities: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.alternate_baselines)
    pub alternate_baselines: ::std::vec::Vec<csvcmsg_packet_entities::Alternate_baseline_t>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.has_pvs_vis_bits)
    pub has_pvs_vis_bits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.cmd_recv_status)
    pub cmd_recv_status: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.non_transmitted_entities)
    pub non_transmitted_entities: ::protobuf::MessageField<csvcmsg_packet_entities::Non_transmitted_entities_t>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.cq_starved_command_ticks)
    pub cq_starved_command_ticks: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.cq_discarded_command_ticks)
    pub cq_discarded_command_ticks: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.dev_padding)
    pub dev_padding: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PacketEntities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PacketEntities {
    fn default() -> &'a CSVCMsg_PacketEntities {
        <CSVCMsg_PacketEntities as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PacketEntities {
    pub fn new() -> CSVCMsg_PacketEntities {
        ::std::default::Default::default()
    }

    // optional int32 max_entries = 1;

    pub fn max_entries(&self) -> i32 {
        self.max_entries.unwrap_or(0)
    }

    pub fn clear_max_entries(&mut self) {
        self.max_entries = ::std::option::Option::None;
    }

    pub fn has_max_entries(&self) -> bool {
        self.max_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_entries(&mut self, v: i32) {
        self.max_entries = ::std::option::Option::Some(v);
    }

    // optional int32 updated_entries = 2;

    pub fn updated_entries(&self) -> i32 {
        self.updated_entries.unwrap_or(0)
    }

    pub fn clear_updated_entries(&mut self) {
        self.updated_entries = ::std::option::Option::None;
    }

    pub fn has_updated_entries(&self) -> bool {
        self.updated_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_entries(&mut self, v: i32) {
        self.updated_entries = ::std::option::Option::Some(v);
    }

    // optional bool legacy_is_delta = 3;

    pub fn legacy_is_delta(&self) -> bool {
        self.legacy_is_delta.unwrap_or(false)
    }

    pub fn clear_legacy_is_delta(&mut self) {
        self.legacy_is_delta = ::std::option::Option::None;
    }

    pub fn has_legacy_is_delta(&self) -> bool {
        self.legacy_is_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_is_delta(&mut self, v: bool) {
        self.legacy_is_delta = ::std::option::Option::Some(v);
    }

    // optional bool update_baseline = 4;

    pub fn update_baseline(&self) -> bool {
        self.update_baseline.unwrap_or(false)
    }

    pub fn clear_update_baseline(&mut self) {
        self.update_baseline = ::std::option::Option::None;
    }

    pub fn has_update_baseline(&self) -> bool {
        self.update_baseline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_baseline(&mut self, v: bool) {
        self.update_baseline = ::std::option::Option::Some(v);
    }

    // optional int32 baseline = 5;

    pub fn baseline(&self) -> i32 {
        self.baseline.unwrap_or(0)
    }

    pub fn clear_baseline(&mut self) {
        self.baseline = ::std::option::Option::None;
    }

    pub fn has_baseline(&self) -> bool {
        self.baseline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline(&mut self, v: i32) {
        self.baseline = ::std::option::Option::Some(v);
    }

    // optional int32 delta_from = 6;

    pub fn delta_from(&self) -> i32 {
        self.delta_from.unwrap_or(0)
    }

    pub fn clear_delta_from(&mut self) {
        self.delta_from = ::std::option::Option::None;
    }

    pub fn has_delta_from(&self) -> bool {
        self.delta_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_from(&mut self, v: i32) {
        self.delta_from = ::std::option::Option::Some(v);
    }

    // optional bytes entity_data = 7;

    pub fn entity_data(&self) -> &[u8] {
        match self.entity_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entity_data(&mut self) {
        self.entity_data = ::std::option::Option::None;
    }

    pub fn has_entity_data(&self) -> bool {
        self.entity_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_data(&mut self, v: ::bytes::Bytes) {
        self.entity_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_data(&mut self) -> &mut ::bytes::Bytes {
        if self.entity_data.is_none() {
            self.entity_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.entity_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity_data(&mut self) -> ::bytes::Bytes {
        self.entity_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool pending_full_frame = 8;

    pub fn pending_full_frame(&self) -> bool {
        self.pending_full_frame.unwrap_or(false)
    }

    pub fn clear_pending_full_frame(&mut self) {
        self.pending_full_frame = ::std::option::Option::None;
    }

    pub fn has_pending_full_frame(&self) -> bool {
        self.pending_full_frame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_full_frame(&mut self, v: bool) {
        self.pending_full_frame = ::std::option::Option::Some(v);
    }

    // optional uint32 active_spawngroup_handle = 9;

    pub fn active_spawngroup_handle(&self) -> u32 {
        self.active_spawngroup_handle.unwrap_or(0)
    }

    pub fn clear_active_spawngroup_handle(&mut self) {
        self.active_spawngroup_handle = ::std::option::Option::None;
    }

    pub fn has_active_spawngroup_handle(&self) -> bool {
        self.active_spawngroup_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_spawngroup_handle(&mut self, v: u32) {
        self.active_spawngroup_handle = ::std::option::Option::Some(v);
    }

    // optional uint32 max_spawngroup_creationsequence = 10;

    pub fn max_spawngroup_creationsequence(&self) -> u32 {
        self.max_spawngroup_creationsequence.unwrap_or(0)
    }

    pub fn clear_max_spawngroup_creationsequence(&mut self) {
        self.max_spawngroup_creationsequence = ::std::option::Option::None;
    }

    pub fn has_max_spawngroup_creationsequence(&self) -> bool {
        self.max_spawngroup_creationsequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_spawngroup_creationsequence(&mut self, v: u32) {
        self.max_spawngroup_creationsequence = ::std::option::Option::Some(v);
    }

    // optional uint32 last_cmd_number_executed = 11;

    pub fn last_cmd_number_executed(&self) -> u32 {
        self.last_cmd_number_executed.unwrap_or(0)
    }

    pub fn clear_last_cmd_number_executed(&mut self) {
        self.last_cmd_number_executed = ::std::option::Option::None;
    }

    pub fn has_last_cmd_number_executed(&self) -> bool {
        self.last_cmd_number_executed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_cmd_number_executed(&mut self, v: u32) {
        self.last_cmd_number_executed = ::std::option::Option::Some(v);
    }

    // optional sint32 last_cmd_number_recv_delta = 17;

    pub fn last_cmd_number_recv_delta(&self) -> i32 {
        self.last_cmd_number_recv_delta.unwrap_or(0)
    }

    pub fn clear_last_cmd_number_recv_delta(&mut self) {
        self.last_cmd_number_recv_delta = ::std::option::Option::None;
    }

    pub fn has_last_cmd_number_recv_delta(&self) -> bool {
        self.last_cmd_number_recv_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_cmd_number_recv_delta(&mut self, v: i32) {
        self.last_cmd_number_recv_delta = ::std::option::Option::Some(v);
    }

    // optional uint32 server_tick = 12;

    pub fn server_tick(&self) -> u32 {
        self.server_tick.unwrap_or(0)
    }

    pub fn clear_server_tick(&mut self) {
        self.server_tick = ::std::option::Option::None;
    }

    pub fn has_server_tick(&self) -> bool {
        self.server_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tick(&mut self, v: u32) {
        self.server_tick = ::std::option::Option::Some(v);
    }

    // optional bytes serialized_entities = 13;

    pub fn serialized_entities(&self) -> &[u8] {
        match self.serialized_entities.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_entities(&mut self) {
        self.serialized_entities = ::std::option::Option::None;
    }

    pub fn has_serialized_entities(&self) -> bool {
        self.serialized_entities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_entities(&mut self, v: ::bytes::Bytes) {
        self.serialized_entities = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_entities(&mut self) -> &mut ::bytes::Bytes {
        if self.serialized_entities.is_none() {
            self.serialized_entities = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.serialized_entities.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_entities(&mut self) -> ::bytes::Bytes {
        self.serialized_entities.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 has_pvs_vis_bits = 16;

    pub fn has_pvs_vis_bits(&self) -> u32 {
        self.has_pvs_vis_bits.unwrap_or(0)
    }

    pub fn clear_has_pvs_vis_bits(&mut self) {
        self.has_pvs_vis_bits = ::std::option::Option::None;
    }

    pub fn has_has_pvs_vis_bits(&self) -> bool {
        self.has_pvs_vis_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_pvs_vis_bits(&mut self, v: u32) {
        self.has_pvs_vis_bits = ::std::option::Option::Some(v);
    }

    // optional uint32 cq_starved_command_ticks = 20;

    pub fn cq_starved_command_ticks(&self) -> u32 {
        self.cq_starved_command_ticks.unwrap_or(0)
    }

    pub fn clear_cq_starved_command_ticks(&mut self) {
        self.cq_starved_command_ticks = ::std::option::Option::None;
    }

    pub fn has_cq_starved_command_ticks(&self) -> bool {
        self.cq_starved_command_ticks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cq_starved_command_ticks(&mut self, v: u32) {
        self.cq_starved_command_ticks = ::std::option::Option::Some(v);
    }

    // optional uint32 cq_discarded_command_ticks = 21;

    pub fn cq_discarded_command_ticks(&self) -> u32 {
        self.cq_discarded_command_ticks.unwrap_or(0)
    }

    pub fn clear_cq_discarded_command_ticks(&mut self) {
        self.cq_discarded_command_ticks = ::std::option::Option::None;
    }

    pub fn has_cq_discarded_command_ticks(&self) -> bool {
        self.cq_discarded_command_ticks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cq_discarded_command_ticks(&mut self, v: u32) {
        self.cq_discarded_command_ticks = ::std::option::Option::Some(v);
    }

    // optional bytes dev_padding = 999;

    pub fn dev_padding(&self) -> &[u8] {
        match self.dev_padding.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_dev_padding(&mut self) {
        self.dev_padding = ::std::option::Option::None;
    }

    pub fn has_dev_padding(&self) -> bool {
        self.dev_padding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dev_padding(&mut self, v: ::bytes::Bytes) {
        self.dev_padding = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dev_padding(&mut self) -> &mut ::bytes::Bytes {
        if self.dev_padding.is_none() {
            self.dev_padding = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.dev_padding.as_mut().unwrap()
    }

    // Take field
    pub fn take_dev_padding(&mut self) -> ::bytes::Bytes {
        self.dev_padding.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_entries",
            |m: &CSVCMsg_PacketEntities| { &m.max_entries },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.max_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updated_entries",
            |m: &CSVCMsg_PacketEntities| { &m.updated_entries },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.updated_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_is_delta",
            |m: &CSVCMsg_PacketEntities| { &m.legacy_is_delta },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.legacy_is_delta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_baseline",
            |m: &CSVCMsg_PacketEntities| { &m.update_baseline },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.update_baseline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseline",
            |m: &CSVCMsg_PacketEntities| { &m.baseline },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.baseline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta_from",
            |m: &CSVCMsg_PacketEntities| { &m.delta_from },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.delta_from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_data",
            |m: &CSVCMsg_PacketEntities| { &m.entity_data },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.entity_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pending_full_frame",
            |m: &CSVCMsg_PacketEntities| { &m.pending_full_frame },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.pending_full_frame },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_spawngroup_handle",
            |m: &CSVCMsg_PacketEntities| { &m.active_spawngroup_handle },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.active_spawngroup_handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_spawngroup_creationsequence",
            |m: &CSVCMsg_PacketEntities| { &m.max_spawngroup_creationsequence },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.max_spawngroup_creationsequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_cmd_number_executed",
            |m: &CSVCMsg_PacketEntities| { &m.last_cmd_number_executed },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.last_cmd_number_executed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_cmd_number_recv_delta",
            |m: &CSVCMsg_PacketEntities| { &m.last_cmd_number_recv_delta },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.last_cmd_number_recv_delta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_tick",
            |m: &CSVCMsg_PacketEntities| { &m.server_tick },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.server_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_entities",
            |m: &CSVCMsg_PacketEntities| { &m.serialized_entities },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.serialized_entities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "alternate_baselines",
            |m: &CSVCMsg_PacketEntities| { &m.alternate_baselines },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.alternate_baselines },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_pvs_vis_bits",
            |m: &CSVCMsg_PacketEntities| { &m.has_pvs_vis_bits },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.has_pvs_vis_bits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cmd_recv_status",
            |m: &CSVCMsg_PacketEntities| { &m.cmd_recv_status },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.cmd_recv_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, csvcmsg_packet_entities::Non_transmitted_entities_t>(
            "non_transmitted_entities",
            |m: &CSVCMsg_PacketEntities| { &m.non_transmitted_entities },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.non_transmitted_entities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cq_starved_command_ticks",
            |m: &CSVCMsg_PacketEntities| { &m.cq_starved_command_ticks },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.cq_starved_command_ticks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cq_discarded_command_ticks",
            |m: &CSVCMsg_PacketEntities| { &m.cq_discarded_command_ticks },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.cq_discarded_command_ticks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dev_padding",
            |m: &CSVCMsg_PacketEntities| { &m.dev_padding },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.dev_padding },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_PacketEntities>(
            "CSVCMsg_PacketEntities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_PacketEntities {
    const NAME: &'static str = "CSVCMsg_PacketEntities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.updated_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.legacy_is_delta = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.update_baseline = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.baseline = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.delta_from = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.entity_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                64 => {
                    self.pending_full_frame = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.active_spawngroup_handle = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.max_spawngroup_creationsequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.last_cmd_number_executed = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.last_cmd_number_recv_delta = ::std::option::Option::Some(is.read_sint32()?);
                },
                96 => {
                    self.server_tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.serialized_entities = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                122 => {
                    self.alternate_baselines.push(is.read_message()?);
                },
                128 => {
                    self.has_pvs_vis_bits = ::std::option::Option::Some(is.read_uint32()?);
                },
                178 => {
                    is.read_repeated_packed_sint32_into(&mut self.cmd_recv_status)?;
                },
                176 => {
                    self.cmd_recv_status.push(is.read_sint32()?);
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.non_transmitted_entities)?;
                },
                160 => {
                    self.cq_starved_command_ticks = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.cq_discarded_command_ticks = ::std::option::Option::Some(is.read_uint32()?);
                },
                7994 => {
                    self.dev_padding = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.max_entries {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.updated_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.legacy_is_delta {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_baseline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.baseline {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.delta_from {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.entity_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.pending_full_frame {
            my_size += 1 + 1;
        }
        if let Some(v) = self.active_spawngroup_handle {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.max_spawngroup_creationsequence {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.last_cmd_number_executed {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.last_cmd_number_recv_delta {
            my_size += ::protobuf::rt::sint32_size(17, v);
        }
        if let Some(v) = self.server_tick {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.serialized_entities.as_ref() {
            my_size += ::protobuf::rt::bytes_size(13, &v);
        }
        for value in &self.alternate_baselines {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.has_pvs_vis_bits {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        my_size += ::protobuf::rt::vec_packed_sint32_size(22, &self.cmd_recv_status);
        if let Some(v) = self.non_transmitted_entities.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cq_starved_command_ticks {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.cq_discarded_command_ticks {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.dev_padding.as_ref() {
            my_size += ::protobuf::rt::bytes_size(999, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.max_entries {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.updated_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.legacy_is_delta {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.update_baseline {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.baseline {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.delta_from {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.entity_data.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.pending_full_frame {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.active_spawngroup_handle {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.max_spawngroup_creationsequence {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.last_cmd_number_executed {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.last_cmd_number_recv_delta {
            os.write_sint32(17, v)?;
        }
        if let Some(v) = self.server_tick {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.serialized_entities.as_ref() {
            os.write_bytes(13, v)?;
        }
        for v in &self.alternate_baselines {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.has_pvs_vis_bits {
            os.write_uint32(16, v)?;
        }
        os.write_repeated_packed_sint32(22, &self.cmd_recv_status)?;
        if let Some(v) = self.non_transmitted_entities.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.cq_starved_command_ticks {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.cq_discarded_command_ticks {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.dev_padding.as_ref() {
            os.write_bytes(999, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PacketEntities {
        CSVCMsg_PacketEntities::new()
    }

    fn clear(&mut self) {
        self.max_entries = ::std::option::Option::None;
        self.updated_entries = ::std::option::Option::None;
        self.legacy_is_delta = ::std::option::Option::None;
        self.update_baseline = ::std::option::Option::None;
        self.baseline = ::std::option::Option::None;
        self.delta_from = ::std::option::Option::None;
        self.entity_data = ::std::option::Option::None;
        self.pending_full_frame = ::std::option::Option::None;
        self.active_spawngroup_handle = ::std::option::Option::None;
        self.max_spawngroup_creationsequence = ::std::option::Option::None;
        self.last_cmd_number_executed = ::std::option::Option::None;
        self.last_cmd_number_recv_delta = ::std::option::Option::None;
        self.server_tick = ::std::option::Option::None;
        self.serialized_entities = ::std::option::Option::None;
        self.alternate_baselines.clear();
        self.has_pvs_vis_bits = ::std::option::Option::None;
        self.cmd_recv_status.clear();
        self.non_transmitted_entities.clear();
        self.cq_starved_command_ticks = ::std::option::Option::None;
        self.cq_discarded_command_ticks = ::std::option::Option::None;
        self.dev_padding = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PacketEntities {
        static instance: CSVCMsg_PacketEntities = CSVCMsg_PacketEntities {
            max_entries: ::std::option::Option::None,
            updated_entries: ::std::option::Option::None,
            legacy_is_delta: ::std::option::Option::None,
            update_baseline: ::std::option::Option::None,
            baseline: ::std::option::Option::None,
            delta_from: ::std::option::Option::None,
            entity_data: ::std::option::Option::None,
            pending_full_frame: ::std::option::Option::None,
            active_spawngroup_handle: ::std::option::Option::None,
            max_spawngroup_creationsequence: ::std::option::Option::None,
            last_cmd_number_executed: ::std::option::Option::None,
            last_cmd_number_recv_delta: ::std::option::Option::None,
            server_tick: ::std::option::Option::None,
            serialized_entities: ::std::option::Option::None,
            alternate_baselines: ::std::vec::Vec::new(),
            has_pvs_vis_bits: ::std::option::Option::None,
            cmd_recv_status: ::std::vec::Vec::new(),
            non_transmitted_entities: ::protobuf::MessageField::none(),
            cq_starved_command_ticks: ::std::option::Option::None,
            cq_discarded_command_ticks: ::std::option::Option::None,
            dev_padding: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_PacketEntities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_PacketEntities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_PacketEntities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_PacketEntities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_PacketEntities`
pub mod csvcmsg_packet_entities {
    // @@protoc_insertion_point(message:CSVCMsg_PacketEntities.alternate_baseline_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Alternate_baseline_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.alternate_baseline_t.entity_index)
        pub entity_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.alternate_baseline_t.baseline_index)
        pub baseline_index: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_PacketEntities.alternate_baseline_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Alternate_baseline_t {
        fn default() -> &'a Alternate_baseline_t {
            <Alternate_baseline_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Alternate_baseline_t {
        pub fn new() -> Alternate_baseline_t {
            ::std::default::Default::default()
        }

        // optional int32 entity_index = 1;

        pub fn entity_index(&self) -> i32 {
            self.entity_index.unwrap_or(0)
        }

        pub fn clear_entity_index(&mut self) {
            self.entity_index = ::std::option::Option::None;
        }

        pub fn has_entity_index(&self) -> bool {
            self.entity_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_index(&mut self, v: i32) {
            self.entity_index = ::std::option::Option::Some(v);
        }

        // optional int32 baseline_index = 2;

        pub fn baseline_index(&self) -> i32 {
            self.baseline_index.unwrap_or(0)
        }

        pub fn clear_baseline_index(&mut self) {
            self.baseline_index = ::std::option::Option::None;
        }

        pub fn has_baseline_index(&self) -> bool {
            self.baseline_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_baseline_index(&mut self, v: i32) {
            self.baseline_index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_index",
                |m: &Alternate_baseline_t| { &m.entity_index },
                |m: &mut Alternate_baseline_t| { &mut m.entity_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "baseline_index",
                |m: &Alternate_baseline_t| { &m.baseline_index },
                |m: &mut Alternate_baseline_t| { &mut m.baseline_index },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Alternate_baseline_t>(
                "CSVCMsg_PacketEntities.alternate_baseline_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Alternate_baseline_t {
        const NAME: &'static str = "alternate_baseline_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.baseline_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entity_index {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.baseline_index {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.entity_index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.baseline_index {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Alternate_baseline_t {
            Alternate_baseline_t::new()
        }

        fn clear(&mut self) {
            self.entity_index = ::std::option::Option::None;
            self.baseline_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Alternate_baseline_t {
            static instance: Alternate_baseline_t = Alternate_baseline_t {
                entity_index: ::std::option::Option::None,
                baseline_index: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Alternate_baseline_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_PacketEntities.alternate_baseline_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Alternate_baseline_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Alternate_baseline_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CSVCMsg_PacketEntities.non_transmitted_entities_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Non_transmitted_entities_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.non_transmitted_entities_t.header_count)
        pub header_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.non_transmitted_entities_t.data)
        pub data: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_PacketEntities.non_transmitted_entities_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Non_transmitted_entities_t {
        fn default() -> &'a Non_transmitted_entities_t {
            <Non_transmitted_entities_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Non_transmitted_entities_t {
        pub fn new() -> Non_transmitted_entities_t {
            ::std::default::Default::default()
        }

        // optional int32 header_count = 1;

        pub fn header_count(&self) -> i32 {
            self.header_count.unwrap_or(0)
        }

        pub fn clear_header_count(&mut self) {
            self.header_count = ::std::option::Option::None;
        }

        pub fn has_header_count(&self) -> bool {
            self.header_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_header_count(&mut self, v: i32) {
            self.header_count = ::std::option::Option::Some(v);
        }

        // optional bytes data = 2;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::bytes::Bytes) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::bytes::Bytes {
            self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "header_count",
                |m: &Non_transmitted_entities_t| { &m.header_count },
                |m: &mut Non_transmitted_entities_t| { &mut m.header_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &Non_transmitted_entities_t| { &m.data },
                |m: &mut Non_transmitted_entities_t| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Non_transmitted_entities_t>(
                "CSVCMsg_PacketEntities.non_transmitted_entities_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Non_transmitted_entities_t {
        const NAME: &'static str = "non_transmitted_entities_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.header_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.header_count {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.header_count {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Non_transmitted_entities_t {
            Non_transmitted_entities_t::new()
        }

        fn clear(&mut self) {
            self.header_count = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Non_transmitted_entities_t {
            static instance: Non_transmitted_entities_t = Non_transmitted_entities_t {
                header_count: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Non_transmitted_entities_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_PacketEntities.non_transmitted_entities_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Non_transmitted_entities_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Non_transmitted_entities_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_TempEntities)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_TempEntities {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.reliable)
    pub reliable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.num_entries)
    pub num_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.entity_data)
    pub entity_data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_TempEntities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_TempEntities {
    fn default() -> &'a CSVCMsg_TempEntities {
        <CSVCMsg_TempEntities as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_TempEntities {
    pub fn new() -> CSVCMsg_TempEntities {
        ::std::default::Default::default()
    }

    // optional bool reliable = 1;

    pub fn reliable(&self) -> bool {
        self.reliable.unwrap_or(false)
    }

    pub fn clear_reliable(&mut self) {
        self.reliable = ::std::option::Option::None;
    }

    pub fn has_reliable(&self) -> bool {
        self.reliable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable(&mut self, v: bool) {
        self.reliable = ::std::option::Option::Some(v);
    }

    // optional int32 num_entries = 2;

    pub fn num_entries(&self) -> i32 {
        self.num_entries.unwrap_or(0)
    }

    pub fn clear_num_entries(&mut self) {
        self.num_entries = ::std::option::Option::None;
    }

    pub fn has_num_entries(&self) -> bool {
        self.num_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries(&mut self, v: i32) {
        self.num_entries = ::std::option::Option::Some(v);
    }

    // optional bytes entity_data = 3;

    pub fn entity_data(&self) -> &[u8] {
        match self.entity_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entity_data(&mut self) {
        self.entity_data = ::std::option::Option::None;
    }

    pub fn has_entity_data(&self) -> bool {
        self.entity_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_data(&mut self, v: ::bytes::Bytes) {
        self.entity_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_data(&mut self) -> &mut ::bytes::Bytes {
        if self.entity_data.is_none() {
            self.entity_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.entity_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity_data(&mut self) -> ::bytes::Bytes {
        self.entity_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reliable",
            |m: &CSVCMsg_TempEntities| { &m.reliable },
            |m: &mut CSVCMsg_TempEntities| { &mut m.reliable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_entries",
            |m: &CSVCMsg_TempEntities| { &m.num_entries },
            |m: &mut CSVCMsg_TempEntities| { &mut m.num_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_data",
            |m: &CSVCMsg_TempEntities| { &m.entity_data },
            |m: &mut CSVCMsg_TempEntities| { &mut m.entity_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_TempEntities>(
            "CSVCMsg_TempEntities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_TempEntities {
    const NAME: &'static str = "CSVCMsg_TempEntities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.num_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.entity_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.num_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entity_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reliable {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.num_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_TempEntities {
        CSVCMsg_TempEntities::new()
    }

    fn clear(&mut self) {
        self.reliable = ::std::option::Option::None;
        self.num_entries = ::std::option::Option::None;
        self.entity_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_TempEntities {
        static instance: CSVCMsg_TempEntities = CSVCMsg_TempEntities {
            reliable: ::std::option::Option::None,
            num_entries: ::std::option::Option::None,
            entity_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_TempEntities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_TempEntities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_TempEntities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_TempEntities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_CreateStringTable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_CreateStringTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.num_entries)
    pub num_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_fixed_size)
    pub user_data_fixed_size: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_size)
    pub user_data_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_size_bits)
    pub user_data_size_bits: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.flags)
    pub flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.string_data)
    pub string_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.uncompressed_size)
    pub uncompressed_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.data_compressed)
    pub data_compressed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.using_varint_bitcounts)
    pub using_varint_bitcounts: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CreateStringTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CreateStringTable {
    fn default() -> &'a CSVCMsg_CreateStringTable {
        <CSVCMsg_CreateStringTable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CreateStringTable {
    pub fn new() -> CSVCMsg_CreateStringTable {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 num_entries = 2;

    pub fn num_entries(&self) -> i32 {
        self.num_entries.unwrap_or(0)
    }

    pub fn clear_num_entries(&mut self) {
        self.num_entries = ::std::option::Option::None;
    }

    pub fn has_num_entries(&self) -> bool {
        self.num_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries(&mut self, v: i32) {
        self.num_entries = ::std::option::Option::Some(v);
    }

    // optional bool user_data_fixed_size = 3;

    pub fn user_data_fixed_size(&self) -> bool {
        self.user_data_fixed_size.unwrap_or(false)
    }

    pub fn clear_user_data_fixed_size(&mut self) {
        self.user_data_fixed_size = ::std::option::Option::None;
    }

    pub fn has_user_data_fixed_size(&self) -> bool {
        self.user_data_fixed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_fixed_size(&mut self, v: bool) {
        self.user_data_fixed_size = ::std::option::Option::Some(v);
    }

    // optional int32 user_data_size = 4;

    pub fn user_data_size(&self) -> i32 {
        self.user_data_size.unwrap_or(0)
    }

    pub fn clear_user_data_size(&mut self) {
        self.user_data_size = ::std::option::Option::None;
    }

    pub fn has_user_data_size(&self) -> bool {
        self.user_data_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_size(&mut self, v: i32) {
        self.user_data_size = ::std::option::Option::Some(v);
    }

    // optional int32 user_data_size_bits = 5;

    pub fn user_data_size_bits(&self) -> i32 {
        self.user_data_size_bits.unwrap_or(0)
    }

    pub fn clear_user_data_size_bits(&mut self) {
        self.user_data_size_bits = ::std::option::Option::None;
    }

    pub fn has_user_data_size_bits(&self) -> bool {
        self.user_data_size_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_size_bits(&mut self, v: i32) {
        self.user_data_size_bits = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 6;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes string_data = 7;

    pub fn string_data(&self) -> &[u8] {
        match self.string_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_data(&mut self) {
        self.string_data = ::std::option::Option::None;
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::bytes::Bytes) {
        self.string_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&mut self) -> &mut ::bytes::Bytes {
        if self.string_data.is_none() {
            self.string_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.string_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::bytes::Bytes {
        self.string_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional int32 uncompressed_size = 8;

    pub fn uncompressed_size(&self) -> i32 {
        self.uncompressed_size.unwrap_or(0)
    }

    pub fn clear_uncompressed_size(&mut self) {
        self.uncompressed_size = ::std::option::Option::None;
    }

    pub fn has_uncompressed_size(&self) -> bool {
        self.uncompressed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_size(&mut self, v: i32) {
        self.uncompressed_size = ::std::option::Option::Some(v);
    }

    // optional bool data_compressed = 9;

    pub fn data_compressed(&self) -> bool {
        self.data_compressed.unwrap_or(false)
    }

    pub fn clear_data_compressed(&mut self) {
        self.data_compressed = ::std::option::Option::None;
    }

    pub fn has_data_compressed(&self) -> bool {
        self.data_compressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_compressed(&mut self, v: bool) {
        self.data_compressed = ::std::option::Option::Some(v);
    }

    // optional bool using_varint_bitcounts = 10;

    pub fn using_varint_bitcounts(&self) -> bool {
        self.using_varint_bitcounts.unwrap_or(false)
    }

    pub fn clear_using_varint_bitcounts(&mut self) {
        self.using_varint_bitcounts = ::std::option::Option::None;
    }

    pub fn has_using_varint_bitcounts(&self) -> bool {
        self.using_varint_bitcounts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_using_varint_bitcounts(&mut self, v: bool) {
        self.using_varint_bitcounts = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSVCMsg_CreateStringTable| { &m.name },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_entries",
            |m: &CSVCMsg_CreateStringTable| { &m.num_entries },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.num_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_data_fixed_size",
            |m: &CSVCMsg_CreateStringTable| { &m.user_data_fixed_size },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.user_data_fixed_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_data_size",
            |m: &CSVCMsg_CreateStringTable| { &m.user_data_size },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.user_data_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_data_size_bits",
            |m: &CSVCMsg_CreateStringTable| { &m.user_data_size_bits },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.user_data_size_bits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CSVCMsg_CreateStringTable| { &m.flags },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_data",
            |m: &CSVCMsg_CreateStringTable| { &m.string_data },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.string_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uncompressed_size",
            |m: &CSVCMsg_CreateStringTable| { &m.uncompressed_size },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.uncompressed_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_compressed",
            |m: &CSVCMsg_CreateStringTable| { &m.data_compressed },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.data_compressed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "using_varint_bitcounts",
            |m: &CSVCMsg_CreateStringTable| { &m.using_varint_bitcounts },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.using_varint_bitcounts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_CreateStringTable>(
            "CSVCMsg_CreateStringTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_CreateStringTable {
    const NAME: &'static str = "CSVCMsg_CreateStringTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.num_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.user_data_fixed_size = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.user_data_size = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.user_data_size_bits = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.string_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                64 => {
                    self.uncompressed_size = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.data_compressed = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.using_varint_bitcounts = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.num_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.user_data_fixed_size {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_data_size {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.user_data_size_bits {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.string_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.uncompressed_size {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.data_compressed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.using_varint_bitcounts {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.num_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.user_data_fixed_size {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.user_data_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.user_data_size_bits {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.string_data.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.uncompressed_size {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.data_compressed {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.using_varint_bitcounts {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CreateStringTable {
        CSVCMsg_CreateStringTable::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.num_entries = ::std::option::Option::None;
        self.user_data_fixed_size = ::std::option::Option::None;
        self.user_data_size = ::std::option::Option::None;
        self.user_data_size_bits = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.string_data = ::std::option::Option::None;
        self.uncompressed_size = ::std::option::Option::None;
        self.data_compressed = ::std::option::Option::None;
        self.using_varint_bitcounts = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CreateStringTable {
        static instance: CSVCMsg_CreateStringTable = CSVCMsg_CreateStringTable {
            name: ::std::option::Option::None,
            num_entries: ::std::option::Option::None,
            user_data_fixed_size: ::std::option::Option::None,
            user_data_size: ::std::option::Option::None,
            user_data_size_bits: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            string_data: ::std::option::Option::None,
            uncompressed_size: ::std::option::Option::None,
            data_compressed: ::std::option::Option::None,
            using_varint_bitcounts: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_CreateStringTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_CreateStringTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_CreateStringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_CreateStringTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_UpdateStringTable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_UpdateStringTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.table_id)
    pub table_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.num_changed_entries)
    pub num_changed_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.string_data)
    pub string_data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_UpdateStringTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_UpdateStringTable {
    fn default() -> &'a CSVCMsg_UpdateStringTable {
        <CSVCMsg_UpdateStringTable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_UpdateStringTable {
    pub fn new() -> CSVCMsg_UpdateStringTable {
        ::std::default::Default::default()
    }

    // optional int32 table_id = 1;

    pub fn table_id(&self) -> i32 {
        self.table_id.unwrap_or(0)
    }

    pub fn clear_table_id(&mut self) {
        self.table_id = ::std::option::Option::None;
    }

    pub fn has_table_id(&self) -> bool {
        self.table_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_id(&mut self, v: i32) {
        self.table_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_changed_entries = 2;

    pub fn num_changed_entries(&self) -> i32 {
        self.num_changed_entries.unwrap_or(0)
    }

    pub fn clear_num_changed_entries(&mut self) {
        self.num_changed_entries = ::std::option::Option::None;
    }

    pub fn has_num_changed_entries(&self) -> bool {
        self.num_changed_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_changed_entries(&mut self, v: i32) {
        self.num_changed_entries = ::std::option::Option::Some(v);
    }

    // optional bytes string_data = 3;

    pub fn string_data(&self) -> &[u8] {
        match self.string_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_data(&mut self) {
        self.string_data = ::std::option::Option::None;
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::bytes::Bytes) {
        self.string_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&mut self) -> &mut ::bytes::Bytes {
        if self.string_data.is_none() {
            self.string_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.string_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::bytes::Bytes {
        self.string_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "table_id",
            |m: &CSVCMsg_UpdateStringTable| { &m.table_id },
            |m: &mut CSVCMsg_UpdateStringTable| { &mut m.table_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_changed_entries",
            |m: &CSVCMsg_UpdateStringTable| { &m.num_changed_entries },
            |m: &mut CSVCMsg_UpdateStringTable| { &mut m.num_changed_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_data",
            |m: &CSVCMsg_UpdateStringTable| { &m.string_data },
            |m: &mut CSVCMsg_UpdateStringTable| { &mut m.string_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_UpdateStringTable>(
            "CSVCMsg_UpdateStringTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_UpdateStringTable {
    const NAME: &'static str = "CSVCMsg_UpdateStringTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.table_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.num_changed_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.string_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.table_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.num_changed_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.string_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.table_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.num_changed_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.string_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_UpdateStringTable {
        CSVCMsg_UpdateStringTable::new()
    }

    fn clear(&mut self) {
        self.table_id = ::std::option::Option::None;
        self.num_changed_entries = ::std::option::Option::None;
        self.string_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_UpdateStringTable {
        static instance: CSVCMsg_UpdateStringTable = CSVCMsg_UpdateStringTable {
            table_id: ::std::option::Option::None,
            num_changed_entries: ::std::option::Option::None,
            string_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_UpdateStringTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_UpdateStringTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_UpdateStringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_UpdateStringTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_VoiceData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_VoiceData {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.audio)
    pub audio: ::protobuf::MessageField<CMsgVoiceAudio>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.client)
    pub client: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.proximity)
    pub proximity: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.audible_mask)
    pub audible_mask: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.tick)
    pub tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.passthrough)
    pub passthrough: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_VoiceData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_VoiceData {
    fn default() -> &'a CSVCMsg_VoiceData {
        <CSVCMsg_VoiceData as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_VoiceData {
    pub fn new() -> CSVCMsg_VoiceData {
        ::std::default::Default::default()
    }

    // optional int32 client = 2;

    pub fn client(&self) -> i32 {
        self.client.unwrap_or(-1i32)
    }

    pub fn clear_client(&mut self) {
        self.client = ::std::option::Option::None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: i32) {
        self.client = ::std::option::Option::Some(v);
    }

    // optional bool proximity = 3;

    pub fn proximity(&self) -> bool {
        self.proximity.unwrap_or(false)
    }

    pub fn clear_proximity(&mut self) {
        self.proximity = ::std::option::Option::None;
    }

    pub fn has_proximity(&self) -> bool {
        self.proximity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proximity(&mut self, v: bool) {
        self.proximity = ::std::option::Option::Some(v);
    }

    // optional fixed64 xuid = 4;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 audible_mask = 5;

    pub fn audible_mask(&self) -> i32 {
        self.audible_mask.unwrap_or(0)
    }

    pub fn clear_audible_mask(&mut self) {
        self.audible_mask = ::std::option::Option::None;
    }

    pub fn has_audible_mask(&self) -> bool {
        self.audible_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audible_mask(&mut self, v: i32) {
        self.audible_mask = ::std::option::Option::Some(v);
    }

    // optional uint32 tick = 6;

    pub fn tick(&self) -> u32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: u32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional int32 passthrough = 7;

    pub fn passthrough(&self) -> i32 {
        self.passthrough.unwrap_or(0)
    }

    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: i32) {
        self.passthrough = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVoiceAudio>(
            "audio",
            |m: &CSVCMsg_VoiceData| { &m.audio },
            |m: &mut CSVCMsg_VoiceData| { &mut m.audio },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client",
            |m: &CSVCMsg_VoiceData| { &m.client },
            |m: &mut CSVCMsg_VoiceData| { &mut m.client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proximity",
            |m: &CSVCMsg_VoiceData| { &m.proximity },
            |m: &mut CSVCMsg_VoiceData| { &mut m.proximity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xuid",
            |m: &CSVCMsg_VoiceData| { &m.xuid },
            |m: &mut CSVCMsg_VoiceData| { &mut m.xuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audible_mask",
            |m: &CSVCMsg_VoiceData| { &m.audible_mask },
            |m: &mut CSVCMsg_VoiceData| { &mut m.audible_mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CSVCMsg_VoiceData| { &m.tick },
            |m: &mut CSVCMsg_VoiceData| { &mut m.tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passthrough",
            |m: &CSVCMsg_VoiceData| { &m.passthrough },
            |m: &mut CSVCMsg_VoiceData| { &mut m.passthrough },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_VoiceData>(
            "CSVCMsg_VoiceData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_VoiceData {
    const NAME: &'static str = "CSVCMsg_VoiceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audio)?;
                },
                16 => {
                    self.client = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.proximity = ::std::option::Option::Some(is.read_bool()?);
                },
                33 => {
                    self.xuid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.audible_mask = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.passthrough = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.audio.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.proximity {
            my_size += 1 + 1;
        }
        if let Some(v) = self.xuid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.audible_mask {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.passthrough {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.audio.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.client {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.proximity {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.xuid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.audible_mask {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.tick {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.passthrough {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_VoiceData {
        CSVCMsg_VoiceData::new()
    }

    fn clear(&mut self) {
        self.audio.clear();
        self.client = ::std::option::Option::None;
        self.proximity = ::std::option::Option::None;
        self.xuid = ::std::option::Option::None;
        self.audible_mask = ::std::option::Option::None;
        self.tick = ::std::option::Option::None;
        self.passthrough = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_VoiceData {
        static instance: CSVCMsg_VoiceData = CSVCMsg_VoiceData {
            audio: ::protobuf::MessageField::none(),
            client: ::std::option::Option::None,
            proximity: ::std::option::Option::None,
            xuid: ::std::option::Option::None,
            audible_mask: ::std::option::Option::None,
            tick: ::std::option::Option::None,
            passthrough: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_VoiceData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_VoiceData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_VoiceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_VoiceData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_PacketReliable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_PacketReliable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PacketReliable.tick)
    pub tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketReliable.messagessize)
    pub messagessize: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketReliable.state)
    pub state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PacketReliable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PacketReliable {
    fn default() -> &'a CSVCMsg_PacketReliable {
        <CSVCMsg_PacketReliable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PacketReliable {
    pub fn new() -> CSVCMsg_PacketReliable {
        ::std::default::Default::default()
    }

    // optional int32 tick = 1;

    pub fn tick(&self) -> i32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional int32 messagessize = 2;

    pub fn messagessize(&self) -> i32 {
        self.messagessize.unwrap_or(0)
    }

    pub fn clear_messagessize(&mut self) {
        self.messagessize = ::std::option::Option::None;
    }

    pub fn has_messagessize(&self) -> bool {
        self.messagessize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messagessize(&mut self, v: i32) {
        self.messagessize = ::std::option::Option::Some(v);
    }

    // optional bool state = 3;

    pub fn state(&self) -> bool {
        self.state.unwrap_or(false)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CSVCMsg_PacketReliable| { &m.tick },
            |m: &mut CSVCMsg_PacketReliable| { &mut m.tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messagessize",
            |m: &CSVCMsg_PacketReliable| { &m.messagessize },
            |m: &mut CSVCMsg_PacketReliable| { &mut m.messagessize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CSVCMsg_PacketReliable| { &m.state },
            |m: &mut CSVCMsg_PacketReliable| { &mut m.state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_PacketReliable>(
            "CSVCMsg_PacketReliable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_PacketReliable {
    const NAME: &'static str = "CSVCMsg_PacketReliable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.messagessize = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.messagessize {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.state {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.messagessize {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PacketReliable {
        CSVCMsg_PacketReliable::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.messagessize = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PacketReliable {
        static instance: CSVCMsg_PacketReliable = CSVCMsg_PacketReliable {
            tick: ::std::option::Option::None,
            messagessize: ::std::option::Option::None,
            state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_PacketReliable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_PacketReliable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_PacketReliable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_PacketReliable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_FullFrameSplit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_FullFrameSplit {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.tick)
    pub tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.section)
    pub section: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.total)
    pub total: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_FullFrameSplit.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_FullFrameSplit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_FullFrameSplit {
    fn default() -> &'a CSVCMsg_FullFrameSplit {
        <CSVCMsg_FullFrameSplit as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_FullFrameSplit {
    pub fn new() -> CSVCMsg_FullFrameSplit {
        ::std::default::Default::default()
    }

    // optional int32 tick = 1;

    pub fn tick(&self) -> i32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional int32 section = 2;

    pub fn section(&self) -> i32 {
        self.section.unwrap_or(0)
    }

    pub fn clear_section(&mut self) {
        self.section = ::std::option::Option::None;
    }

    pub fn has_section(&self) -> bool {
        self.section.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section(&mut self, v: i32) {
        self.section = ::std::option::Option::Some(v);
    }

    // optional int32 total = 3;

    pub fn total(&self) -> i32 {
        self.total.unwrap_or(0)
    }

    pub fn clear_total(&mut self) {
        self.total = ::std::option::Option::None;
    }

    pub fn has_total(&self) -> bool {
        self.total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: i32) {
        self.total = ::std::option::Option::Some(v);
    }

    // optional bytes data = 4;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CSVCMsg_FullFrameSplit| { &m.tick },
            |m: &mut CSVCMsg_FullFrameSplit| { &mut m.tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "section",
            |m: &CSVCMsg_FullFrameSplit| { &m.section },
            |m: &mut CSVCMsg_FullFrameSplit| { &mut m.section },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total",
            |m: &CSVCMsg_FullFrameSplit| { &m.total },
            |m: &mut CSVCMsg_FullFrameSplit| { &mut m.total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CSVCMsg_FullFrameSplit| { &m.data },
            |m: &mut CSVCMsg_FullFrameSplit| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_FullFrameSplit>(
            "CSVCMsg_FullFrameSplit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_FullFrameSplit {
    const NAME: &'static str = "CSVCMsg_FullFrameSplit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.section = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.total = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.section {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.total {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.section {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.total {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_FullFrameSplit {
        CSVCMsg_FullFrameSplit::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.section = ::std::option::Option::None;
        self.total = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_FullFrameSplit {
        static instance: CSVCMsg_FullFrameSplit = CSVCMsg_FullFrameSplit {
            tick: ::std::option::Option::None,
            section: ::std::option::Option::None,
            total: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_FullFrameSplit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_FullFrameSplit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_FullFrameSplit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_FullFrameSplit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_HLTVStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_HLTVStatus {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.master)
    pub master: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.clients)
    pub clients: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.slots)
    pub slots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HLTVStatus.proxies)
    pub proxies: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_HLTVStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_HLTVStatus {
    fn default() -> &'a CSVCMsg_HLTVStatus {
        <CSVCMsg_HLTVStatus as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_HLTVStatus {
    pub fn new() -> CSVCMsg_HLTVStatus {
        ::std::default::Default::default()
    }

    // optional string master = 1;

    pub fn master(&self) -> &str {
        match self.master.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_master(&mut self) {
        self.master = ::std::option::Option::None;
    }

    pub fn has_master(&self) -> bool {
        self.master.is_some()
    }

    // Param is passed by value, moved
    pub fn set_master(&mut self, v: ::std::string::String) {
        self.master = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_master(&mut self) -> &mut ::std::string::String {
        if self.master.is_none() {
            self.master = ::std::option::Option::Some(::std::string::String::new());
        }
        self.master.as_mut().unwrap()
    }

    // Take field
    pub fn take_master(&mut self) -> ::std::string::String {
        self.master.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 clients = 2;

    pub fn clients(&self) -> i32 {
        self.clients.unwrap_or(0)
    }

    pub fn clear_clients(&mut self) {
        self.clients = ::std::option::Option::None;
    }

    pub fn has_clients(&self) -> bool {
        self.clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clients(&mut self, v: i32) {
        self.clients = ::std::option::Option::Some(v);
    }

    // optional int32 slots = 3;

    pub fn slots(&self) -> i32 {
        self.slots.unwrap_or(0)
    }

    pub fn clear_slots(&mut self) {
        self.slots = ::std::option::Option::None;
    }

    pub fn has_slots(&self) -> bool {
        self.slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots(&mut self, v: i32) {
        self.slots = ::std::option::Option::Some(v);
    }

    // optional int32 proxies = 4;

    pub fn proxies(&self) -> i32 {
        self.proxies.unwrap_or(0)
    }

    pub fn clear_proxies(&mut self) {
        self.proxies = ::std::option::Option::None;
    }

    pub fn has_proxies(&self) -> bool {
        self.proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proxies(&mut self, v: i32) {
        self.proxies = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "master",
            |m: &CSVCMsg_HLTVStatus| { &m.master },
            |m: &mut CSVCMsg_HLTVStatus| { &mut m.master },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clients",
            |m: &CSVCMsg_HLTVStatus| { &m.clients },
            |m: &mut CSVCMsg_HLTVStatus| { &mut m.clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slots",
            |m: &CSVCMsg_HLTVStatus| { &m.slots },
            |m: &mut CSVCMsg_HLTVStatus| { &mut m.slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proxies",
            |m: &CSVCMsg_HLTVStatus| { &m.proxies },
            |m: &mut CSVCMsg_HLTVStatus| { &mut m.proxies },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_HLTVStatus>(
            "CSVCMsg_HLTVStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_HLTVStatus {
    const NAME: &'static str = "CSVCMsg_HLTVStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.master = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.clients = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.slots = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.proxies = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.master.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.clients {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.slots {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.proxies {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.master.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.clients {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.slots {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.proxies {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_HLTVStatus {
        CSVCMsg_HLTVStatus::new()
    }

    fn clear(&mut self) {
        self.master = ::std::option::Option::None;
        self.clients = ::std::option::Option::None;
        self.slots = ::std::option::Option::None;
        self.proxies = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_HLTVStatus {
        static instance: CSVCMsg_HLTVStatus = CSVCMsg_HLTVStatus {
            master: ::std::option::Option::None,
            clients: ::std::option::Option::None,
            slots: ::std::option::Option::None,
            proxies: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_HLTVStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_HLTVStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_HLTVStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_HLTVStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_ServerSteamID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ServerSteamID {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ServerSteamID.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ServerSteamID.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ServerSteamID {
    fn default() -> &'a CSVCMsg_ServerSteamID {
        <CSVCMsg_ServerSteamID as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ServerSteamID {
    pub fn new() -> CSVCMsg_ServerSteamID {
        ::std::default::Default::default()
    }

    // optional uint64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CSVCMsg_ServerSteamID| { &m.steam_id },
            |m: &mut CSVCMsg_ServerSteamID| { &mut m.steam_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_ServerSteamID>(
            "CSVCMsg_ServerSteamID",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_ServerSteamID {
    const NAME: &'static str = "CSVCMsg_ServerSteamID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ServerSteamID {
        CSVCMsg_ServerSteamID::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ServerSteamID {
        static instance: CSVCMsg_ServerSteamID = CSVCMsg_ServerSteamID {
            steam_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_ServerSteamID {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_ServerSteamID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_ServerSteamID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_ServerSteamID {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_CmdKeyValues)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_CmdKeyValues {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CmdKeyValues.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CmdKeyValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CmdKeyValues {
    fn default() -> &'a CSVCMsg_CmdKeyValues {
        <CSVCMsg_CmdKeyValues as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CmdKeyValues {
    pub fn new() -> CSVCMsg_CmdKeyValues {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CSVCMsg_CmdKeyValues| { &m.data },
            |m: &mut CSVCMsg_CmdKeyValues| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_CmdKeyValues>(
            "CSVCMsg_CmdKeyValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_CmdKeyValues {
    const NAME: &'static str = "CSVCMsg_CmdKeyValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CmdKeyValues {
        CSVCMsg_CmdKeyValues::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CmdKeyValues {
        static instance: CSVCMsg_CmdKeyValues = CSVCMsg_CmdKeyValues {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_CmdKeyValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_CmdKeyValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_CmdKeyValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_CmdKeyValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_RconServerDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_RconServerDetails {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_RconServerDetails.token)
    pub token: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSVCMsg_RconServerDetails.details)
    pub details: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_RconServerDetails.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_RconServerDetails {
    fn default() -> &'a CSVCMsg_RconServerDetails {
        <CSVCMsg_RconServerDetails as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_RconServerDetails {
    pub fn new() -> CSVCMsg_RconServerDetails {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::bytes::Bytes) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::bytes::Bytes {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::bytes::Bytes {
        self.token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional string details = 2;

    pub fn details(&self) -> &str {
        match self.details.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_details(&mut self) {
        self.details = ::std::option::Option::None;
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::string::String) {
        self.details = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::string::String {
        if self.details.is_none() {
            self.details = ::std::option::Option::Some(::std::string::String::new());
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::string::String {
        self.details.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CSVCMsg_RconServerDetails| { &m.token },
            |m: &mut CSVCMsg_RconServerDetails| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details",
            |m: &CSVCMsg_RconServerDetails| { &m.details },
            |m: &mut CSVCMsg_RconServerDetails| { &mut m.details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_RconServerDetails>(
            "CSVCMsg_RconServerDetails",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_RconServerDetails {
    const NAME: &'static str = "CSVCMsg_RconServerDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                18 => {
                    self.details = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.details.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_RconServerDetails {
        CSVCMsg_RconServerDetails::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.details = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_RconServerDetails {
        static instance: CSVCMsg_RconServerDetails = CSVCMsg_RconServerDetails {
            token: ::std::option::Option::None,
            details: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_RconServerDetails {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_RconServerDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_RconServerDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_RconServerDetails {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgIPCAddress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgIPCAddress {
    // message fields
    // @@protoc_insertion_point(field:CMsgIPCAddress.computer_guid)
    pub computer_guid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgIPCAddress.process_id)
    pub process_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgIPCAddress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgIPCAddress {
    fn default() -> &'a CMsgIPCAddress {
        <CMsgIPCAddress as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIPCAddress {
    pub fn new() -> CMsgIPCAddress {
        ::std::default::Default::default()
    }

    // optional fixed64 computer_guid = 1;

    pub fn computer_guid(&self) -> u64 {
        self.computer_guid.unwrap_or(0)
    }

    pub fn clear_computer_guid(&mut self) {
        self.computer_guid = ::std::option::Option::None;
    }

    pub fn has_computer_guid(&self) -> bool {
        self.computer_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_computer_guid(&mut self, v: u64) {
        self.computer_guid = ::std::option::Option::Some(v);
    }

    // optional uint32 process_id = 2;

    pub fn process_id(&self) -> u32 {
        self.process_id.unwrap_or(0)
    }

    pub fn clear_process_id(&mut self) {
        self.process_id = ::std::option::Option::None;
    }

    pub fn has_process_id(&self) -> bool {
        self.process_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_id(&mut self, v: u32) {
        self.process_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "computer_guid",
            |m: &CMsgIPCAddress| { &m.computer_guid },
            |m: &mut CMsgIPCAddress| { &mut m.computer_guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "process_id",
            |m: &CMsgIPCAddress| { &m.process_id },
            |m: &mut CMsgIPCAddress| { &mut m.process_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgIPCAddress>(
            "CMsgIPCAddress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgIPCAddress {
    const NAME: &'static str = "CMsgIPCAddress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.computer_guid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.computer_guid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.process_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.computer_guid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.process_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgIPCAddress {
        CMsgIPCAddress::new()
    }

    fn clear(&mut self) {
        self.computer_guid = ::std::option::Option::None;
        self.process_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgIPCAddress {
        static instance: CMsgIPCAddress = CMsgIPCAddress {
            computer_guid: ::std::option::Option::None,
            process_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgIPCAddress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgIPCAddress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgIPCAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIPCAddress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgServerPeer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerPeer {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerPeer.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerPeer.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerPeer.ipc)
    pub ipc: ::protobuf::MessageField<CMsgIPCAddress>,
    // @@protoc_insertion_point(field:CMsgServerPeer.they_hear_you)
    pub they_hear_you: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerPeer.you_hear_them)
    pub you_hear_them: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerPeer.is_listenserver_host)
    pub is_listenserver_host: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerPeer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerPeer {
    fn default() -> &'a CMsgServerPeer {
        <CMsgServerPeer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerPeer {
    pub fn new() -> CMsgServerPeer {
        ::std::default::Default::default()
    }

    // optional int32 player_slot = 1;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool they_hear_you = 4;

    pub fn they_hear_you(&self) -> bool {
        self.they_hear_you.unwrap_or(false)
    }

    pub fn clear_they_hear_you(&mut self) {
        self.they_hear_you = ::std::option::Option::None;
    }

    pub fn has_they_hear_you(&self) -> bool {
        self.they_hear_you.is_some()
    }

    // Param is passed by value, moved
    pub fn set_they_hear_you(&mut self, v: bool) {
        self.they_hear_you = ::std::option::Option::Some(v);
    }

    // optional bool you_hear_them = 5;

    pub fn you_hear_them(&self) -> bool {
        self.you_hear_them.unwrap_or(false)
    }

    pub fn clear_you_hear_them(&mut self) {
        self.you_hear_them = ::std::option::Option::None;
    }

    pub fn has_you_hear_them(&self) -> bool {
        self.you_hear_them.is_some()
    }

    // Param is passed by value, moved
    pub fn set_you_hear_them(&mut self, v: bool) {
        self.you_hear_them = ::std::option::Option::Some(v);
    }

    // optional bool is_listenserver_host = 6;

    pub fn is_listenserver_host(&self) -> bool {
        self.is_listenserver_host.unwrap_or(false)
    }

    pub fn clear_is_listenserver_host(&mut self) {
        self.is_listenserver_host = ::std::option::Option::None;
    }

    pub fn has_is_listenserver_host(&self) -> bool {
        self.is_listenserver_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_listenserver_host(&mut self, v: bool) {
        self.is_listenserver_host = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &CMsgServerPeer| { &m.player_slot },
            |m: &mut CMsgServerPeer| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgServerPeer| { &m.steamid },
            |m: &mut CMsgServerPeer| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgIPCAddress>(
            "ipc",
            |m: &CMsgServerPeer| { &m.ipc },
            |m: &mut CMsgServerPeer| { &mut m.ipc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "they_hear_you",
            |m: &CMsgServerPeer| { &m.they_hear_you },
            |m: &mut CMsgServerPeer| { &mut m.they_hear_you },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "you_hear_them",
            |m: &CMsgServerPeer| { &m.you_hear_them },
            |m: &mut CMsgServerPeer| { &mut m.you_hear_them },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_listenserver_host",
            |m: &CMsgServerPeer| { &m.is_listenserver_host },
            |m: &mut CMsgServerPeer| { &mut m.is_listenserver_host },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerPeer>(
            "CMsgServerPeer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerPeer {
    const NAME: &'static str = "CMsgServerPeer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ipc)?;
                },
                32 => {
                    self.they_hear_you = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.you_hear_them = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_listenserver_host = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ipc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.they_hear_you {
            my_size += 1 + 1;
        }
        if let Some(v) = self.you_hear_them {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_listenserver_host {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_slot {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.ipc.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.they_hear_you {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.you_hear_them {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_listenserver_host {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerPeer {
        CMsgServerPeer::new()
    }

    fn clear(&mut self) {
        self.player_slot = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.ipc.clear();
        self.they_hear_you = ::std::option::Option::None;
        self.you_hear_them = ::std::option::Option::None;
        self.is_listenserver_host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerPeer {
        static instance: CMsgServerPeer = CMsgServerPeer {
            player_slot: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            ipc: ::protobuf::MessageField::none(),
            they_hear_you: ::std::option::Option::None,
            you_hear_them: ::std::option::Option::None,
            is_listenserver_host: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerPeer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerPeer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerPeer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerPeer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_PeerList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_PeerList {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PeerList.peer)
    pub peer: ::std::vec::Vec<CMsgServerPeer>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PeerList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PeerList {
    fn default() -> &'a CSVCMsg_PeerList {
        <CSVCMsg_PeerList as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PeerList {
    pub fn new() -> CSVCMsg_PeerList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "peer",
            |m: &CSVCMsg_PeerList| { &m.peer },
            |m: &mut CSVCMsg_PeerList| { &mut m.peer },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_PeerList>(
            "CSVCMsg_PeerList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_PeerList {
    const NAME: &'static str = "CSVCMsg_PeerList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.peer.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.peer {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.peer {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PeerList {
        CSVCMsg_PeerList::new()
    }

    fn clear(&mut self) {
        self.peer.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PeerList {
        static instance: CSVCMsg_PeerList = CSVCMsg_PeerList {
            peer: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_PeerList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_PeerList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_PeerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_PeerList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_ClearAllStringTables)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_ClearAllStringTables {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ClearAllStringTables.mapname)
    pub mapname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_ClearAllStringTables.create_tables_skipped)
    pub create_tables_skipped: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ClearAllStringTables.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ClearAllStringTables {
    fn default() -> &'a CSVCMsg_ClearAllStringTables {
        <CSVCMsg_ClearAllStringTables as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ClearAllStringTables {
    pub fn new() -> CSVCMsg_ClearAllStringTables {
        ::std::default::Default::default()
    }

    // optional string mapname = 1;

    pub fn mapname(&self) -> &str {
        match self.mapname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mapname(&mut self) {
        self.mapname = ::std::option::Option::None;
    }

    pub fn has_mapname(&self) -> bool {
        self.mapname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mapname(&mut self, v: ::std::string::String) {
        self.mapname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mapname(&mut self) -> &mut ::std::string::String {
        if self.mapname.is_none() {
            self.mapname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mapname.as_mut().unwrap()
    }

    // Take field
    pub fn take_mapname(&mut self) -> ::std::string::String {
        self.mapname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool create_tables_skipped = 3;

    pub fn create_tables_skipped(&self) -> bool {
        self.create_tables_skipped.unwrap_or(false)
    }

    pub fn clear_create_tables_skipped(&mut self) {
        self.create_tables_skipped = ::std::option::Option::None;
    }

    pub fn has_create_tables_skipped(&self) -> bool {
        self.create_tables_skipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_tables_skipped(&mut self, v: bool) {
        self.create_tables_skipped = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mapname",
            |m: &CSVCMsg_ClearAllStringTables| { &m.mapname },
            |m: &mut CSVCMsg_ClearAllStringTables| { &mut m.mapname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "create_tables_skipped",
            |m: &CSVCMsg_ClearAllStringTables| { &m.create_tables_skipped },
            |m: &mut CSVCMsg_ClearAllStringTables| { &mut m.create_tables_skipped },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_ClearAllStringTables>(
            "CSVCMsg_ClearAllStringTables",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_ClearAllStringTables {
    const NAME: &'static str = "CSVCMsg_ClearAllStringTables";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mapname = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.create_tables_skipped = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mapname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.create_tables_skipped {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mapname.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.create_tables_skipped {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ClearAllStringTables {
        CSVCMsg_ClearAllStringTables::new()
    }

    fn clear(&mut self) {
        self.mapname = ::std::option::Option::None;
        self.create_tables_skipped = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ClearAllStringTables {
        static instance: CSVCMsg_ClearAllStringTables = CSVCMsg_ClearAllStringTables {
            mapname: ::std::option::Option::None,
            create_tables_skipped: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_ClearAllStringTables {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_ClearAllStringTables").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_ClearAllStringTables {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_ClearAllStringTables {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoFlattenedSerializerField_t)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoFlattenedSerializerField_t {
    // message fields
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_type_sym)
    pub var_type_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_name_sym)
    pub var_name_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.bit_count)
    pub bit_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.low_value)
    pub low_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.high_value)
    pub high_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.encode_flags)
    pub encode_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.field_serializer_name_sym)
    pub field_serializer_name_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.field_serializer_version)
    pub field_serializer_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.send_node_sym)
    pub send_node_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_encoder_sym)
    pub var_encoder_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.polymorphic_types)
    pub polymorphic_types: ::std::vec::Vec<proto_flattened_serializer_field_t::Polymorphic_field_t>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.var_serializer_sym)
    pub var_serializer_sym: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoFlattenedSerializerField_t.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoFlattenedSerializerField_t {
    fn default() -> &'a ProtoFlattenedSerializerField_t {
        <ProtoFlattenedSerializerField_t as ::protobuf::Message>::default_instance()
    }
}

impl ProtoFlattenedSerializerField_t {
    pub fn new() -> ProtoFlattenedSerializerField_t {
        ::std::default::Default::default()
    }

    // optional int32 var_type_sym = 1;

    pub fn var_type_sym(&self) -> i32 {
        self.var_type_sym.unwrap_or(0)
    }

    pub fn clear_var_type_sym(&mut self) {
        self.var_type_sym = ::std::option::Option::None;
    }

    pub fn has_var_type_sym(&self) -> bool {
        self.var_type_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_type_sym(&mut self, v: i32) {
        self.var_type_sym = ::std::option::Option::Some(v);
    }

    // optional int32 var_name_sym = 2;

    pub fn var_name_sym(&self) -> i32 {
        self.var_name_sym.unwrap_or(0)
    }

    pub fn clear_var_name_sym(&mut self) {
        self.var_name_sym = ::std::option::Option::None;
    }

    pub fn has_var_name_sym(&self) -> bool {
        self.var_name_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_name_sym(&mut self, v: i32) {
        self.var_name_sym = ::std::option::Option::Some(v);
    }

    // optional int32 bit_count = 3;

    pub fn bit_count(&self) -> i32 {
        self.bit_count.unwrap_or(0)
    }

    pub fn clear_bit_count(&mut self) {
        self.bit_count = ::std::option::Option::None;
    }

    pub fn has_bit_count(&self) -> bool {
        self.bit_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bit_count(&mut self, v: i32) {
        self.bit_count = ::std::option::Option::Some(v);
    }

    // optional float low_value = 4;

    pub fn low_value(&self) -> f32 {
        self.low_value.unwrap_or(0.)
    }

    pub fn clear_low_value(&mut self) {
        self.low_value = ::std::option::Option::None;
    }

    pub fn has_low_value(&self) -> bool {
        self.low_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_value(&mut self, v: f32) {
        self.low_value = ::std::option::Option::Some(v);
    }

    // optional float high_value = 5;

    pub fn high_value(&self) -> f32 {
        self.high_value.unwrap_or(0.)
    }

    pub fn clear_high_value(&mut self) {
        self.high_value = ::std::option::Option::None;
    }

    pub fn has_high_value(&self) -> bool {
        self.high_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_value(&mut self, v: f32) {
        self.high_value = ::std::option::Option::Some(v);
    }

    // optional int32 encode_flags = 6;

    pub fn encode_flags(&self) -> i32 {
        self.encode_flags.unwrap_or(0)
    }

    pub fn clear_encode_flags(&mut self) {
        self.encode_flags = ::std::option::Option::None;
    }

    pub fn has_encode_flags(&self) -> bool {
        self.encode_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encode_flags(&mut self, v: i32) {
        self.encode_flags = ::std::option::Option::Some(v);
    }

    // optional int32 field_serializer_name_sym = 7;

    pub fn field_serializer_name_sym(&self) -> i32 {
        self.field_serializer_name_sym.unwrap_or(0)
    }

    pub fn clear_field_serializer_name_sym(&mut self) {
        self.field_serializer_name_sym = ::std::option::Option::None;
    }

    pub fn has_field_serializer_name_sym(&self) -> bool {
        self.field_serializer_name_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_serializer_name_sym(&mut self, v: i32) {
        self.field_serializer_name_sym = ::std::option::Option::Some(v);
    }

    // optional int32 field_serializer_version = 8;

    pub fn field_serializer_version(&self) -> i32 {
        self.field_serializer_version.unwrap_or(0)
    }

    pub fn clear_field_serializer_version(&mut self) {
        self.field_serializer_version = ::std::option::Option::None;
    }

    pub fn has_field_serializer_version(&self) -> bool {
        self.field_serializer_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_serializer_version(&mut self, v: i32) {
        self.field_serializer_version = ::std::option::Option::Some(v);
    }

    // optional int32 send_node_sym = 9;

    pub fn send_node_sym(&self) -> i32 {
        self.send_node_sym.unwrap_or(0)
    }

    pub fn clear_send_node_sym(&mut self) {
        self.send_node_sym = ::std::option::Option::None;
    }

    pub fn has_send_node_sym(&self) -> bool {
        self.send_node_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_node_sym(&mut self, v: i32) {
        self.send_node_sym = ::std::option::Option::Some(v);
    }

    // optional int32 var_encoder_sym = 10;

    pub fn var_encoder_sym(&self) -> i32 {
        self.var_encoder_sym.unwrap_or(0)
    }

    pub fn clear_var_encoder_sym(&mut self) {
        self.var_encoder_sym = ::std::option::Option::None;
    }

    pub fn has_var_encoder_sym(&self) -> bool {
        self.var_encoder_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_encoder_sym(&mut self, v: i32) {
        self.var_encoder_sym = ::std::option::Option::Some(v);
    }

    // optional int32 var_serializer_sym = 12;

    pub fn var_serializer_sym(&self) -> i32 {
        self.var_serializer_sym.unwrap_or(0)
    }

    pub fn clear_var_serializer_sym(&mut self) {
        self.var_serializer_sym = ::std::option::Option::None;
    }

    pub fn has_var_serializer_sym(&self) -> bool {
        self.var_serializer_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_var_serializer_sym(&mut self, v: i32) {
        self.var_serializer_sym = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "var_type_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.var_type_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.var_type_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "var_name_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.var_name_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.var_name_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bit_count",
            |m: &ProtoFlattenedSerializerField_t| { &m.bit_count },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.bit_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_value",
            |m: &ProtoFlattenedSerializerField_t| { &m.low_value },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.low_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "high_value",
            |m: &ProtoFlattenedSerializerField_t| { &m.high_value },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.high_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encode_flags",
            |m: &ProtoFlattenedSerializerField_t| { &m.encode_flags },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.encode_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "field_serializer_name_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.field_serializer_name_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.field_serializer_name_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "field_serializer_version",
            |m: &ProtoFlattenedSerializerField_t| { &m.field_serializer_version },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.field_serializer_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_node_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.send_node_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.send_node_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "var_encoder_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.var_encoder_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.var_encoder_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "polymorphic_types",
            |m: &ProtoFlattenedSerializerField_t| { &m.polymorphic_types },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.polymorphic_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "var_serializer_sym",
            |m: &ProtoFlattenedSerializerField_t| { &m.var_serializer_sym },
            |m: &mut ProtoFlattenedSerializerField_t| { &mut m.var_serializer_sym },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoFlattenedSerializerField_t>(
            "ProtoFlattenedSerializerField_t",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoFlattenedSerializerField_t {
    const NAME: &'static str = "ProtoFlattenedSerializerField_t";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.var_type_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.var_name_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.bit_count = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.low_value = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.high_value = ::std::option::Option::Some(is.read_float()?);
                },
                48 => {
                    self.encode_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.field_serializer_name_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.field_serializer_version = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.send_node_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.var_encoder_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                90 => {
                    self.polymorphic_types.push(is.read_message()?);
                },
                96 => {
                    self.var_serializer_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.var_type_sym {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.var_name_sym {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.bit_count {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.low_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.high_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.encode_flags {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.field_serializer_name_sym {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.field_serializer_version {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.send_node_sym {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.var_encoder_sym {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        for value in &self.polymorphic_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.var_serializer_sym {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.var_type_sym {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.var_name_sym {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.bit_count {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.low_value {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.high_value {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.encode_flags {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.field_serializer_name_sym {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.field_serializer_version {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.send_node_sym {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.var_encoder_sym {
            os.write_int32(10, v)?;
        }
        for v in &self.polymorphic_types {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.var_serializer_sym {
            os.write_int32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoFlattenedSerializerField_t {
        ProtoFlattenedSerializerField_t::new()
    }

    fn clear(&mut self) {
        self.var_type_sym = ::std::option::Option::None;
        self.var_name_sym = ::std::option::Option::None;
        self.bit_count = ::std::option::Option::None;
        self.low_value = ::std::option::Option::None;
        self.high_value = ::std::option::Option::None;
        self.encode_flags = ::std::option::Option::None;
        self.field_serializer_name_sym = ::std::option::Option::None;
        self.field_serializer_version = ::std::option::Option::None;
        self.send_node_sym = ::std::option::Option::None;
        self.var_encoder_sym = ::std::option::Option::None;
        self.polymorphic_types.clear();
        self.var_serializer_sym = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoFlattenedSerializerField_t {
        static instance: ProtoFlattenedSerializerField_t = ProtoFlattenedSerializerField_t {
            var_type_sym: ::std::option::Option::None,
            var_name_sym: ::std::option::Option::None,
            bit_count: ::std::option::Option::None,
            low_value: ::std::option::Option::None,
            high_value: ::std::option::Option::None,
            encode_flags: ::std::option::Option::None,
            field_serializer_name_sym: ::std::option::Option::None,
            field_serializer_version: ::std::option::Option::None,
            send_node_sym: ::std::option::Option::None,
            var_encoder_sym: ::std::option::Option::None,
            polymorphic_types: ::std::vec::Vec::new(),
            var_serializer_sym: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoFlattenedSerializerField_t {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoFlattenedSerializerField_t").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoFlattenedSerializerField_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoFlattenedSerializerField_t {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ProtoFlattenedSerializerField_t`
pub mod proto_flattened_serializer_field_t {
    // @@protoc_insertion_point(message:ProtoFlattenedSerializerField_t.polymorphic_field_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Polymorphic_field_t {
        // message fields
        // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.polymorphic_field_t.polymorphic_field_serializer_name_sym)
        pub polymorphic_field_serializer_name_sym: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:ProtoFlattenedSerializerField_t.polymorphic_field_t.polymorphic_field_serializer_version)
        pub polymorphic_field_serializer_version: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:ProtoFlattenedSerializerField_t.polymorphic_field_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Polymorphic_field_t {
        fn default() -> &'a Polymorphic_field_t {
            <Polymorphic_field_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Polymorphic_field_t {
        pub fn new() -> Polymorphic_field_t {
            ::std::default::Default::default()
        }

        // optional int32 polymorphic_field_serializer_name_sym = 1;

        pub fn polymorphic_field_serializer_name_sym(&self) -> i32 {
            self.polymorphic_field_serializer_name_sym.unwrap_or(0)
        }

        pub fn clear_polymorphic_field_serializer_name_sym(&mut self) {
            self.polymorphic_field_serializer_name_sym = ::std::option::Option::None;
        }

        pub fn has_polymorphic_field_serializer_name_sym(&self) -> bool {
            self.polymorphic_field_serializer_name_sym.is_some()
        }

        // Param is passed by value, moved
        pub fn set_polymorphic_field_serializer_name_sym(&mut self, v: i32) {
            self.polymorphic_field_serializer_name_sym = ::std::option::Option::Some(v);
        }

        // optional int32 polymorphic_field_serializer_version = 2;

        pub fn polymorphic_field_serializer_version(&self) -> i32 {
            self.polymorphic_field_serializer_version.unwrap_or(0)
        }

        pub fn clear_polymorphic_field_serializer_version(&mut self) {
            self.polymorphic_field_serializer_version = ::std::option::Option::None;
        }

        pub fn has_polymorphic_field_serializer_version(&self) -> bool {
            self.polymorphic_field_serializer_version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_polymorphic_field_serializer_version(&mut self, v: i32) {
            self.polymorphic_field_serializer_version = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "polymorphic_field_serializer_name_sym",
                |m: &Polymorphic_field_t| { &m.polymorphic_field_serializer_name_sym },
                |m: &mut Polymorphic_field_t| { &mut m.polymorphic_field_serializer_name_sym },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "polymorphic_field_serializer_version",
                |m: &Polymorphic_field_t| { &m.polymorphic_field_serializer_version },
                |m: &mut Polymorphic_field_t| { &mut m.polymorphic_field_serializer_version },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Polymorphic_field_t>(
                "ProtoFlattenedSerializerField_t.polymorphic_field_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Polymorphic_field_t {
        const NAME: &'static str = "polymorphic_field_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.polymorphic_field_serializer_name_sym = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.polymorphic_field_serializer_version = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.polymorphic_field_serializer_name_sym {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.polymorphic_field_serializer_version {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.polymorphic_field_serializer_name_sym {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.polymorphic_field_serializer_version {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Polymorphic_field_t {
            Polymorphic_field_t::new()
        }

        fn clear(&mut self) {
            self.polymorphic_field_serializer_name_sym = ::std::option::Option::None;
            self.polymorphic_field_serializer_version = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Polymorphic_field_t {
            static instance: Polymorphic_field_t = Polymorphic_field_t {
                polymorphic_field_serializer_name_sym: ::std::option::Option::None,
                polymorphic_field_serializer_version: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Polymorphic_field_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ProtoFlattenedSerializerField_t.polymorphic_field_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Polymorphic_field_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Polymorphic_field_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:ProtoFlattenedSerializer_t)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoFlattenedSerializer_t {
    // message fields
    // @@protoc_insertion_point(field:ProtoFlattenedSerializer_t.serializer_name_sym)
    pub serializer_name_sym: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializer_t.serializer_version)
    pub serializer_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoFlattenedSerializer_t.fields_index)
    pub fields_index: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoFlattenedSerializer_t.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoFlattenedSerializer_t {
    fn default() -> &'a ProtoFlattenedSerializer_t {
        <ProtoFlattenedSerializer_t as ::protobuf::Message>::default_instance()
    }
}

impl ProtoFlattenedSerializer_t {
    pub fn new() -> ProtoFlattenedSerializer_t {
        ::std::default::Default::default()
    }

    // optional int32 serializer_name_sym = 1;

    pub fn serializer_name_sym(&self) -> i32 {
        self.serializer_name_sym.unwrap_or(0)
    }

    pub fn clear_serializer_name_sym(&mut self) {
        self.serializer_name_sym = ::std::option::Option::None;
    }

    pub fn has_serializer_name_sym(&self) -> bool {
        self.serializer_name_sym.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serializer_name_sym(&mut self, v: i32) {
        self.serializer_name_sym = ::std::option::Option::Some(v);
    }

    // optional int32 serializer_version = 2;

    pub fn serializer_version(&self) -> i32 {
        self.serializer_version.unwrap_or(0)
    }

    pub fn clear_serializer_version(&mut self) {
        self.serializer_version = ::std::option::Option::None;
    }

    pub fn has_serializer_version(&self) -> bool {
        self.serializer_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serializer_version(&mut self, v: i32) {
        self.serializer_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serializer_name_sym",
            |m: &ProtoFlattenedSerializer_t| { &m.serializer_name_sym },
            |m: &mut ProtoFlattenedSerializer_t| { &mut m.serializer_name_sym },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serializer_version",
            |m: &ProtoFlattenedSerializer_t| { &m.serializer_version },
            |m: &mut ProtoFlattenedSerializer_t| { &mut m.serializer_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fields_index",
            |m: &ProtoFlattenedSerializer_t| { &m.fields_index },
            |m: &mut ProtoFlattenedSerializer_t| { &mut m.fields_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoFlattenedSerializer_t>(
            "ProtoFlattenedSerializer_t",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoFlattenedSerializer_t {
    const NAME: &'static str = "ProtoFlattenedSerializer_t";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.serializer_name_sym = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.serializer_version = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.fields_index)?;
                },
                24 => {
                    self.fields_index.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serializer_name_sym {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.serializer_version {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.fields_index {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serializer_name_sym {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.serializer_version {
            os.write_int32(2, v)?;
        }
        for v in &self.fields_index {
            os.write_int32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoFlattenedSerializer_t {
        ProtoFlattenedSerializer_t::new()
    }

    fn clear(&mut self) {
        self.serializer_name_sym = ::std::option::Option::None;
        self.serializer_version = ::std::option::Option::None;
        self.fields_index.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoFlattenedSerializer_t {
        static instance: ProtoFlattenedSerializer_t = ProtoFlattenedSerializer_t {
            serializer_name_sym: ::std::option::Option::None,
            serializer_version: ::std::option::Option::None,
            fields_index: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoFlattenedSerializer_t {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoFlattenedSerializer_t").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoFlattenedSerializer_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoFlattenedSerializer_t {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_FlattenedSerializer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_FlattenedSerializer {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_FlattenedSerializer.serializers)
    pub serializers: ::std::vec::Vec<ProtoFlattenedSerializer_t>,
    // @@protoc_insertion_point(field:CSVCMsg_FlattenedSerializer.symbols)
    pub symbols: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_FlattenedSerializer.fields)
    pub fields: ::std::vec::Vec<ProtoFlattenedSerializerField_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_FlattenedSerializer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_FlattenedSerializer {
    fn default() -> &'a CSVCMsg_FlattenedSerializer {
        <CSVCMsg_FlattenedSerializer as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_FlattenedSerializer {
    pub fn new() -> CSVCMsg_FlattenedSerializer {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "serializers",
            |m: &CSVCMsg_FlattenedSerializer| { &m.serializers },
            |m: &mut CSVCMsg_FlattenedSerializer| { &mut m.serializers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbols",
            |m: &CSVCMsg_FlattenedSerializer| { &m.symbols },
            |m: &mut CSVCMsg_FlattenedSerializer| { &mut m.symbols },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fields",
            |m: &CSVCMsg_FlattenedSerializer| { &m.fields },
            |m: &mut CSVCMsg_FlattenedSerializer| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_FlattenedSerializer>(
            "CSVCMsg_FlattenedSerializer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_FlattenedSerializer {
    const NAME: &'static str = "CSVCMsg_FlattenedSerializer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serializers.push(is.read_message()?);
                },
                18 => {
                    self.symbols.push(is.read_string()?);
                },
                26 => {
                    self.fields.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.serializers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.symbols {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.serializers {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.symbols {
            os.write_string(2, &v)?;
        };
        for v in &self.fields {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_FlattenedSerializer {
        CSVCMsg_FlattenedSerializer::new()
    }

    fn clear(&mut self) {
        self.serializers.clear();
        self.symbols.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_FlattenedSerializer {
        static instance: CSVCMsg_FlattenedSerializer = CSVCMsg_FlattenedSerializer {
            serializers: ::std::vec::Vec::new(),
            symbols: ::std::vec::Vec::new(),
            fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_FlattenedSerializer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_FlattenedSerializer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_FlattenedSerializer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_FlattenedSerializer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_StopSound)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_StopSound {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_StopSound.guid)
    pub guid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_StopSound.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_StopSound {
    fn default() -> &'a CSVCMsg_StopSound {
        <CSVCMsg_StopSound as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_StopSound {
    pub fn new() -> CSVCMsg_StopSound {
        ::std::default::Default::default()
    }

    // optional fixed32 guid = 1;

    pub fn guid(&self) -> u32 {
        self.guid.unwrap_or(0)
    }

    pub fn clear_guid(&mut self) {
        self.guid = ::std::option::Option::None;
    }

    pub fn has_guid(&self) -> bool {
        self.guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guid(&mut self, v: u32) {
        self.guid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guid",
            |m: &CSVCMsg_StopSound| { &m.guid },
            |m: &mut CSVCMsg_StopSound| { &mut m.guid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_StopSound>(
            "CSVCMsg_StopSound",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_StopSound {
    const NAME: &'static str = "CSVCMsg_StopSound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.guid = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guid {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.guid {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_StopSound {
        CSVCMsg_StopSound::new()
    }

    fn clear(&mut self) {
        self.guid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_StopSound {
        static instance: CSVCMsg_StopSound = CSVCMsg_StopSound {
            guid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_StopSound {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_StopSound").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_StopSound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_StopSound {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CBidirMsg_RebroadcastGameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBidirMsg_RebroadcastGameEvent {
    // message fields
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.posttoserver)
    pub posttoserver: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.buftype)
    pub buftype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.clientbitcount)
    pub clientbitcount: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastGameEvent.receivingclients)
    pub receivingclients: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CBidirMsg_RebroadcastGameEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBidirMsg_RebroadcastGameEvent {
    fn default() -> &'a CBidirMsg_RebroadcastGameEvent {
        <CBidirMsg_RebroadcastGameEvent as ::protobuf::Message>::default_instance()
    }
}

impl CBidirMsg_RebroadcastGameEvent {
    pub fn new() -> CBidirMsg_RebroadcastGameEvent {
        ::std::default::Default::default()
    }

    // optional bool posttoserver = 1;

    pub fn posttoserver(&self) -> bool {
        self.posttoserver.unwrap_or(false)
    }

    pub fn clear_posttoserver(&mut self) {
        self.posttoserver = ::std::option::Option::None;
    }

    pub fn has_posttoserver(&self) -> bool {
        self.posttoserver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posttoserver(&mut self, v: bool) {
        self.posttoserver = ::std::option::Option::Some(v);
    }

    // optional int32 buftype = 2;

    pub fn buftype(&self) -> i32 {
        self.buftype.unwrap_or(0)
    }

    pub fn clear_buftype(&mut self) {
        self.buftype = ::std::option::Option::None;
    }

    pub fn has_buftype(&self) -> bool {
        self.buftype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buftype(&mut self, v: i32) {
        self.buftype = ::std::option::Option::Some(v);
    }

    // optional uint32 clientbitcount = 3;

    pub fn clientbitcount(&self) -> u32 {
        self.clientbitcount.unwrap_or(0)
    }

    pub fn clear_clientbitcount(&mut self) {
        self.clientbitcount = ::std::option::Option::None;
    }

    pub fn has_clientbitcount(&self) -> bool {
        self.clientbitcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientbitcount(&mut self, v: u32) {
        self.clientbitcount = ::std::option::Option::Some(v);
    }

    // optional uint64 receivingclients = 4;

    pub fn receivingclients(&self) -> u64 {
        self.receivingclients.unwrap_or(0)
    }

    pub fn clear_receivingclients(&mut self) {
        self.receivingclients = ::std::option::Option::None;
    }

    pub fn has_receivingclients(&self) -> bool {
        self.receivingclients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receivingclients(&mut self, v: u64) {
        self.receivingclients = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "posttoserver",
            |m: &CBidirMsg_RebroadcastGameEvent| { &m.posttoserver },
            |m: &mut CBidirMsg_RebroadcastGameEvent| { &mut m.posttoserver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buftype",
            |m: &CBidirMsg_RebroadcastGameEvent| { &m.buftype },
            |m: &mut CBidirMsg_RebroadcastGameEvent| { &mut m.buftype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientbitcount",
            |m: &CBidirMsg_RebroadcastGameEvent| { &m.clientbitcount },
            |m: &mut CBidirMsg_RebroadcastGameEvent| { &mut m.clientbitcount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receivingclients",
            |m: &CBidirMsg_RebroadcastGameEvent| { &m.receivingclients },
            |m: &mut CBidirMsg_RebroadcastGameEvent| { &mut m.receivingclients },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CBidirMsg_RebroadcastGameEvent>(
            "CBidirMsg_RebroadcastGameEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CBidirMsg_RebroadcastGameEvent {
    const NAME: &'static str = "CBidirMsg_RebroadcastGameEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.posttoserver = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.buftype = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.clientbitcount = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.receivingclients = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.posttoserver {
            my_size += 1 + 1;
        }
        if let Some(v) = self.buftype {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.clientbitcount {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.receivingclients {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.posttoserver {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.buftype {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.clientbitcount {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.receivingclients {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBidirMsg_RebroadcastGameEvent {
        CBidirMsg_RebroadcastGameEvent::new()
    }

    fn clear(&mut self) {
        self.posttoserver = ::std::option::Option::None;
        self.buftype = ::std::option::Option::None;
        self.clientbitcount = ::std::option::Option::None;
        self.receivingclients = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBidirMsg_RebroadcastGameEvent {
        static instance: CBidirMsg_RebroadcastGameEvent = CBidirMsg_RebroadcastGameEvent {
            posttoserver: ::std::option::Option::None,
            buftype: ::std::option::Option::None,
            clientbitcount: ::std::option::Option::None,
            receivingclients: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CBidirMsg_RebroadcastGameEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CBidirMsg_RebroadcastGameEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CBidirMsg_RebroadcastGameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBidirMsg_RebroadcastGameEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CBidirMsg_RebroadcastSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CBidirMsg_RebroadcastSource {
    // message fields
    // @@protoc_insertion_point(field:CBidirMsg_RebroadcastSource.eventsource)
    pub eventsource: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CBidirMsg_RebroadcastSource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CBidirMsg_RebroadcastSource {
    fn default() -> &'a CBidirMsg_RebroadcastSource {
        <CBidirMsg_RebroadcastSource as ::protobuf::Message>::default_instance()
    }
}

impl CBidirMsg_RebroadcastSource {
    pub fn new() -> CBidirMsg_RebroadcastSource {
        ::std::default::Default::default()
    }

    // optional int32 eventsource = 1;

    pub fn eventsource(&self) -> i32 {
        self.eventsource.unwrap_or(0)
    }

    pub fn clear_eventsource(&mut self) {
        self.eventsource = ::std::option::Option::None;
    }

    pub fn has_eventsource(&self) -> bool {
        self.eventsource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventsource(&mut self, v: i32) {
        self.eventsource = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventsource",
            |m: &CBidirMsg_RebroadcastSource| { &m.eventsource },
            |m: &mut CBidirMsg_RebroadcastSource| { &mut m.eventsource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CBidirMsg_RebroadcastSource>(
            "CBidirMsg_RebroadcastSource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CBidirMsg_RebroadcastSource {
    const NAME: &'static str = "CBidirMsg_RebroadcastSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eventsource = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eventsource {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eventsource {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CBidirMsg_RebroadcastSource {
        CBidirMsg_RebroadcastSource::new()
    }

    fn clear(&mut self) {
        self.eventsource = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CBidirMsg_RebroadcastSource {
        static instance: CBidirMsg_RebroadcastSource = CBidirMsg_RebroadcastSource {
            eventsource: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CBidirMsg_RebroadcastSource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CBidirMsg_RebroadcastSource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CBidirMsg_RebroadcastSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBidirMsg_RebroadcastSource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgServerNetworkStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerNetworkStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.dedicated)
    pub dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.cpu_usage)
    pub cpu_usage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.memory_used_mb)
    pub memory_used_mb: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.memory_free_mb)
    pub memory_free_mb: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.uptime)
    pub uptime: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.spawn_count)
    pub spawn_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_clients)
    pub num_clients: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_bots)
    pub num_bots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_spectators)
    pub num_spectators: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.num_tv_relays)
    pub num_tv_relays: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.fps)
    pub fps: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.ports)
    pub ports: ::std::vec::Vec<cmsg_server_network_stats::Port>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_ping_ms)
    pub avg_ping_ms: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_engine_latency_out)
    pub avg_engine_latency_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_packets_out)
    pub avg_packets_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_packets_in)
    pub avg_packets_in: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_loss_out)
    pub avg_loss_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_loss_in)
    pub avg_loss_in: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_data_out)
    pub avg_data_out: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.avg_data_in)
    pub avg_data_in: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_data_in)
    pub total_data_in: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_packets_in)
    pub total_packets_in: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_data_out)
    pub total_data_out: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.total_packets_out)
    pub total_packets_out: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerNetworkStats.players)
    pub players: ::std::vec::Vec<cmsg_server_network_stats::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerNetworkStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerNetworkStats {
    fn default() -> &'a CMsgServerNetworkStats {
        <CMsgServerNetworkStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerNetworkStats {
    pub fn new() -> CMsgServerNetworkStats {
        ::std::default::Default::default()
    }

    // optional bool dedicated = 1;

    pub fn dedicated(&self) -> bool {
        self.dedicated.unwrap_or(false)
    }

    pub fn clear_dedicated(&mut self) {
        self.dedicated = ::std::option::Option::None;
    }

    pub fn has_dedicated(&self) -> bool {
        self.dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dedicated(&mut self, v: bool) {
        self.dedicated = ::std::option::Option::Some(v);
    }

    // optional int32 cpu_usage = 2;

    pub fn cpu_usage(&self) -> i32 {
        self.cpu_usage.unwrap_or(0)
    }

    pub fn clear_cpu_usage(&mut self) {
        self.cpu_usage = ::std::option::Option::None;
    }

    pub fn has_cpu_usage(&self) -> bool {
        self.cpu_usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_usage(&mut self, v: i32) {
        self.cpu_usage = ::std::option::Option::Some(v);
    }

    // optional int32 memory_used_mb = 3;

    pub fn memory_used_mb(&self) -> i32 {
        self.memory_used_mb.unwrap_or(0)
    }

    pub fn clear_memory_used_mb(&mut self) {
        self.memory_used_mb = ::std::option::Option::None;
    }

    pub fn has_memory_used_mb(&self) -> bool {
        self.memory_used_mb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_used_mb(&mut self, v: i32) {
        self.memory_used_mb = ::std::option::Option::Some(v);
    }

    // optional int32 memory_free_mb = 4;

    pub fn memory_free_mb(&self) -> i32 {
        self.memory_free_mb.unwrap_or(0)
    }

    pub fn clear_memory_free_mb(&mut self) {
        self.memory_free_mb = ::std::option::Option::None;
    }

    pub fn has_memory_free_mb(&self) -> bool {
        self.memory_free_mb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_memory_free_mb(&mut self, v: i32) {
        self.memory_free_mb = ::std::option::Option::Some(v);
    }

    // optional int32 uptime = 5;

    pub fn uptime(&self) -> i32 {
        self.uptime.unwrap_or(0)
    }

    pub fn clear_uptime(&mut self) {
        self.uptime = ::std::option::Option::None;
    }

    pub fn has_uptime(&self) -> bool {
        self.uptime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uptime(&mut self, v: i32) {
        self.uptime = ::std::option::Option::Some(v);
    }

    // optional int32 spawn_count = 6;

    pub fn spawn_count(&self) -> i32 {
        self.spawn_count.unwrap_or(0)
    }

    pub fn clear_spawn_count(&mut self) {
        self.spawn_count = ::std::option::Option::None;
    }

    pub fn has_spawn_count(&self) -> bool {
        self.spawn_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawn_count(&mut self, v: i32) {
        self.spawn_count = ::std::option::Option::Some(v);
    }

    // optional int32 num_clients = 8;

    pub fn num_clients(&self) -> i32 {
        self.num_clients.unwrap_or(0)
    }

    pub fn clear_num_clients(&mut self) {
        self.num_clients = ::std::option::Option::None;
    }

    pub fn has_num_clients(&self) -> bool {
        self.num_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_clients(&mut self, v: i32) {
        self.num_clients = ::std::option::Option::Some(v);
    }

    // optional int32 num_bots = 9;

    pub fn num_bots(&self) -> i32 {
        self.num_bots.unwrap_or(0)
    }

    pub fn clear_num_bots(&mut self) {
        self.num_bots = ::std::option::Option::None;
    }

    pub fn has_num_bots(&self) -> bool {
        self.num_bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_bots(&mut self, v: i32) {
        self.num_bots = ::std::option::Option::Some(v);
    }

    // optional int32 num_spectators = 10;

    pub fn num_spectators(&self) -> i32 {
        self.num_spectators.unwrap_or(0)
    }

    pub fn clear_num_spectators(&mut self) {
        self.num_spectators = ::std::option::Option::None;
    }

    pub fn has_num_spectators(&self) -> bool {
        self.num_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_spectators(&mut self, v: i32) {
        self.num_spectators = ::std::option::Option::Some(v);
    }

    // optional int32 num_tv_relays = 11;

    pub fn num_tv_relays(&self) -> i32 {
        self.num_tv_relays.unwrap_or(0)
    }

    pub fn clear_num_tv_relays(&mut self) {
        self.num_tv_relays = ::std::option::Option::None;
    }

    pub fn has_num_tv_relays(&self) -> bool {
        self.num_tv_relays.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_tv_relays(&mut self, v: i32) {
        self.num_tv_relays = ::std::option::Option::Some(v);
    }

    // optional float fps = 12;

    pub fn fps(&self) -> f32 {
        self.fps.unwrap_or(0.)
    }

    pub fn clear_fps(&mut self) {
        self.fps = ::std::option::Option::None;
    }

    pub fn has_fps(&self) -> bool {
        self.fps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fps(&mut self, v: f32) {
        self.fps = ::std::option::Option::Some(v);
    }

    // optional float avg_ping_ms = 18;

    pub fn avg_ping_ms(&self) -> f32 {
        self.avg_ping_ms.unwrap_or(0.)
    }

    pub fn clear_avg_ping_ms(&mut self) {
        self.avg_ping_ms = ::std::option::Option::None;
    }

    pub fn has_avg_ping_ms(&self) -> bool {
        self.avg_ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_ping_ms(&mut self, v: f32) {
        self.avg_ping_ms = ::std::option::Option::Some(v);
    }

    // optional float avg_engine_latency_out = 19;

    pub fn avg_engine_latency_out(&self) -> f32 {
        self.avg_engine_latency_out.unwrap_or(0.)
    }

    pub fn clear_avg_engine_latency_out(&mut self) {
        self.avg_engine_latency_out = ::std::option::Option::None;
    }

    pub fn has_avg_engine_latency_out(&self) -> bool {
        self.avg_engine_latency_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_engine_latency_out(&mut self, v: f32) {
        self.avg_engine_latency_out = ::std::option::Option::Some(v);
    }

    // optional float avg_packets_out = 20;

    pub fn avg_packets_out(&self) -> f32 {
        self.avg_packets_out.unwrap_or(0.)
    }

    pub fn clear_avg_packets_out(&mut self) {
        self.avg_packets_out = ::std::option::Option::None;
    }

    pub fn has_avg_packets_out(&self) -> bool {
        self.avg_packets_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_packets_out(&mut self, v: f32) {
        self.avg_packets_out = ::std::option::Option::Some(v);
    }

    // optional float avg_packets_in = 21;

    pub fn avg_packets_in(&self) -> f32 {
        self.avg_packets_in.unwrap_or(0.)
    }

    pub fn clear_avg_packets_in(&mut self) {
        self.avg_packets_in = ::std::option::Option::None;
    }

    pub fn has_avg_packets_in(&self) -> bool {
        self.avg_packets_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_packets_in(&mut self, v: f32) {
        self.avg_packets_in = ::std::option::Option::Some(v);
    }

    // optional float avg_loss_out = 22;

    pub fn avg_loss_out(&self) -> f32 {
        self.avg_loss_out.unwrap_or(0.)
    }

    pub fn clear_avg_loss_out(&mut self) {
        self.avg_loss_out = ::std::option::Option::None;
    }

    pub fn has_avg_loss_out(&self) -> bool {
        self.avg_loss_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_loss_out(&mut self, v: f32) {
        self.avg_loss_out = ::std::option::Option::Some(v);
    }

    // optional float avg_loss_in = 23;

    pub fn avg_loss_in(&self) -> f32 {
        self.avg_loss_in.unwrap_or(0.)
    }

    pub fn clear_avg_loss_in(&mut self) {
        self.avg_loss_in = ::std::option::Option::None;
    }

    pub fn has_avg_loss_in(&self) -> bool {
        self.avg_loss_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_loss_in(&mut self, v: f32) {
        self.avg_loss_in = ::std::option::Option::Some(v);
    }

    // optional float avg_data_out = 24;

    pub fn avg_data_out(&self) -> f32 {
        self.avg_data_out.unwrap_or(0.)
    }

    pub fn clear_avg_data_out(&mut self) {
        self.avg_data_out = ::std::option::Option::None;
    }

    pub fn has_avg_data_out(&self) -> bool {
        self.avg_data_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_data_out(&mut self, v: f32) {
        self.avg_data_out = ::std::option::Option::Some(v);
    }

    // optional float avg_data_in = 25;

    pub fn avg_data_in(&self) -> f32 {
        self.avg_data_in.unwrap_or(0.)
    }

    pub fn clear_avg_data_in(&mut self) {
        self.avg_data_in = ::std::option::Option::None;
    }

    pub fn has_avg_data_in(&self) -> bool {
        self.avg_data_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_data_in(&mut self, v: f32) {
        self.avg_data_in = ::std::option::Option::Some(v);
    }

    // optional uint64 total_data_in = 26;

    pub fn total_data_in(&self) -> u64 {
        self.total_data_in.unwrap_or(0)
    }

    pub fn clear_total_data_in(&mut self) {
        self.total_data_in = ::std::option::Option::None;
    }

    pub fn has_total_data_in(&self) -> bool {
        self.total_data_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_data_in(&mut self, v: u64) {
        self.total_data_in = ::std::option::Option::Some(v);
    }

    // optional uint64 total_packets_in = 27;

    pub fn total_packets_in(&self) -> u64 {
        self.total_packets_in.unwrap_or(0)
    }

    pub fn clear_total_packets_in(&mut self) {
        self.total_packets_in = ::std::option::Option::None;
    }

    pub fn has_total_packets_in(&self) -> bool {
        self.total_packets_in.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_packets_in(&mut self, v: u64) {
        self.total_packets_in = ::std::option::Option::Some(v);
    }

    // optional uint64 total_data_out = 28;

    pub fn total_data_out(&self) -> u64 {
        self.total_data_out.unwrap_or(0)
    }

    pub fn clear_total_data_out(&mut self) {
        self.total_data_out = ::std::option::Option::None;
    }

    pub fn has_total_data_out(&self) -> bool {
        self.total_data_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_data_out(&mut self, v: u64) {
        self.total_data_out = ::std::option::Option::Some(v);
    }

    // optional uint64 total_packets_out = 29;

    pub fn total_packets_out(&self) -> u64 {
        self.total_packets_out.unwrap_or(0)
    }

    pub fn clear_total_packets_out(&mut self) {
        self.total_packets_out = ::std::option::Option::None;
    }

    pub fn has_total_packets_out(&self) -> bool {
        self.total_packets_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_packets_out(&mut self, v: u64) {
        self.total_packets_out = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dedicated",
            |m: &CMsgServerNetworkStats| { &m.dedicated },
            |m: &mut CMsgServerNetworkStats| { &mut m.dedicated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cpu_usage",
            |m: &CMsgServerNetworkStats| { &m.cpu_usage },
            |m: &mut CMsgServerNetworkStats| { &mut m.cpu_usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "memory_used_mb",
            |m: &CMsgServerNetworkStats| { &m.memory_used_mb },
            |m: &mut CMsgServerNetworkStats| { &mut m.memory_used_mb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "memory_free_mb",
            |m: &CMsgServerNetworkStats| { &m.memory_free_mb },
            |m: &mut CMsgServerNetworkStats| { &mut m.memory_free_mb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uptime",
            |m: &CMsgServerNetworkStats| { &m.uptime },
            |m: &mut CMsgServerNetworkStats| { &mut m.uptime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawn_count",
            |m: &CMsgServerNetworkStats| { &m.spawn_count },
            |m: &mut CMsgServerNetworkStats| { &mut m.spawn_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_clients",
            |m: &CMsgServerNetworkStats| { &m.num_clients },
            |m: &mut CMsgServerNetworkStats| { &mut m.num_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_bots",
            |m: &CMsgServerNetworkStats| { &m.num_bots },
            |m: &mut CMsgServerNetworkStats| { &mut m.num_bots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_spectators",
            |m: &CMsgServerNetworkStats| { &m.num_spectators },
            |m: &mut CMsgServerNetworkStats| { &mut m.num_spectators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_tv_relays",
            |m: &CMsgServerNetworkStats| { &m.num_tv_relays },
            |m: &mut CMsgServerNetworkStats| { &mut m.num_tv_relays },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fps",
            |m: &CMsgServerNetworkStats| { &m.fps },
            |m: &mut CMsgServerNetworkStats| { &mut m.fps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ports",
            |m: &CMsgServerNetworkStats| { &m.ports },
            |m: &mut CMsgServerNetworkStats| { &mut m.ports },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_ping_ms",
            |m: &CMsgServerNetworkStats| { &m.avg_ping_ms },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_ping_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_engine_latency_out",
            |m: &CMsgServerNetworkStats| { &m.avg_engine_latency_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_engine_latency_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_packets_out",
            |m: &CMsgServerNetworkStats| { &m.avg_packets_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_packets_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_packets_in",
            |m: &CMsgServerNetworkStats| { &m.avg_packets_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_packets_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_loss_out",
            |m: &CMsgServerNetworkStats| { &m.avg_loss_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_loss_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_loss_in",
            |m: &CMsgServerNetworkStats| { &m.avg_loss_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_loss_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_data_out",
            |m: &CMsgServerNetworkStats| { &m.avg_data_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_data_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "avg_data_in",
            |m: &CMsgServerNetworkStats| { &m.avg_data_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.avg_data_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_data_in",
            |m: &CMsgServerNetworkStats| { &m.total_data_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.total_data_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_packets_in",
            |m: &CMsgServerNetworkStats| { &m.total_packets_in },
            |m: &mut CMsgServerNetworkStats| { &mut m.total_packets_in },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_data_out",
            |m: &CMsgServerNetworkStats| { &m.total_data_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.total_data_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_packets_out",
            |m: &CMsgServerNetworkStats| { &m.total_packets_out },
            |m: &mut CMsgServerNetworkStats| { &mut m.total_packets_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgServerNetworkStats| { &m.players },
            |m: &mut CMsgServerNetworkStats| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerNetworkStats>(
            "CMsgServerNetworkStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerNetworkStats {
    const NAME: &'static str = "CMsgServerNetworkStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.cpu_usage = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.memory_used_mb = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.memory_free_mb = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.uptime = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.spawn_count = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.num_clients = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.num_bots = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.num_spectators = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.num_tv_relays = ::std::option::Option::Some(is.read_int32()?);
                },
                101 => {
                    self.fps = ::std::option::Option::Some(is.read_float()?);
                },
                138 => {
                    self.ports.push(is.read_message()?);
                },
                149 => {
                    self.avg_ping_ms = ::std::option::Option::Some(is.read_float()?);
                },
                157 => {
                    self.avg_engine_latency_out = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.avg_packets_out = ::std::option::Option::Some(is.read_float()?);
                },
                173 => {
                    self.avg_packets_in = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.avg_loss_out = ::std::option::Option::Some(is.read_float()?);
                },
                189 => {
                    self.avg_loss_in = ::std::option::Option::Some(is.read_float()?);
                },
                197 => {
                    self.avg_data_out = ::std::option::Option::Some(is.read_float()?);
                },
                205 => {
                    self.avg_data_in = ::std::option::Option::Some(is.read_float()?);
                },
                208 => {
                    self.total_data_in = ::std::option::Option::Some(is.read_uint64()?);
                },
                216 => {
                    self.total_packets_in = ::std::option::Option::Some(is.read_uint64()?);
                },
                224 => {
                    self.total_data_out = ::std::option::Option::Some(is.read_uint64()?);
                },
                232 => {
                    self.total_packets_out = ::std::option::Option::Some(is.read_uint64()?);
                },
                242 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dedicated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cpu_usage {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.memory_used_mb {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.memory_free_mb {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.uptime {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.spawn_count {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.num_clients {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.num_bots {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.num_spectators {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.num_tv_relays {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.fps {
            my_size += 1 + 4;
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.avg_ping_ms {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_engine_latency_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_packets_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_packets_in {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_loss_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_loss_in {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_data_out {
            my_size += 2 + 4;
        }
        if let Some(v) = self.avg_data_in {
            my_size += 2 + 4;
        }
        if let Some(v) = self.total_data_in {
            my_size += ::protobuf::rt::uint64_size(26, v);
        }
        if let Some(v) = self.total_packets_in {
            my_size += ::protobuf::rt::uint64_size(27, v);
        }
        if let Some(v) = self.total_data_out {
            my_size += ::protobuf::rt::uint64_size(28, v);
        }
        if let Some(v) = self.total_packets_out {
            my_size += ::protobuf::rt::uint64_size(29, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dedicated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.cpu_usage {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.memory_used_mb {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.memory_free_mb {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.uptime {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.spawn_count {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.num_clients {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.num_bots {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.num_spectators {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.num_tv_relays {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.fps {
            os.write_float(12, v)?;
        }
        for v in &self.ports {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.avg_ping_ms {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.avg_engine_latency_out {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.avg_packets_out {
            os.write_float(20, v)?;
        }
        if let Some(v) = self.avg_packets_in {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.avg_loss_out {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.avg_loss_in {
            os.write_float(23, v)?;
        }
        if let Some(v) = self.avg_data_out {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.avg_data_in {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.total_data_in {
            os.write_uint64(26, v)?;
        }
        if let Some(v) = self.total_packets_in {
            os.write_uint64(27, v)?;
        }
        if let Some(v) = self.total_data_out {
            os.write_uint64(28, v)?;
        }
        if let Some(v) = self.total_packets_out {
            os.write_uint64(29, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerNetworkStats {
        CMsgServerNetworkStats::new()
    }

    fn clear(&mut self) {
        self.dedicated = ::std::option::Option::None;
        self.cpu_usage = ::std::option::Option::None;
        self.memory_used_mb = ::std::option::Option::None;
        self.memory_free_mb = ::std::option::Option::None;
        self.uptime = ::std::option::Option::None;
        self.spawn_count = ::std::option::Option::None;
        self.num_clients = ::std::option::Option::None;
        self.num_bots = ::std::option::Option::None;
        self.num_spectators = ::std::option::Option::None;
        self.num_tv_relays = ::std::option::Option::None;
        self.fps = ::std::option::Option::None;
        self.ports.clear();
        self.avg_ping_ms = ::std::option::Option::None;
        self.avg_engine_latency_out = ::std::option::Option::None;
        self.avg_packets_out = ::std::option::Option::None;
        self.avg_packets_in = ::std::option::Option::None;
        self.avg_loss_out = ::std::option::Option::None;
        self.avg_loss_in = ::std::option::Option::None;
        self.avg_data_out = ::std::option::Option::None;
        self.avg_data_in = ::std::option::Option::None;
        self.total_data_in = ::std::option::Option::None;
        self.total_packets_in = ::std::option::Option::None;
        self.total_data_out = ::std::option::Option::None;
        self.total_packets_out = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerNetworkStats {
        static instance: CMsgServerNetworkStats = CMsgServerNetworkStats {
            dedicated: ::std::option::Option::None,
            cpu_usage: ::std::option::Option::None,
            memory_used_mb: ::std::option::Option::None,
            memory_free_mb: ::std::option::Option::None,
            uptime: ::std::option::Option::None,
            spawn_count: ::std::option::Option::None,
            num_clients: ::std::option::Option::None,
            num_bots: ::std::option::Option::None,
            num_spectators: ::std::option::Option::None,
            num_tv_relays: ::std::option::Option::None,
            fps: ::std::option::Option::None,
            ports: ::std::vec::Vec::new(),
            avg_ping_ms: ::std::option::Option::None,
            avg_engine_latency_out: ::std::option::Option::None,
            avg_packets_out: ::std::option::Option::None,
            avg_packets_in: ::std::option::Option::None,
            avg_loss_out: ::std::option::Option::None,
            avg_loss_in: ::std::option::Option::None,
            avg_data_out: ::std::option::Option::None,
            avg_data_in: ::std::option::Option::None,
            total_data_in: ::std::option::Option::None,
            total_packets_in: ::std::option::Option::None,
            total_data_out: ::std::option::Option::None,
            total_packets_out: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerNetworkStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerNetworkStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerNetworkStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerNetworkStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgServerNetworkStats`
pub mod cmsg_server_network_stats {
    // @@protoc_insertion_point(message:CMsgServerNetworkStats.Port)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Port {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Port.port)
        pub port: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Port.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerNetworkStats.Port.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Port {
        fn default() -> &'a Port {
            <Port as ::protobuf::Message>::default_instance()
        }
    }

    impl Port {
        pub fn new() -> Port {
            ::std::default::Default::default()
        }

        // optional int32 port = 1;

        pub fn port(&self) -> i32 {
            self.port.unwrap_or(0)
        }

        pub fn clear_port(&mut self) {
            self.port = ::std::option::Option::None;
        }

        pub fn has_port(&self) -> bool {
            self.port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_port(&mut self, v: i32) {
            self.port = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "port",
                |m: &Port| { &m.port },
                |m: &mut Port| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Port| { &m.name },
                |m: &mut Port| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Port>(
                "CMsgServerNetworkStats.Port",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Port {
        const NAME: &'static str = "Port";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.port = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.port {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.port {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Port {
            Port::new()
        }

        fn clear(&mut self) {
            self.port = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Port {
            static instance: Port = Port {
                port: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Port {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerNetworkStats.Port").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Port {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Port {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgServerNetworkStats.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.remote_addr)
        pub remote_addr: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.ping_avg_ms)
        pub ping_avg_ms: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.packet_loss_pct)
        pub packet_loss_pct: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.is_bot)
        pub is_bot: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.loss_in)
        pub loss_in: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.loss_out)
        pub loss_out: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgServerNetworkStats.Player.engine_latency_ms)
        pub engine_latency_ms: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerNetworkStats.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional string remote_addr = 2;

        pub fn remote_addr(&self) -> &str {
            match self.remote_addr.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_remote_addr(&mut self) {
            self.remote_addr = ::std::option::Option::None;
        }

        pub fn has_remote_addr(&self) -> bool {
            self.remote_addr.is_some()
        }

        // Param is passed by value, moved
        pub fn set_remote_addr(&mut self, v: ::std::string::String) {
            self.remote_addr = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_remote_addr(&mut self) -> &mut ::std::string::String {
            if self.remote_addr.is_none() {
                self.remote_addr = ::std::option::Option::Some(::std::string::String::new());
            }
            self.remote_addr.as_mut().unwrap()
        }

        // Take field
        pub fn take_remote_addr(&mut self) -> ::std::string::String {
            self.remote_addr.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 ping_avg_ms = 4;

        pub fn ping_avg_ms(&self) -> i32 {
            self.ping_avg_ms.unwrap_or(0)
        }

        pub fn clear_ping_avg_ms(&mut self) {
            self.ping_avg_ms = ::std::option::Option::None;
        }

        pub fn has_ping_avg_ms(&self) -> bool {
            self.ping_avg_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_avg_ms(&mut self, v: i32) {
            self.ping_avg_ms = ::std::option::Option::Some(v);
        }

        // optional float packet_loss_pct = 5;

        pub fn packet_loss_pct(&self) -> f32 {
            self.packet_loss_pct.unwrap_or(0.)
        }

        pub fn clear_packet_loss_pct(&mut self) {
            self.packet_loss_pct = ::std::option::Option::None;
        }

        pub fn has_packet_loss_pct(&self) -> bool {
            self.packet_loss_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packet_loss_pct(&mut self, v: f32) {
            self.packet_loss_pct = ::std::option::Option::Some(v);
        }

        // optional bool is_bot = 6;

        pub fn is_bot(&self) -> bool {
            self.is_bot.unwrap_or(false)
        }

        pub fn clear_is_bot(&mut self) {
            self.is_bot = ::std::option::Option::None;
        }

        pub fn has_is_bot(&self) -> bool {
            self.is_bot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_bot(&mut self, v: bool) {
            self.is_bot = ::std::option::Option::Some(v);
        }

        // optional float loss_in = 7;

        pub fn loss_in(&self) -> f32 {
            self.loss_in.unwrap_or(0.)
        }

        pub fn clear_loss_in(&mut self) {
            self.loss_in = ::std::option::Option::None;
        }

        pub fn has_loss_in(&self) -> bool {
            self.loss_in.is_some()
        }

        // Param is passed by value, moved
        pub fn set_loss_in(&mut self, v: f32) {
            self.loss_in = ::std::option::Option::Some(v);
        }

        // optional float loss_out = 8;

        pub fn loss_out(&self) -> f32 {
            self.loss_out.unwrap_or(0.)
        }

        pub fn clear_loss_out(&mut self) {
            self.loss_out = ::std::option::Option::None;
        }

        pub fn has_loss_out(&self) -> bool {
            self.loss_out.is_some()
        }

        // Param is passed by value, moved
        pub fn set_loss_out(&mut self, v: f32) {
            self.loss_out = ::std::option::Option::Some(v);
        }

        // optional int32 engine_latency_ms = 9;

        pub fn engine_latency_ms(&self) -> i32 {
            self.engine_latency_ms.unwrap_or(0)
        }

        pub fn clear_engine_latency_ms(&mut self) {
            self.engine_latency_ms = ::std::option::Option::None;
        }

        pub fn has_engine_latency_ms(&self) -> bool {
            self.engine_latency_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_engine_latency_ms(&mut self, v: i32) {
            self.engine_latency_ms = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &Player| { &m.steamid },
                |m: &mut Player| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "remote_addr",
                |m: &Player| { &m.remote_addr },
                |m: &mut Player| { &mut m.remote_addr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ping_avg_ms",
                |m: &Player| { &m.ping_avg_ms },
                |m: &mut Player| { &mut m.ping_avg_ms },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "packet_loss_pct",
                |m: &Player| { &m.packet_loss_pct },
                |m: &mut Player| { &mut m.packet_loss_pct },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_bot",
                |m: &Player| { &m.is_bot },
                |m: &mut Player| { &mut m.is_bot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "loss_in",
                |m: &Player| { &m.loss_in },
                |m: &mut Player| { &mut m.loss_in },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "loss_out",
                |m: &Player| { &m.loss_out },
                |m: &mut Player| { &mut m.loss_out },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "engine_latency_ms",
                |m: &Player| { &m.engine_latency_ms },
                |m: &mut Player| { &mut m.engine_latency_ms },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgServerNetworkStats.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.remote_addr = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.ping_avg_ms = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.packet_loss_pct = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.is_bot = ::std::option::Option::Some(is.read_bool()?);
                    },
                    61 => {
                        self.loss_in = ::std::option::Option::Some(is.read_float()?);
                    },
                    69 => {
                        self.loss_out = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.engine_latency_ms = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.remote_addr.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.ping_avg_ms {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.packet_loss_pct {
                my_size += 1 + 4;
            }
            if let Some(v) = self.is_bot {
                my_size += 1 + 1;
            }
            if let Some(v) = self.loss_in {
                my_size += 1 + 4;
            }
            if let Some(v) = self.loss_out {
                my_size += 1 + 4;
            }
            if let Some(v) = self.engine_latency_ms {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.remote_addr.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.ping_avg_ms {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.packet_loss_pct {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.is_bot {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.loss_in {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.loss_out {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.engine_latency_ms {
                os.write_int32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.remote_addr = ::std::option::Option::None;
            self.ping_avg_ms = ::std::option::Option::None;
            self.packet_loss_pct = ::std::option::Option::None;
            self.is_bot = ::std::option::Option::None;
            self.loss_in = ::std::option::Option::None;
            self.loss_out = ::std::option::Option::None;
            self.engine_latency_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steamid: ::std::option::Option::None,
                remote_addr: ::std::option::Option::None,
                ping_avg_ms: ::std::option::Option::None,
                packet_loss_pct: ::std::option::Option::None,
                is_bot: ::std::option::Option::None,
                loss_in: ::std::option::Option::None,
                loss_out: ::std::option::Option::None,
                engine_latency_ms: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgServerNetworkStats.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsg_HltvReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_HltvReplay {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.delay)
    pub delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.primary_target)
    pub primary_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_stop_at)
    pub replay_stop_at: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_start_at)
    pub replay_start_at: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_begin)
    pub replay_slowdown_begin: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_end)
    pub replay_slowdown_end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_rate)
    pub replay_slowdown_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.reason)
    pub reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_HltvReplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_HltvReplay {
    fn default() -> &'a CSVCMsg_HltvReplay {
        <CSVCMsg_HltvReplay as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_HltvReplay {
    pub fn new() -> CSVCMsg_HltvReplay {
        ::std::default::Default::default()
    }

    // optional int32 delay = 1;

    pub fn delay(&self) -> i32 {
        self.delay.unwrap_or(0)
    }

    pub fn clear_delay(&mut self) {
        self.delay = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: i32) {
        self.delay = ::std::option::Option::Some(v);
    }

    // optional int32 primary_target = 2;

    pub fn primary_target(&self) -> i32 {
        self.primary_target.unwrap_or(-1i32)
    }

    pub fn clear_primary_target(&mut self) {
        self.primary_target = ::std::option::Option::None;
    }

    pub fn has_primary_target(&self) -> bool {
        self.primary_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_target(&mut self, v: i32) {
        self.primary_target = ::std::option::Option::Some(v);
    }

    // optional int32 replay_stop_at = 3;

    pub fn replay_stop_at(&self) -> i32 {
        self.replay_stop_at.unwrap_or(0)
    }

    pub fn clear_replay_stop_at(&mut self) {
        self.replay_stop_at = ::std::option::Option::None;
    }

    pub fn has_replay_stop_at(&self) -> bool {
        self.replay_stop_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_stop_at(&mut self, v: i32) {
        self.replay_stop_at = ::std::option::Option::Some(v);
    }

    // optional int32 replay_start_at = 4;

    pub fn replay_start_at(&self) -> i32 {
        self.replay_start_at.unwrap_or(0)
    }

    pub fn clear_replay_start_at(&mut self) {
        self.replay_start_at = ::std::option::Option::None;
    }

    pub fn has_replay_start_at(&self) -> bool {
        self.replay_start_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_start_at(&mut self, v: i32) {
        self.replay_start_at = ::std::option::Option::Some(v);
    }

    // optional int32 replay_slowdown_begin = 5;

    pub fn replay_slowdown_begin(&self) -> i32 {
        self.replay_slowdown_begin.unwrap_or(0)
    }

    pub fn clear_replay_slowdown_begin(&mut self) {
        self.replay_slowdown_begin = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_begin(&self) -> bool {
        self.replay_slowdown_begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_begin(&mut self, v: i32) {
        self.replay_slowdown_begin = ::std::option::Option::Some(v);
    }

    // optional int32 replay_slowdown_end = 6;

    pub fn replay_slowdown_end(&self) -> i32 {
        self.replay_slowdown_end.unwrap_or(0)
    }

    pub fn clear_replay_slowdown_end(&mut self) {
        self.replay_slowdown_end = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_end(&self) -> bool {
        self.replay_slowdown_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_end(&mut self, v: i32) {
        self.replay_slowdown_end = ::std::option::Option::Some(v);
    }

    // optional float replay_slowdown_rate = 7;

    pub fn replay_slowdown_rate(&self) -> f32 {
        self.replay_slowdown_rate.unwrap_or(0.)
    }

    pub fn clear_replay_slowdown_rate(&mut self) {
        self.replay_slowdown_rate = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_rate(&self) -> bool {
        self.replay_slowdown_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_rate(&mut self, v: f32) {
        self.replay_slowdown_rate = ::std::option::Option::Some(v);
    }

    // optional int32 reason = 8;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delay",
            |m: &CSVCMsg_HltvReplay| { &m.delay },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_target",
            |m: &CSVCMsg_HltvReplay| { &m.primary_target },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.primary_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_stop_at",
            |m: &CSVCMsg_HltvReplay| { &m.replay_stop_at },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_stop_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_start_at",
            |m: &CSVCMsg_HltvReplay| { &m.replay_start_at },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_start_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_slowdown_begin",
            |m: &CSVCMsg_HltvReplay| { &m.replay_slowdown_begin },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_slowdown_begin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_slowdown_end",
            |m: &CSVCMsg_HltvReplay| { &m.replay_slowdown_end },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_slowdown_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_slowdown_rate",
            |m: &CSVCMsg_HltvReplay| { &m.replay_slowdown_rate },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_slowdown_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CSVCMsg_HltvReplay| { &m.reason },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_HltvReplay>(
            "CSVCMsg_HltvReplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_HltvReplay {
    const NAME: &'static str = "CSVCMsg_HltvReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.delay = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.primary_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.replay_stop_at = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.replay_start_at = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.replay_slowdown_begin = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.replay_slowdown_end = ::std::option::Option::Some(is.read_int32()?);
                },
                61 => {
                    self.replay_slowdown_rate = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.delay {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.primary_target {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.replay_stop_at {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.replay_start_at {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.replay_slowdown_begin {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.replay_slowdown_end {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.replay_slowdown_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.delay {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.primary_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.replay_stop_at {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.replay_start_at {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.replay_slowdown_begin {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.replay_slowdown_end {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.replay_slowdown_rate {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_HltvReplay {
        CSVCMsg_HltvReplay::new()
    }

    fn clear(&mut self) {
        self.delay = ::std::option::Option::None;
        self.primary_target = ::std::option::Option::None;
        self.replay_stop_at = ::std::option::Option::None;
        self.replay_start_at = ::std::option::Option::None;
        self.replay_slowdown_begin = ::std::option::Option::None;
        self.replay_slowdown_end = ::std::option::Option::None;
        self.replay_slowdown_rate = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_HltvReplay {
        static instance: CSVCMsg_HltvReplay = CSVCMsg_HltvReplay {
            delay: ::std::option::Option::None,
            primary_target: ::std::option::Option::None,
            replay_stop_at: ::std::option::Option::None,
            replay_start_at: ::std::option::Option::None,
            replay_slowdown_begin: ::std::option::Option::None,
            replay_slowdown_end: ::std::option::Option::None,
            replay_slowdown_rate: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_HltvReplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_HltvReplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_HltvReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_HltvReplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_HltvReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_HltvReplay {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.request)
    pub request: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.slowdown_length)
    pub slowdown_length: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.slowdown_rate)
    pub slowdown_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.primary_target)
    pub primary_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.event_time)
    pub event_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_HltvReplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_HltvReplay {
    fn default() -> &'a CCLCMsg_HltvReplay {
        <CCLCMsg_HltvReplay as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_HltvReplay {
    pub fn new() -> CCLCMsg_HltvReplay {
        ::std::default::Default::default()
    }

    // optional int32 request = 1;

    pub fn request(&self) -> i32 {
        self.request.unwrap_or(0)
    }

    pub fn clear_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: i32) {
        self.request = ::std::option::Option::Some(v);
    }

    // optional float slowdown_length = 2;

    pub fn slowdown_length(&self) -> f32 {
        self.slowdown_length.unwrap_or(0.)
    }

    pub fn clear_slowdown_length(&mut self) {
        self.slowdown_length = ::std::option::Option::None;
    }

    pub fn has_slowdown_length(&self) -> bool {
        self.slowdown_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slowdown_length(&mut self, v: f32) {
        self.slowdown_length = ::std::option::Option::Some(v);
    }

    // optional float slowdown_rate = 3;

    pub fn slowdown_rate(&self) -> f32 {
        self.slowdown_rate.unwrap_or(0.)
    }

    pub fn clear_slowdown_rate(&mut self) {
        self.slowdown_rate = ::std::option::Option::None;
    }

    pub fn has_slowdown_rate(&self) -> bool {
        self.slowdown_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slowdown_rate(&mut self, v: f32) {
        self.slowdown_rate = ::std::option::Option::Some(v);
    }

    // optional int32 primary_target = 4;

    pub fn primary_target(&self) -> i32 {
        self.primary_target.unwrap_or(-1i32)
    }

    pub fn clear_primary_target(&mut self) {
        self.primary_target = ::std::option::Option::None;
    }

    pub fn has_primary_target(&self) -> bool {
        self.primary_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_target(&mut self, v: i32) {
        self.primary_target = ::std::option::Option::Some(v);
    }

    // optional float event_time = 5;

    pub fn event_time(&self) -> f32 {
        self.event_time.unwrap_or(0.)
    }

    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: f32) {
        self.event_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request",
            |m: &CCLCMsg_HltvReplay| { &m.request },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slowdown_length",
            |m: &CCLCMsg_HltvReplay| { &m.slowdown_length },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.slowdown_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slowdown_rate",
            |m: &CCLCMsg_HltvReplay| { &m.slowdown_rate },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.slowdown_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_target",
            |m: &CCLCMsg_HltvReplay| { &m.primary_target },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.primary_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_time",
            |m: &CCLCMsg_HltvReplay| { &m.event_time },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.event_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_HltvReplay>(
            "CCLCMsg_HltvReplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_HltvReplay {
    const NAME: &'static str = "CCLCMsg_HltvReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.slowdown_length = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.slowdown_rate = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.primary_target = ::std::option::Option::Some(is.read_int32()?);
                },
                45 => {
                    self.event_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.slowdown_length {
            my_size += 1 + 4;
        }
        if let Some(v) = self.slowdown_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.primary_target {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.event_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slowdown_length {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.slowdown_rate {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.primary_target {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_HltvReplay {
        CCLCMsg_HltvReplay::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.slowdown_length = ::std::option::Option::None;
        self.slowdown_rate = ::std::option::Option::None;
        self.primary_target = ::std::option::Option::None;
        self.event_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_HltvReplay {
        static instance: CCLCMsg_HltvReplay = CCLCMsg_HltvReplay {
            request: ::std::option::Option::None,
            slowdown_length: ::std::option::Option::None,
            slowdown_rate: ::std::option::Option::None,
            primary_target: ::std::option::Option::None,
            event_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_HltvReplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_HltvReplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_HltvReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_HltvReplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_Broadcast_Command)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_Broadcast_Command {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Broadcast_Command.cmd)
    pub cmd: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Broadcast_Command.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Broadcast_Command {
    fn default() -> &'a CSVCMsg_Broadcast_Command {
        <CSVCMsg_Broadcast_Command as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Broadcast_Command {
    pub fn new() -> CSVCMsg_Broadcast_Command {
        ::std::default::Default::default()
    }

    // optional string cmd = 1;

    pub fn cmd(&self) -> &str {
        match self.cmd.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: ::std::string::String) {
        self.cmd = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd(&mut self) -> &mut ::std::string::String {
        if self.cmd.is_none() {
            self.cmd = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_cmd(&mut self) -> ::std::string::String {
        self.cmd.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd",
            |m: &CSVCMsg_Broadcast_Command| { &m.cmd },
            |m: &mut CSVCMsg_Broadcast_Command| { &mut m.cmd },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Broadcast_Command>(
            "CSVCMsg_Broadcast_Command",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Broadcast_Command {
    const NAME: &'static str = "CSVCMsg_Broadcast_Command";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cmd = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cmd.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cmd.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Broadcast_Command {
        CSVCMsg_Broadcast_Command::new()
    }

    fn clear(&mut self) {
        self.cmd = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Broadcast_Command {
        static instance: CSVCMsg_Broadcast_Command = CSVCMsg_Broadcast_Command {
            cmd: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Broadcast_Command {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Broadcast_Command").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Broadcast_Command {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Broadcast_Command {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CCLCMsg_HltvFixupOperatorTick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCLCMsg_HltvFixupOperatorTick {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.tick)
    pub tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.props_data)
    pub props_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.eye_angles)
    pub eye_angles: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.observer_mode)
    pub observer_mode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.cameraman_scoreboard)
    pub cameraman_scoreboard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.observer_target)
    pub observer_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvFixupOperatorTick.view_offset)
    pub view_offset: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_HltvFixupOperatorTick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_HltvFixupOperatorTick {
    fn default() -> &'a CCLCMsg_HltvFixupOperatorTick {
        <CCLCMsg_HltvFixupOperatorTick as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_HltvFixupOperatorTick {
    pub fn new() -> CCLCMsg_HltvFixupOperatorTick {
        ::std::default::Default::default()
    }

    // optional int32 tick = 1;

    pub fn tick(&self) -> i32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional bytes props_data = 2;

    pub fn props_data(&self) -> &[u8] {
        match self.props_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_props_data(&mut self) {
        self.props_data = ::std::option::Option::None;
    }

    pub fn has_props_data(&self) -> bool {
        self.props_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_props_data(&mut self, v: ::bytes::Bytes) {
        self.props_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_props_data(&mut self) -> &mut ::bytes::Bytes {
        if self.props_data.is_none() {
            self.props_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.props_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_props_data(&mut self) -> ::bytes::Bytes {
        self.props_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional int32 observer_mode = 5;

    pub fn observer_mode(&self) -> i32 {
        self.observer_mode.unwrap_or(0)
    }

    pub fn clear_observer_mode(&mut self) {
        self.observer_mode = ::std::option::Option::None;
    }

    pub fn has_observer_mode(&self) -> bool {
        self.observer_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observer_mode(&mut self, v: i32) {
        self.observer_mode = ::std::option::Option::Some(v);
    }

    // optional bool cameraman_scoreboard = 6;

    pub fn cameraman_scoreboard(&self) -> bool {
        self.cameraman_scoreboard.unwrap_or(false)
    }

    pub fn clear_cameraman_scoreboard(&mut self) {
        self.cameraman_scoreboard = ::std::option::Option::None;
    }

    pub fn has_cameraman_scoreboard(&self) -> bool {
        self.cameraman_scoreboard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cameraman_scoreboard(&mut self, v: bool) {
        self.cameraman_scoreboard = ::std::option::Option::Some(v);
    }

    // optional int32 observer_target = 7;

    pub fn observer_target(&self) -> i32 {
        self.observer_target.unwrap_or(0)
    }

    pub fn clear_observer_target(&mut self) {
        self.observer_target = ::std::option::Option::None;
    }

    pub fn has_observer_target(&self) -> bool {
        self.observer_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observer_target(&mut self, v: i32) {
        self.observer_target = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.tick },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "props_data",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.props_data },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.props_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.origin },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "eye_angles",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.eye_angles },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.eye_angles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observer_mode",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.observer_mode },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.observer_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cameraman_scoreboard",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.cameraman_scoreboard },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.cameraman_scoreboard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "observer_target",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.observer_target },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.observer_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "view_offset",
            |m: &CCLCMsg_HltvFixupOperatorTick| { &m.view_offset },
            |m: &mut CCLCMsg_HltvFixupOperatorTick| { &mut m.view_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_HltvFixupOperatorTick>(
            "CCLCMsg_HltvFixupOperatorTick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_HltvFixupOperatorTick {
    const NAME: &'static str = "CCLCMsg_HltvFixupOperatorTick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.props_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.eye_angles)?;
                },
                40 => {
                    self.observer_mode = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.cameraman_scoreboard = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.observer_target = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.view_offset)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.props_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.eye_angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.observer_mode {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.cameraman_scoreboard {
            my_size += 1 + 1;
        }
        if let Some(v) = self.observer_target {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.view_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.props_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.eye_angles.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.observer_mode {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.cameraman_scoreboard {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.observer_target {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.view_offset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_HltvFixupOperatorTick {
        CCLCMsg_HltvFixupOperatorTick::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.props_data = ::std::option::Option::None;
        self.origin.clear();
        self.eye_angles.clear();
        self.observer_mode = ::std::option::Option::None;
        self.cameraman_scoreboard = ::std::option::Option::None;
        self.observer_target = ::std::option::Option::None;
        self.view_offset.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_HltvFixupOperatorTick {
        static instance: CCLCMsg_HltvFixupOperatorTick = CCLCMsg_HltvFixupOperatorTick {
            tick: ::std::option::Option::None,
            props_data: ::std::option::Option::None,
            origin: ::protobuf::MessageField::none(),
            eye_angles: ::protobuf::MessageField::none(),
            observer_mode: ::std::option::Option::None,
            cameraman_scoreboard: ::std::option::Option::None,
            observer_target: ::std::option::Option::None,
            view_offset: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_HltvFixupOperatorTick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_HltvFixupOperatorTick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_HltvFixupOperatorTick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_HltvFixupOperatorTick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_HltvFixupOperatorStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_HltvFixupOperatorStatus {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_HltvFixupOperatorStatus.mode)
    pub mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvFixupOperatorStatus.override_operator_name)
    pub override_operator_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_HltvFixupOperatorStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_HltvFixupOperatorStatus {
    fn default() -> &'a CSVCMsg_HltvFixupOperatorStatus {
        <CSVCMsg_HltvFixupOperatorStatus as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_HltvFixupOperatorStatus {
    pub fn new() -> CSVCMsg_HltvFixupOperatorStatus {
        ::std::default::Default::default()
    }

    // optional uint32 mode = 1;

    pub fn mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional string override_operator_name = 2;

    pub fn override_operator_name(&self) -> &str {
        match self.override_operator_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_override_operator_name(&mut self) {
        self.override_operator_name = ::std::option::Option::None;
    }

    pub fn has_override_operator_name(&self) -> bool {
        self.override_operator_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_operator_name(&mut self, v: ::std::string::String) {
        self.override_operator_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_override_operator_name(&mut self) -> &mut ::std::string::String {
        if self.override_operator_name.is_none() {
            self.override_operator_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.override_operator_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_override_operator_name(&mut self) -> ::std::string::String {
        self.override_operator_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &CSVCMsg_HltvFixupOperatorStatus| { &m.mode },
            |m: &mut CSVCMsg_HltvFixupOperatorStatus| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "override_operator_name",
            |m: &CSVCMsg_HltvFixupOperatorStatus| { &m.override_operator_name },
            |m: &mut CSVCMsg_HltvFixupOperatorStatus| { &mut m.override_operator_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_HltvFixupOperatorStatus>(
            "CSVCMsg_HltvFixupOperatorStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_HltvFixupOperatorStatus {
    const NAME: &'static str = "CSVCMsg_HltvFixupOperatorStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.override_operator_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.override_operator_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.override_operator_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_HltvFixupOperatorStatus {
        CSVCMsg_HltvFixupOperatorStatus::new()
    }

    fn clear(&mut self) {
        self.mode = ::std::option::Option::None;
        self.override_operator_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_HltvFixupOperatorStatus {
        static instance: CSVCMsg_HltvFixupOperatorStatus = CSVCMsg_HltvFixupOperatorStatus {
            mode: ::std::option::Option::None,
            override_operator_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_HltvFixupOperatorStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_HltvFixupOperatorStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_HltvFixupOperatorStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_HltvFixupOperatorStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgServerUserCmd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerUserCmd {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerUserCmd.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgServerUserCmd.cmd_number)
    pub cmd_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerUserCmd.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerUserCmd.server_tick_executed)
    pub server_tick_executed: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerUserCmd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerUserCmd {
    fn default() -> &'a CMsgServerUserCmd {
        <CMsgServerUserCmd as ::protobuf::Message>::default_instance()
    }
}

impl CMsgServerUserCmd {
    pub fn new() -> CMsgServerUserCmd {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional int32 cmd_number = 2;

    pub fn cmd_number(&self) -> i32 {
        self.cmd_number.unwrap_or(0)
    }

    pub fn clear_cmd_number(&mut self) {
        self.cmd_number = ::std::option::Option::None;
    }

    pub fn has_cmd_number(&self) -> bool {
        self.cmd_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_number(&mut self, v: i32) {
        self.cmd_number = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot = 3;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional int32 server_tick_executed = 4;

    pub fn server_tick_executed(&self) -> i32 {
        self.server_tick_executed.unwrap_or(0)
    }

    pub fn clear_server_tick_executed(&mut self) {
        self.server_tick_executed = ::std::option::Option::None;
    }

    pub fn has_server_tick_executed(&self) -> bool {
        self.server_tick_executed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tick_executed(&mut self, v: i32) {
        self.server_tick_executed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CMsgServerUserCmd| { &m.data },
            |m: &mut CMsgServerUserCmd| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd_number",
            |m: &CMsgServerUserCmd| { &m.cmd_number },
            |m: &mut CMsgServerUserCmd| { &mut m.cmd_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &CMsgServerUserCmd| { &m.player_slot },
            |m: &mut CMsgServerUserCmd| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_tick_executed",
            |m: &CMsgServerUserCmd| { &m.server_tick_executed },
            |m: &mut CMsgServerUserCmd| { &mut m.server_tick_executed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgServerUserCmd>(
            "CMsgServerUserCmd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgServerUserCmd {
    const NAME: &'static str = "CMsgServerUserCmd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                16 => {
                    self.cmd_number = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.server_tick_executed = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.cmd_number {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.server_tick_executed {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.cmd_number {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.server_tick_executed {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerUserCmd {
        CMsgServerUserCmd::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.cmd_number = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.server_tick_executed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerUserCmd {
        static instance: CMsgServerUserCmd = CMsgServerUserCmd {
            data: ::std::option::Option::None,
            cmd_number: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            server_tick_executed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgServerUserCmd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgServerUserCmd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgServerUserCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgServerUserCmd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_UserCommands)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_UserCommands {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_UserCommands.commands)
    pub commands: ::std::vec::Vec<CMsgServerUserCmd>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_UserCommands.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_UserCommands {
    fn default() -> &'a CSVCMsg_UserCommands {
        <CSVCMsg_UserCommands as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_UserCommands {
    pub fn new() -> CSVCMsg_UserCommands {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "commands",
            |m: &CSVCMsg_UserCommands| { &m.commands },
            |m: &mut CSVCMsg_UserCommands| { &mut m.commands },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_UserCommands>(
            "CSVCMsg_UserCommands",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_UserCommands {
    const NAME: &'static str = "CSVCMsg_UserCommands";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.commands.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.commands {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.commands {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_UserCommands {
        CSVCMsg_UserCommands::new()
    }

    fn clear(&mut self) {
        self.commands.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_UserCommands {
        static instance: CSVCMsg_UserCommands = CSVCMsg_UserCommands {
            commands: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_UserCommands {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_UserCommands").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_UserCommands {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_UserCommands {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CLC_Messages)
pub enum CLC_Messages {
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ClientInfo)
    clc_ClientInfo = 20,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_Move)
    clc_Move = 21,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_VoiceData)
    clc_VoiceData = 22,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_BaselineAck)
    clc_BaselineAck = 23,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ListenEvents)
    clc_ListenEvents = 24,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_RespondCvarValue)
    clc_RespondCvarValue = 25,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_FileCRCCheck)
    clc_FileCRCCheck = 26,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_LoadingProgress)
    clc_LoadingProgress = 27,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_SplitPlayerConnect)
    clc_SplitPlayerConnect = 28,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ClientMessage)
    clc_ClientMessage = 29,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_SplitPlayerDisconnect)
    clc_SplitPlayerDisconnect = 30,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ServerStatus)
    clc_ServerStatus = 31,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ServerPing)
    clc_ServerPing = 32,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_RequestPause)
    clc_RequestPause = 33,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_CmdKeyValues)
    clc_CmdKeyValues = 34,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_RconServerDetails)
    clc_RconServerDetails = 35,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_HltvReplay)
    clc_HltvReplay = 36,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_Diagnostic)
    clc_Diagnostic = 37,
}

impl ::protobuf::Enum for CLC_Messages {
    const NAME: &'static str = "CLC_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CLC_Messages> {
        match value {
            20 => ::std::option::Option::Some(CLC_Messages::clc_ClientInfo),
            21 => ::std::option::Option::Some(CLC_Messages::clc_Move),
            22 => ::std::option::Option::Some(CLC_Messages::clc_VoiceData),
            23 => ::std::option::Option::Some(CLC_Messages::clc_BaselineAck),
            24 => ::std::option::Option::Some(CLC_Messages::clc_ListenEvents),
            25 => ::std::option::Option::Some(CLC_Messages::clc_RespondCvarValue),
            26 => ::std::option::Option::Some(CLC_Messages::clc_FileCRCCheck),
            27 => ::std::option::Option::Some(CLC_Messages::clc_LoadingProgress),
            28 => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerConnect),
            29 => ::std::option::Option::Some(CLC_Messages::clc_ClientMessage),
            30 => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerDisconnect),
            31 => ::std::option::Option::Some(CLC_Messages::clc_ServerStatus),
            32 => ::std::option::Option::Some(CLC_Messages::clc_ServerPing),
            33 => ::std::option::Option::Some(CLC_Messages::clc_RequestPause),
            34 => ::std::option::Option::Some(CLC_Messages::clc_CmdKeyValues),
            35 => ::std::option::Option::Some(CLC_Messages::clc_RconServerDetails),
            36 => ::std::option::Option::Some(CLC_Messages::clc_HltvReplay),
            37 => ::std::option::Option::Some(CLC_Messages::clc_Diagnostic),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CLC_Messages> {
        match str {
            "clc_ClientInfo" => ::std::option::Option::Some(CLC_Messages::clc_ClientInfo),
            "clc_Move" => ::std::option::Option::Some(CLC_Messages::clc_Move),
            "clc_VoiceData" => ::std::option::Option::Some(CLC_Messages::clc_VoiceData),
            "clc_BaselineAck" => ::std::option::Option::Some(CLC_Messages::clc_BaselineAck),
            "clc_ListenEvents" => ::std::option::Option::Some(CLC_Messages::clc_ListenEvents),
            "clc_RespondCvarValue" => ::std::option::Option::Some(CLC_Messages::clc_RespondCvarValue),
            "clc_FileCRCCheck" => ::std::option::Option::Some(CLC_Messages::clc_FileCRCCheck),
            "clc_LoadingProgress" => ::std::option::Option::Some(CLC_Messages::clc_LoadingProgress),
            "clc_SplitPlayerConnect" => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerConnect),
            "clc_ClientMessage" => ::std::option::Option::Some(CLC_Messages::clc_ClientMessage),
            "clc_SplitPlayerDisconnect" => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerDisconnect),
            "clc_ServerStatus" => ::std::option::Option::Some(CLC_Messages::clc_ServerStatus),
            "clc_ServerPing" => ::std::option::Option::Some(CLC_Messages::clc_ServerPing),
            "clc_RequestPause" => ::std::option::Option::Some(CLC_Messages::clc_RequestPause),
            "clc_CmdKeyValues" => ::std::option::Option::Some(CLC_Messages::clc_CmdKeyValues),
            "clc_RconServerDetails" => ::std::option::Option::Some(CLC_Messages::clc_RconServerDetails),
            "clc_HltvReplay" => ::std::option::Option::Some(CLC_Messages::clc_HltvReplay),
            "clc_Diagnostic" => ::std::option::Option::Some(CLC_Messages::clc_Diagnostic),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CLC_Messages] = &[
        CLC_Messages::clc_ClientInfo,
        CLC_Messages::clc_Move,
        CLC_Messages::clc_VoiceData,
        CLC_Messages::clc_BaselineAck,
        CLC_Messages::clc_ListenEvents,
        CLC_Messages::clc_RespondCvarValue,
        CLC_Messages::clc_FileCRCCheck,
        CLC_Messages::clc_LoadingProgress,
        CLC_Messages::clc_SplitPlayerConnect,
        CLC_Messages::clc_ClientMessage,
        CLC_Messages::clc_SplitPlayerDisconnect,
        CLC_Messages::clc_ServerStatus,
        CLC_Messages::clc_ServerPing,
        CLC_Messages::clc_RequestPause,
        CLC_Messages::clc_CmdKeyValues,
        CLC_Messages::clc_RconServerDetails,
        CLC_Messages::clc_HltvReplay,
        CLC_Messages::clc_Diagnostic,
    ];
}

impl ::protobuf::EnumFull for CLC_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CLC_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CLC_Messages::clc_ClientInfo => 0,
            CLC_Messages::clc_Move => 1,
            CLC_Messages::clc_VoiceData => 2,
            CLC_Messages::clc_BaselineAck => 3,
            CLC_Messages::clc_ListenEvents => 4,
            CLC_Messages::clc_RespondCvarValue => 5,
            CLC_Messages::clc_FileCRCCheck => 6,
            CLC_Messages::clc_LoadingProgress => 7,
            CLC_Messages::clc_SplitPlayerConnect => 8,
            CLC_Messages::clc_ClientMessage => 9,
            CLC_Messages::clc_SplitPlayerDisconnect => 10,
            CLC_Messages::clc_ServerStatus => 11,
            CLC_Messages::clc_ServerPing => 12,
            CLC_Messages::clc_RequestPause => 13,
            CLC_Messages::clc_CmdKeyValues => 14,
            CLC_Messages::clc_RconServerDetails => 15,
            CLC_Messages::clc_HltvReplay => 16,
            CLC_Messages::clc_Diagnostic => 17,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CLC_Messages {
    fn default() -> Self {
        CLC_Messages::clc_ClientInfo
    }
}

impl CLC_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CLC_Messages>("CLC_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SVC_Messages)
pub enum SVC_Messages {
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ServerInfo)
    svc_ServerInfo = 40,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_FlattenedSerializer)
    svc_FlattenedSerializer = 41,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ClassInfo)
    svc_ClassInfo = 42,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SetPause)
    svc_SetPause = 43,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_CreateStringTable)
    svc_CreateStringTable = 44,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_UpdateStringTable)
    svc_UpdateStringTable = 45,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_VoiceInit)
    svc_VoiceInit = 46,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_VoiceData)
    svc_VoiceData = 47,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Print)
    svc_Print = 48,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Sounds)
    svc_Sounds = 49,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SetView)
    svc_SetView = 50,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ClearAllStringTables)
    svc_ClearAllStringTables = 51,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_CmdKeyValues)
    svc_CmdKeyValues = 52,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_BSPDecal)
    svc_BSPDecal = 53,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SplitScreen)
    svc_SplitScreen = 54,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PacketEntities)
    svc_PacketEntities = 55,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Prefetch)
    svc_Prefetch = 56,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Menu)
    svc_Menu = 57,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_GetCvarValue)
    svc_GetCvarValue = 58,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_StopSound)
    svc_StopSound = 59,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PeerList)
    svc_PeerList = 60,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PacketReliable)
    svc_PacketReliable = 61,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_HLTVStatus)
    svc_HLTVStatus = 62,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ServerSteamID)
    svc_ServerSteamID = 63,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_FullFrameSplit)
    svc_FullFrameSplit = 70,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_RconServerDetails)
    svc_RconServerDetails = 71,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_UserMessage)
    svc_UserMessage = 72,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_HltvReplay)
    svc_HltvReplay = 73,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Broadcast_Command)
    svc_Broadcast_Command = 74,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_HltvFixupOperatorStatus)
    svc_HltvFixupOperatorStatus = 75,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_UserCmds)
    svc_UserCmds = 76,
}

impl ::protobuf::Enum for SVC_Messages {
    const NAME: &'static str = "SVC_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SVC_Messages> {
        match value {
            40 => ::std::option::Option::Some(SVC_Messages::svc_ServerInfo),
            41 => ::std::option::Option::Some(SVC_Messages::svc_FlattenedSerializer),
            42 => ::std::option::Option::Some(SVC_Messages::svc_ClassInfo),
            43 => ::std::option::Option::Some(SVC_Messages::svc_SetPause),
            44 => ::std::option::Option::Some(SVC_Messages::svc_CreateStringTable),
            45 => ::std::option::Option::Some(SVC_Messages::svc_UpdateStringTable),
            46 => ::std::option::Option::Some(SVC_Messages::svc_VoiceInit),
            47 => ::std::option::Option::Some(SVC_Messages::svc_VoiceData),
            48 => ::std::option::Option::Some(SVC_Messages::svc_Print),
            49 => ::std::option::Option::Some(SVC_Messages::svc_Sounds),
            50 => ::std::option::Option::Some(SVC_Messages::svc_SetView),
            51 => ::std::option::Option::Some(SVC_Messages::svc_ClearAllStringTables),
            52 => ::std::option::Option::Some(SVC_Messages::svc_CmdKeyValues),
            53 => ::std::option::Option::Some(SVC_Messages::svc_BSPDecal),
            54 => ::std::option::Option::Some(SVC_Messages::svc_SplitScreen),
            55 => ::std::option::Option::Some(SVC_Messages::svc_PacketEntities),
            56 => ::std::option::Option::Some(SVC_Messages::svc_Prefetch),
            57 => ::std::option::Option::Some(SVC_Messages::svc_Menu),
            58 => ::std::option::Option::Some(SVC_Messages::svc_GetCvarValue),
            59 => ::std::option::Option::Some(SVC_Messages::svc_StopSound),
            60 => ::std::option::Option::Some(SVC_Messages::svc_PeerList),
            61 => ::std::option::Option::Some(SVC_Messages::svc_PacketReliable),
            62 => ::std::option::Option::Some(SVC_Messages::svc_HLTVStatus),
            63 => ::std::option::Option::Some(SVC_Messages::svc_ServerSteamID),
            70 => ::std::option::Option::Some(SVC_Messages::svc_FullFrameSplit),
            71 => ::std::option::Option::Some(SVC_Messages::svc_RconServerDetails),
            72 => ::std::option::Option::Some(SVC_Messages::svc_UserMessage),
            73 => ::std::option::Option::Some(SVC_Messages::svc_HltvReplay),
            74 => ::std::option::Option::Some(SVC_Messages::svc_Broadcast_Command),
            75 => ::std::option::Option::Some(SVC_Messages::svc_HltvFixupOperatorStatus),
            76 => ::std::option::Option::Some(SVC_Messages::svc_UserCmds),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SVC_Messages> {
        match str {
            "svc_ServerInfo" => ::std::option::Option::Some(SVC_Messages::svc_ServerInfo),
            "svc_FlattenedSerializer" => ::std::option::Option::Some(SVC_Messages::svc_FlattenedSerializer),
            "svc_ClassInfo" => ::std::option::Option::Some(SVC_Messages::svc_ClassInfo),
            "svc_SetPause" => ::std::option::Option::Some(SVC_Messages::svc_SetPause),
            "svc_CreateStringTable" => ::std::option::Option::Some(SVC_Messages::svc_CreateStringTable),
            "svc_UpdateStringTable" => ::std::option::Option::Some(SVC_Messages::svc_UpdateStringTable),
            "svc_VoiceInit" => ::std::option::Option::Some(SVC_Messages::svc_VoiceInit),
            "svc_VoiceData" => ::std::option::Option::Some(SVC_Messages::svc_VoiceData),
            "svc_Print" => ::std::option::Option::Some(SVC_Messages::svc_Print),
            "svc_Sounds" => ::std::option::Option::Some(SVC_Messages::svc_Sounds),
            "svc_SetView" => ::std::option::Option::Some(SVC_Messages::svc_SetView),
            "svc_ClearAllStringTables" => ::std::option::Option::Some(SVC_Messages::svc_ClearAllStringTables),
            "svc_CmdKeyValues" => ::std::option::Option::Some(SVC_Messages::svc_CmdKeyValues),
            "svc_BSPDecal" => ::std::option::Option::Some(SVC_Messages::svc_BSPDecal),
            "svc_SplitScreen" => ::std::option::Option::Some(SVC_Messages::svc_SplitScreen),
            "svc_PacketEntities" => ::std::option::Option::Some(SVC_Messages::svc_PacketEntities),
            "svc_Prefetch" => ::std::option::Option::Some(SVC_Messages::svc_Prefetch),
            "svc_Menu" => ::std::option::Option::Some(SVC_Messages::svc_Menu),
            "svc_GetCvarValue" => ::std::option::Option::Some(SVC_Messages::svc_GetCvarValue),
            "svc_StopSound" => ::std::option::Option::Some(SVC_Messages::svc_StopSound),
            "svc_PeerList" => ::std::option::Option::Some(SVC_Messages::svc_PeerList),
            "svc_PacketReliable" => ::std::option::Option::Some(SVC_Messages::svc_PacketReliable),
            "svc_HLTVStatus" => ::std::option::Option::Some(SVC_Messages::svc_HLTVStatus),
            "svc_ServerSteamID" => ::std::option::Option::Some(SVC_Messages::svc_ServerSteamID),
            "svc_FullFrameSplit" => ::std::option::Option::Some(SVC_Messages::svc_FullFrameSplit),
            "svc_RconServerDetails" => ::std::option::Option::Some(SVC_Messages::svc_RconServerDetails),
            "svc_UserMessage" => ::std::option::Option::Some(SVC_Messages::svc_UserMessage),
            "svc_HltvReplay" => ::std::option::Option::Some(SVC_Messages::svc_HltvReplay),
            "svc_Broadcast_Command" => ::std::option::Option::Some(SVC_Messages::svc_Broadcast_Command),
            "svc_HltvFixupOperatorStatus" => ::std::option::Option::Some(SVC_Messages::svc_HltvFixupOperatorStatus),
            "svc_UserCmds" => ::std::option::Option::Some(SVC_Messages::svc_UserCmds),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SVC_Messages] = &[
        SVC_Messages::svc_ServerInfo,
        SVC_Messages::svc_FlattenedSerializer,
        SVC_Messages::svc_ClassInfo,
        SVC_Messages::svc_SetPause,
        SVC_Messages::svc_CreateStringTable,
        SVC_Messages::svc_UpdateStringTable,
        SVC_Messages::svc_VoiceInit,
        SVC_Messages::svc_VoiceData,
        SVC_Messages::svc_Print,
        SVC_Messages::svc_Sounds,
        SVC_Messages::svc_SetView,
        SVC_Messages::svc_ClearAllStringTables,
        SVC_Messages::svc_CmdKeyValues,
        SVC_Messages::svc_BSPDecal,
        SVC_Messages::svc_SplitScreen,
        SVC_Messages::svc_PacketEntities,
        SVC_Messages::svc_Prefetch,
        SVC_Messages::svc_Menu,
        SVC_Messages::svc_GetCvarValue,
        SVC_Messages::svc_StopSound,
        SVC_Messages::svc_PeerList,
        SVC_Messages::svc_PacketReliable,
        SVC_Messages::svc_HLTVStatus,
        SVC_Messages::svc_ServerSteamID,
        SVC_Messages::svc_FullFrameSplit,
        SVC_Messages::svc_RconServerDetails,
        SVC_Messages::svc_UserMessage,
        SVC_Messages::svc_HltvReplay,
        SVC_Messages::svc_Broadcast_Command,
        SVC_Messages::svc_HltvFixupOperatorStatus,
        SVC_Messages::svc_UserCmds,
    ];
}

impl ::protobuf::EnumFull for SVC_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SVC_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SVC_Messages::svc_ServerInfo => 0,
            SVC_Messages::svc_FlattenedSerializer => 1,
            SVC_Messages::svc_ClassInfo => 2,
            SVC_Messages::svc_SetPause => 3,
            SVC_Messages::svc_CreateStringTable => 4,
            SVC_Messages::svc_UpdateStringTable => 5,
            SVC_Messages::svc_VoiceInit => 6,
            SVC_Messages::svc_VoiceData => 7,
            SVC_Messages::svc_Print => 8,
            SVC_Messages::svc_Sounds => 9,
            SVC_Messages::svc_SetView => 10,
            SVC_Messages::svc_ClearAllStringTables => 11,
            SVC_Messages::svc_CmdKeyValues => 12,
            SVC_Messages::svc_BSPDecal => 13,
            SVC_Messages::svc_SplitScreen => 14,
            SVC_Messages::svc_PacketEntities => 15,
            SVC_Messages::svc_Prefetch => 16,
            SVC_Messages::svc_Menu => 17,
            SVC_Messages::svc_GetCvarValue => 18,
            SVC_Messages::svc_StopSound => 19,
            SVC_Messages::svc_PeerList => 20,
            SVC_Messages::svc_PacketReliable => 21,
            SVC_Messages::svc_HLTVStatus => 22,
            SVC_Messages::svc_ServerSteamID => 23,
            SVC_Messages::svc_FullFrameSplit => 24,
            SVC_Messages::svc_RconServerDetails => 25,
            SVC_Messages::svc_UserMessage => 26,
            SVC_Messages::svc_HltvReplay => 27,
            SVC_Messages::svc_Broadcast_Command => 28,
            SVC_Messages::svc_HltvFixupOperatorStatus => 29,
            SVC_Messages::svc_UserCmds => 30,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SVC_Messages {
    fn default() -> Self {
        SVC_Messages::svc_ServerInfo
    }
}

impl SVC_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SVC_Messages>("SVC_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VoiceDataFormat_t)
pub enum VoiceDataFormat_t {
    // @@protoc_insertion_point(enum_value:VoiceDataFormat_t.VOICEDATA_FORMAT_STEAM)
    VOICEDATA_FORMAT_STEAM = 0,
    // @@protoc_insertion_point(enum_value:VoiceDataFormat_t.VOICEDATA_FORMAT_ENGINE)
    VOICEDATA_FORMAT_ENGINE = 1,
    // @@protoc_insertion_point(enum_value:VoiceDataFormat_t.VOICEDATA_FORMAT_OPUS)
    VOICEDATA_FORMAT_OPUS = 2,
}

impl ::protobuf::Enum for VoiceDataFormat_t {
    const NAME: &'static str = "VoiceDataFormat_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoiceDataFormat_t> {
        match value {
            0 => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM),
            1 => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE),
            2 => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_OPUS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VoiceDataFormat_t> {
        match str {
            "VOICEDATA_FORMAT_STEAM" => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM),
            "VOICEDATA_FORMAT_ENGINE" => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE),
            "VOICEDATA_FORMAT_OPUS" => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_OPUS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VoiceDataFormat_t] = &[
        VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM,
        VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE,
        VoiceDataFormat_t::VOICEDATA_FORMAT_OPUS,
    ];
}

impl ::protobuf::EnumFull for VoiceDataFormat_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VoiceDataFormat_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VoiceDataFormat_t {
    fn default() -> Self {
        VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM
    }
}

impl VoiceDataFormat_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VoiceDataFormat_t>("VoiceDataFormat_t")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:RequestPause_t)
pub enum RequestPause_t {
    // @@protoc_insertion_point(enum_value:RequestPause_t.RP_PAUSE)
    RP_PAUSE = 0,
    // @@protoc_insertion_point(enum_value:RequestPause_t.RP_UNPAUSE)
    RP_UNPAUSE = 1,
    // @@protoc_insertion_point(enum_value:RequestPause_t.RP_TOGGLEPAUSE)
    RP_TOGGLEPAUSE = 2,
}

impl ::protobuf::Enum for RequestPause_t {
    const NAME: &'static str = "RequestPause_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestPause_t> {
        match value {
            0 => ::std::option::Option::Some(RequestPause_t::RP_PAUSE),
            1 => ::std::option::Option::Some(RequestPause_t::RP_UNPAUSE),
            2 => ::std::option::Option::Some(RequestPause_t::RP_TOGGLEPAUSE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<RequestPause_t> {
        match str {
            "RP_PAUSE" => ::std::option::Option::Some(RequestPause_t::RP_PAUSE),
            "RP_UNPAUSE" => ::std::option::Option::Some(RequestPause_t::RP_UNPAUSE),
            "RP_TOGGLEPAUSE" => ::std::option::Option::Some(RequestPause_t::RP_TOGGLEPAUSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [RequestPause_t] = &[
        RequestPause_t::RP_PAUSE,
        RequestPause_t::RP_UNPAUSE,
        RequestPause_t::RP_TOGGLEPAUSE,
    ];
}

impl ::protobuf::EnumFull for RequestPause_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("RequestPause_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for RequestPause_t {
    fn default() -> Self {
        RequestPause_t::RP_PAUSE
    }
}

impl RequestPause_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RequestPause_t>("RequestPause_t")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PrefetchType)
pub enum PrefetchType {
    // @@protoc_insertion_point(enum_value:PrefetchType.PFT_SOUND)
    PFT_SOUND = 0,
}

impl ::protobuf::Enum for PrefetchType {
    const NAME: &'static str = "PrefetchType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrefetchType> {
        match value {
            0 => ::std::option::Option::Some(PrefetchType::PFT_SOUND),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PrefetchType> {
        match str {
            "PFT_SOUND" => ::std::option::Option::Some(PrefetchType::PFT_SOUND),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PrefetchType] = &[
        PrefetchType::PFT_SOUND,
    ];
}

impl ::protobuf::EnumFull for PrefetchType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PrefetchType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PrefetchType {
    fn default() -> Self {
        PrefetchType::PFT_SOUND
    }
}

impl PrefetchType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PrefetchType>("PrefetchType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESplitScreenMessageType)
pub enum ESplitScreenMessageType {
    // @@protoc_insertion_point(enum_value:ESplitScreenMessageType.MSG_SPLITSCREEN_ADDUSER)
    MSG_SPLITSCREEN_ADDUSER = 0,
    // @@protoc_insertion_point(enum_value:ESplitScreenMessageType.MSG_SPLITSCREEN_REMOVEUSER)
    MSG_SPLITSCREEN_REMOVEUSER = 1,
}

impl ::protobuf::Enum for ESplitScreenMessageType {
    const NAME: &'static str = "ESplitScreenMessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESplitScreenMessageType> {
        match value {
            0 => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            1 => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESplitScreenMessageType> {
        match str {
            "MSG_SPLITSCREEN_ADDUSER" => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            "MSG_SPLITSCREEN_REMOVEUSER" => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESplitScreenMessageType] = &[
        ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER,
        ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER,
    ];
}

impl ::protobuf::EnumFull for ESplitScreenMessageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESplitScreenMessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESplitScreenMessageType {
    fn default() -> Self {
        ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER
    }
}

impl ESplitScreenMessageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESplitScreenMessageType>("ESplitScreenMessageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EQueryCvarValueStatus)
pub enum EQueryCvarValueStatus {
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_ValueIntact)
    eQueryCvarValueStatus_ValueIntact = 0,
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_CvarNotFound)
    eQueryCvarValueStatus_CvarNotFound = 1,
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_NotACvar)
    eQueryCvarValueStatus_NotACvar = 2,
    // @@protoc_insertion_point(enum_value:EQueryCvarValueStatus.eQueryCvarValueStatus_CvarProtected)
    eQueryCvarValueStatus_CvarProtected = 3,
}

impl ::protobuf::Enum for EQueryCvarValueStatus {
    const NAME: &'static str = "EQueryCvarValueStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EQueryCvarValueStatus> {
        match value {
            0 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact),
            1 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarNotFound),
            2 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_NotACvar),
            3 => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarProtected),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EQueryCvarValueStatus> {
        match str {
            "eQueryCvarValueStatus_ValueIntact" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact),
            "eQueryCvarValueStatus_CvarNotFound" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarNotFound),
            "eQueryCvarValueStatus_NotACvar" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_NotACvar),
            "eQueryCvarValueStatus_CvarProtected" => ::std::option::Option::Some(EQueryCvarValueStatus::eQueryCvarValueStatus_CvarProtected),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EQueryCvarValueStatus] = &[
        EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact,
        EQueryCvarValueStatus::eQueryCvarValueStatus_CvarNotFound,
        EQueryCvarValueStatus::eQueryCvarValueStatus_NotACvar,
        EQueryCvarValueStatus::eQueryCvarValueStatus_CvarProtected,
    ];
}

impl ::protobuf::EnumFull for EQueryCvarValueStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EQueryCvarValueStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EQueryCvarValueStatus {
    fn default() -> Self {
        EQueryCvarValueStatus::eQueryCvarValueStatus_ValueIntact
    }
}

impl EQueryCvarValueStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EQueryCvarValueStatus>("EQueryCvarValueStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DIALOG_TYPE)
pub enum DIALOG_TYPE {
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_MSG)
    DIALOG_MSG = 0,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_MENU)
    DIALOG_MENU = 1,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_TEXT)
    DIALOG_TEXT = 2,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_ENTRY)
    DIALOG_ENTRY = 3,
    // @@protoc_insertion_point(enum_value:DIALOG_TYPE.DIALOG_ASKCONNECT)
    DIALOG_ASKCONNECT = 4,
}

impl ::protobuf::Enum for DIALOG_TYPE {
    const NAME: &'static str = "DIALOG_TYPE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DIALOG_TYPE> {
        match value {
            0 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MSG),
            1 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MENU),
            2 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_TEXT),
            3 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ENTRY),
            4 => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ASKCONNECT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DIALOG_TYPE> {
        match str {
            "DIALOG_MSG" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MSG),
            "DIALOG_MENU" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_MENU),
            "DIALOG_TEXT" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_TEXT),
            "DIALOG_ENTRY" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ENTRY),
            "DIALOG_ASKCONNECT" => ::std::option::Option::Some(DIALOG_TYPE::DIALOG_ASKCONNECT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DIALOG_TYPE] = &[
        DIALOG_TYPE::DIALOG_MSG,
        DIALOG_TYPE::DIALOG_MENU,
        DIALOG_TYPE::DIALOG_TEXT,
        DIALOG_TYPE::DIALOG_ENTRY,
        DIALOG_TYPE::DIALOG_ASKCONNECT,
    ];
}

impl ::protobuf::EnumFull for DIALOG_TYPE {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("DIALOG_TYPE").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for DIALOG_TYPE {
    fn default() -> Self {
        DIALOG_TYPE::DIALOG_MSG
    }
}

impl DIALOG_TYPE {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<DIALOG_TYPE>("DIALOG_TYPE")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SVC_Messages_LowFrequency)
pub enum SVC_Messages_LowFrequency {
    // @@protoc_insertion_point(enum_value:SVC_Messages_LowFrequency.svc_dummy)
    svc_dummy = 600,
}

impl ::protobuf::Enum for SVC_Messages_LowFrequency {
    const NAME: &'static str = "SVC_Messages_LowFrequency";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SVC_Messages_LowFrequency> {
        match value {
            600 => ::std::option::Option::Some(SVC_Messages_LowFrequency::svc_dummy),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SVC_Messages_LowFrequency> {
        match str {
            "svc_dummy" => ::std::option::Option::Some(SVC_Messages_LowFrequency::svc_dummy),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SVC_Messages_LowFrequency] = &[
        SVC_Messages_LowFrequency::svc_dummy,
    ];
}

impl ::protobuf::EnumFull for SVC_Messages_LowFrequency {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SVC_Messages_LowFrequency").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SVC_Messages_LowFrequency::svc_dummy => 0,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SVC_Messages_LowFrequency {
    fn default() -> Self {
        SVC_Messages_LowFrequency::svc_dummy
    }
}

impl SVC_Messages_LowFrequency {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SVC_Messages_LowFrequency>("SVC_Messages_LowFrequency")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Bidirectional_Messages)
pub enum Bidirectional_Messages {
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages.bi_RebroadcastGameEvent)
    bi_RebroadcastGameEvent = 16,
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages.bi_RebroadcastSource)
    bi_RebroadcastSource = 17,
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages.bi_GameEvent)
    bi_GameEvent = 18,
}

impl ::protobuf::Enum for Bidirectional_Messages {
    const NAME: &'static str = "Bidirectional_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Bidirectional_Messages> {
        match value {
            16 => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastGameEvent),
            17 => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastSource),
            18 => ::std::option::Option::Some(Bidirectional_Messages::bi_GameEvent),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Bidirectional_Messages> {
        match str {
            "bi_RebroadcastGameEvent" => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastGameEvent),
            "bi_RebroadcastSource" => ::std::option::Option::Some(Bidirectional_Messages::bi_RebroadcastSource),
            "bi_GameEvent" => ::std::option::Option::Some(Bidirectional_Messages::bi_GameEvent),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Bidirectional_Messages] = &[
        Bidirectional_Messages::bi_RebroadcastGameEvent,
        Bidirectional_Messages::bi_RebroadcastSource,
        Bidirectional_Messages::bi_GameEvent,
    ];
}

impl ::protobuf::EnumFull for Bidirectional_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Bidirectional_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Bidirectional_Messages::bi_RebroadcastGameEvent => 0,
            Bidirectional_Messages::bi_RebroadcastSource => 1,
            Bidirectional_Messages::bi_GameEvent => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Bidirectional_Messages {
    fn default() -> Self {
        Bidirectional_Messages::bi_RebroadcastGameEvent
    }
}

impl Bidirectional_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Bidirectional_Messages>("Bidirectional_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:Bidirectional_Messages_LowFrequency)
pub enum Bidirectional_Messages_LowFrequency {
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages_LowFrequency.bi_RelayInfo)
    bi_RelayInfo = 700,
    // @@protoc_insertion_point(enum_value:Bidirectional_Messages_LowFrequency.bi_RelayPacket)
    bi_RelayPacket = 701,
}

impl ::protobuf::Enum for Bidirectional_Messages_LowFrequency {
    const NAME: &'static str = "Bidirectional_Messages_LowFrequency";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Bidirectional_Messages_LowFrequency> {
        match value {
            700 => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayInfo),
            701 => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayPacket),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<Bidirectional_Messages_LowFrequency> {
        match str {
            "bi_RelayInfo" => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayInfo),
            "bi_RelayPacket" => ::std::option::Option::Some(Bidirectional_Messages_LowFrequency::bi_RelayPacket),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Bidirectional_Messages_LowFrequency] = &[
        Bidirectional_Messages_LowFrequency::bi_RelayInfo,
        Bidirectional_Messages_LowFrequency::bi_RelayPacket,
    ];
}

impl ::protobuf::EnumFull for Bidirectional_Messages_LowFrequency {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Bidirectional_Messages_LowFrequency").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Bidirectional_Messages_LowFrequency::bi_RelayInfo => 0,
            Bidirectional_Messages_LowFrequency::bi_RelayPacket => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Bidirectional_Messages_LowFrequency {
    fn default() -> Self {
        Bidirectional_Messages_LowFrequency::bi_RelayInfo
    }
}

impl Bidirectional_Messages_LowFrequency {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Bidirectional_Messages_LowFrequency>("Bidirectional_Messages_LowFrequency")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ReplayEventType_t)
pub enum ReplayEventType_t {
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_CANCEL)
    REPLAY_EVENT_CANCEL = 0,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_DEATH)
    REPLAY_EVENT_DEATH = 1,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_GENERIC)
    REPLAY_EVENT_GENERIC = 2,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_STUCK_NEED_FULL_UPDATE)
    REPLAY_EVENT_STUCK_NEED_FULL_UPDATE = 3,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_VICTORY)
    REPLAY_EVENT_VICTORY = 4,
}

impl ::protobuf::Enum for ReplayEventType_t {
    const NAME: &'static str = "ReplayEventType_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReplayEventType_t> {
        match value {
            0 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_CANCEL),
            1 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_DEATH),
            2 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_GENERIC),
            3 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE),
            4 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_VICTORY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ReplayEventType_t> {
        match str {
            "REPLAY_EVENT_CANCEL" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_CANCEL),
            "REPLAY_EVENT_DEATH" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_DEATH),
            "REPLAY_EVENT_GENERIC" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_GENERIC),
            "REPLAY_EVENT_STUCK_NEED_FULL_UPDATE" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE),
            "REPLAY_EVENT_VICTORY" => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_VICTORY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ReplayEventType_t] = &[
        ReplayEventType_t::REPLAY_EVENT_CANCEL,
        ReplayEventType_t::REPLAY_EVENT_DEATH,
        ReplayEventType_t::REPLAY_EVENT_GENERIC,
        ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE,
        ReplayEventType_t::REPLAY_EVENT_VICTORY,
    ];
}

impl ::protobuf::EnumFull for ReplayEventType_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ReplayEventType_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ReplayEventType_t {
    fn default() -> Self {
        ReplayEventType_t::REPLAY_EVENT_CANCEL
    }
}

impl ReplayEventType_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ReplayEventType_t>("ReplayEventType_t")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11netmessages.proto\x1a\x16networkbasetypes.proto\"\xb8\x01\n\x12CCL\
    CMsg_ClientInfo\x12$\n\x0esend_table_crc\x18\x01\x20\x01(\x07R\x0csendTa\
    bleCrc\x12!\n\x0cserver_count\x18\x02\x20\x01(\rR\x0bserverCount\x12\x17\
    \n\x07is_hltv\x18\x03\x20\x01(\x08R\x06isHltv\x12\x1d\n\nfriends_id\x18\
    \x05\x20\x01(\rR\tfriendsId\x12!\n\x0cfriends_name\x18\x06\x20\x01(\tR\
    \x0bfriendsName\"R\n\x0cCCLCMsg_Move\x12\x12\n\x04data\x18\x03\x20\x01(\
    \x0cR\x04data\x12.\n\x13last_command_number\x18\x04\x20\x01(\rR\x11lastC\
    ommandNumber\"\x8d\x03\n\x0eCMsgVoiceAudio\x12B\n\x06format\x18\x01\x20\
    \x01(\x0e2\x12.VoiceDataFormat_t:\x16VOICEDATA_FORMAT_STEAMR\x06format\
    \x12\x1d\n\nvoice_data\x18\x02\x20\x01(\x0cR\tvoiceData\x12%\n\x0esequen\
    ce_bytes\x18\x03\x20\x01(\x05R\rsequenceBytes\x12%\n\x0esection_number\
    \x18\x04\x20\x01(\rR\rsectionNumber\x12\x1f\n\x0bsample_rate\x18\x05\x20\
    \x01(\rR\nsampleRate\x12<\n\x1auncompressed_sample_offset\x18\x06\x20\
    \x01(\rR\x18uncompressedSampleOffset\x12\x1f\n\x0bnum_packets\x18\x07\
    \x20\x01(\rR\nnumPackets\x12)\n\x0epacket_offsets\x18\x08\x20\x03(\rR\rp\
    acketOffsetsB\x02\x10\x01\x12\x1f\n\x0bvoice_level\x18\t\x20\x01(\x02R\n\
    voiceLevel\"b\n\x11CCLCMsg_VoiceData\x12%\n\x05audio\x18\x01\x20\x01(\
    \x0b2\x0f.CMsgVoiceAudioR\x05audio\x12\x12\n\x04xuid\x18\x02\x20\x01(\
    \x06R\x04xuid\x12\x12\n\x04tick\x18\x03\x20\x01(\rR\x04tick\"[\n\x13CCLC\
    Msg_BaselineAck\x12#\n\rbaseline_tick\x18\x01\x20\x01(\x05R\x0cbaselineT\
    ick\x12\x1f\n\x0bbaseline_nr\x18\x02\x20\x01(\x05R\nbaselineNr\"5\n\x14C\
    CLCMsg_ListenEvents\x12\x1d\n\nevent_mask\x18\x01\x20\x03(\x07R\teventMa\
    sk\"}\n\x18CCLCMsg_RespondCvarValue\x12\x16\n\x06cookie\x18\x01\x20\x01(\
    \x05R\x06cookie\x12\x1f\n\x0bstatus_code\x18\x02\x20\x01(\x05R\nstatusCo\
    de\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\
    \x04\x20\x01(\tR\x05value\"\x9a\x01\n\x14CCLCMsg_FileCRCCheck\x12\x1b\n\
    \tcode_path\x18\x01\x20\x01(\x05R\x08codePath\x12\x12\n\x04path\x18\x02\
    \x20\x01(\tR\x04path\x12#\n\rcode_filename\x18\x03\x20\x01(\x05R\x0ccode\
    Filename\x12\x1a\n\x08filename\x18\x04\x20\x01(\tR\x08filename\x12\x10\n\
    \x03crc\x18\x05\x20\x01(\x07R\x03crc\"5\n\x17CCLCMsg_LoadingProgress\x12\
    \x1a\n\x08progress\x18\x01\x20\x01(\x05R\x08progress\"<\n\x1aCCLCMsg_Spl\
    itPlayerConnect\x12\x1e\n\nplayername\x18\x01\x20\x01(\tR\nplayername\"F\
    \n\x15CCLCMsg_ClientMessage\x12\x19\n\x08msg_type\x18\x01\x20\x01(\x05R\
    \x07msgType\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\"3\n\x1dCCLC\
    Msg_SplitPlayerDisconnect\x12\x12\n\x04slot\x18\x01\x20\x01(\x05R\x04slo\
    t\"6\n\x14CCLCMsg_ServerStatus\x12\x1e\n\nsimplified\x18\x01\x20\x01(\
    \x08R\nsimplified\"q\n\x14CCLCMsg_RequestPause\x128\n\npause_type\x18\
    \x01\x20\x01(\x0e2\x0f.RequestPause_t:\x08RP_PAUSER\tpauseType\x12\x1f\n\
    \x0bpause_group\x18\x02\x20\x01(\x05R\npauseGroup\"*\n\x14CCLCMsg_CmdKey\
    Values\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\"1\n\x19CCLCMsg_R\
    conServerDetails\x12\x14\n\x05token\x18\x01\x20\x01(\x0cR\x05token\"\xa6\
    \x04\n\x16CMsgSource2SystemSpecs\x12\x15\n\x06cpu_id\x18\x01\x20\x01(\tR\
    \x05cpuId\x12\x1b\n\tcpu_brand\x18\x02\x20\x01(\tR\x08cpuBrand\x12\x1b\n\
    \tcpu_model\x18\x03\x20\x01(\rR\x08cpuModel\x12(\n\x10cpu_num_physical\
    \x18\x04\x20\x01(\rR\x0ecpuNumPhysical\x121\n\x15ram_physical_total_mb\
    \x18\x15\x20\x01(\rR\x12ramPhysicalTotalMb\x129\n\x19gpu_rendersystem_dl\
    l_name\x18)\x20\x01(\tR\x16gpuRendersystemDllName\x12\"\n\rgpu_vendor_id\
    \x18*\x20\x01(\rR\x0bgpuVendorId\x12&\n\x0fgpu_driver_name\x18+\x20\x01(\
    \tR\rgpuDriverName\x125\n\x17gpu_driver_version_high\x18,\x20\x01(\rR\
    \x14gpuDriverVersionHigh\x123\n\x16gpu_driver_version_low\x18-\x20\x01(\
    \rR\x13gpuDriverVersionLow\x12/\n\x14gpu_dx_support_level\x18.\x20\x01(\
    \rR\x11gpuDxSupportLevel\x12:\n\x1agpu_texture_memory_size_mb\x18/\x20\
    \x01(\rR\x16gpuTextureMemorySizeMb\"\xd4\x02\n\x1eCMsgSource2VProfLiteRe\
    portItem\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12%\n\x0eactive_\
    samples\x18\x02\x20\x01(\rR\ractiveSamples\x12\x19\n\x08usec_max\x18\x03\
    \x20\x01(\rR\x07usecMax\x12&\n\x0fusec_avg_active\x18\x0b\x20\x01(\rR\ru\
    secAvgActive\x12&\n\x0fusec_p50_active\x18\x0c\x20\x01(\rR\rusecP50Activ\
    e\x12&\n\x0fusec_p99_active\x18\r\x20\x01(\rR\rusecP99Active\x12\x20\n\
    \x0cusec_avg_all\x18\x15\x20\x01(\rR\nusecAvgAll\x12\x20\n\x0cusec_p50_a\
    ll\x18\x16\x20\x01(\rR\nusecP50All\x12\x20\n\x0cusec_p99_all\x18\x17\x20\
    \x01(\rR\nusecP99All\"\xb5\x01\n\x1aCMsgSource2VProfLiteReport\x125\n\
    \x05total\x18\x01\x20\x01(\x0b2\x1f.CMsgSource2VProfLiteReportItemR\x05t\
    otal\x125\n\x05items\x18\x02\x20\x03(\x0b2\x1f.CMsgSource2VProfLiteRepor\
    tItemR\x05items\x12)\n\x10discarded_frames\x18\x03\x20\x01(\rR\x0fdiscar\
    dedFrames\"\x90\x01\n\x12CCLCMsg_Diagnostic\x12:\n\x0csystem_specs\x18\
    \x01\x20\x01(\x0b2\x17.CMsgSource2SystemSpecsR\x0bsystemSpecs\x12>\n\x0c\
    vprof_report\x18\x02\x20\x01(\x0b2\x1b.CMsgSource2VProfLiteReportR\x0bvp\
    rofReport\"\xe4\x03\n-CSource2Metrics_MatchPerfSummary_Notification\x12\
    \x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1b\n\tgame_mode\x18\
    \x02\x20\x01(\tR\x08gameMode\x12&\n\x0fserver_build_id\x18\x03\x20\x01(\
    \rR\rserverBuildId\x12B\n\x0eserver_profile\x18\n\x20\x01(\x0b2\x1b.CMsg\
    Source2VProfLiteReportR\rserverProfile\x12O\n\x07clients\x18\x0b\x20\x03\
    (\x0b25.CSource2Metrics_MatchPerfSummary_Notification.ClientR\x07clients\
    \x12\x10\n\x03map\x18\x14\x20\x01(\tR\x03map\x1a\xb0\x01\n\x06Client\x12\
    :\n\x0csystem_specs\x18\x01\x20\x01(\x0b2\x17.CMsgSource2SystemSpecsR\
    \x0bsystemSpecs\x125\n\x07profile\x18\x02\x20\x01(\x0b2\x1b.CMsgSource2V\
    ProfLiteReportR\x07profile\x12\x19\n\x08build_id\x18\x03\x20\x01(\rR\x07\
    buildId\x12\x18\n\x07steamid\x18\n\x20\x01(\x06R\x07steamid\"\xc2\x04\n\
    \x12CSVCMsg_ServerInfo\x12\x1a\n\x08protocol\x18\x01\x20\x01(\x05R\x08pr\
    otocol\x12!\n\x0cserver_count\x18\x02\x20\x01(\x05R\x0bserverCount\x12!\
    \n\x0cis_dedicated\x18\x03\x20\x01(\x08R\x0bisDedicated\x12\x17\n\x07is_\
    hltv\x18\x04\x20\x01(\x08R\x06isHltv\x12\x11\n\x04c_os\x18\x06\x20\x01(\
    \x05R\x03cOs\x12\x1f\n\x0bmax_clients\x18\n\x20\x01(\x05R\nmaxClients\
    \x12\x1f\n\x0bmax_classes\x18\x0b\x20\x01(\x05R\nmaxClasses\x12#\n\x0bpl\
    ayer_slot\x18\x0c\x20\x01(\x05:\x02-1R\nplayerSlot\x12#\n\rtick_interval\
    \x18\r\x20\x01(\x02R\x0ctickInterval\x12\x19\n\x08game_dir\x18\x0e\x20\
    \x01(\tR\x07gameDir\x12\x19\n\x08map_name\x18\x0f\x20\x01(\tR\x07mapName\
    \x12\x19\n\x08sky_name\x18\x10\x20\x01(\tR\x07skyName\x12\x1b\n\thost_na\
    me\x18\x11\x20\x01(\tR\x08hostName\x12\x1d\n\naddon_name\x18\x12\x20\x01\
    (\tR\taddonName\x12Q\n\x13game_session_config\x18\x13\x20\x01(\x0b2!.CSV\
    CMsg_GameSessionConfigurationR\x11gameSessionConfig\x122\n\x15game_sessi\
    on_manifest\x18\x14\x20\x01(\x0cR\x13gameSessionManifest\"\xb8\x01\n\x11\
    CSVCMsg_ClassInfo\x12(\n\x10create_on_client\x18\x01\x20\x01(\x08R\x0ecr\
    eateOnClient\x124\n\x07classes\x18\x02\x20\x03(\x0b2\x1a.CSVCMsg_ClassIn\
    fo.class_tR\x07classes\x1aC\n\x07class_t\x12\x19\n\x08class_id\x18\x01\
    \x20\x01(\x05R\x07classId\x12\x1d\n\nclass_name\x18\x03\x20\x01(\tR\tcla\
    ssName\"*\n\x10CSVCMsg_SetPause\x12\x16\n\x06paused\x18\x01\x20\x01(\x08\
    R\x06paused\"`\n\x11CSVCMsg_VoiceInit\x12\x18\n\x07quality\x18\x01\x20\
    \x01(\x05R\x07quality\x12\x14\n\x05codec\x18\x02\x20\x01(\tR\x05codec\
    \x12\x1b\n\x07version\x18\x03\x20\x01(\x05:\x010R\x07version\"#\n\rCSVCM\
    sg_Print\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"\xcc\x05\n\x0eCS\
    VCMsg_Sounds\x12%\n\x0ereliable_sound\x18\x01\x20\x01(\x08R\rreliableSou\
    nd\x123\n\x06sounds\x18\x02\x20\x03(\x0b2\x1b.CSVCMsg_Sounds.sounddata_t\
    R\x06sounds\x1a\xdd\x04\n\x0bsounddata_t\x12\x19\n\x08origin_x\x18\x01\
    \x20\x01(\x11R\x07originX\x12\x19\n\x08origin_y\x18\x02\x20\x01(\x11R\
    \x07originY\x12\x19\n\x08origin_z\x18\x03\x20\x01(\x11R\x07originZ\x12\
    \x16\n\x06volume\x18\x04\x20\x01(\rR\x06volume\x12\x1f\n\x0bdelay_value\
    \x18\x05\x20\x01(\x02R\ndelayValue\x12'\n\x0fsequence_number\x18\x06\x20\
    \x01(\x05R\x0esequenceNumber\x12%\n\x0centity_index\x18\x07\x20\x01(\x05\
    :\x02-1R\x0bentityIndex\x12\x18\n\x07channel\x18\x08\x20\x01(\x05R\x07ch\
    annel\x12\x14\n\x05pitch\x18\t\x20\x01(\x05R\x05pitch\x12\x14\n\x05flags\
    \x18\n\x20\x01(\x05R\x05flags\x12\x1b\n\tsound_num\x18\x0b\x20\x01(\rR\
    \x08soundNum\x12(\n\x10sound_num_handle\x18\x0c\x20\x01(\x07R\x0esoundNu\
    mHandle\x12%\n\x0espeaker_entity\x18\r\x20\x01(\x05R\rspeakerEntity\x12\
    \x1f\n\x0brandom_seed\x18\x0e\x20\x01(\x05R\nrandomSeed\x12\x1f\n\x0bsou\
    nd_level\x18\x0f\x20\x01(\x05R\nsoundLevel\x12\x1f\n\x0bis_sentence\x18\
    \x10\x20\x01(\x08R\nisSentence\x12\x1d\n\nis_ambient\x18\x11\x20\x01(\
    \x08R\tisAmbient\x12\x12\n\x04guid\x18\x12\x20\x01(\rR\x04guid\x12*\n\
    \x11sound_resource_id\x18\x13\x20\x01(\x06R\x0fsoundResourceId\"r\n\x10C\
    SVCMsg_Prefetch\x12\x1f\n\x0bsound_index\x18\x01\x20\x01(\x05R\nsoundInd\
    ex\x12=\n\rresource_type\x18\x02\x20\x01(\x0e2\r.PrefetchType:\tPFT_SOUN\
    DR\x0cresourceType\"P\n\x0fCSVCMsg_SetView\x12%\n\x0centity_index\x18\
    \x01\x20\x01(\x05:\x02-1R\x0bentityIndex\x12\x16\n\x04slot\x18\x02\x20\
    \x01(\x05:\x02-1R\x04slot\"Q\n\x10CSVCMsg_FixAngle\x12\x1a\n\x08relative\
    \x18\x01\x20\x01(\x08R\x08relative\x12!\n\x05angle\x18\x02\x20\x01(\x0b2\
    \x0b.CMsgQAngleR\x05angle\";\n\x16CSVCMsg_CrosshairAngle\x12!\n\x05angle\
    \x18\x01\x20\x01(\x0b2\x0b.CMsgQAngleR\x05angle\"\xcc\x01\n\x10CSVCMsg_B\
    SPDecal\x12\x1d\n\x03pos\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x03pos\
    \x12.\n\x13decal_texture_index\x18\x02\x20\x01(\x05R\x11decalTextureInde\
    x\x12%\n\x0centity_index\x18\x03\x20\x01(\x05:\x02-1R\x0bentityIndex\x12\
    \x1f\n\x0bmodel_index\x18\x04\x20\x01(\x05R\nmodelIndex\x12!\n\x0clow_pr\
    iority\x18\x05\x20\x01(\x08R\x0blowPriority\"\x97\x01\n\x13CSVCMsg_Split\
    Screen\x12E\n\x04type\x18\x01\x20\x01(\x0e2\x18.ESplitScreenMessageType:\
    \x17MSG_SPLITSCREEN_ADDUSERR\x04type\x12\x12\n\x04slot\x18\x02\x20\x01(\
    \x05R\x04slot\x12%\n\x0cplayer_index\x18\x03\x20\x01(\x05:\x02-1R\x0bpla\
    yerIndex\"K\n\x14CSVCMsg_GetCvarValue\x12\x16\n\x06cookie\x18\x01\x20\
    \x01(\x05R\x06cookie\x12\x1b\n\tcvar_name\x18\x02\x20\x01(\tR\x08cvarNam\
    e\"W\n\x0cCSVCMsg_Menu\x12\x1f\n\x0bdialog_type\x18\x01\x20\x01(\x05R\nd\
    ialogType\x12&\n\x0fmenu_key_values\x18\x02\x20\x01(\x0cR\rmenuKeyValues\
    \"m\n\x13CSVCMsg_UserMessage\x12\x19\n\x08msg_type\x18\x01\x20\x01(\x05R\
    \x07msgType\x12\x19\n\x08msg_data\x18\x02\x20\x01(\x0cR\x07msgData\x12\
    \x20\n\x0bpassthrough\x18\x03\x20\x01(\x05R\x0bpassthrough\"\xad\x03\n\
    \x11CSVCMsg_SendTable\x12\x15\n\x06is_end\x18\x01\x20\x01(\x08R\x05isEnd\
    \x12$\n\x0enet_table_name\x18\x02\x20\x01(\tR\x0cnetTableName\x12#\n\rne\
    eds_decoder\x18\x03\x20\x01(\x08R\x0cneedsDecoder\x123\n\x05props\x18\
    \x04\x20\x03(\x0b2\x1d.CSVCMsg_SendTable.sendprop_tR\x05props\x1a\x80\
    \x02\n\nsendprop_t\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\
    \x19\n\x08var_name\x18\x02\x20\x01(\tR\x07varName\x12\x14\n\x05flags\x18\
    \x03\x20\x01(\x05R\x05flags\x12\x1a\n\x08priority\x18\x04\x20\x01(\x05R\
    \x08priority\x12\x17\n\x07dt_name\x18\x05\x20\x01(\tR\x06dtName\x12!\n\
    \x0cnum_elements\x18\x06\x20\x01(\x05R\x0bnumElements\x12\x1b\n\tlow_val\
    ue\x18\x07\x20\x01(\x02R\x08lowValue\x12\x1d\n\nhigh_value\x18\x08\x20\
    \x01(\x02R\thighValue\x12\x19\n\x08num_bits\x18\t\x20\x01(\x05R\x07numBi\
    ts\"\xff\x01\n\x15CSVCMsg_GameEventList\x12E\n\x0bdescriptors\x18\x01\
    \x20\x03(\x0b2#.CSVCMsg_GameEventList.descriptor_tR\x0bdescriptors\x1a/\
    \n\x05key_t\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x1an\n\x0cdescriptor_t\x12\x18\n\
    \x07eventid\x18\x01\x20\x01(\x05R\x07eventid\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x120\n\x04keys\x18\x03\x20\x03(\x0b2\x1c.CSVCMsg_Ga\
    meEventList.key_tR\x04keys\"\xf7\t\n\x16CSVCMsg_PacketEntities\x12\x1f\n\
    \x0bmax_entries\x18\x01\x20\x01(\x05R\nmaxEntries\x12'\n\x0fupdated_entr\
    ies\x18\x02\x20\x01(\x05R\x0eupdatedEntries\x12&\n\x0flegacy_is_delta\
    \x18\x03\x20\x01(\x08R\rlegacyIsDelta\x12'\n\x0fupdate_baseline\x18\x04\
    \x20\x01(\x08R\x0eupdateBaseline\x12\x1a\n\x08baseline\x18\x05\x20\x01(\
    \x05R\x08baseline\x12\x1d\n\ndelta_from\x18\x06\x20\x01(\x05R\tdeltaFrom\
    \x12\x1f\n\x0bentity_data\x18\x07\x20\x01(\x0cR\nentityData\x12,\n\x12pe\
    nding_full_frame\x18\x08\x20\x01(\x08R\x10pendingFullFrame\x128\n\x18act\
    ive_spawngroup_handle\x18\t\x20\x01(\rR\x16activeSpawngroupHandle\x12F\n\
    \x1fmax_spawngroup_creationsequence\x18\n\x20\x01(\rR\x1dmaxSpawngroupCr\
    eationsequence\x127\n\x18last_cmd_number_executed\x18\x0b\x20\x01(\rR\
    \x15lastCmdNumberExecuted\x12:\n\x1alast_cmd_number_recv_delta\x18\x11\
    \x20\x01(\x11R\x16lastCmdNumberRecvDelta\x12\x1f\n\x0bserver_tick\x18\
    \x0c\x20\x01(\rR\nserverTick\x12/\n\x13serialized_entities\x18\r\x20\x01\
    (\x0cR\x12serializedEntities\x12]\n\x13alternate_baselines\x18\x0f\x20\
    \x03(\x0b2,.CSVCMsg_PacketEntities.alternate_baseline_tR\x12alternateBas\
    elines\x12'\n\x10has_pvs_vis_bits\x18\x10\x20\x01(\rR\rhasPvsVisBits\x12\
    *\n\x0fcmd_recv_status\x18\x16\x20\x03(\x11R\rcmdRecvStatusB\x02\x10\x01\
    \x12l\n\x18non_transmitted_entities\x18\x13\x20\x01(\x0b22.CSVCMsg_Packe\
    tEntities.non_transmitted_entities_tR\x16nonTransmittedEntities\x127\n\
    \x18cq_starved_command_ticks\x18\x14\x20\x01(\rR\x15cqStarvedCommandTick\
    s\x12;\n\x1acq_discarded_command_ticks\x18\x15\x20\x01(\rR\x17cqDiscarde\
    dCommandTicks\x12\x20\n\x0bdev_padding\x18\xe7\x07\x20\x01(\x0cR\ndevPad\
    ding\x1a`\n\x14alternate_baseline_t\x12!\n\x0centity_index\x18\x01\x20\
    \x01(\x05R\x0bentityIndex\x12%\n\x0ebaseline_index\x18\x02\x20\x01(\x05R\
    \rbaselineIndex\x1aS\n\x1anon_transmitted_entities_t\x12!\n\x0cheader_co\
    unt\x18\x01\x20\x01(\x05R\x0bheaderCount\x12\x12\n\x04data\x18\x02\x20\
    \x01(\x0cR\x04data\"t\n\x14CSVCMsg_TempEntities\x12\x1a\n\x08reliable\
    \x18\x01\x20\x01(\x08R\x08reliable\x12\x1f\n\x0bnum_entries\x18\x02\x20\
    \x01(\x05R\nnumEntries\x12\x1f\n\x0bentity_data\x18\x03\x20\x01(\x0cR\ne\
    ntityData\"\x99\x03\n\x19CSVCMsg_CreateStringTable\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x1f\n\x0bnum_entries\x18\x02\x20\x01(\x05R\
    \nnumEntries\x12/\n\x14user_data_fixed_size\x18\x03\x20\x01(\x08R\x11use\
    rDataFixedSize\x12$\n\x0euser_data_size\x18\x04\x20\x01(\x05R\x0cuserDat\
    aSize\x12-\n\x13user_data_size_bits\x18\x05\x20\x01(\x05R\x10userDataSiz\
    eBits\x12\x14\n\x05flags\x18\x06\x20\x01(\x05R\x05flags\x12\x1f\n\x0bstr\
    ing_data\x18\x07\x20\x01(\x0cR\nstringData\x12+\n\x11uncompressed_size\
    \x18\x08\x20\x01(\x05R\x10uncompressedSize\x12'\n\x0fdata_compressed\x18\
    \t\x20\x01(\x08R\x0edataCompressed\x124\n\x16using_varint_bitcounts\x18\
    \n\x20\x01(\x08R\x14usingVarintBitcounts\"\x87\x01\n\x19CSVCMsg_UpdateSt\
    ringTable\x12\x19\n\x08table_id\x18\x01\x20\x01(\x05R\x07tableId\x12.\n\
    \x13num_changed_entries\x18\x02\x20\x01(\x05R\x11numChangedEntries\x12\
    \x1f\n\x0bstring_data\x18\x03\x20\x01(\x0cR\nstringData\"\xe1\x01\n\x11C\
    SVCMsg_VoiceData\x12%\n\x05audio\x18\x01\x20\x01(\x0b2\x0f.CMsgVoiceAudi\
    oR\x05audio\x12\x1a\n\x06client\x18\x02\x20\x01(\x05:\x02-1R\x06client\
    \x12\x1c\n\tproximity\x18\x03\x20\x01(\x08R\tproximity\x12\x12\n\x04xuid\
    \x18\x04\x20\x01(\x06R\x04xuid\x12!\n\x0caudible_mask\x18\x05\x20\x01(\
    \x05R\x0baudibleMask\x12\x12\n\x04tick\x18\x06\x20\x01(\rR\x04tick\x12\
    \x20\n\x0bpassthrough\x18\x07\x20\x01(\x05R\x0bpassthrough\"f\n\x16CSVCM\
    sg_PacketReliable\x12\x12\n\x04tick\x18\x01\x20\x01(\x05R\x04tick\x12\"\
    \n\x0cmessagessize\x18\x02\x20\x01(\x05R\x0cmessagessize\x12\x14\n\x05st\
    ate\x18\x03\x20\x01(\x08R\x05state\"p\n\x16CSVCMsg_FullFrameSplit\x12\
    \x12\n\x04tick\x18\x01\x20\x01(\x05R\x04tick\x12\x18\n\x07section\x18\
    \x02\x20\x01(\x05R\x07section\x12\x14\n\x05total\x18\x03\x20\x01(\x05R\
    \x05total\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04data\"v\n\x12CSVCMs\
    g_HLTVStatus\x12\x16\n\x06master\x18\x01\x20\x01(\tR\x06master\x12\x18\n\
    \x07clients\x18\x02\x20\x01(\x05R\x07clients\x12\x14\n\x05slots\x18\x03\
    \x20\x01(\x05R\x05slots\x12\x18\n\x07proxies\x18\x04\x20\x01(\x05R\x07pr\
    oxies\"2\n\x15CSVCMsg_ServerSteamID\x12\x19\n\x08steam_id\x18\x01\x20\
    \x01(\x04R\x07steamId\"*\n\x14CSVCMsg_CmdKeyValues\x12\x12\n\x04data\x18\
    \x01\x20\x01(\x0cR\x04data\"K\n\x19CSVCMsg_RconServerDetails\x12\x14\n\
    \x05token\x18\x01\x20\x01(\x0cR\x05token\x12\x18\n\x07details\x18\x02\
    \x20\x01(\tR\x07details\"T\n\x0eCMsgIPCAddress\x12#\n\rcomputer_guid\x18\
    \x01\x20\x01(\x06R\x0ccomputerGuid\x12\x1d\n\nprocess_id\x18\x02\x20\x01\
    (\rR\tprocessId\"\xec\x01\n\x0eCMsgServerPeer\x12#\n\x0bplayer_slot\x18\
    \x01\x20\x01(\x05:\x02-1R\nplayerSlot\x12\x18\n\x07steamid\x18\x02\x20\
    \x01(\x06R\x07steamid\x12!\n\x03ipc\x18\x03\x20\x01(\x0b2\x0f.CMsgIPCAdd\
    ressR\x03ipc\x12\"\n\rthey_hear_you\x18\x04\x20\x01(\x08R\x0btheyHearYou\
    \x12\"\n\ryou_hear_them\x18\x05\x20\x01(\x08R\x0byouHearThem\x120\n\x14i\
    s_listenserver_host\x18\x06\x20\x01(\x08R\x12isListenserverHost\"7\n\x10\
    CSVCMsg_PeerList\x12#\n\x04peer\x18\x01\x20\x03(\x0b2\x0f.CMsgServerPeer\
    R\x04peer\"l\n\x1cCSVCMsg_ClearAllStringTables\x12\x18\n\x07mapname\x18\
    \x01\x20\x01(\tR\x07mapname\x122\n\x15create_tables_skipped\x18\x03\x20\
    \x01(\x08R\x13createTablesSkipped\"\xee\x05\n\x1fProtoFlattenedSerialize\
    rField_t\x12\x20\n\x0cvar_type_sym\x18\x01\x20\x01(\x05R\nvarTypeSym\x12\
    \x20\n\x0cvar_name_sym\x18\x02\x20\x01(\x05R\nvarNameSym\x12\x1b\n\tbit_\
    count\x18\x03\x20\x01(\x05R\x08bitCount\x12\x1b\n\tlow_value\x18\x04\x20\
    \x01(\x02R\x08lowValue\x12\x1d\n\nhigh_value\x18\x05\x20\x01(\x02R\thigh\
    Value\x12!\n\x0cencode_flags\x18\x06\x20\x01(\x05R\x0bencodeFlags\x129\n\
    \x19field_serializer_name_sym\x18\x07\x20\x01(\x05R\x16fieldSerializerNa\
    meSym\x128\n\x18field_serializer_version\x18\x08\x20\x01(\x05R\x16fieldS\
    erializerVersion\x12\"\n\rsend_node_sym\x18\t\x20\x01(\x05R\x0bsendNodeS\
    ym\x12&\n\x0fvar_encoder_sym\x18\n\x20\x01(\x05R\rvarEncoderSym\x12a\n\
    \x11polymorphic_types\x18\x0b\x20\x03(\x0b24.ProtoFlattenedSerializerFie\
    ld_t.polymorphic_field_tR\x10polymorphicTypes\x12,\n\x12var_serializer_s\
    ym\x18\x0c\x20\x01(\x05R\x10varSerializerSym\x1a\xb8\x01\n\x13polymorphi\
    c_field_t\x12P\n%polymorphic_field_serializer_name_sym\x18\x01\x20\x01(\
    \x05R!polymorphicFieldSerializerNameSym\x12O\n$polymorphic_field_seriali\
    zer_version\x18\x02\x20\x01(\x05R!polymorphicFieldSerializerVersion\"\
    \x9e\x01\n\x1aProtoFlattenedSerializer_t\x12.\n\x13serializer_name_sym\
    \x18\x01\x20\x01(\x05R\x11serializerNameSym\x12-\n\x12serializer_version\
    \x18\x02\x20\x01(\x05R\x11serializerVersion\x12!\n\x0cfields_index\x18\
    \x03\x20\x03(\x05R\x0bfieldsIndex\"\xb0\x01\n\x1bCSVCMsg_FlattenedSerial\
    izer\x12=\n\x0bserializers\x18\x01\x20\x03(\x0b2\x1b.ProtoFlattenedSeria\
    lizer_tR\x0bserializers\x12\x18\n\x07symbols\x18\x02\x20\x03(\tR\x07symb\
    ols\x128\n\x06fields\x18\x03\x20\x03(\x0b2\x20.ProtoFlattenedSerializerF\
    ield_tR\x06fields\"'\n\x11CSVCMsg_StopSound\x12\x12\n\x04guid\x18\x01\
    \x20\x01(\x07R\x04guid\"\xb2\x01\n\x1eCBidirMsg_RebroadcastGameEvent\x12\
    \"\n\x0cposttoserver\x18\x01\x20\x01(\x08R\x0cposttoserver\x12\x18\n\x07\
    buftype\x18\x02\x20\x01(\x05R\x07buftype\x12&\n\x0eclientbitcount\x18\
    \x03\x20\x01(\rR\x0eclientbitcount\x12*\n\x10receivingclients\x18\x04\
    \x20\x01(\x04R\x10receivingclients\"?\n\x1bCBidirMsg_RebroadcastSource\
    \x12\x20\n\x0beventsource\x18\x01\x20\x01(\x05R\x0beventsource\"\xdb\t\n\
    \x16CMsgServerNetworkStats\x12\x1c\n\tdedicated\x18\x01\x20\x01(\x08R\td\
    edicated\x12\x1b\n\tcpu_usage\x18\x02\x20\x01(\x05R\x08cpuUsage\x12$\n\
    \x0ememory_used_mb\x18\x03\x20\x01(\x05R\x0cmemoryUsedMb\x12$\n\x0ememor\
    y_free_mb\x18\x04\x20\x01(\x05R\x0cmemoryFreeMb\x12\x16\n\x06uptime\x18\
    \x05\x20\x01(\x05R\x06uptime\x12\x1f\n\x0bspawn_count\x18\x06\x20\x01(\
    \x05R\nspawnCount\x12\x1f\n\x0bnum_clients\x18\x08\x20\x01(\x05R\nnumCli\
    ents\x12\x19\n\x08num_bots\x18\t\x20\x01(\x05R\x07numBots\x12%\n\x0enum_\
    spectators\x18\n\x20\x01(\x05R\rnumSpectators\x12\"\n\rnum_tv_relays\x18\
    \x0b\x20\x01(\x05R\x0bnumTvRelays\x12\x10\n\x03fps\x18\x0c\x20\x01(\x02R\
    \x03fps\x122\n\x05ports\x18\x11\x20\x03(\x0b2\x1c.CMsgServerNetworkStats\
    .PortR\x05ports\x12\x1e\n\x0bavg_ping_ms\x18\x12\x20\x01(\x02R\tavgPingM\
    s\x123\n\x16avg_engine_latency_out\x18\x13\x20\x01(\x02R\x13avgEngineLat\
    encyOut\x12&\n\x0favg_packets_out\x18\x14\x20\x01(\x02R\ravgPacketsOut\
    \x12$\n\x0eavg_packets_in\x18\x15\x20\x01(\x02R\x0cavgPacketsIn\x12\x20\
    \n\x0cavg_loss_out\x18\x16\x20\x01(\x02R\navgLossOut\x12\x1e\n\x0bavg_lo\
    ss_in\x18\x17\x20\x01(\x02R\tavgLossIn\x12\x20\n\x0cavg_data_out\x18\x18\
    \x20\x01(\x02R\navgDataOut\x12\x1e\n\x0bavg_data_in\x18\x19\x20\x01(\x02\
    R\tavgDataIn\x12\"\n\rtotal_data_in\x18\x1a\x20\x01(\x04R\x0btotalDataIn\
    \x12(\n\x10total_packets_in\x18\x1b\x20\x01(\x04R\x0etotalPacketsIn\x12$\
    \n\x0etotal_data_out\x18\x1c\x20\x01(\x04R\x0ctotalDataOut\x12*\n\x11tot\
    al_packets_out\x18\x1d\x20\x01(\x04R\x0ftotalPacketsOut\x128\n\x07player\
    s\x18\x1e\x20\x03(\x0b2\x1e.CMsgServerNetworkStats.PlayerR\x07players\
    \x1a.\n\x04Port\x12\x12\n\x04port\x18\x01\x20\x01(\x05R\x04port\x12\x12\
    \n\x04name\x18\x02\x20\x01(\tR\x04name\x1a\x82\x02\n\x06Player\x12\x18\n\
    \x07steamid\x18\x01\x20\x01(\x04R\x07steamid\x12\x1f\n\x0bremote_addr\
    \x18\x02\x20\x01(\tR\nremoteAddr\x12\x1e\n\x0bping_avg_ms\x18\x04\x20\
    \x01(\x05R\tpingAvgMs\x12&\n\x0fpacket_loss_pct\x18\x05\x20\x01(\x02R\rp\
    acketLossPct\x12\x15\n\x06is_bot\x18\x06\x20\x01(\x08R\x05isBot\x12\x17\
    \n\x07loss_in\x18\x07\x20\x01(\x02R\x06lossIn\x12\x19\n\x08loss_out\x18\
    \x08\x20\x01(\x02R\x07lossOut\x12*\n\x11engine_latency_ms\x18\t\x20\x01(\
    \x05R\x0fengineLatencyMs\"\xd1\x02\n\x12CSVCMsg_HltvReplay\x12\x14\n\x05\
    delay\x18\x01\x20\x01(\x05R\x05delay\x12)\n\x0eprimary_target\x18\x02\
    \x20\x01(\x05:\x02-1R\rprimaryTarget\x12$\n\x0ereplay_stop_at\x18\x03\
    \x20\x01(\x05R\x0creplayStopAt\x12&\n\x0freplay_start_at\x18\x04\x20\x01\
    (\x05R\rreplayStartAt\x122\n\x15replay_slowdown_begin\x18\x05\x20\x01(\
    \x05R\x13replaySlowdownBegin\x12.\n\x13replay_slowdown_end\x18\x06\x20\
    \x01(\x05R\x11replaySlowdownEnd\x120\n\x14replay_slowdown_rate\x18\x07\
    \x20\x01(\x02R\x12replaySlowdownRate\x12\x16\n\x06reason\x18\x08\x20\x01\
    (\x05R\x06reason\"\xc6\x01\n\x12CCLCMsg_HltvReplay\x12\x18\n\x07request\
    \x18\x01\x20\x01(\x05R\x07request\x12'\n\x0fslowdown_length\x18\x02\x20\
    \x01(\x02R\x0eslowdownLength\x12#\n\rslowdown_rate\x18\x03\x20\x01(\x02R\
    \x0cslowdownRate\x12)\n\x0eprimary_target\x18\x04\x20\x01(\x05:\x02-1R\r\
    primaryTarget\x12\x1d\n\nevent_time\x18\x05\x20\x01(\x02R\teventTime\"-\
    \n\x19CSVCMsg_Broadcast_Command\x12\x10\n\x03cmd\x18\x01\x20\x01(\tR\x03\
    cmd\"\xd2\x02\n\x1dCCLCMsg_HltvFixupOperatorTick\x12\x12\n\x04tick\x18\
    \x01\x20\x01(\x05R\x04tick\x12\x1d\n\nprops_data\x18\x02\x20\x01(\x0cR\t\
    propsData\x12#\n\x06origin\x18\x03\x20\x01(\x0b2\x0b.CMsgVectorR\x06orig\
    in\x12*\n\neye_angles\x18\x04\x20\x01(\x0b2\x0b.CMsgQAngleR\teyeAngles\
    \x12#\n\robserver_mode\x18\x05\x20\x01(\x05R\x0cobserverMode\x121\n\x14c\
    ameraman_scoreboard\x18\x06\x20\x01(\x08R\x13cameramanScoreboard\x12'\n\
    \x0fobserver_target\x18\x07\x20\x01(\x05R\x0eobserverTarget\x12,\n\x0bvi\
    ew_offset\x18\x08\x20\x01(\x0b2\x0b.CMsgVectorR\nviewOffset\"k\n\x1fCSVC\
    Msg_HltvFixupOperatorStatus\x12\x12\n\x04mode\x18\x01\x20\x01(\rR\x04mod\
    e\x124\n\x16override_operator_name\x18\x02\x20\x01(\tR\x14overrideOperat\
    orName\"\x9d\x01\n\x11CMsgServerUserCmd\x12\x12\n\x04data\x18\x01\x20\
    \x01(\x0cR\x04data\x12\x1d\n\ncmd_number\x18\x02\x20\x01(\x05R\tcmdNumbe\
    r\x12#\n\x0bplayer_slot\x18\x03\x20\x01(\x05:\x02-1R\nplayerSlot\x120\n\
    \x14server_tick_executed\x18\x04\x20\x01(\x05R\x12serverTickExecuted\"F\
    \n\x14CSVCMsg_UserCommands\x12.\n\x08commands\x18\x01\x20\x03(\x0b2\x12.\
    CMsgServerUserCmdR\x08commands*\xa2\x03\n\x0cCLC_Messages\x12\x12\n\x0ec\
    lc_ClientInfo\x10\x14\x12\x0c\n\x08clc_Move\x10\x15\x12\x11\n\rclc_Voice\
    Data\x10\x16\x12\x13\n\x0fclc_BaselineAck\x10\x17\x12\x14\n\x10clc_Liste\
    nEvents\x10\x18\x12\x18\n\x14clc_RespondCvarValue\x10\x19\x12\x14\n\x10c\
    lc_FileCRCCheck\x10\x1a\x12\x17\n\x13clc_LoadingProgress\x10\x1b\x12\x1a\
    \n\x16clc_SplitPlayerConnect\x10\x1c\x12\x15\n\x11clc_ClientMessage\x10\
    \x1d\x12\x1d\n\x19clc_SplitPlayerDisconnect\x10\x1e\x12\x14\n\x10clc_Ser\
    verStatus\x10\x1f\x12\x12\n\x0eclc_ServerPing\x10\x20\x12\x14\n\x10clc_R\
    equestPause\x10!\x12\x14\n\x10clc_CmdKeyValues\x10\"\x12\x19\n\x15clc_Rc\
    onServerDetails\x10#\x12\x12\n\x0eclc_HltvReplay\x10$\x12\x12\n\x0eclc_D\
    iagnostic\x10%*\xab\x05\n\x0cSVC_Messages\x12\x12\n\x0esvc_ServerInfo\
    \x10(\x12\x1b\n\x17svc_FlattenedSerializer\x10)\x12\x11\n\rsvc_ClassInfo\
    \x10*\x12\x10\n\x0csvc_SetPause\x10+\x12\x19\n\x15svc_CreateStringTable\
    \x10,\x12\x19\n\x15svc_UpdateStringTable\x10-\x12\x11\n\rsvc_VoiceInit\
    \x10.\x12\x11\n\rsvc_VoiceData\x10/\x12\r\n\tsvc_Print\x100\x12\x0e\n\ns\
    vc_Sounds\x101\x12\x0f\n\x0bsvc_SetView\x102\x12\x1c\n\x18svc_ClearAllSt\
    ringTables\x103\x12\x14\n\x10svc_CmdKeyValues\x104\x12\x10\n\x0csvc_BSPD\
    ecal\x105\x12\x13\n\x0fsvc_SplitScreen\x106\x12\x16\n\x12svc_PacketEntit\
    ies\x107\x12\x10\n\x0csvc_Prefetch\x108\x12\x0c\n\x08svc_Menu\x109\x12\
    \x14\n\x10svc_GetCvarValue\x10:\x12\x11\n\rsvc_StopSound\x10;\x12\x10\n\
    \x0csvc_PeerList\x10<\x12\x16\n\x12svc_PacketReliable\x10=\x12\x12\n\x0e\
    svc_HLTVStatus\x10>\x12\x15\n\x11svc_ServerSteamID\x10?\x12\x16\n\x12svc\
    _FullFrameSplit\x10F\x12\x19\n\x15svc_RconServerDetails\x10G\x12\x13\n\
    \x0fsvc_UserMessage\x10H\x12\x12\n\x0esvc_HltvReplay\x10I\x12\x19\n\x15s\
    vc_Broadcast_Command\x10J\x12\x1f\n\x1bsvc_HltvFixupOperatorStatus\x10K\
    \x12\x10\n\x0csvc_UserCmds\x10L*g\n\x11VoiceDataFormat_t\x12\x1a\n\x16VO\
    ICEDATA_FORMAT_STEAM\x10\0\x12\x1b\n\x17VOICEDATA_FORMAT_ENGINE\x10\x01\
    \x12\x19\n\x15VOICEDATA_FORMAT_OPUS\x10\x02*B\n\x0eRequestPause_t\x12\
    \x0c\n\x08RP_PAUSE\x10\0\x12\x0e\n\nRP_UNPAUSE\x10\x01\x12\x12\n\x0eRP_T\
    OGGLEPAUSE\x10\x02*\x1d\n\x0cPrefetchType\x12\r\n\tPFT_SOUND\x10\0*V\n\
    \x17ESplitScreenMessageType\x12\x1b\n\x17MSG_SPLITSCREEN_ADDUSER\x10\0\
    \x12\x1e\n\x1aMSG_SPLITSCREEN_REMOVEUSER\x10\x01*\xb3\x01\n\x15EQueryCva\
    rValueStatus\x12%\n!eQueryCvarValueStatus_ValueIntact\x10\0\x12&\n\"eQue\
    ryCvarValueStatus_CvarNotFound\x10\x01\x12\"\n\x1eeQueryCvarValueStatus_\
    NotACvar\x10\x02\x12'\n#eQueryCvarValueStatus_CvarProtected\x10\x03*h\n\
    \x0bDIALOG_TYPE\x12\x0e\n\nDIALOG_MSG\x10\0\x12\x0f\n\x0bDIALOG_MENU\x10\
    \x01\x12\x0f\n\x0bDIALOG_TEXT\x10\x02\x12\x10\n\x0cDIALOG_ENTRY\x10\x03\
    \x12\x15\n\x11DIALOG_ASKCONNECT\x10\x04*+\n\x19SVC_Messages_LowFrequency\
    \x12\x0e\n\tsvc_dummy\x10\xd8\x04*a\n\x16Bidirectional_Messages\x12\x1b\
    \n\x17bi_RebroadcastGameEvent\x10\x10\x12\x18\n\x14bi_RebroadcastSource\
    \x10\x11\x12\x10\n\x0cbi_GameEvent\x10\x12*M\n#Bidirectional_Messages_Lo\
    wFrequency\x12\x11\n\x0cbi_RelayInfo\x10\xbc\x05\x12\x13\n\x0ebi_RelayPa\
    cket\x10\xbd\x05*\xa1\x01\n\x11ReplayEventType_t\x12\x17\n\x13REPLAY_EVE\
    NT_CANCEL\x10\0\x12\x16\n\x12REPLAY_EVENT_DEATH\x10\x01\x12\x18\n\x14REP\
    LAY_EVENT_GENERIC\x10\x02\x12'\n#REPLAY_EVENT_STUCK_NEED_FULL_UPDATE\x10\
    \x03\x12\x18\n\x14REPLAY_EVENT_VICTORY\x10\x04\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::networkbasetypes::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(78);
            messages.push(CCLCMsg_ClientInfo::generated_message_descriptor_data());
            messages.push(CCLCMsg_Move::generated_message_descriptor_data());
            messages.push(CMsgVoiceAudio::generated_message_descriptor_data());
            messages.push(CCLCMsg_VoiceData::generated_message_descriptor_data());
            messages.push(CCLCMsg_BaselineAck::generated_message_descriptor_data());
            messages.push(CCLCMsg_ListenEvents::generated_message_descriptor_data());
            messages.push(CCLCMsg_RespondCvarValue::generated_message_descriptor_data());
            messages.push(CCLCMsg_FileCRCCheck::generated_message_descriptor_data());
            messages.push(CCLCMsg_LoadingProgress::generated_message_descriptor_data());
            messages.push(CCLCMsg_SplitPlayerConnect::generated_message_descriptor_data());
            messages.push(CCLCMsg_ClientMessage::generated_message_descriptor_data());
            messages.push(CCLCMsg_SplitPlayerDisconnect::generated_message_descriptor_data());
            messages.push(CCLCMsg_ServerStatus::generated_message_descriptor_data());
            messages.push(CCLCMsg_RequestPause::generated_message_descriptor_data());
            messages.push(CCLCMsg_CmdKeyValues::generated_message_descriptor_data());
            messages.push(CCLCMsg_RconServerDetails::generated_message_descriptor_data());
            messages.push(CMsgSource2SystemSpecs::generated_message_descriptor_data());
            messages.push(CMsgSource2VProfLiteReportItem::generated_message_descriptor_data());
            messages.push(CMsgSource2VProfLiteReport::generated_message_descriptor_data());
            messages.push(CCLCMsg_Diagnostic::generated_message_descriptor_data());
            messages.push(CSource2Metrics_MatchPerfSummary_Notification::generated_message_descriptor_data());
            messages.push(CSVCMsg_ServerInfo::generated_message_descriptor_data());
            messages.push(CSVCMsg_ClassInfo::generated_message_descriptor_data());
            messages.push(CSVCMsg_SetPause::generated_message_descriptor_data());
            messages.push(CSVCMsg_VoiceInit::generated_message_descriptor_data());
            messages.push(CSVCMsg_Print::generated_message_descriptor_data());
            messages.push(CSVCMsg_Sounds::generated_message_descriptor_data());
            messages.push(CSVCMsg_Prefetch::generated_message_descriptor_data());
            messages.push(CSVCMsg_SetView::generated_message_descriptor_data());
            messages.push(CSVCMsg_FixAngle::generated_message_descriptor_data());
            messages.push(CSVCMsg_CrosshairAngle::generated_message_descriptor_data());
            messages.push(CSVCMsg_BSPDecal::generated_message_descriptor_data());
            messages.push(CSVCMsg_SplitScreen::generated_message_descriptor_data());
            messages.push(CSVCMsg_GetCvarValue::generated_message_descriptor_data());
            messages.push(CSVCMsg_Menu::generated_message_descriptor_data());
            messages.push(CSVCMsg_UserMessage::generated_message_descriptor_data());
            messages.push(CSVCMsg_SendTable::generated_message_descriptor_data());
            messages.push(CSVCMsg_GameEventList::generated_message_descriptor_data());
            messages.push(CSVCMsg_PacketEntities::generated_message_descriptor_data());
            messages.push(CSVCMsg_TempEntities::generated_message_descriptor_data());
            messages.push(CSVCMsg_CreateStringTable::generated_message_descriptor_data());
            messages.push(CSVCMsg_UpdateStringTable::generated_message_descriptor_data());
            messages.push(CSVCMsg_VoiceData::generated_message_descriptor_data());
            messages.push(CSVCMsg_PacketReliable::generated_message_descriptor_data());
            messages.push(CSVCMsg_FullFrameSplit::generated_message_descriptor_data());
            messages.push(CSVCMsg_HLTVStatus::generated_message_descriptor_data());
            messages.push(CSVCMsg_ServerSteamID::generated_message_descriptor_data());
            messages.push(CSVCMsg_CmdKeyValues::generated_message_descriptor_data());
            messages.push(CSVCMsg_RconServerDetails::generated_message_descriptor_data());
            messages.push(CMsgIPCAddress::generated_message_descriptor_data());
            messages.push(CMsgServerPeer::generated_message_descriptor_data());
            messages.push(CSVCMsg_PeerList::generated_message_descriptor_data());
            messages.push(CSVCMsg_ClearAllStringTables::generated_message_descriptor_data());
            messages.push(ProtoFlattenedSerializerField_t::generated_message_descriptor_data());
            messages.push(ProtoFlattenedSerializer_t::generated_message_descriptor_data());
            messages.push(CSVCMsg_FlattenedSerializer::generated_message_descriptor_data());
            messages.push(CSVCMsg_StopSound::generated_message_descriptor_data());
            messages.push(CBidirMsg_RebroadcastGameEvent::generated_message_descriptor_data());
            messages.push(CBidirMsg_RebroadcastSource::generated_message_descriptor_data());
            messages.push(CMsgServerNetworkStats::generated_message_descriptor_data());
            messages.push(CSVCMsg_HltvReplay::generated_message_descriptor_data());
            messages.push(CCLCMsg_HltvReplay::generated_message_descriptor_data());
            messages.push(CSVCMsg_Broadcast_Command::generated_message_descriptor_data());
            messages.push(CCLCMsg_HltvFixupOperatorTick::generated_message_descriptor_data());
            messages.push(CSVCMsg_HltvFixupOperatorStatus::generated_message_descriptor_data());
            messages.push(CMsgServerUserCmd::generated_message_descriptor_data());
            messages.push(CSVCMsg_UserCommands::generated_message_descriptor_data());
            messages.push(csource2metrics_match_perf_summary_notification::Client::generated_message_descriptor_data());
            messages.push(csvcmsg_class_info::Class_t::generated_message_descriptor_data());
            messages.push(csvcmsg_sounds::Sounddata_t::generated_message_descriptor_data());
            messages.push(csvcmsg_send_table::Sendprop_t::generated_message_descriptor_data());
            messages.push(csvcmsg_game_event_list::Key_t::generated_message_descriptor_data());
            messages.push(csvcmsg_game_event_list::Descriptor_t::generated_message_descriptor_data());
            messages.push(csvcmsg_packet_entities::Alternate_baseline_t::generated_message_descriptor_data());
            messages.push(csvcmsg_packet_entities::Non_transmitted_entities_t::generated_message_descriptor_data());
            messages.push(proto_flattened_serializer_field_t::Polymorphic_field_t::generated_message_descriptor_data());
            messages.push(cmsg_server_network_stats::Port::generated_message_descriptor_data());
            messages.push(cmsg_server_network_stats::Player::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(12);
            enums.push(CLC_Messages::generated_enum_descriptor_data());
            enums.push(SVC_Messages::generated_enum_descriptor_data());
            enums.push(VoiceDataFormat_t::generated_enum_descriptor_data());
            enums.push(RequestPause_t::generated_enum_descriptor_data());
            enums.push(PrefetchType::generated_enum_descriptor_data());
            enums.push(ESplitScreenMessageType::generated_enum_descriptor_data());
            enums.push(EQueryCvarValueStatus::generated_enum_descriptor_data());
            enums.push(DIALOG_TYPE::generated_enum_descriptor_data());
            enums.push(SVC_Messages_LowFrequency::generated_enum_descriptor_data());
            enums.push(Bidirectional_Messages::generated_enum_descriptor_data());
            enums.push(Bidirectional_Messages_LowFrequency::generated_enum_descriptor_data());
            enums.push(ReplayEventType_t::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
