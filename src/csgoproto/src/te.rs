// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `te.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgTEArmorRicochet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEArmorRicochet {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEArmorRicochet.pos)
    pub pos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEArmorRicochet.dir)
    pub dir: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEArmorRicochet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEArmorRicochet {
    fn default() -> &'a CMsgTEArmorRicochet {
        <CMsgTEArmorRicochet as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEArmorRicochet {
    pub fn new() -> CMsgTEArmorRicochet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "pos",
            |m: &CMsgTEArmorRicochet| { &m.pos },
            |m: &mut CMsgTEArmorRicochet| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "dir",
            |m: &CMsgTEArmorRicochet| { &m.dir },
            |m: &mut CMsgTEArmorRicochet| { &mut m.dir },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEArmorRicochet>(
            "CMsgTEArmorRicochet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEArmorRicochet {
    const NAME: &'static str = "CMsgTEArmorRicochet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dir)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dir.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEArmorRicochet {
        CMsgTEArmorRicochet::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.dir.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEArmorRicochet {
        static instance: CMsgTEArmorRicochet = CMsgTEArmorRicochet {
            pos: ::protobuf::MessageField::none(),
            dir: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEArmorRicochet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEArmorRicochet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEArmorRicochet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEArmorRicochet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEBaseBeam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBaseBeam {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.modelindex)
    pub modelindex: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.haloindex)
    pub haloindex: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.startframe)
    pub startframe: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.framerate)
    pub framerate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.life)
    pub life: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.width)
    pub width: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.endwidth)
    pub endwidth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.fadelength)
    pub fadelength: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.amplitude)
    pub amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.speed)
    pub speed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBaseBeam.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBaseBeam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBaseBeam {
    fn default() -> &'a CMsgTEBaseBeam {
        <CMsgTEBaseBeam as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBaseBeam {
    pub fn new() -> CMsgTEBaseBeam {
        ::std::default::Default::default()
    }

    // optional fixed64 modelindex = 1;

    pub fn modelindex(&self) -> u64 {
        self.modelindex.unwrap_or(0)
    }

    pub fn clear_modelindex(&mut self) {
        self.modelindex = ::std::option::Option::None;
    }

    pub fn has_modelindex(&self) -> bool {
        self.modelindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modelindex(&mut self, v: u64) {
        self.modelindex = ::std::option::Option::Some(v);
    }

    // optional fixed64 haloindex = 2;

    pub fn haloindex(&self) -> u64 {
        self.haloindex.unwrap_or(0)
    }

    pub fn clear_haloindex(&mut self) {
        self.haloindex = ::std::option::Option::None;
    }

    pub fn has_haloindex(&self) -> bool {
        self.haloindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_haloindex(&mut self, v: u64) {
        self.haloindex = ::std::option::Option::Some(v);
    }

    // optional uint32 startframe = 3;

    pub fn startframe(&self) -> u32 {
        self.startframe.unwrap_or(0)
    }

    pub fn clear_startframe(&mut self) {
        self.startframe = ::std::option::Option::None;
    }

    pub fn has_startframe(&self) -> bool {
        self.startframe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startframe(&mut self, v: u32) {
        self.startframe = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate = 4;

    pub fn framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional float life = 5;

    pub fn life(&self) -> f32 {
        self.life.unwrap_or(0.)
    }

    pub fn clear_life(&mut self) {
        self.life = ::std::option::Option::None;
    }

    pub fn has_life(&self) -> bool {
        self.life.is_some()
    }

    // Param is passed by value, moved
    pub fn set_life(&mut self, v: f32) {
        self.life = ::std::option::Option::Some(v);
    }

    // optional float width = 6;

    pub fn width(&self) -> f32 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional float endwidth = 7;

    pub fn endwidth(&self) -> f32 {
        self.endwidth.unwrap_or(0.)
    }

    pub fn clear_endwidth(&mut self) {
        self.endwidth = ::std::option::Option::None;
    }

    pub fn has_endwidth(&self) -> bool {
        self.endwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endwidth(&mut self, v: f32) {
        self.endwidth = ::std::option::Option::Some(v);
    }

    // optional uint32 fadelength = 8;

    pub fn fadelength(&self) -> u32 {
        self.fadelength.unwrap_or(0)
    }

    pub fn clear_fadelength(&mut self) {
        self.fadelength = ::std::option::Option::None;
    }

    pub fn has_fadelength(&self) -> bool {
        self.fadelength.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fadelength(&mut self, v: u32) {
        self.fadelength = ::std::option::Option::Some(v);
    }

    // optional float amplitude = 9;

    pub fn amplitude(&self) -> f32 {
        self.amplitude.unwrap_or(0.)
    }

    pub fn clear_amplitude(&mut self) {
        self.amplitude = ::std::option::Option::None;
    }

    pub fn has_amplitude(&self) -> bool {
        self.amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amplitude(&mut self, v: f32) {
        self.amplitude = ::std::option::Option::Some(v);
    }

    // optional fixed32 color = 10;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional uint32 speed = 11;

    pub fn speed(&self) -> u32 {
        self.speed.unwrap_or(0)
    }

    pub fn clear_speed(&mut self) {
        self.speed = ::std::option::Option::None;
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: u32) {
        self.speed = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 12;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modelindex",
            |m: &CMsgTEBaseBeam| { &m.modelindex },
            |m: &mut CMsgTEBaseBeam| { &mut m.modelindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "haloindex",
            |m: &CMsgTEBaseBeam| { &m.haloindex },
            |m: &mut CMsgTEBaseBeam| { &mut m.haloindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "startframe",
            |m: &CMsgTEBaseBeam| { &m.startframe },
            |m: &mut CMsgTEBaseBeam| { &mut m.startframe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "framerate",
            |m: &CMsgTEBaseBeam| { &m.framerate },
            |m: &mut CMsgTEBaseBeam| { &mut m.framerate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "life",
            |m: &CMsgTEBaseBeam| { &m.life },
            |m: &mut CMsgTEBaseBeam| { &mut m.life },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgTEBaseBeam| { &m.width },
            |m: &mut CMsgTEBaseBeam| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endwidth",
            |m: &CMsgTEBaseBeam| { &m.endwidth },
            |m: &mut CMsgTEBaseBeam| { &mut m.endwidth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fadelength",
            |m: &CMsgTEBaseBeam| { &m.fadelength },
            |m: &mut CMsgTEBaseBeam| { &mut m.fadelength },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amplitude",
            |m: &CMsgTEBaseBeam| { &m.amplitude },
            |m: &mut CMsgTEBaseBeam| { &mut m.amplitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CMsgTEBaseBeam| { &m.color },
            |m: &mut CMsgTEBaseBeam| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speed",
            |m: &CMsgTEBaseBeam| { &m.speed },
            |m: &mut CMsgTEBaseBeam| { &mut m.speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgTEBaseBeam| { &m.flags },
            |m: &mut CMsgTEBaseBeam| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEBaseBeam>(
            "CMsgTEBaseBeam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEBaseBeam {
    const NAME: &'static str = "CMsgTEBaseBeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.modelindex = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.haloindex = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.startframe = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.framerate = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.life = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.width = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.endwidth = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.fadelength = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                88 => {
                    self.speed = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modelindex {
            my_size += 1 + 8;
        }
        if let Some(v) = self.haloindex {
            my_size += 1 + 8;
        }
        if let Some(v) = self.startframe {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.framerate {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.life {
            my_size += 1 + 4;
        }
        if let Some(v) = self.width {
            my_size += 1 + 4;
        }
        if let Some(v) = self.endwidth {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fadelength {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        if let Some(v) = self.speed {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.modelindex {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.haloindex {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.startframe {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.framerate {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.life {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.width {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.endwidth {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.fadelength {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.amplitude {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.speed {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBaseBeam {
        CMsgTEBaseBeam::new()
    }

    fn clear(&mut self) {
        self.modelindex = ::std::option::Option::None;
        self.haloindex = ::std::option::Option::None;
        self.startframe = ::std::option::Option::None;
        self.framerate = ::std::option::Option::None;
        self.life = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.endwidth = ::std::option::Option::None;
        self.fadelength = ::std::option::Option::None;
        self.amplitude = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.speed = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBaseBeam {
        static instance: CMsgTEBaseBeam = CMsgTEBaseBeam {
            modelindex: ::std::option::Option::None,
            haloindex: ::std::option::Option::None,
            startframe: ::std::option::Option::None,
            framerate: ::std::option::Option::None,
            life: ::std::option::Option::None,
            width: ::std::option::Option::None,
            endwidth: ::std::option::Option::None,
            fadelength: ::std::option::Option::None,
            amplitude: ::std::option::Option::None,
            color: ::std::option::Option::None,
            speed: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEBaseBeam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEBaseBeam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEBaseBeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEBaseBeam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEBeamEntPoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBeamEntPoint {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBeamEntPoint.base)
    pub base: ::protobuf::MessageField<CMsgTEBaseBeam>,
    // @@protoc_insertion_point(field:CMsgTEBeamEntPoint.startentity)
    pub startentity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBeamEntPoint.endentity)
    pub endentity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBeamEntPoint.start)
    pub start: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBeamEntPoint.end)
    pub end: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBeamEntPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBeamEntPoint {
    fn default() -> &'a CMsgTEBeamEntPoint {
        <CMsgTEBeamEntPoint as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBeamEntPoint {
    pub fn new() -> CMsgTEBeamEntPoint {
        ::std::default::Default::default()
    }

    // optional uint32 startentity = 2;

    pub fn startentity(&self) -> u32 {
        self.startentity.unwrap_or(0)
    }

    pub fn clear_startentity(&mut self) {
        self.startentity = ::std::option::Option::None;
    }

    pub fn has_startentity(&self) -> bool {
        self.startentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startentity(&mut self, v: u32) {
        self.startentity = ::std::option::Option::Some(v);
    }

    // optional uint32 endentity = 3;

    pub fn endentity(&self) -> u32 {
        self.endentity.unwrap_or(0)
    }

    pub fn clear_endentity(&mut self) {
        self.endentity = ::std::option::Option::None;
    }

    pub fn has_endentity(&self) -> bool {
        self.endentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endentity(&mut self, v: u32) {
        self.endentity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTEBaseBeam>(
            "base",
            |m: &CMsgTEBeamEntPoint| { &m.base },
            |m: &mut CMsgTEBeamEntPoint| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "startentity",
            |m: &CMsgTEBeamEntPoint| { &m.startentity },
            |m: &mut CMsgTEBeamEntPoint| { &mut m.startentity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endentity",
            |m: &CMsgTEBeamEntPoint| { &m.endentity },
            |m: &mut CMsgTEBeamEntPoint| { &mut m.endentity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "start",
            |m: &CMsgTEBeamEntPoint| { &m.start },
            |m: &mut CMsgTEBeamEntPoint| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "end",
            |m: &CMsgTEBeamEntPoint| { &m.end },
            |m: &mut CMsgTEBeamEntPoint| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEBeamEntPoint>(
            "CMsgTEBeamEntPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEBeamEntPoint {
    const NAME: &'static str = "CMsgTEBeamEntPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                16 => {
                    self.startentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.endentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.startentity {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.endentity {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.startentity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.endentity {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBeamEntPoint {
        CMsgTEBeamEntPoint::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.startentity = ::std::option::Option::None;
        self.endentity = ::std::option::Option::None;
        self.start.clear();
        self.end.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBeamEntPoint {
        static instance: CMsgTEBeamEntPoint = CMsgTEBeamEntPoint {
            base: ::protobuf::MessageField::none(),
            startentity: ::std::option::Option::None,
            endentity: ::std::option::Option::None,
            start: ::protobuf::MessageField::none(),
            end: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEBeamEntPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEBeamEntPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEBeamEntPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEBeamEntPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEBeamEnts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBeamEnts {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBeamEnts.base)
    pub base: ::protobuf::MessageField<CMsgTEBaseBeam>,
    // @@protoc_insertion_point(field:CMsgTEBeamEnts.startentity)
    pub startentity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBeamEnts.endentity)
    pub endentity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBeamEnts.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBeamEnts {
    fn default() -> &'a CMsgTEBeamEnts {
        <CMsgTEBeamEnts as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBeamEnts {
    pub fn new() -> CMsgTEBeamEnts {
        ::std::default::Default::default()
    }

    // optional uint32 startentity = 2;

    pub fn startentity(&self) -> u32 {
        self.startentity.unwrap_or(0)
    }

    pub fn clear_startentity(&mut self) {
        self.startentity = ::std::option::Option::None;
    }

    pub fn has_startentity(&self) -> bool {
        self.startentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startentity(&mut self, v: u32) {
        self.startentity = ::std::option::Option::Some(v);
    }

    // optional uint32 endentity = 3;

    pub fn endentity(&self) -> u32 {
        self.endentity.unwrap_or(0)
    }

    pub fn clear_endentity(&mut self) {
        self.endentity = ::std::option::Option::None;
    }

    pub fn has_endentity(&self) -> bool {
        self.endentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endentity(&mut self, v: u32) {
        self.endentity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTEBaseBeam>(
            "base",
            |m: &CMsgTEBeamEnts| { &m.base },
            |m: &mut CMsgTEBeamEnts| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "startentity",
            |m: &CMsgTEBeamEnts| { &m.startentity },
            |m: &mut CMsgTEBeamEnts| { &mut m.startentity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endentity",
            |m: &CMsgTEBeamEnts| { &m.endentity },
            |m: &mut CMsgTEBeamEnts| { &mut m.endentity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEBeamEnts>(
            "CMsgTEBeamEnts",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEBeamEnts {
    const NAME: &'static str = "CMsgTEBeamEnts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                16 => {
                    self.startentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.endentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.startentity {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.endentity {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.startentity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.endentity {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBeamEnts {
        CMsgTEBeamEnts::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.startentity = ::std::option::Option::None;
        self.endentity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBeamEnts {
        static instance: CMsgTEBeamEnts = CMsgTEBeamEnts {
            base: ::protobuf::MessageField::none(),
            startentity: ::std::option::Option::None,
            endentity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEBeamEnts {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEBeamEnts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEBeamEnts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEBeamEnts {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEBeamPoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBeamPoints {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBeamPoints.base)
    pub base: ::protobuf::MessageField<CMsgTEBaseBeam>,
    // @@protoc_insertion_point(field:CMsgTEBeamPoints.start)
    pub start: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBeamPoints.end)
    pub end: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBeamPoints.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBeamPoints {
    fn default() -> &'a CMsgTEBeamPoints {
        <CMsgTEBeamPoints as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBeamPoints {
    pub fn new() -> CMsgTEBeamPoints {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTEBaseBeam>(
            "base",
            |m: &CMsgTEBeamPoints| { &m.base },
            |m: &mut CMsgTEBeamPoints| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "start",
            |m: &CMsgTEBeamPoints| { &m.start },
            |m: &mut CMsgTEBeamPoints| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "end",
            |m: &CMsgTEBeamPoints| { &m.end },
            |m: &mut CMsgTEBeamPoints| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEBeamPoints>(
            "CMsgTEBeamPoints",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEBeamPoints {
    const NAME: &'static str = "CMsgTEBeamPoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBeamPoints {
        CMsgTEBeamPoints::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.start.clear();
        self.end.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBeamPoints {
        static instance: CMsgTEBeamPoints = CMsgTEBeamPoints {
            base: ::protobuf::MessageField::none(),
            start: ::protobuf::MessageField::none(),
            end: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEBeamPoints {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEBeamPoints").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEBeamPoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEBeamPoints {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEBeamRing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBeamRing {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBeamRing.base)
    pub base: ::protobuf::MessageField<CMsgTEBaseBeam>,
    // @@protoc_insertion_point(field:CMsgTEBeamRing.startentity)
    pub startentity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBeamRing.endentity)
    pub endentity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBeamRing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBeamRing {
    fn default() -> &'a CMsgTEBeamRing {
        <CMsgTEBeamRing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBeamRing {
    pub fn new() -> CMsgTEBeamRing {
        ::std::default::Default::default()
    }

    // optional uint32 startentity = 2;

    pub fn startentity(&self) -> u32 {
        self.startentity.unwrap_or(0)
    }

    pub fn clear_startentity(&mut self) {
        self.startentity = ::std::option::Option::None;
    }

    pub fn has_startentity(&self) -> bool {
        self.startentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startentity(&mut self, v: u32) {
        self.startentity = ::std::option::Option::Some(v);
    }

    // optional uint32 endentity = 3;

    pub fn endentity(&self) -> u32 {
        self.endentity.unwrap_or(0)
    }

    pub fn clear_endentity(&mut self) {
        self.endentity = ::std::option::Option::None;
    }

    pub fn has_endentity(&self) -> bool {
        self.endentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endentity(&mut self, v: u32) {
        self.endentity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgTEBaseBeam>(
            "base",
            |m: &CMsgTEBeamRing| { &m.base },
            |m: &mut CMsgTEBeamRing| { &mut m.base },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "startentity",
            |m: &CMsgTEBeamRing| { &m.startentity },
            |m: &mut CMsgTEBeamRing| { &mut m.startentity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endentity",
            |m: &CMsgTEBeamRing| { &m.endentity },
            |m: &mut CMsgTEBeamRing| { &mut m.endentity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEBeamRing>(
            "CMsgTEBeamRing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEBeamRing {
    const NAME: &'static str = "CMsgTEBeamRing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.base)?;
                },
                16 => {
                    self.startentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.endentity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.startentity {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.endentity {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.base.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.startentity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.endentity {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBeamRing {
        CMsgTEBeamRing::new()
    }

    fn clear(&mut self) {
        self.base.clear();
        self.startentity = ::std::option::Option::None;
        self.endentity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBeamRing {
        static instance: CMsgTEBeamRing = CMsgTEBeamRing {
            base: ::protobuf::MessageField::none(),
            startentity: ::std::option::Option::None,
            endentity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEBeamRing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEBeamRing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEBeamRing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEBeamRing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEBSPDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBSPDecal {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBSPDecal.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBSPDecal.normal)
    pub normal: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBSPDecal.saxis)
    pub saxis: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBSPDecal.entity)
    pub entity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTEBSPDecal.index)
    pub index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBSPDecal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBSPDecal {
    fn default() -> &'a CMsgTEBSPDecal {
        <CMsgTEBSPDecal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBSPDecal {
    pub fn new() -> CMsgTEBSPDecal {
        ::std::default::Default::default()
    }

    // optional int32 entity = 4;

    pub fn entity(&self) -> i32 {
        self.entity.unwrap_or(-1i32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional uint32 index = 5;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEBSPDecal| { &m.origin },
            |m: &mut CMsgTEBSPDecal| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "normal",
            |m: &CMsgTEBSPDecal| { &m.normal },
            |m: &mut CMsgTEBSPDecal| { &mut m.normal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "saxis",
            |m: &CMsgTEBSPDecal| { &m.saxis },
            |m: &mut CMsgTEBSPDecal| { &mut m.saxis },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity",
            |m: &CMsgTEBSPDecal| { &m.entity },
            |m: &mut CMsgTEBSPDecal| { &mut m.entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CMsgTEBSPDecal| { &m.index },
            |m: &mut CMsgTEBSPDecal| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEBSPDecal>(
            "CMsgTEBSPDecal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEBSPDecal {
    const NAME: &'static str = "CMsgTEBSPDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.saxis)?;
                },
                32 => {
                    self.entity = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.saxis.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entity {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.saxis.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.entity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBSPDecal {
        CMsgTEBSPDecal::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.normal.clear();
        self.saxis.clear();
        self.entity = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBSPDecal {
        static instance: CMsgTEBSPDecal = CMsgTEBSPDecal {
            origin: ::protobuf::MessageField::none(),
            normal: ::protobuf::MessageField::none(),
            saxis: ::protobuf::MessageField::none(),
            entity: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEBSPDecal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEBSPDecal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEBSPDecal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEBSPDecal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEBubbles)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBubbles {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBubbles.mins)
    pub mins: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBubbles.maxs)
    pub maxs: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBubbles.height)
    pub height: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBubbles.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBubbles.speed)
    pub speed: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBubbles.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBubbles {
    fn default() -> &'a CMsgTEBubbles {
        <CMsgTEBubbles as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBubbles {
    pub fn new() -> CMsgTEBubbles {
        ::std::default::Default::default()
    }

    // optional float height = 3;

    pub fn height(&self) -> f32 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 4;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional float speed = 5;

    pub fn speed(&self) -> f32 {
        self.speed.unwrap_or(0.)
    }

    pub fn clear_speed(&mut self) {
        self.speed = ::std::option::Option::None;
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "mins",
            |m: &CMsgTEBubbles| { &m.mins },
            |m: &mut CMsgTEBubbles| { &mut m.mins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "maxs",
            |m: &CMsgTEBubbles| { &m.maxs },
            |m: &mut CMsgTEBubbles| { &mut m.maxs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgTEBubbles| { &m.height },
            |m: &mut CMsgTEBubbles| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CMsgTEBubbles| { &m.count },
            |m: &mut CMsgTEBubbles| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speed",
            |m: &CMsgTEBubbles| { &m.speed },
            |m: &mut CMsgTEBubbles| { &mut m.speed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEBubbles>(
            "CMsgTEBubbles",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEBubbles {
    const NAME: &'static str = "CMsgTEBubbles";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mins)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxs)?;
                },
                29 => {
                    self.height = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.speed = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mins.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.height {
            my_size += 1 + 4;
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.speed {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mins.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.height {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.speed {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBubbles {
        CMsgTEBubbles::new()
    }

    fn clear(&mut self) {
        self.mins.clear();
        self.maxs.clear();
        self.height = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.speed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBubbles {
        static instance: CMsgTEBubbles = CMsgTEBubbles {
            mins: ::protobuf::MessageField::none(),
            maxs: ::protobuf::MessageField::none(),
            height: ::std::option::Option::None,
            count: ::std::option::Option::None,
            speed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEBubbles {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEBubbles").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEBubbles {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEBubbles {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEBubbleTrail)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBubbleTrail {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBubbleTrail.mins)
    pub mins: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBubbleTrail.maxs)
    pub maxs: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBubbleTrail.waterz)
    pub waterz: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEBubbleTrail.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBubbleTrail.speed)
    pub speed: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBubbleTrail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBubbleTrail {
    fn default() -> &'a CMsgTEBubbleTrail {
        <CMsgTEBubbleTrail as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBubbleTrail {
    pub fn new() -> CMsgTEBubbleTrail {
        ::std::default::Default::default()
    }

    // optional float waterz = 3;

    pub fn waterz(&self) -> f32 {
        self.waterz.unwrap_or(0.)
    }

    pub fn clear_waterz(&mut self) {
        self.waterz = ::std::option::Option::None;
    }

    pub fn has_waterz(&self) -> bool {
        self.waterz.is_some()
    }

    // Param is passed by value, moved
    pub fn set_waterz(&mut self, v: f32) {
        self.waterz = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 4;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional float speed = 5;

    pub fn speed(&self) -> f32 {
        self.speed.unwrap_or(0.)
    }

    pub fn clear_speed(&mut self) {
        self.speed = ::std::option::Option::None;
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "mins",
            |m: &CMsgTEBubbleTrail| { &m.mins },
            |m: &mut CMsgTEBubbleTrail| { &mut m.mins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "maxs",
            |m: &CMsgTEBubbleTrail| { &m.maxs },
            |m: &mut CMsgTEBubbleTrail| { &mut m.maxs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "waterz",
            |m: &CMsgTEBubbleTrail| { &m.waterz },
            |m: &mut CMsgTEBubbleTrail| { &mut m.waterz },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CMsgTEBubbleTrail| { &m.count },
            |m: &mut CMsgTEBubbleTrail| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speed",
            |m: &CMsgTEBubbleTrail| { &m.speed },
            |m: &mut CMsgTEBubbleTrail| { &mut m.speed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEBubbleTrail>(
            "CMsgTEBubbleTrail",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEBubbleTrail {
    const NAME: &'static str = "CMsgTEBubbleTrail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mins)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.maxs)?;
                },
                29 => {
                    self.waterz = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.speed = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mins.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.maxs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.waterz {
            my_size += 1 + 4;
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.speed {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mins.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.maxs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.waterz {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.speed {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBubbleTrail {
        CMsgTEBubbleTrail::new()
    }

    fn clear(&mut self) {
        self.mins.clear();
        self.maxs.clear();
        self.waterz = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.speed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBubbleTrail {
        static instance: CMsgTEBubbleTrail = CMsgTEBubbleTrail {
            mins: ::protobuf::MessageField::none(),
            maxs: ::protobuf::MessageField::none(),
            waterz: ::std::option::Option::None,
            count: ::std::option::Option::None,
            speed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEBubbleTrail {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEBubbleTrail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEBubbleTrail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEBubbleTrail {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEDecal {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEDecal.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEDecal.start)
    pub start: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEDecal.entity)
    pub entity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTEDecal.hitbox)
    pub hitbox: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEDecal.index)
    pub index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEDecal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEDecal {
    fn default() -> &'a CMsgTEDecal {
        <CMsgTEDecal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEDecal {
    pub fn new() -> CMsgTEDecal {
        ::std::default::Default::default()
    }

    // optional int32 entity = 3;

    pub fn entity(&self) -> i32 {
        self.entity.unwrap_or(-1i32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional uint32 hitbox = 4;

    pub fn hitbox(&self) -> u32 {
        self.hitbox.unwrap_or(0)
    }

    pub fn clear_hitbox(&mut self) {
        self.hitbox = ::std::option::Option::None;
    }

    pub fn has_hitbox(&self) -> bool {
        self.hitbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hitbox(&mut self, v: u32) {
        self.hitbox = ::std::option::Option::Some(v);
    }

    // optional uint32 index = 5;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEDecal| { &m.origin },
            |m: &mut CMsgTEDecal| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "start",
            |m: &CMsgTEDecal| { &m.start },
            |m: &mut CMsgTEDecal| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity",
            |m: &CMsgTEDecal| { &m.entity },
            |m: &mut CMsgTEDecal| { &mut m.entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hitbox",
            |m: &CMsgTEDecal| { &m.hitbox },
            |m: &mut CMsgTEDecal| { &mut m.hitbox },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CMsgTEDecal| { &m.index },
            |m: &mut CMsgTEDecal| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEDecal>(
            "CMsgTEDecal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEDecal {
    const NAME: &'static str = "CMsgTEDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                24 => {
                    self.entity = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.hitbox = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entity {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.hitbox {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.entity {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hitbox {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEDecal {
        CMsgTEDecal::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.start.clear();
        self.entity = ::std::option::Option::None;
        self.hitbox = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEDecal {
        static instance: CMsgTEDecal = CMsgTEDecal {
            origin: ::protobuf::MessageField::none(),
            start: ::protobuf::MessageField::none(),
            entity: ::std::option::Option::None,
            hitbox: ::std::option::Option::None,
            index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEDecal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEDecal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEDecal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEDecal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgEffectData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEffectData {
    // message fields
    // @@protoc_insertion_point(field:CMsgEffectData.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgEffectData.start)
    pub start: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgEffectData.normal)
    pub normal: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgEffectData.angles)
    pub angles: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CMsgEffectData.entity)
    pub entity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.otherentity)
    pub otherentity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgEffectData.magnitude)
    pub magnitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgEffectData.radius)
    pub radius: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgEffectData.surfaceprop)
    pub surfaceprop: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.effectindex)
    pub effectindex: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgEffectData.damagetype)
    pub damagetype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.material)
    pub material: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.hitbox)
    pub hitbox: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.attachmentindex)
    pub attachmentindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgEffectData.effectname)
    pub effectname: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgEffectData.attachmentname)
    pub attachmentname: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEffectData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEffectData {
    fn default() -> &'a CMsgEffectData {
        <CMsgEffectData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgEffectData {
    pub fn new() -> CMsgEffectData {
        ::std::default::Default::default()
    }

    // optional fixed32 entity = 5;

    pub fn entity(&self) -> u32 {
        self.entity.unwrap_or(16777215u32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: u32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional fixed32 otherentity = 6;

    pub fn otherentity(&self) -> u32 {
        self.otherentity.unwrap_or(16777215u32)
    }

    pub fn clear_otherentity(&mut self) {
        self.otherentity = ::std::option::Option::None;
    }

    pub fn has_otherentity(&self) -> bool {
        self.otherentity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otherentity(&mut self, v: u32) {
        self.otherentity = ::std::option::Option::Some(v);
    }

    // optional float scale = 7;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float magnitude = 8;

    pub fn magnitude(&self) -> f32 {
        self.magnitude.unwrap_or(0.)
    }

    pub fn clear_magnitude(&mut self) {
        self.magnitude = ::std::option::Option::None;
    }

    pub fn has_magnitude(&self) -> bool {
        self.magnitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magnitude(&mut self, v: f32) {
        self.magnitude = ::std::option::Option::Some(v);
    }

    // optional float radius = 9;

    pub fn radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }

    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }

    // optional fixed32 surfaceprop = 10;

    pub fn surfaceprop(&self) -> u32 {
        self.surfaceprop.unwrap_or(0)
    }

    pub fn clear_surfaceprop(&mut self) {
        self.surfaceprop = ::std::option::Option::None;
    }

    pub fn has_surfaceprop(&self) -> bool {
        self.surfaceprop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surfaceprop(&mut self, v: u32) {
        self.surfaceprop = ::std::option::Option::Some(v);
    }

    // optional fixed64 effectindex = 11;

    pub fn effectindex(&self) -> u64 {
        self.effectindex.unwrap_or(0)
    }

    pub fn clear_effectindex(&mut self) {
        self.effectindex = ::std::option::Option::None;
    }

    pub fn has_effectindex(&self) -> bool {
        self.effectindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effectindex(&mut self, v: u64) {
        self.effectindex = ::std::option::Option::Some(v);
    }

    // optional uint32 damagetype = 12;

    pub fn damagetype(&self) -> u32 {
        self.damagetype.unwrap_or(0)
    }

    pub fn clear_damagetype(&mut self) {
        self.damagetype = ::std::option::Option::None;
    }

    pub fn has_damagetype(&self) -> bool {
        self.damagetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damagetype(&mut self, v: u32) {
        self.damagetype = ::std::option::Option::Some(v);
    }

    // optional uint32 material = 13;

    pub fn material(&self) -> u32 {
        self.material.unwrap_or(0)
    }

    pub fn clear_material(&mut self) {
        self.material = ::std::option::Option::None;
    }

    pub fn has_material(&self) -> bool {
        self.material.is_some()
    }

    // Param is passed by value, moved
    pub fn set_material(&mut self, v: u32) {
        self.material = ::std::option::Option::Some(v);
    }

    // optional uint32 hitbox = 14;

    pub fn hitbox(&self) -> u32 {
        self.hitbox.unwrap_or(0)
    }

    pub fn clear_hitbox(&mut self) {
        self.hitbox = ::std::option::Option::None;
    }

    pub fn has_hitbox(&self) -> bool {
        self.hitbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hitbox(&mut self, v: u32) {
        self.hitbox = ::std::option::Option::Some(v);
    }

    // optional uint32 color = 15;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 16;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional int32 attachmentindex = 17;

    pub fn attachmentindex(&self) -> i32 {
        self.attachmentindex.unwrap_or(0)
    }

    pub fn clear_attachmentindex(&mut self) {
        self.attachmentindex = ::std::option::Option::None;
    }

    pub fn has_attachmentindex(&self) -> bool {
        self.attachmentindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentindex(&mut self, v: i32) {
        self.attachmentindex = ::std::option::Option::Some(v);
    }

    // optional uint32 effectname = 18;

    pub fn effectname(&self) -> u32 {
        self.effectname.unwrap_or(0)
    }

    pub fn clear_effectname(&mut self) {
        self.effectname = ::std::option::Option::None;
    }

    pub fn has_effectname(&self) -> bool {
        self.effectname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effectname(&mut self, v: u32) {
        self.effectname = ::std::option::Option::Some(v);
    }

    // optional uint32 attachmentname = 19;

    pub fn attachmentname(&self) -> u32 {
        self.attachmentname.unwrap_or(0)
    }

    pub fn clear_attachmentname(&mut self) {
        self.attachmentname = ::std::option::Option::None;
    }

    pub fn has_attachmentname(&self) -> bool {
        self.attachmentname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attachmentname(&mut self, v: u32) {
        self.attachmentname = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgEffectData| { &m.origin },
            |m: &mut CMsgEffectData| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "start",
            |m: &CMsgEffectData| { &m.start },
            |m: &mut CMsgEffectData| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "normal",
            |m: &CMsgEffectData| { &m.normal },
            |m: &mut CMsgEffectData| { &mut m.normal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "angles",
            |m: &CMsgEffectData| { &m.angles },
            |m: &mut CMsgEffectData| { &mut m.angles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity",
            |m: &CMsgEffectData| { &m.entity },
            |m: &mut CMsgEffectData| { &mut m.entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "otherentity",
            |m: &CMsgEffectData| { &m.otherentity },
            |m: &mut CMsgEffectData| { &mut m.otherentity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgEffectData| { &m.scale },
            |m: &mut CMsgEffectData| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "magnitude",
            |m: &CMsgEffectData| { &m.magnitude },
            |m: &mut CMsgEffectData| { &mut m.magnitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radius",
            |m: &CMsgEffectData| { &m.radius },
            |m: &mut CMsgEffectData| { &mut m.radius },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "surfaceprop",
            |m: &CMsgEffectData| { &m.surfaceprop },
            |m: &mut CMsgEffectData| { &mut m.surfaceprop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effectindex",
            |m: &CMsgEffectData| { &m.effectindex },
            |m: &mut CMsgEffectData| { &mut m.effectindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damagetype",
            |m: &CMsgEffectData| { &m.damagetype },
            |m: &mut CMsgEffectData| { &mut m.damagetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "material",
            |m: &CMsgEffectData| { &m.material },
            |m: &mut CMsgEffectData| { &mut m.material },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hitbox",
            |m: &CMsgEffectData| { &m.hitbox },
            |m: &mut CMsgEffectData| { &mut m.hitbox },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CMsgEffectData| { &m.color },
            |m: &mut CMsgEffectData| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgEffectData| { &m.flags },
            |m: &mut CMsgEffectData| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentindex",
            |m: &CMsgEffectData| { &m.attachmentindex },
            |m: &mut CMsgEffectData| { &mut m.attachmentindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effectname",
            |m: &CMsgEffectData| { &m.effectname },
            |m: &mut CMsgEffectData| { &mut m.effectname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "attachmentname",
            |m: &CMsgEffectData| { &m.attachmentname },
            |m: &mut CMsgEffectData| { &mut m.attachmentname },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgEffectData>(
            "CMsgEffectData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgEffectData {
    const NAME: &'static str = "CMsgEffectData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                },
                45 => {
                    self.entity = ::std::option::Option::Some(is.read_fixed32()?);
                },
                53 => {
                    self.otherentity = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.magnitude = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.radius = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.surfaceprop = ::std::option::Option::Some(is.read_fixed32()?);
                },
                89 => {
                    self.effectindex = ::std::option::Option::Some(is.read_fixed64()?);
                },
                96 => {
                    self.damagetype = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.material = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.hitbox = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.attachmentindex = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.effectname = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.attachmentname = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entity {
            my_size += 1 + 4;
        }
        if let Some(v) = self.otherentity {
            my_size += 1 + 4;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.magnitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.radius {
            my_size += 1 + 4;
        }
        if let Some(v) = self.surfaceprop {
            my_size += 1 + 4;
        }
        if let Some(v) = self.effectindex {
            my_size += 1 + 8;
        }
        if let Some(v) = self.damagetype {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.material {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.hitbox {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.attachmentindex {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.effectname {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.attachmentname {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.angles.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.entity {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.otherentity {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.magnitude {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.radius {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.surfaceprop {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.effectindex {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.damagetype {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.material {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.hitbox {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.attachmentindex {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.effectname {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.attachmentname {
            os.write_uint32(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEffectData {
        CMsgEffectData::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.start.clear();
        self.normal.clear();
        self.angles.clear();
        self.entity = ::std::option::Option::None;
        self.otherentity = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.magnitude = ::std::option::Option::None;
        self.radius = ::std::option::Option::None;
        self.surfaceprop = ::std::option::Option::None;
        self.effectindex = ::std::option::Option::None;
        self.damagetype = ::std::option::Option::None;
        self.material = ::std::option::Option::None;
        self.hitbox = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.attachmentindex = ::std::option::Option::None;
        self.effectname = ::std::option::Option::None;
        self.attachmentname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEffectData {
        static instance: CMsgEffectData = CMsgEffectData {
            origin: ::protobuf::MessageField::none(),
            start: ::protobuf::MessageField::none(),
            normal: ::protobuf::MessageField::none(),
            angles: ::protobuf::MessageField::none(),
            entity: ::std::option::Option::None,
            otherentity: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            magnitude: ::std::option::Option::None,
            radius: ::std::option::Option::None,
            surfaceprop: ::std::option::Option::None,
            effectindex: ::std::option::Option::None,
            damagetype: ::std::option::Option::None,
            material: ::std::option::Option::None,
            hitbox: ::std::option::Option::None,
            color: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            attachmentindex: ::std::option::Option::None,
            effectname: ::std::option::Option::None,
            attachmentname: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgEffectData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgEffectData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgEffectData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgEffectData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEEffectDispatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEEffectDispatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEEffectDispatch.effectdata)
    pub effectdata: ::protobuf::MessageField<CMsgEffectData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEEffectDispatch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEEffectDispatch {
    fn default() -> &'a CMsgTEEffectDispatch {
        <CMsgTEEffectDispatch as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEEffectDispatch {
    pub fn new() -> CMsgTEEffectDispatch {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgEffectData>(
            "effectdata",
            |m: &CMsgTEEffectDispatch| { &m.effectdata },
            |m: &mut CMsgTEEffectDispatch| { &mut m.effectdata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEEffectDispatch>(
            "CMsgTEEffectDispatch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEEffectDispatch {
    const NAME: &'static str = "CMsgTEEffectDispatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.effectdata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.effectdata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.effectdata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEEffectDispatch {
        CMsgTEEffectDispatch::new()
    }

    fn clear(&mut self) {
        self.effectdata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEEffectDispatch {
        static instance: CMsgTEEffectDispatch = CMsgTEEffectDispatch {
            effectdata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEEffectDispatch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEEffectDispatch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEEffectDispatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEEffectDispatch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEEnergySplash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEEnergySplash {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEEnergySplash.pos)
    pub pos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEEnergySplash.dir)
    pub dir: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEEnergySplash.explosive)
    pub explosive: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEEnergySplash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEEnergySplash {
    fn default() -> &'a CMsgTEEnergySplash {
        <CMsgTEEnergySplash as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEEnergySplash {
    pub fn new() -> CMsgTEEnergySplash {
        ::std::default::Default::default()
    }

    // optional bool explosive = 3;

    pub fn explosive(&self) -> bool {
        self.explosive.unwrap_or(false)
    }

    pub fn clear_explosive(&mut self) {
        self.explosive = ::std::option::Option::None;
    }

    pub fn has_explosive(&self) -> bool {
        self.explosive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explosive(&mut self, v: bool) {
        self.explosive = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "pos",
            |m: &CMsgTEEnergySplash| { &m.pos },
            |m: &mut CMsgTEEnergySplash| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "dir",
            |m: &CMsgTEEnergySplash| { &m.dir },
            |m: &mut CMsgTEEnergySplash| { &mut m.dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "explosive",
            |m: &CMsgTEEnergySplash| { &m.explosive },
            |m: &mut CMsgTEEnergySplash| { &mut m.explosive },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEEnergySplash>(
            "CMsgTEEnergySplash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEEnergySplash {
    const NAME: &'static str = "CMsgTEEnergySplash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dir)?;
                },
                24 => {
                    self.explosive = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.explosive {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.dir.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.explosive {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEEnergySplash {
        CMsgTEEnergySplash::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.dir.clear();
        self.explosive = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEEnergySplash {
        static instance: CMsgTEEnergySplash = CMsgTEEnergySplash {
            pos: ::protobuf::MessageField::none(),
            dir: ::protobuf::MessageField::none(),
            explosive: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEEnergySplash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEEnergySplash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEEnergySplash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEEnergySplash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEFizz)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEFizz {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEFizz.entity)
    pub entity: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTEFizz.density)
    pub density: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEFizz.current)
    pub current: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEFizz.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEFizz {
    fn default() -> &'a CMsgTEFizz {
        <CMsgTEFizz as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEFizz {
    pub fn new() -> CMsgTEFizz {
        ::std::default::Default::default()
    }

    // optional int32 entity = 1;

    pub fn entity(&self) -> i32 {
        self.entity.unwrap_or(-1i32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }

    // optional uint32 density = 2;

    pub fn density(&self) -> u32 {
        self.density.unwrap_or(0)
    }

    pub fn clear_density(&mut self) {
        self.density = ::std::option::Option::None;
    }

    pub fn has_density(&self) -> bool {
        self.density.is_some()
    }

    // Param is passed by value, moved
    pub fn set_density(&mut self, v: u32) {
        self.density = ::std::option::Option::Some(v);
    }

    // optional int32 current = 3;

    pub fn current(&self) -> i32 {
        self.current.unwrap_or(0)
    }

    pub fn clear_current(&mut self) {
        self.current = ::std::option::Option::None;
    }

    pub fn has_current(&self) -> bool {
        self.current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: i32) {
        self.current = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity",
            |m: &CMsgTEFizz| { &m.entity },
            |m: &mut CMsgTEFizz| { &mut m.entity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "density",
            |m: &CMsgTEFizz| { &m.density },
            |m: &mut CMsgTEFizz| { &mut m.density },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current",
            |m: &CMsgTEFizz| { &m.current },
            |m: &mut CMsgTEFizz| { &mut m.current },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEFizz>(
            "CMsgTEFizz",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEFizz {
    const NAME: &'static str = "CMsgTEFizz";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.density = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.current = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.density {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.current {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.density {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.current {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEFizz {
        CMsgTEFizz::new()
    }

    fn clear(&mut self) {
        self.entity = ::std::option::Option::None;
        self.density = ::std::option::Option::None;
        self.current = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEFizz {
        static instance: CMsgTEFizz = CMsgTEFizz {
            entity: ::std::option::Option::None,
            density: ::std::option::Option::None,
            current: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEFizz {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEFizz").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEFizz {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEFizz {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEShatterSurface)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEShatterSurface {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.angles)
    pub angles: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.force)
    pub force: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.forcepos)
    pub forcepos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.width)
    pub width: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.height)
    pub height: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.shardsize)
    pub shardsize: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.surfacetype)
    pub surfacetype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.frontcolor)
    pub frontcolor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEShatterSurface.backcolor)
    pub backcolor: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEShatterSurface.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEShatterSurface {
    fn default() -> &'a CMsgTEShatterSurface {
        <CMsgTEShatterSurface as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEShatterSurface {
    pub fn new() -> CMsgTEShatterSurface {
        ::std::default::Default::default()
    }

    // optional float width = 5;

    pub fn width(&self) -> f32 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional float height = 6;

    pub fn height(&self) -> f32 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional float shardsize = 7;

    pub fn shardsize(&self) -> f32 {
        self.shardsize.unwrap_or(0.)
    }

    pub fn clear_shardsize(&mut self) {
        self.shardsize = ::std::option::Option::None;
    }

    pub fn has_shardsize(&self) -> bool {
        self.shardsize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shardsize(&mut self, v: f32) {
        self.shardsize = ::std::option::Option::Some(v);
    }

    // optional uint32 surfacetype = 8;

    pub fn surfacetype(&self) -> u32 {
        self.surfacetype.unwrap_or(0)
    }

    pub fn clear_surfacetype(&mut self) {
        self.surfacetype = ::std::option::Option::None;
    }

    pub fn has_surfacetype(&self) -> bool {
        self.surfacetype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_surfacetype(&mut self, v: u32) {
        self.surfacetype = ::std::option::Option::Some(v);
    }

    // optional fixed32 frontcolor = 9;

    pub fn frontcolor(&self) -> u32 {
        self.frontcolor.unwrap_or(0)
    }

    pub fn clear_frontcolor(&mut self) {
        self.frontcolor = ::std::option::Option::None;
    }

    pub fn has_frontcolor(&self) -> bool {
        self.frontcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frontcolor(&mut self, v: u32) {
        self.frontcolor = ::std::option::Option::Some(v);
    }

    // optional fixed32 backcolor = 10;

    pub fn backcolor(&self) -> u32 {
        self.backcolor.unwrap_or(0)
    }

    pub fn clear_backcolor(&mut self) {
        self.backcolor = ::std::option::Option::None;
    }

    pub fn has_backcolor(&self) -> bool {
        self.backcolor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backcolor(&mut self, v: u32) {
        self.backcolor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEShatterSurface| { &m.origin },
            |m: &mut CMsgTEShatterSurface| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "angles",
            |m: &CMsgTEShatterSurface| { &m.angles },
            |m: &mut CMsgTEShatterSurface| { &mut m.angles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "force",
            |m: &CMsgTEShatterSurface| { &m.force },
            |m: &mut CMsgTEShatterSurface| { &mut m.force },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "forcepos",
            |m: &CMsgTEShatterSurface| { &m.forcepos },
            |m: &mut CMsgTEShatterSurface| { &mut m.forcepos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgTEShatterSurface| { &m.width },
            |m: &mut CMsgTEShatterSurface| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgTEShatterSurface| { &m.height },
            |m: &mut CMsgTEShatterSurface| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "shardsize",
            |m: &CMsgTEShatterSurface| { &m.shardsize },
            |m: &mut CMsgTEShatterSurface| { &mut m.shardsize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "surfacetype",
            |m: &CMsgTEShatterSurface| { &m.surfacetype },
            |m: &mut CMsgTEShatterSurface| { &mut m.surfacetype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frontcolor",
            |m: &CMsgTEShatterSurface| { &m.frontcolor },
            |m: &mut CMsgTEShatterSurface| { &mut m.frontcolor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "backcolor",
            |m: &CMsgTEShatterSurface| { &m.backcolor },
            |m: &mut CMsgTEShatterSurface| { &mut m.backcolor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEShatterSurface>(
            "CMsgTEShatterSurface",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEShatterSurface {
    const NAME: &'static str = "CMsgTEShatterSurface";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.force)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.forcepos)?;
                },
                45 => {
                    self.width = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.height = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.shardsize = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.surfacetype = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.frontcolor = ::std::option::Option::Some(is.read_fixed32()?);
                },
                85 => {
                    self.backcolor = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.force.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.forcepos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.width {
            my_size += 1 + 4;
        }
        if let Some(v) = self.height {
            my_size += 1 + 4;
        }
        if let Some(v) = self.shardsize {
            my_size += 1 + 4;
        }
        if let Some(v) = self.surfacetype {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.frontcolor {
            my_size += 1 + 4;
        }
        if let Some(v) = self.backcolor {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.angles.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.force.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.forcepos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.width {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.height {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.shardsize {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.surfacetype {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.frontcolor {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.backcolor {
            os.write_fixed32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEShatterSurface {
        CMsgTEShatterSurface::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.angles.clear();
        self.force.clear();
        self.forcepos.clear();
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.shardsize = ::std::option::Option::None;
        self.surfacetype = ::std::option::Option::None;
        self.frontcolor = ::std::option::Option::None;
        self.backcolor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEShatterSurface {
        static instance: CMsgTEShatterSurface = CMsgTEShatterSurface {
            origin: ::protobuf::MessageField::none(),
            angles: ::protobuf::MessageField::none(),
            force: ::protobuf::MessageField::none(),
            forcepos: ::protobuf::MessageField::none(),
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            shardsize: ::std::option::Option::None,
            surfacetype: ::std::option::Option::None,
            frontcolor: ::std::option::Option::None,
            backcolor: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEShatterSurface {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEShatterSurface").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEShatterSurface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEShatterSurface {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEGlowSprite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEGlowSprite {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEGlowSprite.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEGlowSprite.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEGlowSprite.life)
    pub life: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEGlowSprite.brightness)
    pub brightness: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEGlowSprite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEGlowSprite {
    fn default() -> &'a CMsgTEGlowSprite {
        <CMsgTEGlowSprite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEGlowSprite {
    pub fn new() -> CMsgTEGlowSprite {
        ::std::default::Default::default()
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional float life = 3;

    pub fn life(&self) -> f32 {
        self.life.unwrap_or(0.)
    }

    pub fn clear_life(&mut self) {
        self.life = ::std::option::Option::None;
    }

    pub fn has_life(&self) -> bool {
        self.life.is_some()
    }

    // Param is passed by value, moved
    pub fn set_life(&mut self, v: f32) {
        self.life = ::std::option::Option::Some(v);
    }

    // optional uint32 brightness = 4;

    pub fn brightness(&self) -> u32 {
        self.brightness.unwrap_or(0)
    }

    pub fn clear_brightness(&mut self) {
        self.brightness = ::std::option::Option::None;
    }

    pub fn has_brightness(&self) -> bool {
        self.brightness.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brightness(&mut self, v: u32) {
        self.brightness = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEGlowSprite| { &m.origin },
            |m: &mut CMsgTEGlowSprite| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgTEGlowSprite| { &m.scale },
            |m: &mut CMsgTEGlowSprite| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "life",
            |m: &CMsgTEGlowSprite| { &m.life },
            |m: &mut CMsgTEGlowSprite| { &mut m.life },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "brightness",
            |m: &CMsgTEGlowSprite| { &m.brightness },
            |m: &mut CMsgTEGlowSprite| { &mut m.brightness },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEGlowSprite>(
            "CMsgTEGlowSprite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEGlowSprite {
    const NAME: &'static str = "CMsgTEGlowSprite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.life = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.brightness = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.life {
            my_size += 1 + 4;
        }
        if let Some(v) = self.brightness {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.life {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.brightness {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEGlowSprite {
        CMsgTEGlowSprite::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.scale = ::std::option::Option::None;
        self.life = ::std::option::Option::None;
        self.brightness = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEGlowSprite {
        static instance: CMsgTEGlowSprite = CMsgTEGlowSprite {
            origin: ::protobuf::MessageField::none(),
            scale: ::std::option::Option::None,
            life: ::std::option::Option::None,
            brightness: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEGlowSprite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEGlowSprite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEGlowSprite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEGlowSprite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEImpact)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEImpact {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEImpact.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEImpact.normal)
    pub normal: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEImpact.type)
    pub type_: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEImpact.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEImpact {
    fn default() -> &'a CMsgTEImpact {
        <CMsgTEImpact as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEImpact {
    pub fn new() -> CMsgTEImpact {
        ::std::default::Default::default()
    }

    // optional uint32 type = 3;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEImpact| { &m.origin },
            |m: &mut CMsgTEImpact| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "normal",
            |m: &CMsgTEImpact| { &m.normal },
            |m: &mut CMsgTEImpact| { &mut m.normal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgTEImpact| { &m.type_ },
            |m: &mut CMsgTEImpact| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEImpact>(
            "CMsgTEImpact",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEImpact {
    const NAME: &'static str = "CMsgTEImpact";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEImpact {
        CMsgTEImpact::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.normal.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEImpact {
        static instance: CMsgTEImpact = CMsgTEImpact {
            origin: ::protobuf::MessageField::none(),
            normal: ::protobuf::MessageField::none(),
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEImpact {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEImpact").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEImpact {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEImpact {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEMuzzleFlash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEMuzzleFlash {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEMuzzleFlash.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEMuzzleFlash.angles)
    pub angles: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CMsgTEMuzzleFlash.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEMuzzleFlash.type)
    pub type_: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEMuzzleFlash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEMuzzleFlash {
    fn default() -> &'a CMsgTEMuzzleFlash {
        <CMsgTEMuzzleFlash as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEMuzzleFlash {
    pub fn new() -> CMsgTEMuzzleFlash {
        ::std::default::Default::default()
    }

    // optional float scale = 3;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 4;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEMuzzleFlash| { &m.origin },
            |m: &mut CMsgTEMuzzleFlash| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "angles",
            |m: &CMsgTEMuzzleFlash| { &m.angles },
            |m: &mut CMsgTEMuzzleFlash| { &mut m.angles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgTEMuzzleFlash| { &m.scale },
            |m: &mut CMsgTEMuzzleFlash| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgTEMuzzleFlash| { &m.type_ },
            |m: &mut CMsgTEMuzzleFlash| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEMuzzleFlash>(
            "CMsgTEMuzzleFlash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEMuzzleFlash {
    const NAME: &'static str = "CMsgTEMuzzleFlash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                },
                29 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.angles.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.scale {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEMuzzleFlash {
        CMsgTEMuzzleFlash::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.angles.clear();
        self.scale = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEMuzzleFlash {
        static instance: CMsgTEMuzzleFlash = CMsgTEMuzzleFlash {
            origin: ::protobuf::MessageField::none(),
            angles: ::protobuf::MessageField::none(),
            scale: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEMuzzleFlash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEMuzzleFlash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEMuzzleFlash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEMuzzleFlash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEBloodStream)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEBloodStream {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEBloodStream.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBloodStream.direction)
    pub direction: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEBloodStream.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEBloodStream.amount)
    pub amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEBloodStream.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEBloodStream {
    fn default() -> &'a CMsgTEBloodStream {
        <CMsgTEBloodStream as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEBloodStream {
    pub fn new() -> CMsgTEBloodStream {
        ::std::default::Default::default()
    }

    // optional fixed32 color = 3;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional uint32 amount = 4;

    pub fn amount(&self) -> u32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u32) {
        self.amount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEBloodStream| { &m.origin },
            |m: &mut CMsgTEBloodStream| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "direction",
            |m: &CMsgTEBloodStream| { &m.direction },
            |m: &mut CMsgTEBloodStream| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CMsgTEBloodStream| { &m.color },
            |m: &mut CMsgTEBloodStream| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &CMsgTEBloodStream| { &m.amount },
            |m: &mut CMsgTEBloodStream| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEBloodStream>(
            "CMsgTEBloodStream",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEBloodStream {
    const NAME: &'static str = "CMsgTEBloodStream";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.direction)?;
                },
                29 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.direction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.amount {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEBloodStream {
        CMsgTEBloodStream::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.direction.clear();
        self.color = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEBloodStream {
        static instance: CMsgTEBloodStream = CMsgTEBloodStream {
            origin: ::protobuf::MessageField::none(),
            direction: ::protobuf::MessageField::none(),
            color: ::std::option::Option::None,
            amount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEBloodStream {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEBloodStream").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEBloodStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEBloodStream {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEExplosion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEExplosion {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEExplosion.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.framerate)
    pub framerate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.normal)
    pub normal: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.materialtype)
    pub materialtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.radius)
    pub radius: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.magnitude)
    pub magnitude: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.affect_ragdolls)
    pub affect_ragdolls: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.effect_name)
    pub effect_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgTEExplosion.explosion_type)
    pub explosion_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEExplosion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEExplosion {
    fn default() -> &'a CMsgTEExplosion {
        <CMsgTEExplosion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEExplosion {
    pub fn new() -> CMsgTEExplosion {
        ::std::default::Default::default()
    }

    // optional uint32 framerate = 2;

    pub fn framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 3;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 materialtype = 5;

    pub fn materialtype(&self) -> u32 {
        self.materialtype.unwrap_or(0)
    }

    pub fn clear_materialtype(&mut self) {
        self.materialtype = ::std::option::Option::None;
    }

    pub fn has_materialtype(&self) -> bool {
        self.materialtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_materialtype(&mut self, v: u32) {
        self.materialtype = ::std::option::Option::Some(v);
    }

    // optional uint32 radius = 6;

    pub fn radius(&self) -> u32 {
        self.radius.unwrap_or(0)
    }

    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: u32) {
        self.radius = ::std::option::Option::Some(v);
    }

    // optional uint32 magnitude = 7;

    pub fn magnitude(&self) -> u32 {
        self.magnitude.unwrap_or(0)
    }

    pub fn clear_magnitude(&mut self) {
        self.magnitude = ::std::option::Option::None;
    }

    pub fn has_magnitude(&self) -> bool {
        self.magnitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magnitude(&mut self, v: u32) {
        self.magnitude = ::std::option::Option::Some(v);
    }

    // optional float scale = 8;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional bool affect_ragdolls = 9;

    pub fn affect_ragdolls(&self) -> bool {
        self.affect_ragdolls.unwrap_or(false)
    }

    pub fn clear_affect_ragdolls(&mut self) {
        self.affect_ragdolls = ::std::option::Option::None;
    }

    pub fn has_affect_ragdolls(&self) -> bool {
        self.affect_ragdolls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affect_ragdolls(&mut self, v: bool) {
        self.affect_ragdolls = ::std::option::Option::Some(v);
    }

    // optional string effect_name = 10;

    pub fn effect_name(&self) -> &str {
        match self.effect_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_effect_name(&mut self) {
        self.effect_name = ::std::option::Option::None;
    }

    pub fn has_effect_name(&self) -> bool {
        self.effect_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_name(&mut self, v: ::std::string::String) {
        self.effect_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect_name(&mut self) -> &mut ::std::string::String {
        if self.effect_name.is_none() {
            self.effect_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.effect_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_effect_name(&mut self) -> ::std::string::String {
        self.effect_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 explosion_type = 11;

    pub fn explosion_type(&self) -> u32 {
        self.explosion_type.unwrap_or(0)
    }

    pub fn clear_explosion_type(&mut self) {
        self.explosion_type = ::std::option::Option::None;
    }

    pub fn has_explosion_type(&self) -> bool {
        self.explosion_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explosion_type(&mut self, v: u32) {
        self.explosion_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEExplosion| { &m.origin },
            |m: &mut CMsgTEExplosion| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "framerate",
            |m: &CMsgTEExplosion| { &m.framerate },
            |m: &mut CMsgTEExplosion| { &mut m.framerate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgTEExplosion| { &m.flags },
            |m: &mut CMsgTEExplosion| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "normal",
            |m: &CMsgTEExplosion| { &m.normal },
            |m: &mut CMsgTEExplosion| { &mut m.normal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "materialtype",
            |m: &CMsgTEExplosion| { &m.materialtype },
            |m: &mut CMsgTEExplosion| { &mut m.materialtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radius",
            |m: &CMsgTEExplosion| { &m.radius },
            |m: &mut CMsgTEExplosion| { &mut m.radius },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "magnitude",
            |m: &CMsgTEExplosion| { &m.magnitude },
            |m: &mut CMsgTEExplosion| { &mut m.magnitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgTEExplosion| { &m.scale },
            |m: &mut CMsgTEExplosion| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "affect_ragdolls",
            |m: &CMsgTEExplosion| { &m.affect_ragdolls },
            |m: &mut CMsgTEExplosion| { &mut m.affect_ragdolls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect_name",
            |m: &CMsgTEExplosion| { &m.effect_name },
            |m: &mut CMsgTEExplosion| { &mut m.effect_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "explosion_type",
            |m: &CMsgTEExplosion| { &m.explosion_type },
            |m: &mut CMsgTEExplosion| { &mut m.explosion_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEExplosion>(
            "CMsgTEExplosion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEExplosion {
    const NAME: &'static str = "CMsgTEExplosion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                16 => {
                    self.framerate = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                40 => {
                    self.materialtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.radius = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.magnitude = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                72 => {
                    self.affect_ragdolls = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.effect_name = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.explosion_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.framerate {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.materialtype {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.radius {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.magnitude {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.affect_ragdolls {
            my_size += 1 + 1;
        }
        if let Some(v) = self.effect_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.explosion_type {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.framerate {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.materialtype {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.radius {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.magnitude {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.affect_ragdolls {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.effect_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.explosion_type {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEExplosion {
        CMsgTEExplosion::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.framerate = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.normal.clear();
        self.materialtype = ::std::option::Option::None;
        self.radius = ::std::option::Option::None;
        self.magnitude = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.affect_ragdolls = ::std::option::Option::None;
        self.effect_name = ::std::option::Option::None;
        self.explosion_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEExplosion {
        static instance: CMsgTEExplosion = CMsgTEExplosion {
            origin: ::protobuf::MessageField::none(),
            framerate: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            normal: ::protobuf::MessageField::none(),
            materialtype: ::std::option::Option::None,
            radius: ::std::option::Option::None,
            magnitude: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            affect_ragdolls: ::std::option::Option::None,
            effect_name: ::std::option::Option::None,
            explosion_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEExplosion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEExplosion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEExplosion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEExplosion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEDust)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEDust {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEDust.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEDust.size)
    pub size: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEDust.speed)
    pub speed: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEDust.direction)
    pub direction: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEDust.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEDust {
    fn default() -> &'a CMsgTEDust {
        <CMsgTEDust as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEDust {
    pub fn new() -> CMsgTEDust {
        ::std::default::Default::default()
    }

    // optional float size = 2;

    pub fn size(&self) -> f32 {
        self.size.unwrap_or(0.)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: f32) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional float speed = 3;

    pub fn speed(&self) -> f32 {
        self.speed.unwrap_or(0.)
    }

    pub fn clear_speed(&mut self) {
        self.speed = ::std::option::Option::None;
    }

    pub fn has_speed(&self) -> bool {
        self.speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed(&mut self, v: f32) {
        self.speed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEDust| { &m.origin },
            |m: &mut CMsgTEDust| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &CMsgTEDust| { &m.size },
            |m: &mut CMsgTEDust| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "speed",
            |m: &CMsgTEDust| { &m.speed },
            |m: &mut CMsgTEDust| { &mut m.speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "direction",
            |m: &CMsgTEDust| { &m.direction },
            |m: &mut CMsgTEDust| { &mut m.direction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEDust>(
            "CMsgTEDust",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEDust {
    const NAME: &'static str = "CMsgTEDust";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                21 => {
                    self.size = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.speed = ::std::option::Option::Some(is.read_float()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.direction)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.size {
            my_size += 1 + 4;
        }
        if let Some(v) = self.speed {
            my_size += 1 + 4;
        }
        if let Some(v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.size {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.speed {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.direction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEDust {
        CMsgTEDust::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.size = ::std::option::Option::None;
        self.speed = ::std::option::Option::None;
        self.direction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEDust {
        static instance: CMsgTEDust = CMsgTEDust {
            origin: ::protobuf::MessageField::none(),
            size: ::std::option::Option::None,
            speed: ::std::option::Option::None,
            direction: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEDust {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEDust").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEDust {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEDust {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTELargeFunnel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTELargeFunnel {
    // message fields
    // @@protoc_insertion_point(field:CMsgTELargeFunnel.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTELargeFunnel.reversed)
    pub reversed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTELargeFunnel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTELargeFunnel {
    fn default() -> &'a CMsgTELargeFunnel {
        <CMsgTELargeFunnel as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTELargeFunnel {
    pub fn new() -> CMsgTELargeFunnel {
        ::std::default::Default::default()
    }

    // optional uint32 reversed = 2;

    pub fn reversed(&self) -> u32 {
        self.reversed.unwrap_or(0)
    }

    pub fn clear_reversed(&mut self) {
        self.reversed = ::std::option::Option::None;
    }

    pub fn has_reversed(&self) -> bool {
        self.reversed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reversed(&mut self, v: u32) {
        self.reversed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTELargeFunnel| { &m.origin },
            |m: &mut CMsgTELargeFunnel| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reversed",
            |m: &CMsgTELargeFunnel| { &m.reversed },
            |m: &mut CMsgTELargeFunnel| { &mut m.reversed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTELargeFunnel>(
            "CMsgTELargeFunnel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTELargeFunnel {
    const NAME: &'static str = "CMsgTELargeFunnel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                16 => {
                    self.reversed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reversed {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.reversed {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTELargeFunnel {
        CMsgTELargeFunnel::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.reversed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTELargeFunnel {
        static instance: CMsgTELargeFunnel = CMsgTELargeFunnel {
            origin: ::protobuf::MessageField::none(),
            reversed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTELargeFunnel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTELargeFunnel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTELargeFunnel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTELargeFunnel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTESparks)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTESparks {
    // message fields
    // @@protoc_insertion_point(field:CMsgTESparks.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTESparks.magnitude)
    pub magnitude: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTESparks.length)
    pub length: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTESparks.direction)
    pub direction: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTESparks.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTESparks {
    fn default() -> &'a CMsgTESparks {
        <CMsgTESparks as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTESparks {
    pub fn new() -> CMsgTESparks {
        ::std::default::Default::default()
    }

    // optional uint32 magnitude = 2;

    pub fn magnitude(&self) -> u32 {
        self.magnitude.unwrap_or(0)
    }

    pub fn clear_magnitude(&mut self) {
        self.magnitude = ::std::option::Option::None;
    }

    pub fn has_magnitude(&self) -> bool {
        self.magnitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_magnitude(&mut self, v: u32) {
        self.magnitude = ::std::option::Option::Some(v);
    }

    // optional uint32 length = 3;

    pub fn length(&self) -> u32 {
        self.length.unwrap_or(0)
    }

    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: u32) {
        self.length = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTESparks| { &m.origin },
            |m: &mut CMsgTESparks| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "magnitude",
            |m: &CMsgTESparks| { &m.magnitude },
            |m: &mut CMsgTESparks| { &mut m.magnitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "length",
            |m: &CMsgTESparks| { &m.length },
            |m: &mut CMsgTESparks| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "direction",
            |m: &CMsgTESparks| { &m.direction },
            |m: &mut CMsgTESparks| { &mut m.direction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTESparks>(
            "CMsgTESparks",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTESparks {
    const NAME: &'static str = "CMsgTESparks";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                16 => {
                    self.magnitude = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.length = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.direction)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.magnitude {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.magnitude {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.length {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.direction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTESparks {
        CMsgTESparks::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.magnitude = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.direction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTESparks {
        static instance: CMsgTESparks = CMsgTESparks {
            origin: ::protobuf::MessageField::none(),
            magnitude: ::std::option::Option::None,
            length: ::std::option::Option::None,
            direction: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTESparks {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTESparks").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTESparks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTESparks {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEPhysicsProp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEPhysicsProp {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.velocity)
    pub velocity: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.angles)
    pub angles: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.skin)
    pub skin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.effects)
    pub effects: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.modelindex)
    pub modelindex: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.unused_breakmodelsnottomake)
    pub unused_breakmodelsnottomake: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.dmgpos)
    pub dmgpos: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.dmgdir)
    pub dmgdir: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEPhysicsProp.dmgtype)
    pub dmgtype: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEPhysicsProp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEPhysicsProp {
    fn default() -> &'a CMsgTEPhysicsProp {
        <CMsgTEPhysicsProp as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEPhysicsProp {
    pub fn new() -> CMsgTEPhysicsProp {
        ::std::default::Default::default()
    }

    // optional fixed32 skin = 4;

    pub fn skin(&self) -> u32 {
        self.skin.unwrap_or(0)
    }

    pub fn clear_skin(&mut self) {
        self.skin = ::std::option::Option::None;
    }

    pub fn has_skin(&self) -> bool {
        self.skin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skin(&mut self, v: u32) {
        self.skin = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 5;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 effects = 6;

    pub fn effects(&self) -> u32 {
        self.effects.unwrap_or(0)
    }

    pub fn clear_effects(&mut self) {
        self.effects = ::std::option::Option::None;
    }

    pub fn has_effects(&self) -> bool {
        self.effects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: u32) {
        self.effects = ::std::option::Option::Some(v);
    }

    // optional fixed32 color = 7;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional fixed64 modelindex = 8;

    pub fn modelindex(&self) -> u64 {
        self.modelindex.unwrap_or(0)
    }

    pub fn clear_modelindex(&mut self) {
        self.modelindex = ::std::option::Option::None;
    }

    pub fn has_modelindex(&self) -> bool {
        self.modelindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modelindex(&mut self, v: u64) {
        self.modelindex = ::std::option::Option::Some(v);
    }

    // optional uint32 unused_breakmodelsnottomake = 9;

    pub fn unused_breakmodelsnottomake(&self) -> u32 {
        self.unused_breakmodelsnottomake.unwrap_or(0)
    }

    pub fn clear_unused_breakmodelsnottomake(&mut self) {
        self.unused_breakmodelsnottomake = ::std::option::Option::None;
    }

    pub fn has_unused_breakmodelsnottomake(&self) -> bool {
        self.unused_breakmodelsnottomake.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused_breakmodelsnottomake(&mut self, v: u32) {
        self.unused_breakmodelsnottomake = ::std::option::Option::Some(v);
    }

    // optional float scale = 10;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    // optional int32 dmgtype = 13;

    pub fn dmgtype(&self) -> i32 {
        self.dmgtype.unwrap_or(0)
    }

    pub fn clear_dmgtype(&mut self) {
        self.dmgtype = ::std::option::Option::None;
    }

    pub fn has_dmgtype(&self) -> bool {
        self.dmgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmgtype(&mut self, v: i32) {
        self.dmgtype = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEPhysicsProp| { &m.origin },
            |m: &mut CMsgTEPhysicsProp| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "velocity",
            |m: &CMsgTEPhysicsProp| { &m.velocity },
            |m: &mut CMsgTEPhysicsProp| { &mut m.velocity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "angles",
            |m: &CMsgTEPhysicsProp| { &m.angles },
            |m: &mut CMsgTEPhysicsProp| { &mut m.angles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skin",
            |m: &CMsgTEPhysicsProp| { &m.skin },
            |m: &mut CMsgTEPhysicsProp| { &mut m.skin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgTEPhysicsProp| { &m.flags },
            |m: &mut CMsgTEPhysicsProp| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effects",
            |m: &CMsgTEPhysicsProp| { &m.effects },
            |m: &mut CMsgTEPhysicsProp| { &mut m.effects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CMsgTEPhysicsProp| { &m.color },
            |m: &mut CMsgTEPhysicsProp| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "modelindex",
            |m: &CMsgTEPhysicsProp| { &m.modelindex },
            |m: &mut CMsgTEPhysicsProp| { &mut m.modelindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "unused_breakmodelsnottomake",
            |m: &CMsgTEPhysicsProp| { &m.unused_breakmodelsnottomake },
            |m: &mut CMsgTEPhysicsProp| { &mut m.unused_breakmodelsnottomake },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgTEPhysicsProp| { &m.scale },
            |m: &mut CMsgTEPhysicsProp| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "dmgpos",
            |m: &CMsgTEPhysicsProp| { &m.dmgpos },
            |m: &mut CMsgTEPhysicsProp| { &mut m.dmgpos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "dmgdir",
            |m: &CMsgTEPhysicsProp| { &m.dmgdir },
            |m: &mut CMsgTEPhysicsProp| { &mut m.dmgdir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dmgtype",
            |m: &CMsgTEPhysicsProp| { &m.dmgtype },
            |m: &mut CMsgTEPhysicsProp| { &mut m.dmgtype },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEPhysicsProp>(
            "CMsgTEPhysicsProp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEPhysicsProp {
    const NAME: &'static str = "CMsgTEPhysicsProp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.velocity)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                },
                37 => {
                    self.skin = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.effects = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                65 => {
                    self.modelindex = ::std::option::Option::Some(is.read_fixed64()?);
                },
                72 => {
                    self.unused_breakmodelsnottomake = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dmgpos)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dmgdir)?;
                },
                104 => {
                    self.dmgtype = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.velocity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.skin {
            my_size += 1 + 4;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.effects {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        if let Some(v) = self.modelindex {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unused_breakmodelsnottomake {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.dmgpos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dmgdir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dmgtype {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.velocity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.angles.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.skin {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.effects {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.modelindex {
            os.write_fixed64(8, v)?;
        }
        if let Some(v) = self.unused_breakmodelsnottomake {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.scale {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.dmgpos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.dmgdir.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.dmgtype {
            os.write_int32(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEPhysicsProp {
        CMsgTEPhysicsProp::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.velocity.clear();
        self.angles.clear();
        self.skin = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.effects = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.modelindex = ::std::option::Option::None;
        self.unused_breakmodelsnottomake = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.dmgpos.clear();
        self.dmgdir.clear();
        self.dmgtype = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEPhysicsProp {
        static instance: CMsgTEPhysicsProp = CMsgTEPhysicsProp {
            origin: ::protobuf::MessageField::none(),
            velocity: ::protobuf::MessageField::none(),
            angles: ::protobuf::MessageField::none(),
            skin: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            effects: ::std::option::Option::None,
            color: ::std::option::Option::None,
            modelindex: ::std::option::Option::None,
            unused_breakmodelsnottomake: ::std::option::Option::None,
            scale: ::std::option::Option::None,
            dmgpos: ::protobuf::MessageField::none(),
            dmgdir: ::protobuf::MessageField::none(),
            dmgtype: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEPhysicsProp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEPhysicsProp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEPhysicsProp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEPhysicsProp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEPlayerDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEPlayerDecal {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEPlayerDecal.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEPlayerDecal.player)
    pub player: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTEPlayerDecal.entity)
    pub entity: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEPlayerDecal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEPlayerDecal {
    fn default() -> &'a CMsgTEPlayerDecal {
        <CMsgTEPlayerDecal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEPlayerDecal {
    pub fn new() -> CMsgTEPlayerDecal {
        ::std::default::Default::default()
    }

    // optional int32 player = 2;

    pub fn player(&self) -> i32 {
        self.player.unwrap_or(-1i32)
    }

    pub fn clear_player(&mut self) {
        self.player = ::std::option::Option::None;
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: i32) {
        self.player = ::std::option::Option::Some(v);
    }

    // optional int32 entity = 3;

    pub fn entity(&self) -> i32 {
        self.entity.unwrap_or(-1i32)
    }

    pub fn clear_entity(&mut self) {
        self.entity = ::std::option::Option::None;
    }

    pub fn has_entity(&self) -> bool {
        self.entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: i32) {
        self.entity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEPlayerDecal| { &m.origin },
            |m: &mut CMsgTEPlayerDecal| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player",
            |m: &CMsgTEPlayerDecal| { &m.player },
            |m: &mut CMsgTEPlayerDecal| { &mut m.player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity",
            |m: &CMsgTEPlayerDecal| { &m.entity },
            |m: &mut CMsgTEPlayerDecal| { &mut m.entity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEPlayerDecal>(
            "CMsgTEPlayerDecal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEPlayerDecal {
    const NAME: &'static str = "CMsgTEPlayerDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                16 => {
                    self.player = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.entity = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entity {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.player {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEPlayerDecal {
        CMsgTEPlayerDecal::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.player = ::std::option::Option::None;
        self.entity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEPlayerDecal {
        static instance: CMsgTEPlayerDecal = CMsgTEPlayerDecal {
            origin: ::protobuf::MessageField::none(),
            player: ::std::option::Option::None,
            entity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEPlayerDecal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEPlayerDecal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEPlayerDecal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEPlayerDecal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEProjectedDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEProjectedDecal {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEProjectedDecal.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEProjectedDecal.angles)
    pub angles: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CMsgTEProjectedDecal.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTEProjectedDecal.distance)
    pub distance: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEProjectedDecal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEProjectedDecal {
    fn default() -> &'a CMsgTEProjectedDecal {
        <CMsgTEProjectedDecal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEProjectedDecal {
    pub fn new() -> CMsgTEProjectedDecal {
        ::std::default::Default::default()
    }

    // optional uint32 index = 3;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional float distance = 4;

    pub fn distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEProjectedDecal| { &m.origin },
            |m: &mut CMsgTEProjectedDecal| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "angles",
            |m: &CMsgTEProjectedDecal| { &m.angles },
            |m: &mut CMsgTEProjectedDecal| { &mut m.angles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CMsgTEProjectedDecal| { &m.index },
            |m: &mut CMsgTEProjectedDecal| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "distance",
            |m: &CMsgTEProjectedDecal| { &m.distance },
            |m: &mut CMsgTEProjectedDecal| { &mut m.distance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEProjectedDecal>(
            "CMsgTEProjectedDecal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEProjectedDecal {
    const NAME: &'static str = "CMsgTEProjectedDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                },
                24 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.distance = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.angles.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.distance {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.angles.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.distance {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEProjectedDecal {
        CMsgTEProjectedDecal::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.angles.clear();
        self.index = ::std::option::Option::None;
        self.distance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEProjectedDecal {
        static instance: CMsgTEProjectedDecal = CMsgTEProjectedDecal {
            origin: ::protobuf::MessageField::none(),
            angles: ::protobuf::MessageField::none(),
            index: ::std::option::Option::None,
            distance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEProjectedDecal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEProjectedDecal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEProjectedDecal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEProjectedDecal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTESmoke)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTESmoke {
    // message fields
    // @@protoc_insertion_point(field:CMsgTESmoke.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTESmoke.scale)
    pub scale: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTESmoke.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTESmoke {
    fn default() -> &'a CMsgTESmoke {
        <CMsgTESmoke as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTESmoke {
    pub fn new() -> CMsgTESmoke {
        ::std::default::Default::default()
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTESmoke| { &m.origin },
            |m: &mut CMsgTESmoke| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgTESmoke| { &m.scale },
            |m: &mut CMsgTESmoke| { &mut m.scale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTESmoke>(
            "CMsgTESmoke",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTESmoke {
    const NAME: &'static str = "CMsgTESmoke";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTESmoke {
        CMsgTESmoke::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTESmoke {
        static instance: CMsgTESmoke = CMsgTESmoke {
            origin: ::protobuf::MessageField::none(),
            scale: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTESmoke {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTESmoke").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTESmoke {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTESmoke {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTEWorldDecal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTEWorldDecal {
    // message fields
    // @@protoc_insertion_point(field:CMsgTEWorldDecal.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEWorldDecal.normal)
    pub normal: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTEWorldDecal.index)
    pub index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTEWorldDecal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTEWorldDecal {
    fn default() -> &'a CMsgTEWorldDecal {
        <CMsgTEWorldDecal as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTEWorldDecal {
    pub fn new() -> CMsgTEWorldDecal {
        ::std::default::Default::default()
    }

    // optional uint32 index = 3;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CMsgTEWorldDecal| { &m.origin },
            |m: &mut CMsgTEWorldDecal| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "normal",
            |m: &CMsgTEWorldDecal| { &m.normal },
            |m: &mut CMsgTEWorldDecal| { &mut m.normal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CMsgTEWorldDecal| { &m.index },
            |m: &mut CMsgTEWorldDecal| { &mut m.index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTEWorldDecal>(
            "CMsgTEWorldDecal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTEWorldDecal {
    const NAME: &'static str = "CMsgTEWorldDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                24 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTEWorldDecal {
        CMsgTEWorldDecal::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.normal.clear();
        self.index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTEWorldDecal {
        static instance: CMsgTEWorldDecal = CMsgTEWorldDecal {
            origin: ::protobuf::MessageField::none(),
            normal: ::protobuf::MessageField::none(),
            index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTEWorldDecal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTEWorldDecal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTEWorldDecal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTEWorldDecal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETEProtobufIds)
pub enum ETEProtobufIds {
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_EffectDispatchId)
    TE_EffectDispatchId = 400,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_ArmorRicochetId)
    TE_ArmorRicochetId = 401,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BeamEntPointId)
    TE_BeamEntPointId = 402,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BeamEntsId)
    TE_BeamEntsId = 403,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BeamPointsId)
    TE_BeamPointsId = 404,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BeamRingId)
    TE_BeamRingId = 405,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BSPDecalId)
    TE_BSPDecalId = 407,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BubblesId)
    TE_BubblesId = 408,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BubbleTrailId)
    TE_BubbleTrailId = 409,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_DecalId)
    TE_DecalId = 410,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_WorldDecalId)
    TE_WorldDecalId = 411,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_EnergySplashId)
    TE_EnergySplashId = 412,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_FizzId)
    TE_FizzId = 413,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_ShatterSurfaceId)
    TE_ShatterSurfaceId = 414,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_GlowSpriteId)
    TE_GlowSpriteId = 415,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_ImpactId)
    TE_ImpactId = 416,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_MuzzleFlashId)
    TE_MuzzleFlashId = 417,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_BloodStreamId)
    TE_BloodStreamId = 418,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_ExplosionId)
    TE_ExplosionId = 419,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_DustId)
    TE_DustId = 420,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_LargeFunnelId)
    TE_LargeFunnelId = 421,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_SparksId)
    TE_SparksId = 422,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_PhysicsPropId)
    TE_PhysicsPropId = 423,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_PlayerDecalId)
    TE_PlayerDecalId = 424,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_ProjectedDecalId)
    TE_ProjectedDecalId = 425,
    // @@protoc_insertion_point(enum_value:ETEProtobufIds.TE_SmokeId)
    TE_SmokeId = 426,
}

impl ::protobuf::Enum for ETEProtobufIds {
    const NAME: &'static str = "ETEProtobufIds";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETEProtobufIds> {
        match value {
            400 => ::std::option::Option::Some(ETEProtobufIds::TE_EffectDispatchId),
            401 => ::std::option::Option::Some(ETEProtobufIds::TE_ArmorRicochetId),
            402 => ::std::option::Option::Some(ETEProtobufIds::TE_BeamEntPointId),
            403 => ::std::option::Option::Some(ETEProtobufIds::TE_BeamEntsId),
            404 => ::std::option::Option::Some(ETEProtobufIds::TE_BeamPointsId),
            405 => ::std::option::Option::Some(ETEProtobufIds::TE_BeamRingId),
            407 => ::std::option::Option::Some(ETEProtobufIds::TE_BSPDecalId),
            408 => ::std::option::Option::Some(ETEProtobufIds::TE_BubblesId),
            409 => ::std::option::Option::Some(ETEProtobufIds::TE_BubbleTrailId),
            410 => ::std::option::Option::Some(ETEProtobufIds::TE_DecalId),
            411 => ::std::option::Option::Some(ETEProtobufIds::TE_WorldDecalId),
            412 => ::std::option::Option::Some(ETEProtobufIds::TE_EnergySplashId),
            413 => ::std::option::Option::Some(ETEProtobufIds::TE_FizzId),
            414 => ::std::option::Option::Some(ETEProtobufIds::TE_ShatterSurfaceId),
            415 => ::std::option::Option::Some(ETEProtobufIds::TE_GlowSpriteId),
            416 => ::std::option::Option::Some(ETEProtobufIds::TE_ImpactId),
            417 => ::std::option::Option::Some(ETEProtobufIds::TE_MuzzleFlashId),
            418 => ::std::option::Option::Some(ETEProtobufIds::TE_BloodStreamId),
            419 => ::std::option::Option::Some(ETEProtobufIds::TE_ExplosionId),
            420 => ::std::option::Option::Some(ETEProtobufIds::TE_DustId),
            421 => ::std::option::Option::Some(ETEProtobufIds::TE_LargeFunnelId),
            422 => ::std::option::Option::Some(ETEProtobufIds::TE_SparksId),
            423 => ::std::option::Option::Some(ETEProtobufIds::TE_PhysicsPropId),
            424 => ::std::option::Option::Some(ETEProtobufIds::TE_PlayerDecalId),
            425 => ::std::option::Option::Some(ETEProtobufIds::TE_ProjectedDecalId),
            426 => ::std::option::Option::Some(ETEProtobufIds::TE_SmokeId),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETEProtobufIds> {
        match str {
            "TE_EffectDispatchId" => ::std::option::Option::Some(ETEProtobufIds::TE_EffectDispatchId),
            "TE_ArmorRicochetId" => ::std::option::Option::Some(ETEProtobufIds::TE_ArmorRicochetId),
            "TE_BeamEntPointId" => ::std::option::Option::Some(ETEProtobufIds::TE_BeamEntPointId),
            "TE_BeamEntsId" => ::std::option::Option::Some(ETEProtobufIds::TE_BeamEntsId),
            "TE_BeamPointsId" => ::std::option::Option::Some(ETEProtobufIds::TE_BeamPointsId),
            "TE_BeamRingId" => ::std::option::Option::Some(ETEProtobufIds::TE_BeamRingId),
            "TE_BSPDecalId" => ::std::option::Option::Some(ETEProtobufIds::TE_BSPDecalId),
            "TE_BubblesId" => ::std::option::Option::Some(ETEProtobufIds::TE_BubblesId),
            "TE_BubbleTrailId" => ::std::option::Option::Some(ETEProtobufIds::TE_BubbleTrailId),
            "TE_DecalId" => ::std::option::Option::Some(ETEProtobufIds::TE_DecalId),
            "TE_WorldDecalId" => ::std::option::Option::Some(ETEProtobufIds::TE_WorldDecalId),
            "TE_EnergySplashId" => ::std::option::Option::Some(ETEProtobufIds::TE_EnergySplashId),
            "TE_FizzId" => ::std::option::Option::Some(ETEProtobufIds::TE_FizzId),
            "TE_ShatterSurfaceId" => ::std::option::Option::Some(ETEProtobufIds::TE_ShatterSurfaceId),
            "TE_GlowSpriteId" => ::std::option::Option::Some(ETEProtobufIds::TE_GlowSpriteId),
            "TE_ImpactId" => ::std::option::Option::Some(ETEProtobufIds::TE_ImpactId),
            "TE_MuzzleFlashId" => ::std::option::Option::Some(ETEProtobufIds::TE_MuzzleFlashId),
            "TE_BloodStreamId" => ::std::option::Option::Some(ETEProtobufIds::TE_BloodStreamId),
            "TE_ExplosionId" => ::std::option::Option::Some(ETEProtobufIds::TE_ExplosionId),
            "TE_DustId" => ::std::option::Option::Some(ETEProtobufIds::TE_DustId),
            "TE_LargeFunnelId" => ::std::option::Option::Some(ETEProtobufIds::TE_LargeFunnelId),
            "TE_SparksId" => ::std::option::Option::Some(ETEProtobufIds::TE_SparksId),
            "TE_PhysicsPropId" => ::std::option::Option::Some(ETEProtobufIds::TE_PhysicsPropId),
            "TE_PlayerDecalId" => ::std::option::Option::Some(ETEProtobufIds::TE_PlayerDecalId),
            "TE_ProjectedDecalId" => ::std::option::Option::Some(ETEProtobufIds::TE_ProjectedDecalId),
            "TE_SmokeId" => ::std::option::Option::Some(ETEProtobufIds::TE_SmokeId),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETEProtobufIds] = &[
        ETEProtobufIds::TE_EffectDispatchId,
        ETEProtobufIds::TE_ArmorRicochetId,
        ETEProtobufIds::TE_BeamEntPointId,
        ETEProtobufIds::TE_BeamEntsId,
        ETEProtobufIds::TE_BeamPointsId,
        ETEProtobufIds::TE_BeamRingId,
        ETEProtobufIds::TE_BSPDecalId,
        ETEProtobufIds::TE_BubblesId,
        ETEProtobufIds::TE_BubbleTrailId,
        ETEProtobufIds::TE_DecalId,
        ETEProtobufIds::TE_WorldDecalId,
        ETEProtobufIds::TE_EnergySplashId,
        ETEProtobufIds::TE_FizzId,
        ETEProtobufIds::TE_ShatterSurfaceId,
        ETEProtobufIds::TE_GlowSpriteId,
        ETEProtobufIds::TE_ImpactId,
        ETEProtobufIds::TE_MuzzleFlashId,
        ETEProtobufIds::TE_BloodStreamId,
        ETEProtobufIds::TE_ExplosionId,
        ETEProtobufIds::TE_DustId,
        ETEProtobufIds::TE_LargeFunnelId,
        ETEProtobufIds::TE_SparksId,
        ETEProtobufIds::TE_PhysicsPropId,
        ETEProtobufIds::TE_PlayerDecalId,
        ETEProtobufIds::TE_ProjectedDecalId,
        ETEProtobufIds::TE_SmokeId,
    ];
}

impl ::protobuf::EnumFull for ETEProtobufIds {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETEProtobufIds").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ETEProtobufIds::TE_EffectDispatchId => 0,
            ETEProtobufIds::TE_ArmorRicochetId => 1,
            ETEProtobufIds::TE_BeamEntPointId => 2,
            ETEProtobufIds::TE_BeamEntsId => 3,
            ETEProtobufIds::TE_BeamPointsId => 4,
            ETEProtobufIds::TE_BeamRingId => 5,
            ETEProtobufIds::TE_BSPDecalId => 6,
            ETEProtobufIds::TE_BubblesId => 7,
            ETEProtobufIds::TE_BubbleTrailId => 8,
            ETEProtobufIds::TE_DecalId => 9,
            ETEProtobufIds::TE_WorldDecalId => 10,
            ETEProtobufIds::TE_EnergySplashId => 11,
            ETEProtobufIds::TE_FizzId => 12,
            ETEProtobufIds::TE_ShatterSurfaceId => 13,
            ETEProtobufIds::TE_GlowSpriteId => 14,
            ETEProtobufIds::TE_ImpactId => 15,
            ETEProtobufIds::TE_MuzzleFlashId => 16,
            ETEProtobufIds::TE_BloodStreamId => 17,
            ETEProtobufIds::TE_ExplosionId => 18,
            ETEProtobufIds::TE_DustId => 19,
            ETEProtobufIds::TE_LargeFunnelId => 20,
            ETEProtobufIds::TE_SparksId => 21,
            ETEProtobufIds::TE_PhysicsPropId => 22,
            ETEProtobufIds::TE_PlayerDecalId => 23,
            ETEProtobufIds::TE_ProjectedDecalId => 24,
            ETEProtobufIds::TE_SmokeId => 25,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETEProtobufIds {
    fn default() -> Self {
        ETEProtobufIds::TE_EffectDispatchId
    }
}

impl ETEProtobufIds {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ETEProtobufIds>("ETEProtobufIds")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x08te.proto\x1a\x16networkbasetypes.proto\"S\n\x13CMsgTEArmorRicochet\
    \x12\x1d\n\x03pos\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x03pos\x12\x1d\n\
    \x03dir\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x03dir\"\xd2\x02\n\x0eCMsg\
    TEBaseBeam\x12\x1e\n\nmodelindex\x18\x01\x20\x01(\x06R\nmodelindex\x12\
    \x1c\n\thaloindex\x18\x02\x20\x01(\x06R\thaloindex\x12\x1e\n\nstartframe\
    \x18\x03\x20\x01(\rR\nstartframe\x12\x1c\n\tframerate\x18\x04\x20\x01(\r\
    R\tframerate\x12\x12\n\x04life\x18\x05\x20\x01(\x02R\x04life\x12\x14\n\
    \x05width\x18\x06\x20\x01(\x02R\x05width\x12\x1a\n\x08endwidth\x18\x07\
    \x20\x01(\x02R\x08endwidth\x12\x1e\n\nfadelength\x18\x08\x20\x01(\rR\nfa\
    delength\x12\x1c\n\tamplitude\x18\t\x20\x01(\x02R\tamplitude\x12\x14\n\
    \x05color\x18\n\x20\x01(\x07R\x05color\x12\x14\n\x05speed\x18\x0b\x20\
    \x01(\rR\x05speed\x12\x14\n\x05flags\x18\x0c\x20\x01(\rR\x05flags\"\xbb\
    \x01\n\x12CMsgTEBeamEntPoint\x12#\n\x04base\x18\x01\x20\x01(\x0b2\x0f.CM\
    sgTEBaseBeamR\x04base\x12\x20\n\x0bstartentity\x18\x02\x20\x01(\rR\x0bst\
    artentity\x12\x1c\n\tendentity\x18\x03\x20\x01(\rR\tendentity\x12!\n\x05\
    start\x18\x04\x20\x01(\x0b2\x0b.CMsgVectorR\x05start\x12\x1d\n\x03end\
    \x18\x05\x20\x01(\x0b2\x0b.CMsgVectorR\x03end\"u\n\x0eCMsgTEBeamEnts\x12\
    #\n\x04base\x18\x01\x20\x01(\x0b2\x0f.CMsgTEBaseBeamR\x04base\x12\x20\n\
    \x0bstartentity\x18\x02\x20\x01(\rR\x0bstartentity\x12\x1c\n\tendentity\
    \x18\x03\x20\x01(\rR\tendentity\"y\n\x10CMsgTEBeamPoints\x12#\n\x04base\
    \x18\x01\x20\x01(\x0b2\x0f.CMsgTEBaseBeamR\x04base\x12!\n\x05start\x18\
    \x02\x20\x01(\x0b2\x0b.CMsgVectorR\x05start\x12\x1d\n\x03end\x18\x03\x20\
    \x01(\x0b2\x0b.CMsgVectorR\x03end\"u\n\x0eCMsgTEBeamRing\x12#\n\x04base\
    \x18\x01\x20\x01(\x0b2\x0f.CMsgTEBaseBeamR\x04base\x12\x20\n\x0bstartent\
    ity\x18\x02\x20\x01(\rR\x0bstartentity\x12\x1c\n\tendentity\x18\x03\x20\
    \x01(\rR\tendentity\"\xaf\x01\n\x0eCMsgTEBSPDecal\x12#\n\x06origin\x18\
    \x01\x20\x01(\x0b2\x0b.CMsgVectorR\x06origin\x12#\n\x06normal\x18\x02\
    \x20\x01(\x0b2\x0b.CMsgVectorR\x06normal\x12!\n\x05saxis\x18\x03\x20\x01\
    (\x0b2\x0b.CMsgVectorR\x05saxis\x12\x1a\n\x06entity\x18\x04\x20\x01(\x05\
    :\x02-1R\x06entity\x12\x14\n\x05index\x18\x05\x20\x01(\rR\x05index\"\x95\
    \x01\n\rCMsgTEBubbles\x12\x1f\n\x04mins\x18\x01\x20\x01(\x0b2\x0b.CMsgVe\
    ctorR\x04mins\x12\x1f\n\x04maxs\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\
    \x04maxs\x12\x16\n\x06height\x18\x03\x20\x01(\x02R\x06height\x12\x14\n\
    \x05count\x18\x04\x20\x01(\rR\x05count\x12\x14\n\x05speed\x18\x05\x20\
    \x01(\x02R\x05speed\"\x99\x01\n\x11CMsgTEBubbleTrail\x12\x1f\n\x04mins\
    \x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x04mins\x12\x1f\n\x04maxs\x18\x02\
    \x20\x01(\x0b2\x0b.CMsgVectorR\x04maxs\x12\x16\n\x06waterz\x18\x03\x20\
    \x01(\x02R\x06waterz\x12\x14\n\x05count\x18\x04\x20\x01(\rR\x05count\x12\
    \x14\n\x05speed\x18\x05\x20\x01(\x02R\x05speed\"\x9f\x01\n\x0bCMsgTEDeca\
    l\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x06origin\x12!\
    \n\x05start\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x05start\x12\x1a\n\x06\
    entity\x18\x03\x20\x01(\x05:\x02-1R\x06entity\x12\x16\n\x06hitbox\x18\
    \x04\x20\x01(\rR\x06hitbox\x12\x14\n\x05index\x18\x05\x20\x01(\rR\x05ind\
    ex\"\xf2\x04\n\x0eCMsgEffectData\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\
    \x0b.CMsgVectorR\x06origin\x12!\n\x05start\x18\x02\x20\x01(\x0b2\x0b.CMs\
    gVectorR\x05start\x12#\n\x06normal\x18\x03\x20\x01(\x0b2\x0b.CMsgVectorR\
    \x06normal\x12#\n\x06angles\x18\x04\x20\x01(\x0b2\x0b.CMsgQAngleR\x06ang\
    les\x12\x20\n\x06entity\x18\x05\x20\x01(\x07:\x0816777215R\x06entity\x12\
    *\n\x0botherentity\x18\x06\x20\x01(\x07:\x0816777215R\x0botherentity\x12\
    \x14\n\x05scale\x18\x07\x20\x01(\x02R\x05scale\x12\x1c\n\tmagnitude\x18\
    \x08\x20\x01(\x02R\tmagnitude\x12\x16\n\x06radius\x18\t\x20\x01(\x02R\
    \x06radius\x12\x20\n\x0bsurfaceprop\x18\n\x20\x01(\x07R\x0bsurfaceprop\
    \x12\x20\n\x0beffectindex\x18\x0b\x20\x01(\x06R\x0beffectindex\x12\x1e\n\
    \ndamagetype\x18\x0c\x20\x01(\rR\ndamagetype\x12\x1a\n\x08material\x18\r\
    \x20\x01(\rR\x08material\x12\x16\n\x06hitbox\x18\x0e\x20\x01(\rR\x06hitb\
    ox\x12\x14\n\x05color\x18\x0f\x20\x01(\rR\x05color\x12\x14\n\x05flags\
    \x18\x10\x20\x01(\rR\x05flags\x12(\n\x0fattachmentindex\x18\x11\x20\x01(\
    \x05R\x0fattachmentindex\x12\x1e\n\neffectname\x18\x12\x20\x01(\rR\neffe\
    ctname\x12&\n\x0eattachmentname\x18\x13\x20\x01(\rR\x0eattachmentname\"G\
    \n\x14CMsgTEEffectDispatch\x12/\n\neffectdata\x18\x01\x20\x01(\x0b2\x0f.\
    CMsgEffectDataR\neffectdata\"p\n\x12CMsgTEEnergySplash\x12\x1d\n\x03pos\
    \x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x03pos\x12\x1d\n\x03dir\x18\x02\
    \x20\x01(\x0b2\x0b.CMsgVectorR\x03dir\x12\x1c\n\texplosive\x18\x03\x20\
    \x01(\x08R\texplosive\"\\\n\nCMsgTEFizz\x12\x1a\n\x06entity\x18\x01\x20\
    \x01(\x05:\x02-1R\x06entity\x12\x18\n\x07density\x18\x02\x20\x01(\rR\x07\
    density\x12\x18\n\x07current\x18\x03\x20\x01(\x05R\x07current\"\xd8\x02\
    \n\x14CMsgTEShatterSurface\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b.CM\
    sgVectorR\x06origin\x12#\n\x06angles\x18\x02\x20\x01(\x0b2\x0b.CMsgQAngl\
    eR\x06angles\x12!\n\x05force\x18\x03\x20\x01(\x0b2\x0b.CMsgVectorR\x05fo\
    rce\x12'\n\x08forcepos\x18\x04\x20\x01(\x0b2\x0b.CMsgVectorR\x08forcepos\
    \x12\x14\n\x05width\x18\x05\x20\x01(\x02R\x05width\x12\x16\n\x06height\
    \x18\x06\x20\x01(\x02R\x06height\x12\x1c\n\tshardsize\x18\x07\x20\x01(\
    \x02R\tshardsize\x12\x20\n\x0bsurfacetype\x18\x08\x20\x01(\rR\x0bsurface\
    type\x12\x1e\n\nfrontcolor\x18\t\x20\x01(\x07R\nfrontcolor\x12\x1c\n\tba\
    ckcolor\x18\n\x20\x01(\x07R\tbackcolor\"\x81\x01\n\x10CMsgTEGlowSprite\
    \x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x06origin\x12\
    \x14\n\x05scale\x18\x02\x20\x01(\x02R\x05scale\x12\x12\n\x04life\x18\x03\
    \x20\x01(\x02R\x04life\x12\x1e\n\nbrightness\x18\x04\x20\x01(\rR\nbright\
    ness\"l\n\x0cCMsgTEImpact\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b.CMs\
    gVectorR\x06origin\x12#\n\x06normal\x18\x02\x20\x01(\x0b2\x0b.CMsgVector\
    R\x06normal\x12\x12\n\x04type\x18\x03\x20\x01(\rR\x04type\"\x87\x01\n\
    \x11CMsgTEMuzzleFlash\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b.CMsgVec\
    torR\x06origin\x12#\n\x06angles\x18\x02\x20\x01(\x0b2\x0b.CMsgQAngleR\
    \x06angles\x12\x14\n\x05scale\x18\x03\x20\x01(\x02R\x05scale\x12\x12\n\
    \x04type\x18\x04\x20\x01(\rR\x04type\"\x91\x01\n\x11CMsgTEBloodStream\
    \x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x06origin\x12)\n\
    \tdirection\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\tdirection\x12\x14\n\
    \x05color\x18\x03\x20\x01(\x07R\x05color\x12\x16\n\x06amount\x18\x04\x20\
    \x01(\rR\x06amount\"\xf0\x02\n\x0fCMsgTEExplosion\x12#\n\x06origin\x18\
    \x01\x20\x01(\x0b2\x0b.CMsgVectorR\x06origin\x12\x1c\n\tframerate\x18\
    \x02\x20\x01(\rR\tframerate\x12\x14\n\x05flags\x18\x03\x20\x01(\rR\x05fl\
    ags\x12#\n\x06normal\x18\x04\x20\x01(\x0b2\x0b.CMsgVectorR\x06normal\x12\
    \"\n\x0cmaterialtype\x18\x05\x20\x01(\rR\x0cmaterialtype\x12\x16\n\x06ra\
    dius\x18\x06\x20\x01(\rR\x06radius\x12\x1c\n\tmagnitude\x18\x07\x20\x01(\
    \rR\tmagnitude\x12\x14\n\x05scale\x18\x08\x20\x01(\x02R\x05scale\x12'\n\
    \x0faffect_ragdolls\x18\t\x20\x01(\x08R\x0eaffectRagdolls\x12\x1f\n\x0be\
    ffect_name\x18\n\x20\x01(\tR\neffectName\x12%\n\x0eexplosion_type\x18\
    \x0b\x20\x01(\rR\rexplosionType\"\x86\x01\n\nCMsgTEDust\x12#\n\x06origin\
    \x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x06origin\x12\x12\n\x04size\x18\
    \x02\x20\x01(\x02R\x04size\x12\x14\n\x05speed\x18\x03\x20\x01(\x02R\x05s\
    peed\x12)\n\tdirection\x18\x04\x20\x01(\x0b2\x0b.CMsgVectorR\tdirection\
    \"T\n\x11CMsgTELargeFunnel\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b.CM\
    sgVectorR\x06origin\x12\x1a\n\x08reversed\x18\x02\x20\x01(\rR\x08reverse\
    d\"\x94\x01\n\x0cCMsgTESparks\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b\
    .CMsgVectorR\x06origin\x12\x1c\n\tmagnitude\x18\x02\x20\x01(\rR\tmagnitu\
    de\x12\x16\n\x06length\x18\x03\x20\x01(\rR\x06length\x12)\n\tdirection\
    \x18\x04\x20\x01(\x0b2\x0b.CMsgVectorR\tdirection\"\xbb\x03\n\x11CMsgTEP\
    hysicsProp\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x06ori\
    gin\x12'\n\x08velocity\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x08velocity\
    \x12#\n\x06angles\x18\x03\x20\x01(\x0b2\x0b.CMsgQAngleR\x06angles\x12\
    \x12\n\x04skin\x18\x04\x20\x01(\x07R\x04skin\x12\x14\n\x05flags\x18\x05\
    \x20\x01(\rR\x05flags\x12\x18\n\x07effects\x18\x06\x20\x01(\rR\x07effect\
    s\x12\x14\n\x05color\x18\x07\x20\x01(\x07R\x05color\x12\x1e\n\nmodelinde\
    x\x18\x08\x20\x01(\x06R\nmodelindex\x12?\n\x1bunused_breakmodelsnottomak\
    e\x18\t\x20\x01(\rR\x1aunusedBreakmodelsnottomake\x12\x14\n\x05scale\x18\
    \n\x20\x01(\x02R\x05scale\x12#\n\x06dmgpos\x18\x0b\x20\x01(\x0b2\x0b.CMs\
    gVectorR\x06dmgpos\x12#\n\x06dmgdir\x18\x0c\x20\x01(\x0b2\x0b.CMsgVector\
    R\x06dmgdir\x12\x18\n\x07dmgtype\x18\r\x20\x01(\x05R\x07dmgtype\"p\n\x11\
    CMsgTEPlayerDecal\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\
    \x06origin\x12\x1a\n\x06player\x18\x02\x20\x01(\x05:\x02-1R\x06player\
    \x12\x1a\n\x06entity\x18\x03\x20\x01(\x05:\x02-1R\x06entity\"\x92\x01\n\
    \x14CMsgTEProjectedDecal\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\x0b.CMsg\
    VectorR\x06origin\x12#\n\x06angles\x18\x02\x20\x01(\x0b2\x0b.CMsgQAngleR\
    \x06angles\x12\x14\n\x05index\x18\x03\x20\x01(\rR\x05index\x12\x1a\n\x08\
    distance\x18\x04\x20\x01(\x02R\x08distance\"H\n\x0bCMsgTESmoke\x12#\n\
    \x06origin\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x06origin\x12\x14\n\x05\
    scale\x18\x02\x20\x01(\x02R\x05scale\"r\n\x10CMsgTEWorldDecal\x12#\n\x06\
    origin\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x06origin\x12#\n\x06normal\
    \x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x06normal\x12\x14\n\x05index\x18\
    \x03\x20\x01(\rR\x05index*\xbd\x04\n\x0eETEProtobufIds\x12\x18\n\x13TE_E\
    ffectDispatchId\x10\x90\x03\x12\x17\n\x12TE_ArmorRicochetId\x10\x91\x03\
    \x12\x16\n\x11TE_BeamEntPointId\x10\x92\x03\x12\x12\n\rTE_BeamEntsId\x10\
    \x93\x03\x12\x14\n\x0fTE_BeamPointsId\x10\x94\x03\x12\x12\n\rTE_BeamRing\
    Id\x10\x95\x03\x12\x12\n\rTE_BSPDecalId\x10\x97\x03\x12\x11\n\x0cTE_Bubb\
    lesId\x10\x98\x03\x12\x15\n\x10TE_BubbleTrailId\x10\x99\x03\x12\x0f\n\nT\
    E_DecalId\x10\x9a\x03\x12\x14\n\x0fTE_WorldDecalId\x10\x9b\x03\x12\x16\n\
    \x11TE_EnergySplashId\x10\x9c\x03\x12\x0e\n\tTE_FizzId\x10\x9d\x03\x12\
    \x18\n\x13TE_ShatterSurfaceId\x10\x9e\x03\x12\x14\n\x0fTE_GlowSpriteId\
    \x10\x9f\x03\x12\x10\n\x0bTE_ImpactId\x10\xa0\x03\x12\x15\n\x10TE_Muzzle\
    FlashId\x10\xa1\x03\x12\x15\n\x10TE_BloodStreamId\x10\xa2\x03\x12\x13\n\
    \x0eTE_ExplosionId\x10\xa3\x03\x12\x0e\n\tTE_DustId\x10\xa4\x03\x12\x15\
    \n\x10TE_LargeFunnelId\x10\xa5\x03\x12\x10\n\x0bTE_SparksId\x10\xa6\x03\
    \x12\x15\n\x10TE_PhysicsPropId\x10\xa7\x03\x12\x15\n\x10TE_PlayerDecalId\
    \x10\xa8\x03\x12\x18\n\x13TE_ProjectedDecalId\x10\xa9\x03\x12\x0f\n\nTE_\
    SmokeId\x10\xaa\x03\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::networkbasetypes::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(28);
            messages.push(CMsgTEArmorRicochet::generated_message_descriptor_data());
            messages.push(CMsgTEBaseBeam::generated_message_descriptor_data());
            messages.push(CMsgTEBeamEntPoint::generated_message_descriptor_data());
            messages.push(CMsgTEBeamEnts::generated_message_descriptor_data());
            messages.push(CMsgTEBeamPoints::generated_message_descriptor_data());
            messages.push(CMsgTEBeamRing::generated_message_descriptor_data());
            messages.push(CMsgTEBSPDecal::generated_message_descriptor_data());
            messages.push(CMsgTEBubbles::generated_message_descriptor_data());
            messages.push(CMsgTEBubbleTrail::generated_message_descriptor_data());
            messages.push(CMsgTEDecal::generated_message_descriptor_data());
            messages.push(CMsgEffectData::generated_message_descriptor_data());
            messages.push(CMsgTEEffectDispatch::generated_message_descriptor_data());
            messages.push(CMsgTEEnergySplash::generated_message_descriptor_data());
            messages.push(CMsgTEFizz::generated_message_descriptor_data());
            messages.push(CMsgTEShatterSurface::generated_message_descriptor_data());
            messages.push(CMsgTEGlowSprite::generated_message_descriptor_data());
            messages.push(CMsgTEImpact::generated_message_descriptor_data());
            messages.push(CMsgTEMuzzleFlash::generated_message_descriptor_data());
            messages.push(CMsgTEBloodStream::generated_message_descriptor_data());
            messages.push(CMsgTEExplosion::generated_message_descriptor_data());
            messages.push(CMsgTEDust::generated_message_descriptor_data());
            messages.push(CMsgTELargeFunnel::generated_message_descriptor_data());
            messages.push(CMsgTESparks::generated_message_descriptor_data());
            messages.push(CMsgTEPhysicsProp::generated_message_descriptor_data());
            messages.push(CMsgTEPlayerDecal::generated_message_descriptor_data());
            messages.push(CMsgTEProjectedDecal::generated_message_descriptor_data());
            messages.push(CMsgTESmoke::generated_message_descriptor_data());
            messages.push(CMsgTEWorldDecal::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(ETEProtobufIds::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
