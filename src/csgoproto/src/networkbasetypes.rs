// This file is generated by rust-protobuf 3.5.0. Do not edit
// .proto file is parsed by protoc 3.12.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `networkbasetypes.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_0;

// @@protoc_insertion_point(message:CMsgVector)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVector {
    // message fields
    // @@protoc_insertion_point(field:CMsgVector.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector.z)
    pub z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector.w)
    pub w: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVector {
    fn default() -> &'a CMsgVector {
        <CMsgVector as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVector {
    pub fn new() -> CMsgVector {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional float z = 3;

    pub fn z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }

    // optional float w = 4;

    pub fn w(&self) -> f32 {
        self.w.unwrap_or(0.)
    }

    pub fn clear_w(&mut self) {
        self.w = ::std::option::Option::None;
    }

    pub fn has_w(&self) -> bool {
        self.w.is_some()
    }

    // Param is passed by value, moved
    pub fn set_w(&mut self, v: f32) {
        self.w = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgVector| { &m.x },
            |m: &mut CMsgVector| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgVector| { &m.y },
            |m: &mut CMsgVector| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "z",
            |m: &CMsgVector| { &m.z },
            |m: &mut CMsgVector| { &mut m.z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "w",
            |m: &CMsgVector| { &m.w },
            |m: &mut CMsgVector| { &mut m.w },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVector>(
            "CMsgVector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVector {
    const NAME: &'static str = "CMsgVector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.z = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.w = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.w {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.w {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVector {
        CMsgVector::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.w = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVector {
        static instance: CMsgVector = CMsgVector {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            w: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgVector2D)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVector2D {
    // message fields
    // @@protoc_insertion_point(field:CMsgVector2D.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector2D.y)
    pub y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVector2D.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVector2D {
    fn default() -> &'a CMsgVector2D {
        <CMsgVector2D as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVector2D {
    pub fn new() -> CMsgVector2D {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgVector2D| { &m.x },
            |m: &mut CMsgVector2D| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgVector2D| { &m.y },
            |m: &mut CMsgVector2D| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVector2D>(
            "CMsgVector2D",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVector2D {
    const NAME: &'static str = "CMsgVector2D";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVector2D {
        CMsgVector2D::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVector2D {
        static instance: CMsgVector2D = CMsgVector2D {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVector2D {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVector2D").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVector2D {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVector2D {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgQAngle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQAngle {
    // message fields
    // @@protoc_insertion_point(field:CMsgQAngle.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQAngle.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQAngle.z)
    pub z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQAngle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQAngle {
    fn default() -> &'a CMsgQAngle {
        <CMsgQAngle as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQAngle {
    pub fn new() -> CMsgQAngle {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional float z = 3;

    pub fn z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgQAngle| { &m.x },
            |m: &mut CMsgQAngle| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgQAngle| { &m.y },
            |m: &mut CMsgQAngle| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "z",
            |m: &CMsgQAngle| { &m.z },
            |m: &mut CMsgQAngle| { &mut m.z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQAngle>(
            "CMsgQAngle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQAngle {
    const NAME: &'static str = "CMsgQAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.z {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQAngle {
        CMsgQAngle::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQAngle {
        static instance: CMsgQAngle = CMsgQAngle {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQAngle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQAngle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQAngle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgQuaternion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuaternion {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuaternion.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuaternion.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuaternion.z)
    pub z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQuaternion.w)
    pub w: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuaternion.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuaternion {
    fn default() -> &'a CMsgQuaternion {
        <CMsgQuaternion as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQuaternion {
    pub fn new() -> CMsgQuaternion {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional float z = 3;

    pub fn z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }

    // optional float w = 4;

    pub fn w(&self) -> f32 {
        self.w.unwrap_or(0.)
    }

    pub fn clear_w(&mut self) {
        self.w = ::std::option::Option::None;
    }

    pub fn has_w(&self) -> bool {
        self.w.is_some()
    }

    // Param is passed by value, moved
    pub fn set_w(&mut self, v: f32) {
        self.w = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgQuaternion| { &m.x },
            |m: &mut CMsgQuaternion| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgQuaternion| { &m.y },
            |m: &mut CMsgQuaternion| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "z",
            |m: &CMsgQuaternion| { &m.z },
            |m: &mut CMsgQuaternion| { &mut m.z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "w",
            |m: &CMsgQuaternion| { &m.w },
            |m: &mut CMsgQuaternion| { &mut m.w },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQuaternion>(
            "CMsgQuaternion",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQuaternion {
    const NAME: &'static str = "CMsgQuaternion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.z = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.w = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.w {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.w {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuaternion {
        CMsgQuaternion::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.w = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuaternion {
        static instance: CMsgQuaternion = CMsgQuaternion {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            w: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQuaternion {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQuaternion").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQuaternion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQuaternion {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgTransform)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTransform {
    // message fields
    // @@protoc_insertion_point(field:CMsgTransform.position)
    pub position: ::protobuf::MessageField<CMsgVector>,
    // @@protoc_insertion_point(field:CMsgTransform.scale)
    pub scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTransform.orientation)
    pub orientation: ::protobuf::MessageField<CMsgQuaternion>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTransform.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTransform {
    fn default() -> &'a CMsgTransform {
        <CMsgTransform as ::protobuf::Message>::default_instance()
    }
}

impl CMsgTransform {
    pub fn new() -> CMsgTransform {
        ::std::default::Default::default()
    }

    // optional float scale = 2;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVector>(
            "position",
            |m: &CMsgTransform| { &m.position },
            |m: &mut CMsgTransform| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CMsgTransform| { &m.scale },
            |m: &mut CMsgTransform| { &mut m.scale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgQuaternion>(
            "orientation",
            |m: &CMsgTransform| { &m.orientation },
            |m: &mut CMsgTransform| { &mut m.orientation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgTransform>(
            "CMsgTransform",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgTransform {
    const NAME: &'static str = "CMsgTransform";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                21 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.orientation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.orientation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.scale {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.orientation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTransform {
        CMsgTransform::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.scale = ::std::option::Option::None;
        self.orientation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTransform {
        static instance: CMsgTransform = CMsgTransform {
            position: ::protobuf::MessageField::none(),
            scale: ::std::option::Option::None,
            orientation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgTransform {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgTransform").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgTransform {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgTransform {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRGBA)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRGBA {
    // message fields
    // @@protoc_insertion_point(field:CMsgRGBA.r)
    pub r: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRGBA.g)
    pub g: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRGBA.b)
    pub b: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRGBA.a)
    pub a: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRGBA.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRGBA {
    fn default() -> &'a CMsgRGBA {
        <CMsgRGBA as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRGBA {
    pub fn new() -> CMsgRGBA {
        ::std::default::Default::default()
    }

    // optional int32 r = 1;

    pub fn r(&self) -> i32 {
        self.r.unwrap_or(0)
    }

    pub fn clear_r(&mut self) {
        self.r = ::std::option::Option::None;
    }

    pub fn has_r(&self) -> bool {
        self.r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r(&mut self, v: i32) {
        self.r = ::std::option::Option::Some(v);
    }

    // optional int32 g = 2;

    pub fn g(&self) -> i32 {
        self.g.unwrap_or(0)
    }

    pub fn clear_g(&mut self) {
        self.g = ::std::option::Option::None;
    }

    pub fn has_g(&self) -> bool {
        self.g.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g(&mut self, v: i32) {
        self.g = ::std::option::Option::Some(v);
    }

    // optional int32 b = 3;

    pub fn b(&self) -> i32 {
        self.b.unwrap_or(0)
    }

    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: i32) {
        self.b = ::std::option::Option::Some(v);
    }

    // optional int32 a = 4;

    pub fn a(&self) -> i32 {
        self.a.unwrap_or(0)
    }

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: i32) {
        self.a = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "r",
            |m: &CMsgRGBA| { &m.r },
            |m: &mut CMsgRGBA| { &mut m.r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "g",
            |m: &CMsgRGBA| { &m.g },
            |m: &mut CMsgRGBA| { &mut m.g },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "b",
            |m: &CMsgRGBA| { &m.b },
            |m: &mut CMsgRGBA| { &mut m.b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "a",
            |m: &CMsgRGBA| { &m.a },
            |m: &mut CMsgRGBA| { &mut m.a },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRGBA>(
            "CMsgRGBA",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRGBA {
    const NAME: &'static str = "CMsgRGBA";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.r = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.g = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.b = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.a = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.r {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.g {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.b {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.a {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.r {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.g {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.b {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.a {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRGBA {
        CMsgRGBA::new()
    }

    fn clear(&mut self) {
        self.r = ::std::option::Option::None;
        self.g = ::std::option::Option::None;
        self.b = ::std::option::Option::None;
        self.a = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRGBA {
        static instance: CMsgRGBA = CMsgRGBA {
            r: ::std::option::Option::None,
            g: ::std::option::Option::None,
            b: ::std::option::Option::None,
            a: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRGBA {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRGBA").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRGBA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRGBA {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPlayerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerInfo.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPlayerInfo.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerInfo.userid)
    pub userid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPlayerInfo.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerInfo.fakeplayer)
    pub fakeplayer: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPlayerInfo.ishltv)
    pub ishltv: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerInfo {
    fn default() -> &'a CMsgPlayerInfo {
        <CMsgPlayerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerInfo {
    pub fn new() -> CMsgPlayerInfo {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 xuid = 2;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 userid = 3;

    pub fn userid(&self) -> i32 {
        self.userid.unwrap_or(0)
    }

    pub fn clear_userid(&mut self) {
        self.userid = ::std::option::Option::None;
    }

    pub fn has_userid(&self) -> bool {
        self.userid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userid(&mut self, v: i32) {
        self.userid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool fakeplayer = 5;

    pub fn fakeplayer(&self) -> bool {
        self.fakeplayer.unwrap_or(false)
    }

    pub fn clear_fakeplayer(&mut self) {
        self.fakeplayer = ::std::option::Option::None;
    }

    pub fn has_fakeplayer(&self) -> bool {
        self.fakeplayer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fakeplayer(&mut self, v: bool) {
        self.fakeplayer = ::std::option::Option::Some(v);
    }

    // optional bool ishltv = 6;

    pub fn ishltv(&self) -> bool {
        self.ishltv.unwrap_or(false)
    }

    pub fn clear_ishltv(&mut self) {
        self.ishltv = ::std::option::Option::None;
    }

    pub fn has_ishltv(&self) -> bool {
        self.ishltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ishltv(&mut self, v: bool) {
        self.ishltv = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgPlayerInfo| { &m.name },
            |m: &mut CMsgPlayerInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xuid",
            |m: &CMsgPlayerInfo| { &m.xuid },
            |m: &mut CMsgPlayerInfo| { &mut m.xuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "userid",
            |m: &CMsgPlayerInfo| { &m.userid },
            |m: &mut CMsgPlayerInfo| { &mut m.userid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgPlayerInfo| { &m.steamid },
            |m: &mut CMsgPlayerInfo| { &mut m.steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fakeplayer",
            |m: &CMsgPlayerInfo| { &m.fakeplayer },
            |m: &mut CMsgPlayerInfo| { &mut m.fakeplayer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ishltv",
            |m: &CMsgPlayerInfo| { &m.ishltv },
            |m: &mut CMsgPlayerInfo| { &mut m.ishltv },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlayerInfo>(
            "CMsgPlayerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlayerInfo {
    const NAME: &'static str = "CMsgPlayerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.xuid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.userid = ::std::option::Option::Some(is.read_int32()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                40 => {
                    self.fakeplayer = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.ishltv = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.xuid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.userid {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.fakeplayer {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ishltv {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.xuid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.userid {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.fakeplayer {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.ishltv {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerInfo {
        CMsgPlayerInfo::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.xuid = ::std::option::Option::None;
        self.userid = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.fakeplayer = ::std::option::Option::None;
        self.ishltv = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerInfo {
        static instance: CMsgPlayerInfo = CMsgPlayerInfo {
            name: ::std::option::Option::None,
            xuid: ::std::option::Option::None,
            userid: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            fakeplayer: ::std::option::Option::None,
            ishltv: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlayerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlayerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlayerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlayerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEntityMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMsg {
    // message fields
    // @@protoc_insertion_point(field:CEntityMsg.target_entity)
    pub target_entity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMsg {
    fn default() -> &'a CEntityMsg {
        <CEntityMsg as ::protobuf::Message>::default_instance()
    }
}

impl CEntityMsg {
    pub fn new() -> CEntityMsg {
        ::std::default::Default::default()
    }

    // optional uint32 target_entity = 1;

    pub fn target_entity(&self) -> u32 {
        self.target_entity.unwrap_or(16777215u32)
    }

    pub fn clear_target_entity(&mut self) {
        self.target_entity = ::std::option::Option::None;
    }

    pub fn has_target_entity(&self) -> bool {
        self.target_entity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_entity(&mut self, v: u32) {
        self.target_entity = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_entity",
            |m: &CEntityMsg| { &m.target_entity },
            |m: &mut CEntityMsg| { &mut m.target_entity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CEntityMsg>(
            "CEntityMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CEntityMsg {
    const NAME: &'static str = "CEntityMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_entity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_entity {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_entity {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMsg {
        CEntityMsg::new()
    }

    fn clear(&mut self) {
        self.target_entity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMsg {
        static instance: CEntityMsg = CEntityMsg {
            target_entity: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CEntityMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEntityMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEntityMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEntityMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsg_CVars)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsg_CVars {
    // message fields
    // @@protoc_insertion_point(field:CMsg_CVars.cvars)
    pub cvars: ::std::vec::Vec<cmsg_cvars::CVar>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg_CVars.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg_CVars {
    fn default() -> &'a CMsg_CVars {
        <CMsg_CVars as ::protobuf::Message>::default_instance()
    }
}

impl CMsg_CVars {
    pub fn new() -> CMsg_CVars {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cvars",
            |m: &CMsg_CVars| { &m.cvars },
            |m: &mut CMsg_CVars| { &mut m.cvars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsg_CVars>(
            "CMsg_CVars",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsg_CVars {
    const NAME: &'static str = "CMsg_CVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cvars.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cvars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cvars {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg_CVars {
        CMsg_CVars::new()
    }

    fn clear(&mut self) {
        self.cvars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg_CVars {
        static instance: CMsg_CVars = CMsg_CVars {
            cvars: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsg_CVars {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsg_CVars").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsg_CVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsg_CVars {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsg_CVars`
pub mod cmsg_cvars {
    // @@protoc_insertion_point(message:CMsg_CVars.CVar)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CVar {
        // message fields
        // @@protoc_insertion_point(field:CMsg_CVars.CVar.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsg_CVars.CVar.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg_CVars.CVar.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CVar {
        fn default() -> &'a CVar {
            <CVar as ::protobuf::Message>::default_instance()
        }
    }

    impl CVar {
        pub fn new() -> CVar {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &CVar| { &m.name },
                |m: &mut CVar| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &CVar| { &m.value },
                |m: &mut CVar| { &mut m.value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CVar>(
                "CMsg_CVars.CVar",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CVar {
        const NAME: &'static str = "CVar";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CVar {
            CVar::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CVar {
            static instance: CVar = CVar {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CVar {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsg_CVars.CVar").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CVar {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CVar {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CNETMsg_NOP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_NOP {
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_NOP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_NOP {
    fn default() -> &'a CNETMsg_NOP {
        <CNETMsg_NOP as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_NOP {
    pub fn new() -> CNETMsg_NOP {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_NOP>(
            "CNETMsg_NOP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_NOP {
    const NAME: &'static str = "CNETMsg_NOP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_NOP {
        CNETMsg_NOP::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_NOP {
        static instance: CNETMsg_NOP = CNETMsg_NOP {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_NOP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_NOP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_NOP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_NOP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNETMsg_SplitScreenUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SplitScreenUser {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SplitScreenUser.slot)
    pub slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SplitScreenUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SplitScreenUser {
    fn default() -> &'a CNETMsg_SplitScreenUser {
        <CNETMsg_SplitScreenUser as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SplitScreenUser {
    pub fn new() -> CNETMsg_SplitScreenUser {
        ::std::default::Default::default()
    }

    // optional int32 slot = 1;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CNETMsg_SplitScreenUser| { &m.slot },
            |m: &mut CNETMsg_SplitScreenUser| { &mut m.slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SplitScreenUser>(
            "CNETMsg_SplitScreenUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SplitScreenUser {
    const NAME: &'static str = "CNETMsg_SplitScreenUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.slot {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SplitScreenUser {
        CNETMsg_SplitScreenUser::new()
    }

    fn clear(&mut self) {
        self.slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SplitScreenUser {
        static instance: CNETMsg_SplitScreenUser = CNETMsg_SplitScreenUser {
            slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SplitScreenUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SplitScreenUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SplitScreenUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SplitScreenUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNETMsg_Tick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_Tick {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_Tick.tick)
    pub tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_frametime)
    pub host_frametime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_frametime_std_deviation)
    pub host_frametime_std_deviation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_computationtime)
    pub host_computationtime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_computationtime_std_deviation)
    pub host_computationtime_std_deviation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_framestarttime_std_deviation)
    pub host_framestarttime_std_deviation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_loss)
    pub host_loss: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_unfiltered_frametime)
    pub host_unfiltered_frametime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.hltv_replay_flags)
    pub hltv_replay_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.expected_long_tick)
    pub expected_long_tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.expected_long_tick_reason)
    pub expected_long_tick_reason: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_Tick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_Tick {
    fn default() -> &'a CNETMsg_Tick {
        <CNETMsg_Tick as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_Tick {
    pub fn new() -> CNETMsg_Tick {
        ::std::default::Default::default()
    }

    // optional uint32 tick = 1;

    pub fn tick(&self) -> u32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: u32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional uint32 host_frametime = 2;

    pub fn host_frametime(&self) -> u32 {
        self.host_frametime.unwrap_or(0)
    }

    pub fn clear_host_frametime(&mut self) {
        self.host_frametime = ::std::option::Option::None;
    }

    pub fn has_host_frametime(&self) -> bool {
        self.host_frametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_frametime(&mut self, v: u32) {
        self.host_frametime = ::std::option::Option::Some(v);
    }

    // optional uint32 host_frametime_std_deviation = 3;

    pub fn host_frametime_std_deviation(&self) -> u32 {
        self.host_frametime_std_deviation.unwrap_or(0)
    }

    pub fn clear_host_frametime_std_deviation(&mut self) {
        self.host_frametime_std_deviation = ::std::option::Option::None;
    }

    pub fn has_host_frametime_std_deviation(&self) -> bool {
        self.host_frametime_std_deviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_frametime_std_deviation(&mut self, v: u32) {
        self.host_frametime_std_deviation = ::std::option::Option::Some(v);
    }

    // optional uint32 host_computationtime = 4;

    pub fn host_computationtime(&self) -> u32 {
        self.host_computationtime.unwrap_or(0)
    }

    pub fn clear_host_computationtime(&mut self) {
        self.host_computationtime = ::std::option::Option::None;
    }

    pub fn has_host_computationtime(&self) -> bool {
        self.host_computationtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_computationtime(&mut self, v: u32) {
        self.host_computationtime = ::std::option::Option::Some(v);
    }

    // optional uint32 host_computationtime_std_deviation = 5;

    pub fn host_computationtime_std_deviation(&self) -> u32 {
        self.host_computationtime_std_deviation.unwrap_or(0)
    }

    pub fn clear_host_computationtime_std_deviation(&mut self) {
        self.host_computationtime_std_deviation = ::std::option::Option::None;
    }

    pub fn has_host_computationtime_std_deviation(&self) -> bool {
        self.host_computationtime_std_deviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_computationtime_std_deviation(&mut self, v: u32) {
        self.host_computationtime_std_deviation = ::std::option::Option::Some(v);
    }

    // optional uint32 host_framestarttime_std_deviation = 6;

    pub fn host_framestarttime_std_deviation(&self) -> u32 {
        self.host_framestarttime_std_deviation.unwrap_or(0)
    }

    pub fn clear_host_framestarttime_std_deviation(&mut self) {
        self.host_framestarttime_std_deviation = ::std::option::Option::None;
    }

    pub fn has_host_framestarttime_std_deviation(&self) -> bool {
        self.host_framestarttime_std_deviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_framestarttime_std_deviation(&mut self, v: u32) {
        self.host_framestarttime_std_deviation = ::std::option::Option::Some(v);
    }

    // optional uint32 host_loss = 7;

    pub fn host_loss(&self) -> u32 {
        self.host_loss.unwrap_or(0)
    }

    pub fn clear_host_loss(&mut self) {
        self.host_loss = ::std::option::Option::None;
    }

    pub fn has_host_loss(&self) -> bool {
        self.host_loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_loss(&mut self, v: u32) {
        self.host_loss = ::std::option::Option::Some(v);
    }

    // optional uint32 host_unfiltered_frametime = 8;

    pub fn host_unfiltered_frametime(&self) -> u32 {
        self.host_unfiltered_frametime.unwrap_or(0)
    }

    pub fn clear_host_unfiltered_frametime(&mut self) {
        self.host_unfiltered_frametime = ::std::option::Option::None;
    }

    pub fn has_host_unfiltered_frametime(&self) -> bool {
        self.host_unfiltered_frametime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_unfiltered_frametime(&mut self, v: u32) {
        self.host_unfiltered_frametime = ::std::option::Option::Some(v);
    }

    // optional uint32 hltv_replay_flags = 9;

    pub fn hltv_replay_flags(&self) -> u32 {
        self.hltv_replay_flags.unwrap_or(0)
    }

    pub fn clear_hltv_replay_flags(&mut self) {
        self.hltv_replay_flags = ::std::option::Option::None;
    }

    pub fn has_hltv_replay_flags(&self) -> bool {
        self.hltv_replay_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hltv_replay_flags(&mut self, v: u32) {
        self.hltv_replay_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 expected_long_tick = 10;

    pub fn expected_long_tick(&self) -> u32 {
        self.expected_long_tick.unwrap_or(0)
    }

    pub fn clear_expected_long_tick(&mut self) {
        self.expected_long_tick = ::std::option::Option::None;
    }

    pub fn has_expected_long_tick(&self) -> bool {
        self.expected_long_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_long_tick(&mut self, v: u32) {
        self.expected_long_tick = ::std::option::Option::Some(v);
    }

    // optional string expected_long_tick_reason = 11;

    pub fn expected_long_tick_reason(&self) -> &str {
        match self.expected_long_tick_reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_expected_long_tick_reason(&mut self) {
        self.expected_long_tick_reason = ::std::option::Option::None;
    }

    pub fn has_expected_long_tick_reason(&self) -> bool {
        self.expected_long_tick_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_long_tick_reason(&mut self, v: ::std::string::String) {
        self.expected_long_tick_reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expected_long_tick_reason(&mut self) -> &mut ::std::string::String {
        if self.expected_long_tick_reason.is_none() {
            self.expected_long_tick_reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.expected_long_tick_reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_expected_long_tick_reason(&mut self) -> ::std::string::String {
        self.expected_long_tick_reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CNETMsg_Tick| { &m.tick },
            |m: &mut CNETMsg_Tick| { &mut m.tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_frametime",
            |m: &CNETMsg_Tick| { &m.host_frametime },
            |m: &mut CNETMsg_Tick| { &mut m.host_frametime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_frametime_std_deviation",
            |m: &CNETMsg_Tick| { &m.host_frametime_std_deviation },
            |m: &mut CNETMsg_Tick| { &mut m.host_frametime_std_deviation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_computationtime",
            |m: &CNETMsg_Tick| { &m.host_computationtime },
            |m: &mut CNETMsg_Tick| { &mut m.host_computationtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_computationtime_std_deviation",
            |m: &CNETMsg_Tick| { &m.host_computationtime_std_deviation },
            |m: &mut CNETMsg_Tick| { &mut m.host_computationtime_std_deviation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_framestarttime_std_deviation",
            |m: &CNETMsg_Tick| { &m.host_framestarttime_std_deviation },
            |m: &mut CNETMsg_Tick| { &mut m.host_framestarttime_std_deviation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_loss",
            |m: &CNETMsg_Tick| { &m.host_loss },
            |m: &mut CNETMsg_Tick| { &mut m.host_loss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_unfiltered_frametime",
            |m: &CNETMsg_Tick| { &m.host_unfiltered_frametime },
            |m: &mut CNETMsg_Tick| { &mut m.host_unfiltered_frametime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hltv_replay_flags",
            |m: &CNETMsg_Tick| { &m.hltv_replay_flags },
            |m: &mut CNETMsg_Tick| { &mut m.hltv_replay_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expected_long_tick",
            |m: &CNETMsg_Tick| { &m.expected_long_tick },
            |m: &mut CNETMsg_Tick| { &mut m.expected_long_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expected_long_tick_reason",
            |m: &CNETMsg_Tick| { &m.expected_long_tick_reason },
            |m: &mut CNETMsg_Tick| { &mut m.expected_long_tick_reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_Tick>(
            "CNETMsg_Tick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_Tick {
    const NAME: &'static str = "CNETMsg_Tick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.host_frametime = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.host_frametime_std_deviation = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.host_computationtime = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.host_computationtime_std_deviation = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.host_framestarttime_std_deviation = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.host_loss = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.host_unfiltered_frametime = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.hltv_replay_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.expected_long_tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.expected_long_tick_reason = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.host_frametime {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.host_frametime_std_deviation {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.host_computationtime {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.host_computationtime_std_deviation {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.host_framestarttime_std_deviation {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.host_loss {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.host_unfiltered_frametime {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.hltv_replay_flags {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.expected_long_tick {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.expected_long_tick_reason.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.host_frametime {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.host_frametime_std_deviation {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.host_computationtime {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.host_computationtime_std_deviation {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.host_framestarttime_std_deviation {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.host_loss {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.host_unfiltered_frametime {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.hltv_replay_flags {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.expected_long_tick {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.expected_long_tick_reason.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_Tick {
        CNETMsg_Tick::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.host_frametime = ::std::option::Option::None;
        self.host_frametime_std_deviation = ::std::option::Option::None;
        self.host_computationtime = ::std::option::Option::None;
        self.host_computationtime_std_deviation = ::std::option::Option::None;
        self.host_framestarttime_std_deviation = ::std::option::Option::None;
        self.host_loss = ::std::option::Option::None;
        self.host_unfiltered_frametime = ::std::option::Option::None;
        self.hltv_replay_flags = ::std::option::Option::None;
        self.expected_long_tick = ::std::option::Option::None;
        self.expected_long_tick_reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_Tick {
        static instance: CNETMsg_Tick = CNETMsg_Tick {
            tick: ::std::option::Option::None,
            host_frametime: ::std::option::Option::None,
            host_frametime_std_deviation: ::std::option::Option::None,
            host_computationtime: ::std::option::Option::None,
            host_computationtime_std_deviation: ::std::option::Option::None,
            host_framestarttime_std_deviation: ::std::option::Option::None,
            host_loss: ::std::option::Option::None,
            host_unfiltered_frametime: ::std::option::Option::None,
            hltv_replay_flags: ::std::option::Option::None,
            expected_long_tick: ::std::option::Option::None,
            expected_long_tick_reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_Tick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_Tick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_Tick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_Tick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNETMsg_StringCmd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_StringCmd {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_StringCmd.command)
    pub command: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_StringCmd.prediction_sync)
    pub prediction_sync: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_StringCmd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_StringCmd {
    fn default() -> &'a CNETMsg_StringCmd {
        <CNETMsg_StringCmd as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_StringCmd {
    pub fn new() -> CNETMsg_StringCmd {
        ::std::default::Default::default()
    }

    // optional string command = 1;

    pub fn command(&self) -> &str {
        match self.command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::std::string::String) {
        self.command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::std::string::String {
        if self.command.is_none() {
            self.command = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> ::std::string::String {
        self.command.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 prediction_sync = 2;

    pub fn prediction_sync(&self) -> u32 {
        self.prediction_sync.unwrap_or(0)
    }

    pub fn clear_prediction_sync(&mut self) {
        self.prediction_sync = ::std::option::Option::None;
    }

    pub fn has_prediction_sync(&self) -> bool {
        self.prediction_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_sync(&mut self, v: u32) {
        self.prediction_sync = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &CNETMsg_StringCmd| { &m.command },
            |m: &mut CNETMsg_StringCmd| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prediction_sync",
            |m: &CNETMsg_StringCmd| { &m.prediction_sync },
            |m: &mut CNETMsg_StringCmd| { &mut m.prediction_sync },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_StringCmd>(
            "CNETMsg_StringCmd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_StringCmd {
    const NAME: &'static str = "CNETMsg_StringCmd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.prediction_sync = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.prediction_sync {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.prediction_sync {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_StringCmd {
        CNETMsg_StringCmd::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.prediction_sync = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_StringCmd {
        static instance: CNETMsg_StringCmd = CNETMsg_StringCmd {
            command: ::std::option::Option::None,
            prediction_sync: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_StringCmd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_StringCmd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_StringCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_StringCmd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNETMsg_SetConVar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SetConVar {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SetConVar.convars)
    pub convars: ::protobuf::MessageField<CMsg_CVars>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SetConVar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SetConVar {
    fn default() -> &'a CNETMsg_SetConVar {
        <CNETMsg_SetConVar as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SetConVar {
    pub fn new() -> CNETMsg_SetConVar {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsg_CVars>(
            "convars",
            |m: &CNETMsg_SetConVar| { &m.convars },
            |m: &mut CNETMsg_SetConVar| { &mut m.convars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SetConVar>(
            "CNETMsg_SetConVar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SetConVar {
    const NAME: &'static str = "CNETMsg_SetConVar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.convars)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.convars.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.convars.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SetConVar {
        CNETMsg_SetConVar::new()
    }

    fn clear(&mut self) {
        self.convars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SetConVar {
        static instance: CNETMsg_SetConVar = CNETMsg_SetConVar {
            convars: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SetConVar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SetConVar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SetConVar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SetConVar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNETMsg_SignonState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SignonState {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SignonState.signon_state)
    pub signon_state: ::std::option::Option<::protobuf::EnumOrUnknown<SignonState_t>>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.spawn_count)
    pub spawn_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.num_server_players)
    pub num_server_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.players_networkids)
    pub players_networkids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.addons)
    pub addons: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SignonState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SignonState {
    fn default() -> &'a CNETMsg_SignonState {
        <CNETMsg_SignonState as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SignonState {
    pub fn new() -> CNETMsg_SignonState {
        ::std::default::Default::default()
    }

    // optional .SignonState_t signon_state = 1;

    pub fn signon_state(&self) -> SignonState_t {
        match self.signon_state {
            Some(e) => e.enum_value_or(SignonState_t::SIGNONSTATE_NONE),
            None => SignonState_t::SIGNONSTATE_NONE,
        }
    }

    pub fn clear_signon_state(&mut self) {
        self.signon_state = ::std::option::Option::None;
    }

    pub fn has_signon_state(&self) -> bool {
        self.signon_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signon_state(&mut self, v: SignonState_t) {
        self.signon_state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 spawn_count = 2;

    pub fn spawn_count(&self) -> u32 {
        self.spawn_count.unwrap_or(0)
    }

    pub fn clear_spawn_count(&mut self) {
        self.spawn_count = ::std::option::Option::None;
    }

    pub fn has_spawn_count(&self) -> bool {
        self.spawn_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawn_count(&mut self, v: u32) {
        self.spawn_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_server_players = 3;

    pub fn num_server_players(&self) -> u32 {
        self.num_server_players.unwrap_or(0)
    }

    pub fn clear_num_server_players(&mut self) {
        self.num_server_players = ::std::option::Option::None;
    }

    pub fn has_num_server_players(&self) -> bool {
        self.num_server_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_server_players(&mut self, v: u32) {
        self.num_server_players = ::std::option::Option::Some(v);
    }

    // optional string map_name = 5;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string addons = 6;

    pub fn addons(&self) -> &str {
        match self.addons.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_addons(&mut self) {
        self.addons = ::std::option::Option::None;
    }

    pub fn has_addons(&self) -> bool {
        self.addons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addons(&mut self, v: ::std::string::String) {
        self.addons = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addons(&mut self) -> &mut ::std::string::String {
        if self.addons.is_none() {
            self.addons = ::std::option::Option::Some(::std::string::String::new());
        }
        self.addons.as_mut().unwrap()
    }

    // Take field
    pub fn take_addons(&mut self) -> ::std::string::String {
        self.addons.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signon_state",
            |m: &CNETMsg_SignonState| { &m.signon_state },
            |m: &mut CNETMsg_SignonState| { &mut m.signon_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawn_count",
            |m: &CNETMsg_SignonState| { &m.spawn_count },
            |m: &mut CNETMsg_SignonState| { &mut m.spawn_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_server_players",
            |m: &CNETMsg_SignonState| { &m.num_server_players },
            |m: &mut CNETMsg_SignonState| { &mut m.num_server_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players_networkids",
            |m: &CNETMsg_SignonState| { &m.players_networkids },
            |m: &mut CNETMsg_SignonState| { &mut m.players_networkids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &CNETMsg_SignonState| { &m.map_name },
            |m: &mut CNETMsg_SignonState| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "addons",
            |m: &CNETMsg_SignonState| { &m.addons },
            |m: &mut CNETMsg_SignonState| { &mut m.addons },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SignonState>(
            "CNETMsg_SignonState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SignonState {
    const NAME: &'static str = "CNETMsg_SignonState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.signon_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.spawn_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_server_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.players_networkids.push(is.read_string()?);
                },
                42 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.addons = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signon_state {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.spawn_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_server_players {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.players_networkids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.addons.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signon_state {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.spawn_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_server_players {
            os.write_uint32(3, v)?;
        }
        for v in &self.players_networkids {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.addons.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SignonState {
        CNETMsg_SignonState::new()
    }

    fn clear(&mut self) {
        self.signon_state = ::std::option::Option::None;
        self.spawn_count = ::std::option::Option::None;
        self.num_server_players = ::std::option::Option::None;
        self.players_networkids.clear();
        self.map_name = ::std::option::Option::None;
        self.addons = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SignonState {
        static instance: CNETMsg_SignonState = CNETMsg_SignonState {
            signon_state: ::std::option::Option::None,
            spawn_count: ::std::option::Option::None,
            num_server_players: ::std::option::Option::None,
            players_networkids: ::std::vec::Vec::new(),
            map_name: ::std::option::Option::None,
            addons: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SignonState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SignonState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SignonState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SignonState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_GameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_GameEvent {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GameEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameEvent.eventid)
    pub eventid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameEvent.keys)
    pub keys: ::std::vec::Vec<csvcmsg_game_event::Key_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GameEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GameEvent {
    fn default() -> &'a CSVCMsg_GameEvent {
        <CSVCMsg_GameEvent as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GameEvent {
    pub fn new() -> CSVCMsg_GameEvent {
        ::std::default::Default::default()
    }

    // optional string event_name = 1;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 eventid = 2;

    pub fn eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_name",
            |m: &CSVCMsg_GameEvent| { &m.event_name },
            |m: &mut CSVCMsg_GameEvent| { &mut m.event_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CSVCMsg_GameEvent| { &m.eventid },
            |m: &mut CSVCMsg_GameEvent| { &mut m.eventid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &CSVCMsg_GameEvent| { &m.keys },
            |m: &mut CSVCMsg_GameEvent| { &mut m.keys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_GameEvent>(
            "CSVCMsg_GameEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_GameEvent {
    const NAME: &'static str = "CSVCMsg_GameEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eventid = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eventid {
            os.write_int32(2, v)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GameEvent {
        CSVCMsg_GameEvent::new()
    }

    fn clear(&mut self) {
        self.event_name = ::std::option::Option::None;
        self.eventid = ::std::option::Option::None;
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GameEvent {
        static instance: CSVCMsg_GameEvent = CSVCMsg_GameEvent {
            event_name: ::std::option::Option::None,
            eventid: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_GameEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_GameEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_GameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_GameEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_GameEvent`
pub mod csvcmsg_game_event {
    // @@protoc_insertion_point(message:CSVCMsg_GameEvent.key_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_string)
        pub val_string: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_float)
        pub val_float: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_long)
        pub val_long: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_short)
        pub val_short: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_byte)
        pub val_byte: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_bool)
        pub val_bool: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_uint64)
        pub val_uint64: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEvent.key_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string val_string = 2;

        pub fn val_string(&self) -> &str {
            match self.val_string.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_val_string(&mut self) {
            self.val_string = ::std::option::Option::None;
        }

        pub fn has_val_string(&self) -> bool {
            self.val_string.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_string(&mut self, v: ::std::string::String) {
            self.val_string = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_val_string(&mut self) -> &mut ::std::string::String {
            if self.val_string.is_none() {
                self.val_string = ::std::option::Option::Some(::std::string::String::new());
            }
            self.val_string.as_mut().unwrap()
        }

        // Take field
        pub fn take_val_string(&mut self) -> ::std::string::String {
            self.val_string.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float val_float = 3;

        pub fn val_float(&self) -> f32 {
            self.val_float.unwrap_or(0.)
        }

        pub fn clear_val_float(&mut self) {
            self.val_float = ::std::option::Option::None;
        }

        pub fn has_val_float(&self) -> bool {
            self.val_float.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_float(&mut self, v: f32) {
            self.val_float = ::std::option::Option::Some(v);
        }

        // optional int32 val_long = 4;

        pub fn val_long(&self) -> i32 {
            self.val_long.unwrap_or(0)
        }

        pub fn clear_val_long(&mut self) {
            self.val_long = ::std::option::Option::None;
        }

        pub fn has_val_long(&self) -> bool {
            self.val_long.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_long(&mut self, v: i32) {
            self.val_long = ::std::option::Option::Some(v);
        }

        // optional int32 val_short = 5;

        pub fn val_short(&self) -> i32 {
            self.val_short.unwrap_or(0)
        }

        pub fn clear_val_short(&mut self) {
            self.val_short = ::std::option::Option::None;
        }

        pub fn has_val_short(&self) -> bool {
            self.val_short.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_short(&mut self, v: i32) {
            self.val_short = ::std::option::Option::Some(v);
        }

        // optional int32 val_byte = 6;

        pub fn val_byte(&self) -> i32 {
            self.val_byte.unwrap_or(0)
        }

        pub fn clear_val_byte(&mut self) {
            self.val_byte = ::std::option::Option::None;
        }

        pub fn has_val_byte(&self) -> bool {
            self.val_byte.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_byte(&mut self, v: i32) {
            self.val_byte = ::std::option::Option::Some(v);
        }

        // optional bool val_bool = 7;

        pub fn val_bool(&self) -> bool {
            self.val_bool.unwrap_or(false)
        }

        pub fn clear_val_bool(&mut self) {
            self.val_bool = ::std::option::Option::None;
        }

        pub fn has_val_bool(&self) -> bool {
            self.val_bool.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_bool(&mut self, v: bool) {
            self.val_bool = ::std::option::Option::Some(v);
        }

        // optional uint64 val_uint64 = 8;

        pub fn val_uint64(&self) -> u64 {
            self.val_uint64.unwrap_or(0)
        }

        pub fn clear_val_uint64(&mut self) {
            self.val_uint64 = ::std::option::Option::None;
        }

        pub fn has_val_uint64(&self) -> bool {
            self.val_uint64.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_uint64(&mut self, v: u64) {
            self.val_uint64 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Key_t| { &m.type_ },
                |m: &mut Key_t| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_string",
                |m: &Key_t| { &m.val_string },
                |m: &mut Key_t| { &mut m.val_string },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_float",
                |m: &Key_t| { &m.val_float },
                |m: &mut Key_t| { &mut m.val_float },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_long",
                |m: &Key_t| { &m.val_long },
                |m: &mut Key_t| { &mut m.val_long },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_short",
                |m: &Key_t| { &m.val_short },
                |m: &mut Key_t| { &mut m.val_short },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_byte",
                |m: &Key_t| { &m.val_byte },
                |m: &mut Key_t| { &mut m.val_byte },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_bool",
                |m: &Key_t| { &m.val_bool },
                |m: &mut Key_t| { &mut m.val_bool },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_uint64",
                |m: &Key_t| { &m.val_uint64 },
                |m: &mut Key_t| { &mut m.val_uint64 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key_t>(
                "CSVCMsg_GameEvent.key_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.val_string = ::std::option::Option::Some(is.read_string()?);
                    },
                    29 => {
                        self.val_float = ::std::option::Option::Some(is.read_float()?);
                    },
                    32 => {
                        self.val_long = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.val_short = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.val_byte = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.val_bool = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.val_uint64 = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.val_string.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.val_float {
                my_size += 1 + 4;
            }
            if let Some(v) = self.val_long {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.val_short {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.val_byte {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.val_bool {
                my_size += 1 + 1;
            }
            if let Some(v) = self.val_uint64 {
                my_size += ::protobuf::rt::uint64_size(8, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.val_string.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.val_float {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.val_long {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.val_short {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.val_byte {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.val_bool {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.val_uint64 {
                os.write_uint64(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.val_string = ::std::option::Option::None;
            self.val_float = ::std::option::Option::None;
            self.val_long = ::std::option::Option::None;
            self.val_short = ::std::option::Option::None;
            self.val_byte = ::std::option::Option::None;
            self.val_bool = ::std::option::Option::None;
            self.val_uint64 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                val_string: ::std::option::Option::None,
                val_float: ::std::option::Option::None,
                val_long: ::std::option::Option::None,
                val_short: ::std::option::Option::None,
                val_byte: ::std::option::Option::None,
                val_bool: ::std::option::Option::None,
                val_uint64: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Key_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_GameEvent.key_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Key_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Key_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSVCMsgList_GameEvents)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsgList_GameEvents {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsgList_GameEvents.events)
    pub events: ::std::vec::Vec<csvcmsg_list_game_events::Event_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsgList_GameEvents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsgList_GameEvents {
    fn default() -> &'a CSVCMsgList_GameEvents {
        <CSVCMsgList_GameEvents as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsgList_GameEvents {
    pub fn new() -> CSVCMsgList_GameEvents {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &CSVCMsgList_GameEvents| { &m.events },
            |m: &mut CSVCMsgList_GameEvents| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsgList_GameEvents>(
            "CSVCMsgList_GameEvents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsgList_GameEvents {
    const NAME: &'static str = "CSVCMsgList_GameEvents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsgList_GameEvents {
        CSVCMsgList_GameEvents::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsgList_GameEvents {
        static instance: CSVCMsgList_GameEvents = CSVCMsgList_GameEvents {
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsgList_GameEvents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsgList_GameEvents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsgList_GameEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsgList_GameEvents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsgList_GameEvents`
pub mod csvcmsg_list_game_events {
    // @@protoc_insertion_point(message:CSVCMsgList_GameEvents.event_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Event_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsgList_GameEvents.event_t.tick)
        pub tick: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsgList_GameEvents.event_t.event)
        pub event: ::protobuf::MessageField<super::CSVCMsg_GameEvent>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsgList_GameEvents.event_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Event_t {
        fn default() -> &'a Event_t {
            <Event_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Event_t {
        pub fn new() -> Event_t {
            ::std::default::Default::default()
        }

        // optional int32 tick = 1;

        pub fn tick(&self) -> i32 {
            self.tick.unwrap_or(0)
        }

        pub fn clear_tick(&mut self) {
            self.tick = ::std::option::Option::None;
        }

        pub fn has_tick(&self) -> bool {
            self.tick.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tick(&mut self, v: i32) {
            self.tick = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tick",
                |m: &Event_t| { &m.tick },
                |m: &mut Event_t| { &mut m.tick },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CSVCMsg_GameEvent>(
                "event",
                |m: &Event_t| { &m.event },
                |m: &mut Event_t| { &mut m.event },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Event_t>(
                "CSVCMsgList_GameEvents.event_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Event_t {
        const NAME: &'static str = "event_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tick = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.event)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tick {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.event.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tick {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.event.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Event_t {
            Event_t::new()
        }

        fn clear(&mut self) {
            self.tick = ::std::option::Option::None;
            self.event.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Event_t {
            static instance: Event_t = Event_t {
                tick: ::std::option::Option::None,
                event: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Event_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsgList_GameEvents.event_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Event_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Event_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CNETMsg_SpawnGroup_Load)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SpawnGroup_Load {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.worldname)
    pub worldname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.entitylumpname)
    pub entitylumpname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.entityfiltername)
    pub entityfiltername: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.spawngrouphandle)
    pub spawngrouphandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.spawngroupownerhandle)
    pub spawngroupownerhandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.world_offset_pos)
    pub world_offset_pos: ::protobuf::MessageField<CMsgVector>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.world_offset_angle)
    pub world_offset_angle: ::protobuf::MessageField<CMsgQAngle>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.spawngroupmanifest)
    pub spawngroupmanifest: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.tickcount)
    pub tickcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.manifestincomplete)
    pub manifestincomplete: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.localnamefixup)
    pub localnamefixup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.parentnamefixup)
    pub parentnamefixup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.manifestloadpriority)
    pub manifestloadpriority: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.worldgroupid)
    pub worldgroupid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.creationsequence)
    pub creationsequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.savegamefilename)
    pub savegamefilename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.spawngroupparenthandle)
    pub spawngroupparenthandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.leveltransition)
    pub leveltransition: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Load.worldgroupname)
    pub worldgroupname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SpawnGroup_Load.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SpawnGroup_Load {
    fn default() -> &'a CNETMsg_SpawnGroup_Load {
        <CNETMsg_SpawnGroup_Load as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SpawnGroup_Load {
    pub fn new() -> CNETMsg_SpawnGroup_Load {
        ::std::default::Default::default()
    }

    // optional string worldname = 1;

    pub fn worldname(&self) -> &str {
        match self.worldname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_worldname(&mut self) {
        self.worldname = ::std::option::Option::None;
    }

    pub fn has_worldname(&self) -> bool {
        self.worldname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worldname(&mut self, v: ::std::string::String) {
        self.worldname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worldname(&mut self) -> &mut ::std::string::String {
        if self.worldname.is_none() {
            self.worldname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.worldname.as_mut().unwrap()
    }

    // Take field
    pub fn take_worldname(&mut self) -> ::std::string::String {
        self.worldname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string entitylumpname = 2;

    pub fn entitylumpname(&self) -> &str {
        match self.entitylumpname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_entitylumpname(&mut self) {
        self.entitylumpname = ::std::option::Option::None;
    }

    pub fn has_entitylumpname(&self) -> bool {
        self.entitylumpname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entitylumpname(&mut self, v: ::std::string::String) {
        self.entitylumpname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entitylumpname(&mut self) -> &mut ::std::string::String {
        if self.entitylumpname.is_none() {
            self.entitylumpname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.entitylumpname.as_mut().unwrap()
    }

    // Take field
    pub fn take_entitylumpname(&mut self) -> ::std::string::String {
        self.entitylumpname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string entityfiltername = 3;

    pub fn entityfiltername(&self) -> &str {
        match self.entityfiltername.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_entityfiltername(&mut self) {
        self.entityfiltername = ::std::option::Option::None;
    }

    pub fn has_entityfiltername(&self) -> bool {
        self.entityfiltername.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entityfiltername(&mut self, v: ::std::string::String) {
        self.entityfiltername = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entityfiltername(&mut self) -> &mut ::std::string::String {
        if self.entityfiltername.is_none() {
            self.entityfiltername = ::std::option::Option::Some(::std::string::String::new());
        }
        self.entityfiltername.as_mut().unwrap()
    }

    // Take field
    pub fn take_entityfiltername(&mut self) -> ::std::string::String {
        self.entityfiltername.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 spawngrouphandle = 4;

    pub fn spawngrouphandle(&self) -> u32 {
        self.spawngrouphandle.unwrap_or(0)
    }

    pub fn clear_spawngrouphandle(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
    }

    pub fn has_spawngrouphandle(&self) -> bool {
        self.spawngrouphandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngrouphandle(&mut self, v: u32) {
        self.spawngrouphandle = ::std::option::Option::Some(v);
    }

    // optional uint32 spawngroupownerhandle = 5;

    pub fn spawngroupownerhandle(&self) -> u32 {
        self.spawngroupownerhandle.unwrap_or(0)
    }

    pub fn clear_spawngroupownerhandle(&mut self) {
        self.spawngroupownerhandle = ::std::option::Option::None;
    }

    pub fn has_spawngroupownerhandle(&self) -> bool {
        self.spawngroupownerhandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngroupownerhandle(&mut self, v: u32) {
        self.spawngroupownerhandle = ::std::option::Option::Some(v);
    }

    // optional bytes spawngroupmanifest = 8;

    pub fn spawngroupmanifest(&self) -> &[u8] {
        match self.spawngroupmanifest.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_spawngroupmanifest(&mut self) {
        self.spawngroupmanifest = ::std::option::Option::None;
    }

    pub fn has_spawngroupmanifest(&self) -> bool {
        self.spawngroupmanifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngroupmanifest(&mut self, v: ::bytes::Bytes) {
        self.spawngroupmanifest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spawngroupmanifest(&mut self) -> &mut ::bytes::Bytes {
        if self.spawngroupmanifest.is_none() {
            self.spawngroupmanifest = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.spawngroupmanifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_spawngroupmanifest(&mut self) -> ::bytes::Bytes {
        self.spawngroupmanifest.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 flags = 9;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional int32 tickcount = 10;

    pub fn tickcount(&self) -> i32 {
        self.tickcount.unwrap_or(0)
    }

    pub fn clear_tickcount(&mut self) {
        self.tickcount = ::std::option::Option::None;
    }

    pub fn has_tickcount(&self) -> bool {
        self.tickcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tickcount(&mut self, v: i32) {
        self.tickcount = ::std::option::Option::Some(v);
    }

    // optional bool manifestincomplete = 11;

    pub fn manifestincomplete(&self) -> bool {
        self.manifestincomplete.unwrap_or(false)
    }

    pub fn clear_manifestincomplete(&mut self) {
        self.manifestincomplete = ::std::option::Option::None;
    }

    pub fn has_manifestincomplete(&self) -> bool {
        self.manifestincomplete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifestincomplete(&mut self, v: bool) {
        self.manifestincomplete = ::std::option::Option::Some(v);
    }

    // optional string localnamefixup = 12;

    pub fn localnamefixup(&self) -> &str {
        match self.localnamefixup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_localnamefixup(&mut self) {
        self.localnamefixup = ::std::option::Option::None;
    }

    pub fn has_localnamefixup(&self) -> bool {
        self.localnamefixup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localnamefixup(&mut self, v: ::std::string::String) {
        self.localnamefixup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localnamefixup(&mut self) -> &mut ::std::string::String {
        if self.localnamefixup.is_none() {
            self.localnamefixup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.localnamefixup.as_mut().unwrap()
    }

    // Take field
    pub fn take_localnamefixup(&mut self) -> ::std::string::String {
        self.localnamefixup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string parentnamefixup = 13;

    pub fn parentnamefixup(&self) -> &str {
        match self.parentnamefixup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parentnamefixup(&mut self) {
        self.parentnamefixup = ::std::option::Option::None;
    }

    pub fn has_parentnamefixup(&self) -> bool {
        self.parentnamefixup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parentnamefixup(&mut self, v: ::std::string::String) {
        self.parentnamefixup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentnamefixup(&mut self) -> &mut ::std::string::String {
        if self.parentnamefixup.is_none() {
            self.parentnamefixup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parentnamefixup.as_mut().unwrap()
    }

    // Take field
    pub fn take_parentnamefixup(&mut self) -> ::std::string::String {
        self.parentnamefixup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 manifestloadpriority = 14;

    pub fn manifestloadpriority(&self) -> i32 {
        self.manifestloadpriority.unwrap_or(0)
    }

    pub fn clear_manifestloadpriority(&mut self) {
        self.manifestloadpriority = ::std::option::Option::None;
    }

    pub fn has_manifestloadpriority(&self) -> bool {
        self.manifestloadpriority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifestloadpriority(&mut self, v: i32) {
        self.manifestloadpriority = ::std::option::Option::Some(v);
    }

    // optional uint32 worldgroupid = 15;

    pub fn worldgroupid(&self) -> u32 {
        self.worldgroupid.unwrap_or(0)
    }

    pub fn clear_worldgroupid(&mut self) {
        self.worldgroupid = ::std::option::Option::None;
    }

    pub fn has_worldgroupid(&self) -> bool {
        self.worldgroupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worldgroupid(&mut self, v: u32) {
        self.worldgroupid = ::std::option::Option::Some(v);
    }

    // optional uint32 creationsequence = 16;

    pub fn creationsequence(&self) -> u32 {
        self.creationsequence.unwrap_or(0)
    }

    pub fn clear_creationsequence(&mut self) {
        self.creationsequence = ::std::option::Option::None;
    }

    pub fn has_creationsequence(&self) -> bool {
        self.creationsequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationsequence(&mut self, v: u32) {
        self.creationsequence = ::std::option::Option::Some(v);
    }

    // optional string savegamefilename = 17;

    pub fn savegamefilename(&self) -> &str {
        match self.savegamefilename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_savegamefilename(&mut self) {
        self.savegamefilename = ::std::option::Option::None;
    }

    pub fn has_savegamefilename(&self) -> bool {
        self.savegamefilename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_savegamefilename(&mut self, v: ::std::string::String) {
        self.savegamefilename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_savegamefilename(&mut self) -> &mut ::std::string::String {
        if self.savegamefilename.is_none() {
            self.savegamefilename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.savegamefilename.as_mut().unwrap()
    }

    // Take field
    pub fn take_savegamefilename(&mut self) -> ::std::string::String {
        self.savegamefilename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 spawngroupparenthandle = 18;

    pub fn spawngroupparenthandle(&self) -> u32 {
        self.spawngroupparenthandle.unwrap_or(0)
    }

    pub fn clear_spawngroupparenthandle(&mut self) {
        self.spawngroupparenthandle = ::std::option::Option::None;
    }

    pub fn has_spawngroupparenthandle(&self) -> bool {
        self.spawngroupparenthandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngroupparenthandle(&mut self, v: u32) {
        self.spawngroupparenthandle = ::std::option::Option::Some(v);
    }

    // optional bool leveltransition = 19;

    pub fn leveltransition(&self) -> bool {
        self.leveltransition.unwrap_or(false)
    }

    pub fn clear_leveltransition(&mut self) {
        self.leveltransition = ::std::option::Option::None;
    }

    pub fn has_leveltransition(&self) -> bool {
        self.leveltransition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leveltransition(&mut self, v: bool) {
        self.leveltransition = ::std::option::Option::Some(v);
    }

    // optional string worldgroupname = 20;

    pub fn worldgroupname(&self) -> &str {
        match self.worldgroupname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_worldgroupname(&mut self) {
        self.worldgroupname = ::std::option::Option::None;
    }

    pub fn has_worldgroupname(&self) -> bool {
        self.worldgroupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worldgroupname(&mut self, v: ::std::string::String) {
        self.worldgroupname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worldgroupname(&mut self) -> &mut ::std::string::String {
        if self.worldgroupname.is_none() {
            self.worldgroupname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.worldgroupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_worldgroupname(&mut self) -> ::std::string::String {
        self.worldgroupname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "worldname",
            |m: &CNETMsg_SpawnGroup_Load| { &m.worldname },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.worldname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entitylumpname",
            |m: &CNETMsg_SpawnGroup_Load| { &m.entitylumpname },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.entitylumpname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entityfiltername",
            |m: &CNETMsg_SpawnGroup_Load| { &m.entityfiltername },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.entityfiltername },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawngrouphandle",
            |m: &CNETMsg_SpawnGroup_Load| { &m.spawngrouphandle },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.spawngrouphandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawngroupownerhandle",
            |m: &CNETMsg_SpawnGroup_Load| { &m.spawngroupownerhandle },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.spawngroupownerhandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVector>(
            "world_offset_pos",
            |m: &CNETMsg_SpawnGroup_Load| { &m.world_offset_pos },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.world_offset_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgQAngle>(
            "world_offset_angle",
            |m: &CNETMsg_SpawnGroup_Load| { &m.world_offset_angle },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.world_offset_angle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawngroupmanifest",
            |m: &CNETMsg_SpawnGroup_Load| { &m.spawngroupmanifest },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.spawngroupmanifest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CNETMsg_SpawnGroup_Load| { &m.flags },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tickcount",
            |m: &CNETMsg_SpawnGroup_Load| { &m.tickcount },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.tickcount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manifestincomplete",
            |m: &CNETMsg_SpawnGroup_Load| { &m.manifestincomplete },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.manifestincomplete },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "localnamefixup",
            |m: &CNETMsg_SpawnGroup_Load| { &m.localnamefixup },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.localnamefixup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parentnamefixup",
            |m: &CNETMsg_SpawnGroup_Load| { &m.parentnamefixup },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.parentnamefixup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manifestloadpriority",
            |m: &CNETMsg_SpawnGroup_Load| { &m.manifestloadpriority },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.manifestloadpriority },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "worldgroupid",
            |m: &CNETMsg_SpawnGroup_Load| { &m.worldgroupid },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.worldgroupid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creationsequence",
            |m: &CNETMsg_SpawnGroup_Load| { &m.creationsequence },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.creationsequence },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "savegamefilename",
            |m: &CNETMsg_SpawnGroup_Load| { &m.savegamefilename },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.savegamefilename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawngroupparenthandle",
            |m: &CNETMsg_SpawnGroup_Load| { &m.spawngroupparenthandle },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.spawngroupparenthandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leveltransition",
            |m: &CNETMsg_SpawnGroup_Load| { &m.leveltransition },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.leveltransition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "worldgroupname",
            |m: &CNETMsg_SpawnGroup_Load| { &m.worldgroupname },
            |m: &mut CNETMsg_SpawnGroup_Load| { &mut m.worldgroupname },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SpawnGroup_Load>(
            "CNETMsg_SpawnGroup_Load",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SpawnGroup_Load {
    const NAME: &'static str = "CNETMsg_SpawnGroup_Load";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.worldname = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.entitylumpname = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.entityfiltername = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.spawngrouphandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.spawngroupownerhandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.world_offset_pos)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.world_offset_angle)?;
                },
                66 => {
                    self.spawngroupmanifest = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                72 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.tickcount = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.manifestincomplete = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    self.localnamefixup = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.parentnamefixup = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.manifestloadpriority = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.worldgroupid = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.creationsequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                138 => {
                    self.savegamefilename = ::std::option::Option::Some(is.read_string()?);
                },
                144 => {
                    self.spawngroupparenthandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.leveltransition = ::std::option::Option::Some(is.read_bool()?);
                },
                162 => {
                    self.worldgroupname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.worldname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.entitylumpname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.entityfiltername.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.spawngrouphandle {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.spawngroupownerhandle {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.world_offset_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.world_offset_angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.spawngroupmanifest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.tickcount {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.manifestincomplete {
            my_size += 1 + 1;
        }
        if let Some(v) = self.localnamefixup.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.parentnamefixup.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.manifestloadpriority {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.worldgroupid {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.creationsequence {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.savegamefilename.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.spawngroupparenthandle {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.leveltransition {
            my_size += 2 + 1;
        }
        if let Some(v) = self.worldgroupname.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.worldname.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.entitylumpname.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.entityfiltername.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.spawngrouphandle {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.spawngroupownerhandle {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.world_offset_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.world_offset_angle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.spawngroupmanifest.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.tickcount {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.manifestincomplete {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.localnamefixup.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.parentnamefixup.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.manifestloadpriority {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.worldgroupid {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.creationsequence {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.savegamefilename.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.spawngroupparenthandle {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.leveltransition {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.worldgroupname.as_ref() {
            os.write_string(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SpawnGroup_Load {
        CNETMsg_SpawnGroup_Load::new()
    }

    fn clear(&mut self) {
        self.worldname = ::std::option::Option::None;
        self.entitylumpname = ::std::option::Option::None;
        self.entityfiltername = ::std::option::Option::None;
        self.spawngrouphandle = ::std::option::Option::None;
        self.spawngroupownerhandle = ::std::option::Option::None;
        self.world_offset_pos.clear();
        self.world_offset_angle.clear();
        self.spawngroupmanifest = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.tickcount = ::std::option::Option::None;
        self.manifestincomplete = ::std::option::Option::None;
        self.localnamefixup = ::std::option::Option::None;
        self.parentnamefixup = ::std::option::Option::None;
        self.manifestloadpriority = ::std::option::Option::None;
        self.worldgroupid = ::std::option::Option::None;
        self.creationsequence = ::std::option::Option::None;
        self.savegamefilename = ::std::option::Option::None;
        self.spawngroupparenthandle = ::std::option::Option::None;
        self.leveltransition = ::std::option::Option::None;
        self.worldgroupname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SpawnGroup_Load {
        static instance: CNETMsg_SpawnGroup_Load = CNETMsg_SpawnGroup_Load {
            worldname: ::std::option::Option::None,
            entitylumpname: ::std::option::Option::None,
            entityfiltername: ::std::option::Option::None,
            spawngrouphandle: ::std::option::Option::None,
            spawngroupownerhandle: ::std::option::Option::None,
            world_offset_pos: ::protobuf::MessageField::none(),
            world_offset_angle: ::protobuf::MessageField::none(),
            spawngroupmanifest: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            tickcount: ::std::option::Option::None,
            manifestincomplete: ::std::option::Option::None,
            localnamefixup: ::std::option::Option::None,
            parentnamefixup: ::std::option::Option::None,
            manifestloadpriority: ::std::option::Option::None,
            worldgroupid: ::std::option::Option::None,
            creationsequence: ::std::option::Option::None,
            savegamefilename: ::std::option::Option::None,
            spawngroupparenthandle: ::std::option::Option::None,
            leveltransition: ::std::option::Option::None,
            worldgroupname: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SpawnGroup_Load {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SpawnGroup_Load").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SpawnGroup_Load {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SpawnGroup_Load {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNETMsg_SpawnGroup_ManifestUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SpawnGroup_ManifestUpdate {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_ManifestUpdate.spawngrouphandle)
    pub spawngrouphandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_ManifestUpdate.spawngroupmanifest)
    pub spawngroupmanifest: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_ManifestUpdate.manifestincomplete)
    pub manifestincomplete: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SpawnGroup_ManifestUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SpawnGroup_ManifestUpdate {
    fn default() -> &'a CNETMsg_SpawnGroup_ManifestUpdate {
        <CNETMsg_SpawnGroup_ManifestUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SpawnGroup_ManifestUpdate {
    pub fn new() -> CNETMsg_SpawnGroup_ManifestUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 spawngrouphandle = 1;

    pub fn spawngrouphandle(&self) -> u32 {
        self.spawngrouphandle.unwrap_or(0)
    }

    pub fn clear_spawngrouphandle(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
    }

    pub fn has_spawngrouphandle(&self) -> bool {
        self.spawngrouphandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngrouphandle(&mut self, v: u32) {
        self.spawngrouphandle = ::std::option::Option::Some(v);
    }

    // optional bytes spawngroupmanifest = 2;

    pub fn spawngroupmanifest(&self) -> &[u8] {
        match self.spawngroupmanifest.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_spawngroupmanifest(&mut self) {
        self.spawngroupmanifest = ::std::option::Option::None;
    }

    pub fn has_spawngroupmanifest(&self) -> bool {
        self.spawngroupmanifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngroupmanifest(&mut self, v: ::bytes::Bytes) {
        self.spawngroupmanifest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spawngroupmanifest(&mut self) -> &mut ::bytes::Bytes {
        if self.spawngroupmanifest.is_none() {
            self.spawngroupmanifest = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.spawngroupmanifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_spawngroupmanifest(&mut self) -> ::bytes::Bytes {
        self.spawngroupmanifest.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool manifestincomplete = 3;

    pub fn manifestincomplete(&self) -> bool {
        self.manifestincomplete.unwrap_or(false)
    }

    pub fn clear_manifestincomplete(&mut self) {
        self.manifestincomplete = ::std::option::Option::None;
    }

    pub fn has_manifestincomplete(&self) -> bool {
        self.manifestincomplete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifestincomplete(&mut self, v: bool) {
        self.manifestincomplete = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawngrouphandle",
            |m: &CNETMsg_SpawnGroup_ManifestUpdate| { &m.spawngrouphandle },
            |m: &mut CNETMsg_SpawnGroup_ManifestUpdate| { &mut m.spawngrouphandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawngroupmanifest",
            |m: &CNETMsg_SpawnGroup_ManifestUpdate| { &m.spawngroupmanifest },
            |m: &mut CNETMsg_SpawnGroup_ManifestUpdate| { &mut m.spawngroupmanifest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manifestincomplete",
            |m: &CNETMsg_SpawnGroup_ManifestUpdate| { &m.manifestincomplete },
            |m: &mut CNETMsg_SpawnGroup_ManifestUpdate| { &mut m.manifestincomplete },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SpawnGroup_ManifestUpdate>(
            "CNETMsg_SpawnGroup_ManifestUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SpawnGroup_ManifestUpdate {
    const NAME: &'static str = "CNETMsg_SpawnGroup_ManifestUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spawngrouphandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.spawngroupmanifest = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                24 => {
                    self.manifestincomplete = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spawngrouphandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.spawngroupmanifest.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.manifestincomplete {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spawngrouphandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.spawngroupmanifest.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.manifestincomplete {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SpawnGroup_ManifestUpdate {
        CNETMsg_SpawnGroup_ManifestUpdate::new()
    }

    fn clear(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
        self.spawngroupmanifest = ::std::option::Option::None;
        self.manifestincomplete = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SpawnGroup_ManifestUpdate {
        static instance: CNETMsg_SpawnGroup_ManifestUpdate = CNETMsg_SpawnGroup_ManifestUpdate {
            spawngrouphandle: ::std::option::Option::None,
            spawngroupmanifest: ::std::option::Option::None,
            manifestincomplete: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SpawnGroup_ManifestUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SpawnGroup_ManifestUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SpawnGroup_ManifestUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SpawnGroup_ManifestUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNETMsg_SpawnGroup_SetCreationTick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SpawnGroup_SetCreationTick {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_SetCreationTick.spawngrouphandle)
    pub spawngrouphandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_SetCreationTick.tickcount)
    pub tickcount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_SetCreationTick.creationsequence)
    pub creationsequence: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SpawnGroup_SetCreationTick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SpawnGroup_SetCreationTick {
    fn default() -> &'a CNETMsg_SpawnGroup_SetCreationTick {
        <CNETMsg_SpawnGroup_SetCreationTick as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SpawnGroup_SetCreationTick {
    pub fn new() -> CNETMsg_SpawnGroup_SetCreationTick {
        ::std::default::Default::default()
    }

    // optional uint32 spawngrouphandle = 1;

    pub fn spawngrouphandle(&self) -> u32 {
        self.spawngrouphandle.unwrap_or(0)
    }

    pub fn clear_spawngrouphandle(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
    }

    pub fn has_spawngrouphandle(&self) -> bool {
        self.spawngrouphandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngrouphandle(&mut self, v: u32) {
        self.spawngrouphandle = ::std::option::Option::Some(v);
    }

    // optional int32 tickcount = 2;

    pub fn tickcount(&self) -> i32 {
        self.tickcount.unwrap_or(0)
    }

    pub fn clear_tickcount(&mut self) {
        self.tickcount = ::std::option::Option::None;
    }

    pub fn has_tickcount(&self) -> bool {
        self.tickcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tickcount(&mut self, v: i32) {
        self.tickcount = ::std::option::Option::Some(v);
    }

    // optional uint32 creationsequence = 3;

    pub fn creationsequence(&self) -> u32 {
        self.creationsequence.unwrap_or(0)
    }

    pub fn clear_creationsequence(&mut self) {
        self.creationsequence = ::std::option::Option::None;
    }

    pub fn has_creationsequence(&self) -> bool {
        self.creationsequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationsequence(&mut self, v: u32) {
        self.creationsequence = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawngrouphandle",
            |m: &CNETMsg_SpawnGroup_SetCreationTick| { &m.spawngrouphandle },
            |m: &mut CNETMsg_SpawnGroup_SetCreationTick| { &mut m.spawngrouphandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tickcount",
            |m: &CNETMsg_SpawnGroup_SetCreationTick| { &m.tickcount },
            |m: &mut CNETMsg_SpawnGroup_SetCreationTick| { &mut m.tickcount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creationsequence",
            |m: &CNETMsg_SpawnGroup_SetCreationTick| { &m.creationsequence },
            |m: &mut CNETMsg_SpawnGroup_SetCreationTick| { &mut m.creationsequence },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SpawnGroup_SetCreationTick>(
            "CNETMsg_SpawnGroup_SetCreationTick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SpawnGroup_SetCreationTick {
    const NAME: &'static str = "CNETMsg_SpawnGroup_SetCreationTick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spawngrouphandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.tickcount = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.creationsequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spawngrouphandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tickcount {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.creationsequence {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spawngrouphandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tickcount {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.creationsequence {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SpawnGroup_SetCreationTick {
        CNETMsg_SpawnGroup_SetCreationTick::new()
    }

    fn clear(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
        self.tickcount = ::std::option::Option::None;
        self.creationsequence = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SpawnGroup_SetCreationTick {
        static instance: CNETMsg_SpawnGroup_SetCreationTick = CNETMsg_SpawnGroup_SetCreationTick {
            spawngrouphandle: ::std::option::Option::None,
            tickcount: ::std::option::Option::None,
            creationsequence: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SpawnGroup_SetCreationTick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SpawnGroup_SetCreationTick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SpawnGroup_SetCreationTick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SpawnGroup_SetCreationTick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNETMsg_SpawnGroup_Unload)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SpawnGroup_Unload {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Unload.spawngrouphandle)
    pub spawngrouphandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Unload.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_Unload.tickcount)
    pub tickcount: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SpawnGroup_Unload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SpawnGroup_Unload {
    fn default() -> &'a CNETMsg_SpawnGroup_Unload {
        <CNETMsg_SpawnGroup_Unload as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SpawnGroup_Unload {
    pub fn new() -> CNETMsg_SpawnGroup_Unload {
        ::std::default::Default::default()
    }

    // optional uint32 spawngrouphandle = 1;

    pub fn spawngrouphandle(&self) -> u32 {
        self.spawngrouphandle.unwrap_or(0)
    }

    pub fn clear_spawngrouphandle(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
    }

    pub fn has_spawngrouphandle(&self) -> bool {
        self.spawngrouphandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngrouphandle(&mut self, v: u32) {
        self.spawngrouphandle = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 2;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional int32 tickcount = 3;

    pub fn tickcount(&self) -> i32 {
        self.tickcount.unwrap_or(0)
    }

    pub fn clear_tickcount(&mut self) {
        self.tickcount = ::std::option::Option::None;
    }

    pub fn has_tickcount(&self) -> bool {
        self.tickcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tickcount(&mut self, v: i32) {
        self.tickcount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawngrouphandle",
            |m: &CNETMsg_SpawnGroup_Unload| { &m.spawngrouphandle },
            |m: &mut CNETMsg_SpawnGroup_Unload| { &mut m.spawngrouphandle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CNETMsg_SpawnGroup_Unload| { &m.flags },
            |m: &mut CNETMsg_SpawnGroup_Unload| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tickcount",
            |m: &CNETMsg_SpawnGroup_Unload| { &m.tickcount },
            |m: &mut CNETMsg_SpawnGroup_Unload| { &mut m.tickcount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SpawnGroup_Unload>(
            "CNETMsg_SpawnGroup_Unload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SpawnGroup_Unload {
    const NAME: &'static str = "CNETMsg_SpawnGroup_Unload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spawngrouphandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.tickcount = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spawngrouphandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.tickcount {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spawngrouphandle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tickcount {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SpawnGroup_Unload {
        CNETMsg_SpawnGroup_Unload::new()
    }

    fn clear(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.tickcount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SpawnGroup_Unload {
        static instance: CNETMsg_SpawnGroup_Unload = CNETMsg_SpawnGroup_Unload {
            spawngrouphandle: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            tickcount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SpawnGroup_Unload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SpawnGroup_Unload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SpawnGroup_Unload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SpawnGroup_Unload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNETMsg_SpawnGroup_LoadCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_SpawnGroup_LoadCompleted {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SpawnGroup_LoadCompleted.spawngrouphandle)
    pub spawngrouphandle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SpawnGroup_LoadCompleted.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SpawnGroup_LoadCompleted {
    fn default() -> &'a CNETMsg_SpawnGroup_LoadCompleted {
        <CNETMsg_SpawnGroup_LoadCompleted as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SpawnGroup_LoadCompleted {
    pub fn new() -> CNETMsg_SpawnGroup_LoadCompleted {
        ::std::default::Default::default()
    }

    // optional uint32 spawngrouphandle = 1;

    pub fn spawngrouphandle(&self) -> u32 {
        self.spawngrouphandle.unwrap_or(0)
    }

    pub fn clear_spawngrouphandle(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
    }

    pub fn has_spawngrouphandle(&self) -> bool {
        self.spawngrouphandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawngrouphandle(&mut self, v: u32) {
        self.spawngrouphandle = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawngrouphandle",
            |m: &CNETMsg_SpawnGroup_LoadCompleted| { &m.spawngrouphandle },
            |m: &mut CNETMsg_SpawnGroup_LoadCompleted| { &mut m.spawngrouphandle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SpawnGroup_LoadCompleted>(
            "CNETMsg_SpawnGroup_LoadCompleted",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SpawnGroup_LoadCompleted {
    const NAME: &'static str = "CNETMsg_SpawnGroup_LoadCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spawngrouphandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spawngrouphandle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.spawngrouphandle {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SpawnGroup_LoadCompleted {
        CNETMsg_SpawnGroup_LoadCompleted::new()
    }

    fn clear(&mut self) {
        self.spawngrouphandle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SpawnGroup_LoadCompleted {
        static instance: CNETMsg_SpawnGroup_LoadCompleted = CNETMsg_SpawnGroup_LoadCompleted {
            spawngrouphandle: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SpawnGroup_LoadCompleted {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SpawnGroup_LoadCompleted").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SpawnGroup_LoadCompleted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SpawnGroup_LoadCompleted {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSVCMsg_GameSessionConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSVCMsg_GameSessionConfiguration {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_multiplayer)
    pub is_multiplayer: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_loadsavegame)
    pub is_loadsavegame: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_background_map)
    pub is_background_map: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_headless)
    pub is_headless: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.min_client_limit)
    pub min_client_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.max_client_limit)
    pub max_client_limit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.max_clients)
    pub max_clients: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.tick_interval)
    pub tick_interval: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.savegamename)
    pub savegamename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.s1_mapname)
    pub s1_mapname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.gamemode)
    pub gamemode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.server_ip_address)
    pub server_ip_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_localonly)
    pub is_localonly: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.no_steam_server)
    pub no_steam_server: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.is_transition)
    pub is_transition: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.previouslevel)
    pub previouslevel: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSVCMsg_GameSessionConfiguration.landmarkname)
    pub landmarkname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GameSessionConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GameSessionConfiguration {
    fn default() -> &'a CSVCMsg_GameSessionConfiguration {
        <CSVCMsg_GameSessionConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GameSessionConfiguration {
    pub fn new() -> CSVCMsg_GameSessionConfiguration {
        ::std::default::Default::default()
    }

    // optional bool is_multiplayer = 1;

    pub fn is_multiplayer(&self) -> bool {
        self.is_multiplayer.unwrap_or(false)
    }

    pub fn clear_is_multiplayer(&mut self) {
        self.is_multiplayer = ::std::option::Option::None;
    }

    pub fn has_is_multiplayer(&self) -> bool {
        self.is_multiplayer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_multiplayer(&mut self, v: bool) {
        self.is_multiplayer = ::std::option::Option::Some(v);
    }

    // optional bool is_loadsavegame = 2;

    pub fn is_loadsavegame(&self) -> bool {
        self.is_loadsavegame.unwrap_or(false)
    }

    pub fn clear_is_loadsavegame(&mut self) {
        self.is_loadsavegame = ::std::option::Option::None;
    }

    pub fn has_is_loadsavegame(&self) -> bool {
        self.is_loadsavegame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_loadsavegame(&mut self, v: bool) {
        self.is_loadsavegame = ::std::option::Option::Some(v);
    }

    // optional bool is_background_map = 3;

    pub fn is_background_map(&self) -> bool {
        self.is_background_map.unwrap_or(false)
    }

    pub fn clear_is_background_map(&mut self) {
        self.is_background_map = ::std::option::Option::None;
    }

    pub fn has_is_background_map(&self) -> bool {
        self.is_background_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_background_map(&mut self, v: bool) {
        self.is_background_map = ::std::option::Option::Some(v);
    }

    // optional bool is_headless = 4;

    pub fn is_headless(&self) -> bool {
        self.is_headless.unwrap_or(false)
    }

    pub fn clear_is_headless(&mut self) {
        self.is_headless = ::std::option::Option::None;
    }

    pub fn has_is_headless(&self) -> bool {
        self.is_headless.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_headless(&mut self, v: bool) {
        self.is_headless = ::std::option::Option::Some(v);
    }

    // optional uint32 min_client_limit = 5;

    pub fn min_client_limit(&self) -> u32 {
        self.min_client_limit.unwrap_or(0)
    }

    pub fn clear_min_client_limit(&mut self) {
        self.min_client_limit = ::std::option::Option::None;
    }

    pub fn has_min_client_limit(&self) -> bool {
        self.min_client_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_client_limit(&mut self, v: u32) {
        self.min_client_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 max_client_limit = 6;

    pub fn max_client_limit(&self) -> u32 {
        self.max_client_limit.unwrap_or(0)
    }

    pub fn clear_max_client_limit(&mut self) {
        self.max_client_limit = ::std::option::Option::None;
    }

    pub fn has_max_client_limit(&self) -> bool {
        self.max_client_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_client_limit(&mut self, v: u32) {
        self.max_client_limit = ::std::option::Option::Some(v);
    }

    // optional uint32 max_clients = 7;

    pub fn max_clients(&self) -> u32 {
        self.max_clients.unwrap_or(0)
    }

    pub fn clear_max_clients(&mut self) {
        self.max_clients = ::std::option::Option::None;
    }

    pub fn has_max_clients(&self) -> bool {
        self.max_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_clients(&mut self, v: u32) {
        self.max_clients = ::std::option::Option::Some(v);
    }

    // optional fixed32 tick_interval = 8;

    pub fn tick_interval(&self) -> u32 {
        self.tick_interval.unwrap_or(0)
    }

    pub fn clear_tick_interval(&mut self) {
        self.tick_interval = ::std::option::Option::None;
    }

    pub fn has_tick_interval(&self) -> bool {
        self.tick_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_interval(&mut self, v: u32) {
        self.tick_interval = ::std::option::Option::Some(v);
    }

    // optional string hostname = 9;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string savegamename = 10;

    pub fn savegamename(&self) -> &str {
        match self.savegamename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_savegamename(&mut self) {
        self.savegamename = ::std::option::Option::None;
    }

    pub fn has_savegamename(&self) -> bool {
        self.savegamename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_savegamename(&mut self, v: ::std::string::String) {
        self.savegamename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_savegamename(&mut self) -> &mut ::std::string::String {
        if self.savegamename.is_none() {
            self.savegamename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.savegamename.as_mut().unwrap()
    }

    // Take field
    pub fn take_savegamename(&mut self) -> ::std::string::String {
        self.savegamename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string s1_mapname = 11;

    pub fn s1_mapname(&self) -> &str {
        match self.s1_mapname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_s1_mapname(&mut self) {
        self.s1_mapname = ::std::option::Option::None;
    }

    pub fn has_s1_mapname(&self) -> bool {
        self.s1_mapname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_s1_mapname(&mut self, v: ::std::string::String) {
        self.s1_mapname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s1_mapname(&mut self) -> &mut ::std::string::String {
        if self.s1_mapname.is_none() {
            self.s1_mapname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.s1_mapname.as_mut().unwrap()
    }

    // Take field
    pub fn take_s1_mapname(&mut self) -> ::std::string::String {
        self.s1_mapname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string gamemode = 12;

    pub fn gamemode(&self) -> &str {
        match self.gamemode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gamemode(&mut self) {
        self.gamemode = ::std::option::Option::None;
    }

    pub fn has_gamemode(&self) -> bool {
        self.gamemode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamemode(&mut self, v: ::std::string::String) {
        self.gamemode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamemode(&mut self) -> &mut ::std::string::String {
        if self.gamemode.is_none() {
            self.gamemode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gamemode.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamemode(&mut self) -> ::std::string::String {
        self.gamemode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string server_ip_address = 13;

    pub fn server_ip_address(&self) -> &str {
        match self.server_ip_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_ip_address(&mut self) {
        self.server_ip_address = ::std::option::Option::None;
    }

    pub fn has_server_ip_address(&self) -> bool {
        self.server_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip_address(&mut self, v: ::std::string::String) {
        self.server_ip_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_ip_address(&mut self) -> &mut ::std::string::String {
        if self.server_ip_address.is_none() {
            self.server_ip_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_ip_address(&mut self) -> ::std::string::String {
        self.server_ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 14;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool is_localonly = 15;

    pub fn is_localonly(&self) -> bool {
        self.is_localonly.unwrap_or(false)
    }

    pub fn clear_is_localonly(&mut self) {
        self.is_localonly = ::std::option::Option::None;
    }

    pub fn has_is_localonly(&self) -> bool {
        self.is_localonly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_localonly(&mut self, v: bool) {
        self.is_localonly = ::std::option::Option::Some(v);
    }

    // optional bool no_steam_server = 19;

    pub fn no_steam_server(&self) -> bool {
        self.no_steam_server.unwrap_or(false)
    }

    pub fn clear_no_steam_server(&mut self) {
        self.no_steam_server = ::std::option::Option::None;
    }

    pub fn has_no_steam_server(&self) -> bool {
        self.no_steam_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_steam_server(&mut self, v: bool) {
        self.no_steam_server = ::std::option::Option::Some(v);
    }

    // optional bool is_transition = 16;

    pub fn is_transition(&self) -> bool {
        self.is_transition.unwrap_or(false)
    }

    pub fn clear_is_transition(&mut self) {
        self.is_transition = ::std::option::Option::None;
    }

    pub fn has_is_transition(&self) -> bool {
        self.is_transition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_transition(&mut self, v: bool) {
        self.is_transition = ::std::option::Option::Some(v);
    }

    // optional string previouslevel = 17;

    pub fn previouslevel(&self) -> &str {
        match self.previouslevel.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_previouslevel(&mut self) {
        self.previouslevel = ::std::option::Option::None;
    }

    pub fn has_previouslevel(&self) -> bool {
        self.previouslevel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previouslevel(&mut self, v: ::std::string::String) {
        self.previouslevel = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previouslevel(&mut self) -> &mut ::std::string::String {
        if self.previouslevel.is_none() {
            self.previouslevel = ::std::option::Option::Some(::std::string::String::new());
        }
        self.previouslevel.as_mut().unwrap()
    }

    // Take field
    pub fn take_previouslevel(&mut self) -> ::std::string::String {
        self.previouslevel.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string landmarkname = 18;

    pub fn landmarkname(&self) -> &str {
        match self.landmarkname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_landmarkname(&mut self) {
        self.landmarkname = ::std::option::Option::None;
    }

    pub fn has_landmarkname(&self) -> bool {
        self.landmarkname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_landmarkname(&mut self, v: ::std::string::String) {
        self.landmarkname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_landmarkname(&mut self) -> &mut ::std::string::String {
        if self.landmarkname.is_none() {
            self.landmarkname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.landmarkname.as_mut().unwrap()
    }

    // Take field
    pub fn take_landmarkname(&mut self) -> ::std::string::String {
        self.landmarkname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_multiplayer",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.is_multiplayer },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.is_multiplayer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_loadsavegame",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.is_loadsavegame },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.is_loadsavegame },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_background_map",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.is_background_map },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.is_background_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_headless",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.is_headless },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.is_headless },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_client_limit",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.min_client_limit },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.min_client_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_client_limit",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.max_client_limit },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.max_client_limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_clients",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.max_clients },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.max_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick_interval",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.tick_interval },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.tick_interval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.hostname },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.hostname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "savegamename",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.savegamename },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.savegamename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "s1_mapname",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.s1_mapname },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.s1_mapname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamemode",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.gamemode },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.gamemode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_ip_address",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.server_ip_address },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.server_ip_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.data },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_localonly",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.is_localonly },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.is_localonly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "no_steam_server",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.no_steam_server },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.no_steam_server },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_transition",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.is_transition },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.is_transition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "previouslevel",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.previouslevel },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.previouslevel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "landmarkname",
            |m: &CSVCMsg_GameSessionConfiguration| { &m.landmarkname },
            |m: &mut CSVCMsg_GameSessionConfiguration| { &mut m.landmarkname },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_GameSessionConfiguration>(
            "CSVCMsg_GameSessionConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_GameSessionConfiguration {
    const NAME: &'static str = "CSVCMsg_GameSessionConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_multiplayer = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.is_loadsavegame = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.is_background_map = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_headless = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.min_client_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.max_client_limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.max_clients = ::std::option::Option::Some(is.read_uint32()?);
                },
                69 => {
                    self.tick_interval = ::std::option::Option::Some(is.read_fixed32()?);
                },
                74 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.savegamename = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.s1_mapname = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.gamemode = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.server_ip_address = ::std::option::Option::Some(is.read_string()?);
                },
                114 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                120 => {
                    self.is_localonly = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.no_steam_server = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.is_transition = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.previouslevel = ::std::option::Option::Some(is.read_string()?);
                },
                146 => {
                    self.landmarkname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_multiplayer {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_loadsavegame {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_background_map {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_headless {
            my_size += 1 + 1;
        }
        if let Some(v) = self.min_client_limit {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.max_client_limit {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.max_clients {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.tick_interval {
            my_size += 1 + 4;
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.savegamename.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.s1_mapname.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.gamemode.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.server_ip_address.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.is_localonly {
            my_size += 1 + 1;
        }
        if let Some(v) = self.no_steam_server {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_transition {
            my_size += 2 + 1;
        }
        if let Some(v) = self.previouslevel.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.landmarkname.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_multiplayer {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.is_loadsavegame {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.is_background_map {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_headless {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.min_client_limit {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.max_client_limit {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.max_clients {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.tick_interval {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.savegamename.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.s1_mapname.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.gamemode.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.server_ip_address.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(14, v)?;
        }
        if let Some(v) = self.is_localonly {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.no_steam_server {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.is_transition {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.previouslevel.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.landmarkname.as_ref() {
            os.write_string(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GameSessionConfiguration {
        CSVCMsg_GameSessionConfiguration::new()
    }

    fn clear(&mut self) {
        self.is_multiplayer = ::std::option::Option::None;
        self.is_loadsavegame = ::std::option::Option::None;
        self.is_background_map = ::std::option::Option::None;
        self.is_headless = ::std::option::Option::None;
        self.min_client_limit = ::std::option::Option::None;
        self.max_client_limit = ::std::option::Option::None;
        self.max_clients = ::std::option::Option::None;
        self.tick_interval = ::std::option::Option::None;
        self.hostname = ::std::option::Option::None;
        self.savegamename = ::std::option::Option::None;
        self.s1_mapname = ::std::option::Option::None;
        self.gamemode = ::std::option::Option::None;
        self.server_ip_address = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.is_localonly = ::std::option::Option::None;
        self.no_steam_server = ::std::option::Option::None;
        self.is_transition = ::std::option::Option::None;
        self.previouslevel = ::std::option::Option::None;
        self.landmarkname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GameSessionConfiguration {
        static instance: CSVCMsg_GameSessionConfiguration = CSVCMsg_GameSessionConfiguration {
            is_multiplayer: ::std::option::Option::None,
            is_loadsavegame: ::std::option::Option::None,
            is_background_map: ::std::option::Option::None,
            is_headless: ::std::option::Option::None,
            min_client_limit: ::std::option::Option::None,
            max_client_limit: ::std::option::Option::None,
            max_clients: ::std::option::Option::None,
            tick_interval: ::std::option::Option::None,
            hostname: ::std::option::Option::None,
            savegamename: ::std::option::Option::None,
            s1_mapname: ::std::option::Option::None,
            gamemode: ::std::option::Option::None,
            server_ip_address: ::std::option::Option::None,
            data: ::std::option::Option::None,
            is_localonly: ::std::option::Option::None,
            no_steam_server: ::std::option::Option::None,
            is_transition: ::std::option::Option::None,
            previouslevel: ::std::option::Option::None,
            landmarkname: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_GameSessionConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_GameSessionConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_GameSessionConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_GameSessionConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNETMsg_DebugOverlay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNETMsg_DebugOverlay {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.etype)
    pub etype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.vectors)
    pub vectors: ::std::vec::Vec<CMsgVector>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.colors)
    pub colors: ::std::vec::Vec<CMsgRGBA>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.dimensions)
    pub dimensions: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.times)
    pub times: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.bools)
    pub bools: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.uint64s)
    pub uint64s: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CNETMsg_DebugOverlay.strings)
    pub strings: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_DebugOverlay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_DebugOverlay {
    fn default() -> &'a CNETMsg_DebugOverlay {
        <CNETMsg_DebugOverlay as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_DebugOverlay {
    pub fn new() -> CNETMsg_DebugOverlay {
        ::std::default::Default::default()
    }

    // optional int32 etype = 1;

    pub fn etype(&self) -> i32 {
        self.etype.unwrap_or(0)
    }

    pub fn clear_etype(&mut self) {
        self.etype = ::std::option::Option::None;
    }

    pub fn has_etype(&self) -> bool {
        self.etype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_etype(&mut self, v: i32) {
        self.etype = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "etype",
            |m: &CNETMsg_DebugOverlay| { &m.etype },
            |m: &mut CNETMsg_DebugOverlay| { &mut m.etype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vectors",
            |m: &CNETMsg_DebugOverlay| { &m.vectors },
            |m: &mut CNETMsg_DebugOverlay| { &mut m.vectors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "colors",
            |m: &CNETMsg_DebugOverlay| { &m.colors },
            |m: &mut CNETMsg_DebugOverlay| { &mut m.colors },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dimensions",
            |m: &CNETMsg_DebugOverlay| { &m.dimensions },
            |m: &mut CNETMsg_DebugOverlay| { &mut m.dimensions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "times",
            |m: &CNETMsg_DebugOverlay| { &m.times },
            |m: &mut CNETMsg_DebugOverlay| { &mut m.times },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bools",
            |m: &CNETMsg_DebugOverlay| { &m.bools },
            |m: &mut CNETMsg_DebugOverlay| { &mut m.bools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uint64s",
            |m: &CNETMsg_DebugOverlay| { &m.uint64s },
            |m: &mut CNETMsg_DebugOverlay| { &mut m.uint64s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "strings",
            |m: &CNETMsg_DebugOverlay| { &m.strings },
            |m: &mut CNETMsg_DebugOverlay| { &mut m.strings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_DebugOverlay>(
            "CNETMsg_DebugOverlay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_DebugOverlay {
    const NAME: &'static str = "CNETMsg_DebugOverlay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.etype = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.vectors.push(is.read_message()?);
                },
                26 => {
                    self.colors.push(is.read_message()?);
                },
                34 => {
                    is.read_repeated_packed_float_into(&mut self.dimensions)?;
                },
                37 => {
                    self.dimensions.push(is.read_float()?);
                },
                42 => {
                    is.read_repeated_packed_float_into(&mut self.times)?;
                },
                45 => {
                    self.times.push(is.read_float()?);
                },
                50 => {
                    is.read_repeated_packed_bool_into(&mut self.bools)?;
                },
                48 => {
                    self.bools.push(is.read_bool()?);
                },
                58 => {
                    is.read_repeated_packed_uint64_into(&mut self.uint64s)?;
                },
                56 => {
                    self.uint64s.push(is.read_uint64()?);
                },
                66 => {
                    self.strings.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.etype {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.vectors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.colors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 5 * self.dimensions.len() as u64;
        my_size += 5 * self.times.len() as u64;
        my_size += 2 * self.bools.len() as u64;
        for value in &self.uint64s {
            my_size += ::protobuf::rt::uint64_size(7, *value);
        };
        for value in &self.strings {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.etype {
            os.write_int32(1, v)?;
        }
        for v in &self.vectors {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.colors {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.dimensions {
            os.write_float(4, *v)?;
        };
        for v in &self.times {
            os.write_float(5, *v)?;
        };
        for v in &self.bools {
            os.write_bool(6, *v)?;
        };
        for v in &self.uint64s {
            os.write_uint64(7, *v)?;
        };
        for v in &self.strings {
            os.write_string(8, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_DebugOverlay {
        CNETMsg_DebugOverlay::new()
    }

    fn clear(&mut self) {
        self.etype = ::std::option::Option::None;
        self.vectors.clear();
        self.colors.clear();
        self.dimensions.clear();
        self.times.clear();
        self.bools.clear();
        self.uint64s.clear();
        self.strings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_DebugOverlay {
        static instance: CNETMsg_DebugOverlay = CNETMsg_DebugOverlay {
            etype: ::std::option::Option::None,
            vectors: ::std::vec::Vec::new(),
            colors: ::std::vec::Vec::new(),
            dimensions: ::std::vec::Vec::new(),
            times: ::std::vec::Vec::new(),
            bools: ::std::vec::Vec::new(),
            uint64s: ::std::vec::Vec::new(),
            strings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_DebugOverlay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_DebugOverlay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_DebugOverlay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_DebugOverlay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SignonState_t)
pub enum SignonState_t {
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_NONE)
    SIGNONSTATE_NONE = 0,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_CHALLENGE)
    SIGNONSTATE_CHALLENGE = 1,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_CONNECTED)
    SIGNONSTATE_CONNECTED = 2,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_NEW)
    SIGNONSTATE_NEW = 3,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_PRESPAWN)
    SIGNONSTATE_PRESPAWN = 4,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_SPAWN)
    SIGNONSTATE_SPAWN = 5,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_FULL)
    SIGNONSTATE_FULL = 6,
    // @@protoc_insertion_point(enum_value:SignonState_t.SIGNONSTATE_CHANGELEVEL)
    SIGNONSTATE_CHANGELEVEL = 7,
}

impl ::protobuf::Enum for SignonState_t {
    const NAME: &'static str = "SignonState_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SignonState_t> {
        match value {
            0 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_NONE),
            1 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CHALLENGE),
            2 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CONNECTED),
            3 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_NEW),
            4 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_PRESPAWN),
            5 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_SPAWN),
            6 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_FULL),
            7 => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CHANGELEVEL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SignonState_t> {
        match str {
            "SIGNONSTATE_NONE" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_NONE),
            "SIGNONSTATE_CHALLENGE" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CHALLENGE),
            "SIGNONSTATE_CONNECTED" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CONNECTED),
            "SIGNONSTATE_NEW" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_NEW),
            "SIGNONSTATE_PRESPAWN" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_PRESPAWN),
            "SIGNONSTATE_SPAWN" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_SPAWN),
            "SIGNONSTATE_FULL" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_FULL),
            "SIGNONSTATE_CHANGELEVEL" => ::std::option::Option::Some(SignonState_t::SIGNONSTATE_CHANGELEVEL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SignonState_t] = &[
        SignonState_t::SIGNONSTATE_NONE,
        SignonState_t::SIGNONSTATE_CHALLENGE,
        SignonState_t::SIGNONSTATE_CONNECTED,
        SignonState_t::SIGNONSTATE_NEW,
        SignonState_t::SIGNONSTATE_PRESPAWN,
        SignonState_t::SIGNONSTATE_SPAWN,
        SignonState_t::SIGNONSTATE_FULL,
        SignonState_t::SIGNONSTATE_CHANGELEVEL,
    ];
}

impl ::protobuf::EnumFull for SignonState_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SignonState_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SignonState_t {
    fn default() -> Self {
        SignonState_t::SIGNONSTATE_NONE
    }
}

impl SignonState_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SignonState_t>("SignonState_t")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:NET_Messages)
pub enum NET_Messages {
    // @@protoc_insertion_point(enum_value:NET_Messages.net_NOP)
    net_NOP = 0,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_Disconnect_Legacy)
    net_Disconnect_Legacy = 1,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SplitScreenUser)
    net_SplitScreenUser = 3,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_Tick)
    net_Tick = 4,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_StringCmd)
    net_StringCmd = 5,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SetConVar)
    net_SetConVar = 6,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SignonState)
    net_SignonState = 7,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SpawnGroup_Load)
    net_SpawnGroup_Load = 8,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SpawnGroup_ManifestUpdate)
    net_SpawnGroup_ManifestUpdate = 9,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SpawnGroup_SetCreationTick)
    net_SpawnGroup_SetCreationTick = 11,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SpawnGroup_Unload)
    net_SpawnGroup_Unload = 12,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SpawnGroup_LoadCompleted)
    net_SpawnGroup_LoadCompleted = 13,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_DebugOverlay)
    net_DebugOverlay = 15,
}

impl ::protobuf::Enum for NET_Messages {
    const NAME: &'static str = "NET_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NET_Messages> {
        match value {
            0 => ::std::option::Option::Some(NET_Messages::net_NOP),
            1 => ::std::option::Option::Some(NET_Messages::net_Disconnect_Legacy),
            3 => ::std::option::Option::Some(NET_Messages::net_SplitScreenUser),
            4 => ::std::option::Option::Some(NET_Messages::net_Tick),
            5 => ::std::option::Option::Some(NET_Messages::net_StringCmd),
            6 => ::std::option::Option::Some(NET_Messages::net_SetConVar),
            7 => ::std::option::Option::Some(NET_Messages::net_SignonState),
            8 => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_Load),
            9 => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_ManifestUpdate),
            11 => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_SetCreationTick),
            12 => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_Unload),
            13 => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_LoadCompleted),
            15 => ::std::option::Option::Some(NET_Messages::net_DebugOverlay),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<NET_Messages> {
        match str {
            "net_NOP" => ::std::option::Option::Some(NET_Messages::net_NOP),
            "net_Disconnect_Legacy" => ::std::option::Option::Some(NET_Messages::net_Disconnect_Legacy),
            "net_SplitScreenUser" => ::std::option::Option::Some(NET_Messages::net_SplitScreenUser),
            "net_Tick" => ::std::option::Option::Some(NET_Messages::net_Tick),
            "net_StringCmd" => ::std::option::Option::Some(NET_Messages::net_StringCmd),
            "net_SetConVar" => ::std::option::Option::Some(NET_Messages::net_SetConVar),
            "net_SignonState" => ::std::option::Option::Some(NET_Messages::net_SignonState),
            "net_SpawnGroup_Load" => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_Load),
            "net_SpawnGroup_ManifestUpdate" => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_ManifestUpdate),
            "net_SpawnGroup_SetCreationTick" => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_SetCreationTick),
            "net_SpawnGroup_Unload" => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_Unload),
            "net_SpawnGroup_LoadCompleted" => ::std::option::Option::Some(NET_Messages::net_SpawnGroup_LoadCompleted),
            "net_DebugOverlay" => ::std::option::Option::Some(NET_Messages::net_DebugOverlay),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NET_Messages] = &[
        NET_Messages::net_NOP,
        NET_Messages::net_Disconnect_Legacy,
        NET_Messages::net_SplitScreenUser,
        NET_Messages::net_Tick,
        NET_Messages::net_StringCmd,
        NET_Messages::net_SetConVar,
        NET_Messages::net_SignonState,
        NET_Messages::net_SpawnGroup_Load,
        NET_Messages::net_SpawnGroup_ManifestUpdate,
        NET_Messages::net_SpawnGroup_SetCreationTick,
        NET_Messages::net_SpawnGroup_Unload,
        NET_Messages::net_SpawnGroup_LoadCompleted,
        NET_Messages::net_DebugOverlay,
    ];
}

impl ::protobuf::EnumFull for NET_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NET_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            NET_Messages::net_NOP => 0,
            NET_Messages::net_Disconnect_Legacy => 1,
            NET_Messages::net_SplitScreenUser => 2,
            NET_Messages::net_Tick => 3,
            NET_Messages::net_StringCmd => 4,
            NET_Messages::net_SetConVar => 5,
            NET_Messages::net_SignonState => 6,
            NET_Messages::net_SpawnGroup_Load => 7,
            NET_Messages::net_SpawnGroup_ManifestUpdate => 8,
            NET_Messages::net_SpawnGroup_SetCreationTick => 9,
            NET_Messages::net_SpawnGroup_Unload => 10,
            NET_Messages::net_SpawnGroup_LoadCompleted => 11,
            NET_Messages::net_DebugOverlay => 12,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for NET_Messages {
    fn default() -> Self {
        NET_Messages::net_NOP
    }
}

impl NET_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NET_Messages>("NET_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SpawnGroupFlags_t)
pub enum SpawnGroupFlags_t {
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE)
    SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE = 1,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_DONT_SPAWN_ENTITIES)
    SPAWN_GROUP_DONT_SPAWN_ENTITIES = 2,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_SYNCHRONOUS_SPAWN)
    SPAWN_GROUP_SYNCHRONOUS_SPAWN = 4,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP)
    SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP = 8,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES)
    SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES = 16,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_BLOCK_UNTIL_LOADED)
    SPAWN_GROUP_BLOCK_UNTIL_LOADED = 64,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_LOAD_STREAMING_DATA)
    SPAWN_GROUP_LOAD_STREAMING_DATA = 128,
    // @@protoc_insertion_point(enum_value:SpawnGroupFlags_t.SPAWN_GROUP_CREATE_NEW_SCENE_WORLD)
    SPAWN_GROUP_CREATE_NEW_SCENE_WORLD = 256,
}

impl ::protobuf::Enum for SpawnGroupFlags_t {
    const NAME: &'static str = "SpawnGroupFlags_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SpawnGroupFlags_t> {
        match value {
            1 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE),
            2 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_DONT_SPAWN_ENTITIES),
            4 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_SYNCHRONOUS_SPAWN),
            8 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP),
            16 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES),
            64 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_BLOCK_UNTIL_LOADED),
            128 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_LOAD_STREAMING_DATA),
            256 => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_CREATE_NEW_SCENE_WORLD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SpawnGroupFlags_t> {
        match str {
            "SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE),
            "SPAWN_GROUP_DONT_SPAWN_ENTITIES" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_DONT_SPAWN_ENTITIES),
            "SPAWN_GROUP_SYNCHRONOUS_SPAWN" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_SYNCHRONOUS_SPAWN),
            "SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP),
            "SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES),
            "SPAWN_GROUP_BLOCK_UNTIL_LOADED" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_BLOCK_UNTIL_LOADED),
            "SPAWN_GROUP_LOAD_STREAMING_DATA" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_LOAD_STREAMING_DATA),
            "SPAWN_GROUP_CREATE_NEW_SCENE_WORLD" => ::std::option::Option::Some(SpawnGroupFlags_t::SPAWN_GROUP_CREATE_NEW_SCENE_WORLD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SpawnGroupFlags_t] = &[
        SpawnGroupFlags_t::SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE,
        SpawnGroupFlags_t::SPAWN_GROUP_DONT_SPAWN_ENTITIES,
        SpawnGroupFlags_t::SPAWN_GROUP_SYNCHRONOUS_SPAWN,
        SpawnGroupFlags_t::SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP,
        SpawnGroupFlags_t::SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES,
        SpawnGroupFlags_t::SPAWN_GROUP_BLOCK_UNTIL_LOADED,
        SpawnGroupFlags_t::SPAWN_GROUP_LOAD_STREAMING_DATA,
        SpawnGroupFlags_t::SPAWN_GROUP_CREATE_NEW_SCENE_WORLD,
    ];
}

impl ::protobuf::EnumFull for SpawnGroupFlags_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SpawnGroupFlags_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SpawnGroupFlags_t::SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE => 0,
            SpawnGroupFlags_t::SPAWN_GROUP_DONT_SPAWN_ENTITIES => 1,
            SpawnGroupFlags_t::SPAWN_GROUP_SYNCHRONOUS_SPAWN => 2,
            SpawnGroupFlags_t::SPAWN_GROUP_IS_INITIAL_SPAWN_GROUP => 3,
            SpawnGroupFlags_t::SPAWN_GROUP_CREATE_CLIENT_ONLY_ENTITIES => 4,
            SpawnGroupFlags_t::SPAWN_GROUP_BLOCK_UNTIL_LOADED => 5,
            SpawnGroupFlags_t::SPAWN_GROUP_LOAD_STREAMING_DATA => 6,
            SpawnGroupFlags_t::SPAWN_GROUP_CREATE_NEW_SCENE_WORLD => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SpawnGroupFlags_t {
    fn default() -> Self {
        SpawnGroupFlags_t::SPAWN_GROUP_LOAD_ENTITIES_FROM_SAVE
    }
}

impl SpawnGroupFlags_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SpawnGroupFlags_t>("SpawnGroupFlags_t")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x16networkbasetypes.proto\x1a\x18network_connection.proto\"D\n\nCMsgV\
    ector\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\x02\
    \x20\x01(\x02R\x01y\x12\x0c\n\x01z\x18\x03\x20\x01(\x02R\x01z\x12\x0c\n\
    \x01w\x18\x04\x20\x01(\x02R\x01w\"*\n\x0cCMsgVector2D\x12\x0c\n\x01x\x18\
    \x01\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x02R\x01y\"6\n\n\
    CMsgQAngle\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\
    \x02\x20\x01(\x02R\x01y\x12\x0c\n\x01z\x18\x03\x20\x01(\x02R\x01z\"H\n\
    \x0eCMsgQuaternion\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\
    \x01y\x18\x02\x20\x01(\x02R\x01y\x12\x0c\n\x01z\x18\x03\x20\x01(\x02R\
    \x01z\x12\x0c\n\x01w\x18\x04\x20\x01(\x02R\x01w\"\x81\x01\n\rCMsgTransfo\
    rm\x12'\n\x08position\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x08position\
    \x12\x14\n\x05scale\x18\x02\x20\x01(\x02R\x05scale\x121\n\x0borientation\
    \x18\x03\x20\x01(\x0b2\x0f.CMsgQuaternionR\x0borientation\"B\n\x08CMsgRG\
    BA\x12\x0c\n\x01r\x18\x01\x20\x01(\x05R\x01r\x12\x0c\n\x01g\x18\x02\x20\
    \x01(\x05R\x01g\x12\x0c\n\x01b\x18\x03\x20\x01(\x05R\x01b\x12\x0c\n\x01a\
    \x18\x04\x20\x01(\x05R\x01a\"\xa2\x01\n\x0eCMsgPlayerInfo\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04xuid\x18\x02\x20\x01(\x06R\
    \x04xuid\x12\x16\n\x06userid\x18\x03\x20\x01(\x05R\x06userid\x12\x18\n\
    \x07steamid\x18\x04\x20\x01(\x06R\x07steamid\x12\x1e\n\nfakeplayer\x18\
    \x05\x20\x01(\x08R\nfakeplayer\x12\x16\n\x06ishltv\x18\x06\x20\x01(\x08R\
    \x06ishltv\";\n\nCEntityMsg\x12-\n\rtarget_entity\x18\x01\x20\x01(\r:\
    \x0816777215R\x0ctargetEntity\"f\n\nCMsg_CVars\x12&\n\x05cvars\x18\x01\
    \x20\x03(\x0b2\x10.CMsg_CVars.CVarR\x05cvars\x1a0\n\x04CVar\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x02\x20\x01(\
    \tR\x05value\"\r\n\x0bCNETMsg_NOP\"-\n\x17CNETMsg_SplitScreenUser\x12\
    \x12\n\x04slot\x18\x01\x20\x01(\x05R\x04slot\"\xc3\x04\n\x0cCNETMsg_Tick\
    \x12\x12\n\x04tick\x18\x01\x20\x01(\rR\x04tick\x12%\n\x0ehost_frametime\
    \x18\x02\x20\x01(\rR\rhostFrametime\x12?\n\x1chost_frametime_std_deviati\
    on\x18\x03\x20\x01(\rR\x19hostFrametimeStdDeviation\x121\n\x14host_compu\
    tationtime\x18\x04\x20\x01(\rR\x13hostComputationtime\x12K\n\"host_compu\
    tationtime_std_deviation\x18\x05\x20\x01(\rR\x1fhostComputationtimeStdDe\
    viation\x12I\n!host_framestarttime_std_deviation\x18\x06\x20\x01(\rR\x1e\
    hostFramestarttimeStdDeviation\x12\x1b\n\thost_loss\x18\x07\x20\x01(\rR\
    \x08hostLoss\x12:\n\x19host_unfiltered_frametime\x18\x08\x20\x01(\rR\x17\
    hostUnfilteredFrametime\x12*\n\x11hltv_replay_flags\x18\t\x20\x01(\rR\
    \x0fhltvReplayFlags\x12,\n\x12expected_long_tick\x18\n\x20\x01(\rR\x10ex\
    pectedLongTick\x129\n\x19expected_long_tick_reason\x18\x0b\x20\x01(\tR\
    \x16expectedLongTickReason\"V\n\x11CNETMsg_StringCmd\x12\x18\n\x07comman\
    d\x18\x01\x20\x01(\tR\x07command\x12'\n\x0fprediction_sync\x18\x02\x20\
    \x01(\rR\x0epredictionSync\":\n\x11CNETMsg_SetConVar\x12%\n\x07convars\
    \x18\x01\x20\x01(\x0b2\x0b.CMsg_CVarsR\x07convars\"\x8b\x02\n\x13CNETMsg\
    _SignonState\x12C\n\x0csignon_state\x18\x01\x20\x01(\x0e2\x0e.SignonStat\
    e_t:\x10SIGNONSTATE_NONER\x0bsignonState\x12\x1f\n\x0bspawn_count\x18\
    \x02\x20\x01(\rR\nspawnCount\x12,\n\x12num_server_players\x18\x03\x20\
    \x01(\rR\x10numServerPlayers\x12-\n\x12players_networkids\x18\x04\x20\
    \x03(\tR\x11playersNetworkids\x12\x19\n\x08map_name\x18\x05\x20\x01(\tR\
    \x07mapName\x12\x16\n\x06addons\x18\x06\x20\x01(\tR\x06addons\"\xe1\x02\
    \n\x11CSVCMsg_GameEvent\x12\x1d\n\nevent_name\x18\x01\x20\x01(\tR\tevent\
    Name\x12\x18\n\x07eventid\x18\x02\x20\x01(\x05R\x07eventid\x12,\n\x04key\
    s\x18\x03\x20\x03(\x0b2\x18.CSVCMsg_GameEvent.key_tR\x04keys\x1a\xe4\x01\
    \n\x05key_t\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\x1d\n\nv\
    al_string\x18\x02\x20\x01(\tR\tvalString\x12\x1b\n\tval_float\x18\x03\
    \x20\x01(\x02R\x08valFloat\x12\x19\n\x08val_long\x18\x04\x20\x01(\x05R\
    \x07valLong\x12\x1b\n\tval_short\x18\x05\x20\x01(\x05R\x08valShort\x12\
    \x19\n\x08val_byte\x18\x06\x20\x01(\x05R\x07valByte\x12\x19\n\x08val_boo\
    l\x18\x07\x20\x01(\x08R\x07valBool\x12\x1d\n\nval_uint64\x18\x08\x20\x01\
    (\x04R\tvalUint64\"\x9a\x01\n\x16CSVCMsgList_GameEvents\x127\n\x06events\
    \x18\x01\x20\x03(\x0b2\x1f.CSVCMsgList_GameEvents.event_tR\x06events\x1a\
    G\n\x07event_t\x12\x12\n\x04tick\x18\x01\x20\x01(\x05R\x04tick\x12(\n\
    \x05event\x18\x02\x20\x01(\x0b2\x12.CSVCMsg_GameEventR\x05event\"\xff\
    \x06\n\x17CNETMsg_SpawnGroup_Load\x12\x1c\n\tworldname\x18\x01\x20\x01(\
    \tR\tworldname\x12&\n\x0eentitylumpname\x18\x02\x20\x01(\tR\x0eentitylum\
    pname\x12*\n\x10entityfiltername\x18\x03\x20\x01(\tR\x10entityfiltername\
    \x12*\n\x10spawngrouphandle\x18\x04\x20\x01(\rR\x10spawngrouphandle\x124\
    \n\x15spawngroupownerhandle\x18\x05\x20\x01(\rR\x15spawngroupownerhandle\
    \x125\n\x10world_offset_pos\x18\x06\x20\x01(\x0b2\x0b.CMsgVectorR\x0ewor\
    ldOffsetPos\x129\n\x12world_offset_angle\x18\x07\x20\x01(\x0b2\x0b.CMsgQ\
    AngleR\x10worldOffsetAngle\x12.\n\x12spawngroupmanifest\x18\x08\x20\x01(\
    \x0cR\x12spawngroupmanifest\x12\x14\n\x05flags\x18\t\x20\x01(\rR\x05flag\
    s\x12\x1c\n\ttickcount\x18\n\x20\x01(\x05R\ttickcount\x12.\n\x12manifest\
    incomplete\x18\x0b\x20\x01(\x08R\x12manifestincomplete\x12&\n\x0elocalna\
    mefixup\x18\x0c\x20\x01(\tR\x0elocalnamefixup\x12(\n\x0fparentnamefixup\
    \x18\r\x20\x01(\tR\x0fparentnamefixup\x122\n\x14manifestloadpriority\x18\
    \x0e\x20\x01(\x05R\x14manifestloadpriority\x12\"\n\x0cworldgroupid\x18\
    \x0f\x20\x01(\rR\x0cworldgroupid\x12*\n\x10creationsequence\x18\x10\x20\
    \x01(\rR\x10creationsequence\x12*\n\x10savegamefilename\x18\x11\x20\x01(\
    \tR\x10savegamefilename\x126\n\x16spawngroupparenthandle\x18\x12\x20\x01\
    (\rR\x16spawngroupparenthandle\x12(\n\x0fleveltransition\x18\x13\x20\x01\
    (\x08R\x0fleveltransition\x12&\n\x0eworldgroupname\x18\x14\x20\x01(\tR\
    \x0eworldgroupname\"\xaf\x01\n!CNETMsg_SpawnGroup_ManifestUpdate\x12*\n\
    \x10spawngrouphandle\x18\x01\x20\x01(\rR\x10spawngrouphandle\x12.\n\x12s\
    pawngroupmanifest\x18\x02\x20\x01(\x0cR\x12spawngroupmanifest\x12.\n\x12\
    manifestincomplete\x18\x03\x20\x01(\x08R\x12manifestincomplete\"\x9a\x01\
    \n\"CNETMsg_SpawnGroup_SetCreationTick\x12*\n\x10spawngrouphandle\x18\
    \x01\x20\x01(\rR\x10spawngrouphandle\x12\x1c\n\ttickcount\x18\x02\x20\
    \x01(\x05R\ttickcount\x12*\n\x10creationsequence\x18\x03\x20\x01(\rR\x10\
    creationsequence\"{\n\x19CNETMsg_SpawnGroup_Unload\x12*\n\x10spawngrouph\
    andle\x18\x01\x20\x01(\rR\x10spawngrouphandle\x12\x14\n\x05flags\x18\x02\
    \x20\x01(\rR\x05flags\x12\x1c\n\ttickcount\x18\x03\x20\x01(\x05R\ttickco\
    unt\"N\n\x20CNETMsg_SpawnGroup_LoadCompleted\x12*\n\x10spawngrouphandle\
    \x18\x01\x20\x01(\rR\x10spawngrouphandle\"\xce\x05\n\x20CSVCMsg_GameSess\
    ionConfiguration\x12%\n\x0eis_multiplayer\x18\x01\x20\x01(\x08R\risMulti\
    player\x12'\n\x0fis_loadsavegame\x18\x02\x20\x01(\x08R\x0eisLoadsavegame\
    \x12*\n\x11is_background_map\x18\x03\x20\x01(\x08R\x0fisBackgroundMap\
    \x12\x1f\n\x0bis_headless\x18\x04\x20\x01(\x08R\nisHeadless\x12(\n\x10mi\
    n_client_limit\x18\x05\x20\x01(\rR\x0eminClientLimit\x12(\n\x10max_clien\
    t_limit\x18\x06\x20\x01(\rR\x0emaxClientLimit\x12\x1f\n\x0bmax_clients\
    \x18\x07\x20\x01(\rR\nmaxClients\x12#\n\rtick_interval\x18\x08\x20\x01(\
    \x07R\x0ctickInterval\x12\x1a\n\x08hostname\x18\t\x20\x01(\tR\x08hostnam\
    e\x12\"\n\x0csavegamename\x18\n\x20\x01(\tR\x0csavegamename\x12\x1d\n\ns\
    1_mapname\x18\x0b\x20\x01(\tR\ts1Mapname\x12\x1a\n\x08gamemode\x18\x0c\
    \x20\x01(\tR\x08gamemode\x12*\n\x11server_ip_address\x18\r\x20\x01(\tR\
    \x0fserverIpAddress\x12\x12\n\x04data\x18\x0e\x20\x01(\x0cR\x04data\x12!\
    \n\x0cis_localonly\x18\x0f\x20\x01(\x08R\x0bisLocalonly\x12&\n\x0fno_ste\
    am_server\x18\x13\x20\x01(\x08R\rnoSteamServer\x12#\n\ris_transition\x18\
    \x10\x20\x01(\x08R\x0cisTransition\x12$\n\rpreviouslevel\x18\x11\x20\x01\
    (\tR\rpreviouslevel\x12\"\n\x0clandmarkname\x18\x12\x20\x01(\tR\x0clandm\
    arkname\"\xf6\x01\n\x14CNETMsg_DebugOverlay\x12\x14\n\x05etype\x18\x01\
    \x20\x01(\x05R\x05etype\x12%\n\x07vectors\x18\x02\x20\x03(\x0b2\x0b.CMsg\
    VectorR\x07vectors\x12!\n\x06colors\x18\x03\x20\x03(\x0b2\t.CMsgRGBAR\
    \x06colors\x12\x1e\n\ndimensions\x18\x04\x20\x03(\x02R\ndimensions\x12\
    \x14\n\x05times\x18\x05\x20\x03(\x02R\x05times\x12\x14\n\x05bools\x18\
    \x06\x20\x03(\x08R\x05bools\x12\x18\n\x07uint64s\x18\x07\x20\x03(\x04R\
    \x07uint64s\x12\x18\n\x07strings\x18\x08\x20\x03(\tR\x07strings*\xd4\x01\
    \n\rSignonState_t\x12\x14\n\x10SIGNONSTATE_NONE\x10\0\x12\x19\n\x15SIGNO\
    NSTATE_CHALLENGE\x10\x01\x12\x19\n\x15SIGNONSTATE_CONNECTED\x10\x02\x12\
    \x13\n\x0fSIGNONSTATE_NEW\x10\x03\x12\x18\n\x14SIGNONSTATE_PRESPAWN\x10\
    \x04\x12\x15\n\x11SIGNONSTATE_SPAWN\x10\x05\x12\x14\n\x10SIGNONSTATE_FUL\
    L\x10\x06\x12\x1b\n\x17SIGNONSTATE_CHANGELEVEL\x10\x07*\xcb\x02\n\x0cNET\
    _Messages\x12\x0b\n\x07net_NOP\x10\0\x12\x19\n\x15net_Disconnect_Legacy\
    \x10\x01\x12\x17\n\x13net_SplitScreenUser\x10\x03\x12\x0c\n\x08net_Tick\
    \x10\x04\x12\x11\n\rnet_StringCmd\x10\x05\x12\x11\n\rnet_SetConVar\x10\
    \x06\x12\x13\n\x0fnet_SignonState\x10\x07\x12\x17\n\x13net_SpawnGroup_Lo\
    ad\x10\x08\x12!\n\x1dnet_SpawnGroup_ManifestUpdate\x10\t\x12\"\n\x1enet_\
    SpawnGroup_SetCreationTick\x10\x0b\x12\x19\n\x15net_SpawnGroup_Unload\
    \x10\x0c\x12\x20\n\x1cnet_SpawnGroup_LoadCompleted\x10\r\x12\x14\n\x10ne\
    t_DebugOverlay\x10\x0f*\xcc\x02\n\x11SpawnGroupFlags_t\x12'\n#SPAWN_GROU\
    P_LOAD_ENTITIES_FROM_SAVE\x10\x01\x12#\n\x1fSPAWN_GROUP_DONT_SPAWN_ENTIT\
    IES\x10\x02\x12!\n\x1dSPAWN_GROUP_SYNCHRONOUS_SPAWN\x10\x04\x12&\n\"SPAW\
    N_GROUP_IS_INITIAL_SPAWN_GROUP\x10\x08\x12+\n'SPAWN_GROUP_CREATE_CLIENT_\
    ONLY_ENTITIES\x10\x10\x12\"\n\x1eSPAWN_GROUP_BLOCK_UNTIL_LOADED\x10@\x12\
    $\n\x1fSPAWN_GROUP_LOAD_STREAMING_DATA\x10\x80\x01\x12'\n\"SPAWN_GROUP_C\
    REATE_NEW_SCENE_WORLD\x10\x80\x02\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::network_connection::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(27);
            messages.push(CMsgVector::generated_message_descriptor_data());
            messages.push(CMsgVector2D::generated_message_descriptor_data());
            messages.push(CMsgQAngle::generated_message_descriptor_data());
            messages.push(CMsgQuaternion::generated_message_descriptor_data());
            messages.push(CMsgTransform::generated_message_descriptor_data());
            messages.push(CMsgRGBA::generated_message_descriptor_data());
            messages.push(CMsgPlayerInfo::generated_message_descriptor_data());
            messages.push(CEntityMsg::generated_message_descriptor_data());
            messages.push(CMsg_CVars::generated_message_descriptor_data());
            messages.push(CNETMsg_NOP::generated_message_descriptor_data());
            messages.push(CNETMsg_SplitScreenUser::generated_message_descriptor_data());
            messages.push(CNETMsg_Tick::generated_message_descriptor_data());
            messages.push(CNETMsg_StringCmd::generated_message_descriptor_data());
            messages.push(CNETMsg_SetConVar::generated_message_descriptor_data());
            messages.push(CNETMsg_SignonState::generated_message_descriptor_data());
            messages.push(CSVCMsg_GameEvent::generated_message_descriptor_data());
            messages.push(CSVCMsgList_GameEvents::generated_message_descriptor_data());
            messages.push(CNETMsg_SpawnGroup_Load::generated_message_descriptor_data());
            messages.push(CNETMsg_SpawnGroup_ManifestUpdate::generated_message_descriptor_data());
            messages.push(CNETMsg_SpawnGroup_SetCreationTick::generated_message_descriptor_data());
            messages.push(CNETMsg_SpawnGroup_Unload::generated_message_descriptor_data());
            messages.push(CNETMsg_SpawnGroup_LoadCompleted::generated_message_descriptor_data());
            messages.push(CSVCMsg_GameSessionConfiguration::generated_message_descriptor_data());
            messages.push(CNETMsg_DebugOverlay::generated_message_descriptor_data());
            messages.push(cmsg_cvars::CVar::generated_message_descriptor_data());
            messages.push(csvcmsg_game_event::Key_t::generated_message_descriptor_data());
            messages.push(csvcmsg_list_game_events::Event_t::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(3);
            enums.push(SignonState_t::generated_enum_descriptor_data());
            enums.push(NET_Messages::generated_enum_descriptor_data());
            enums.push(SpawnGroupFlags_t::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
