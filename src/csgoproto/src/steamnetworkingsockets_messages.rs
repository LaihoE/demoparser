// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.12.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steamnetworkingsockets_messages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgSteamDatagramSessionCryptInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramSessionCryptInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfo.key_type)
    pub key_type: ::std::option::Option<::protobuf::EnumOrUnknown<cmsg_steam_datagram_session_crypt_info::EKeyType>>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfo.key_data)
    pub key_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfo.nonce)
    pub nonce: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfo.protocol_version)
    pub protocol_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfo.ciphers)
    pub ciphers: ::std::vec::Vec<::protobuf::EnumOrUnknown<ESteamNetworkingSocketsCipher>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramSessionCryptInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramSessionCryptInfo {
    fn default() -> &'a CMsgSteamDatagramSessionCryptInfo {
        <CMsgSteamDatagramSessionCryptInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramSessionCryptInfo {
    pub fn new() -> CMsgSteamDatagramSessionCryptInfo {
        ::std::default::Default::default()
    }

    // optional .CMsgSteamDatagramSessionCryptInfo.EKeyType key_type = 1;

    pub fn key_type(&self) -> cmsg_steam_datagram_session_crypt_info::EKeyType {
        match self.key_type {
            Some(e) => e.enum_value_or(cmsg_steam_datagram_session_crypt_info::EKeyType::INVALID),
            None => cmsg_steam_datagram_session_crypt_info::EKeyType::INVALID,
        }
    }

    pub fn clear_key_type(&mut self) {
        self.key_type = ::std::option::Option::None;
    }

    pub fn has_key_type(&self) -> bool {
        self.key_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_type(&mut self, v: cmsg_steam_datagram_session_crypt_info::EKeyType) {
        self.key_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional bytes key_data = 2;

    pub fn key_data(&self) -> &[u8] {
        match self.key_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key_data(&mut self) {
        self.key_data = ::std::option::Option::None;
    }

    pub fn has_key_data(&self) -> bool {
        self.key_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::bytes::Bytes) {
        self.key_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_data(&mut self) -> &mut ::bytes::Bytes {
        if self.key_data.is_none() {
            self.key_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.key_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::bytes::Bytes {
        self.key_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional fixed64 nonce = 3;

    pub fn nonce(&self) -> u64 {
        self.nonce.unwrap_or(0)
    }

    pub fn clear_nonce(&mut self) {
        self.nonce = ::std::option::Option::None;
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: u64) {
        self.nonce = ::std::option::Option::Some(v);
    }

    // optional uint32 protocol_version = 4;

    pub fn protocol_version(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_type",
            |m: &CMsgSteamDatagramSessionCryptInfo| { &m.key_type },
            |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.key_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_data",
            |m: &CMsgSteamDatagramSessionCryptInfo| { &m.key_data },
            |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.key_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nonce",
            |m: &CMsgSteamDatagramSessionCryptInfo| { &m.nonce },
            |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.nonce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol_version",
            |m: &CMsgSteamDatagramSessionCryptInfo| { &m.protocol_version },
            |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.protocol_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ciphers",
            |m: &CMsgSteamDatagramSessionCryptInfo| { &m.ciphers },
            |m: &mut CMsgSteamDatagramSessionCryptInfo| { &mut m.ciphers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramSessionCryptInfo>(
            "CMsgSteamDatagramSessionCryptInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramSessionCryptInfo {
    const NAME: &'static str = "CMsgSteamDatagramSessionCryptInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.key_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.key_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                25 => {
                    self.nonce = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.protocol_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.ciphers.push(is.read_enum_or_unknown()?);
                },
                42 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.ciphers)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_type {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.key_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.nonce {
            my_size += 1 + 8;
        }
        if let Some(v) = self.protocol_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.ciphers {
            my_size += ::protobuf::rt::int32_size(5, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key_type {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.key_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.nonce {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.protocol_version {
            os.write_uint32(4, v)?;
        }
        for v in &self.ciphers {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramSessionCryptInfo {
        CMsgSteamDatagramSessionCryptInfo::new()
    }

    fn clear(&mut self) {
        self.key_type = ::std::option::Option::None;
        self.key_data = ::std::option::Option::None;
        self.nonce = ::std::option::Option::None;
        self.protocol_version = ::std::option::Option::None;
        self.ciphers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramSessionCryptInfo {
        static instance: CMsgSteamDatagramSessionCryptInfo = CMsgSteamDatagramSessionCryptInfo {
            key_type: ::std::option::Option::None,
            key_data: ::std::option::Option::None,
            nonce: ::std::option::Option::None,
            protocol_version: ::std::option::Option::None,
            ciphers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramSessionCryptInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramSessionCryptInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramSessionCryptInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramSessionCryptInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamDatagramSessionCryptInfo`
pub mod cmsg_steam_datagram_session_crypt_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSteamDatagramSessionCryptInfo.EKeyType)
    pub enum EKeyType {
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramSessionCryptInfo.EKeyType.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgSteamDatagramSessionCryptInfo.EKeyType.CURVE25519)
        CURVE25519 = 1,
    }

    impl ::protobuf::Enum for EKeyType {
        const NAME: &'static str = "EKeyType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EKeyType> {
            match value {
                0 => ::std::option::Option::Some(EKeyType::INVALID),
                1 => ::std::option::Option::Some(EKeyType::CURVE25519),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EKeyType> {
            match str {
                "INVALID" => ::std::option::Option::Some(EKeyType::INVALID),
                "CURVE25519" => ::std::option::Option::Some(EKeyType::CURVE25519),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EKeyType] = &[
            EKeyType::INVALID,
            EKeyType::CURVE25519,
        ];
    }

    impl ::protobuf::EnumFull for EKeyType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgSteamDatagramSessionCryptInfo.EKeyType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EKeyType {
        fn default() -> Self {
            EKeyType::INVALID
        }
    }

    impl EKeyType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EKeyType>("CMsgSteamDatagramSessionCryptInfo.EKeyType")
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamDatagramSessionCryptInfoSigned)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramSessionCryptInfoSigned {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfoSigned.info)
    pub info: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramSessionCryptInfoSigned.signature)
    pub signature: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramSessionCryptInfoSigned.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramSessionCryptInfoSigned {
    fn default() -> &'a CMsgSteamDatagramSessionCryptInfoSigned {
        <CMsgSteamDatagramSessionCryptInfoSigned as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramSessionCryptInfoSigned {
    pub fn new() -> CMsgSteamDatagramSessionCryptInfoSigned {
        ::std::default::Default::default()
    }

    // optional bytes info = 1;

    pub fn info(&self) -> &[u8] {
        match self.info.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_info(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::bytes::Bytes) {
        self.info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::bytes::Bytes {
        if self.info.is_none() {
            self.info = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::bytes::Bytes {
        self.info.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes signature = 2;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::bytes::Bytes) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::bytes::Bytes {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::bytes::Bytes {
        self.signature.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "info",
            |m: &CMsgSteamDatagramSessionCryptInfoSigned| { &m.info },
            |m: &mut CMsgSteamDatagramSessionCryptInfoSigned| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &CMsgSteamDatagramSessionCryptInfoSigned| { &m.signature },
            |m: &mut CMsgSteamDatagramSessionCryptInfoSigned| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramSessionCryptInfoSigned>(
            "CMsgSteamDatagramSessionCryptInfoSigned",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramSessionCryptInfoSigned {
    const NAME: &'static str = "CMsgSteamDatagramSessionCryptInfoSigned";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.info = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                18 => {
                    self.signature = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramSessionCryptInfoSigned {
        CMsgSteamDatagramSessionCryptInfoSigned::new()
    }

    fn clear(&mut self) {
        self.info = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramSessionCryptInfoSigned {
        static instance: CMsgSteamDatagramSessionCryptInfoSigned = CMsgSteamDatagramSessionCryptInfoSigned {
            info: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramSessionCryptInfoSigned {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramSessionCryptInfoSigned").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramSessionCryptInfoSigned {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramSessionCryptInfoSigned {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramDiagnostic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramDiagnostic {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramDiagnostic.severity)
    pub severity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramDiagnostic.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramDiagnostic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramDiagnostic {
    fn default() -> &'a CMsgSteamDatagramDiagnostic {
        <CMsgSteamDatagramDiagnostic as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramDiagnostic {
    pub fn new() -> CMsgSteamDatagramDiagnostic {
        ::std::default::Default::default()
    }

    // optional uint32 severity = 1;

    pub fn severity(&self) -> u32 {
        self.severity.unwrap_or(0)
    }

    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: u32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "severity",
            |m: &CMsgSteamDatagramDiagnostic| { &m.severity },
            |m: &mut CMsgSteamDatagramDiagnostic| { &mut m.severity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgSteamDatagramDiagnostic| { &m.text },
            |m: &mut CMsgSteamDatagramDiagnostic| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramDiagnostic>(
            "CMsgSteamDatagramDiagnostic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramDiagnostic {
    const NAME: &'static str = "CMsgSteamDatagramDiagnostic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.severity = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.severity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramDiagnostic {
        CMsgSteamDatagramDiagnostic::new()
    }

    fn clear(&mut self) {
        self.severity = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramDiagnostic {
        static instance: CMsgSteamDatagramDiagnostic = CMsgSteamDatagramDiagnostic {
            severity: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramDiagnostic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramDiagnostic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramDiagnostic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramDiagnostic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramLinkInstantaneousStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramLinkInstantaneousStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.out_packets_per_sec_x10)
    pub out_packets_per_sec_x10: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.out_bytes_per_sec)
    pub out_bytes_per_sec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.in_packets_per_sec_x10)
    pub in_packets_per_sec_x10: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.in_bytes_per_sec)
    pub in_bytes_per_sec: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.ping_ms)
    pub ping_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.packets_dropped_pct)
    pub packets_dropped_pct: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.packets_weird_sequence_pct)
    pub packets_weird_sequence_pct: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkInstantaneousStats.peak_jitter_usec)
    pub peak_jitter_usec: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramLinkInstantaneousStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLinkInstantaneousStats {
    fn default() -> &'a CMsgSteamDatagramLinkInstantaneousStats {
        <CMsgSteamDatagramLinkInstantaneousStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLinkInstantaneousStats {
    pub fn new() -> CMsgSteamDatagramLinkInstantaneousStats {
        ::std::default::Default::default()
    }

    // optional uint32 out_packets_per_sec_x10 = 1;

    pub fn out_packets_per_sec_x10(&self) -> u32 {
        self.out_packets_per_sec_x10.unwrap_or(0)
    }

    pub fn clear_out_packets_per_sec_x10(&mut self) {
        self.out_packets_per_sec_x10 = ::std::option::Option::None;
    }

    pub fn has_out_packets_per_sec_x10(&self) -> bool {
        self.out_packets_per_sec_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_packets_per_sec_x10(&mut self, v: u32) {
        self.out_packets_per_sec_x10 = ::std::option::Option::Some(v);
    }

    // optional uint32 out_bytes_per_sec = 2;

    pub fn out_bytes_per_sec(&self) -> u32 {
        self.out_bytes_per_sec.unwrap_or(0)
    }

    pub fn clear_out_bytes_per_sec(&mut self) {
        self.out_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_out_bytes_per_sec(&self) -> bool {
        self.out_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_bytes_per_sec(&mut self, v: u32) {
        self.out_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 in_packets_per_sec_x10 = 3;

    pub fn in_packets_per_sec_x10(&self) -> u32 {
        self.in_packets_per_sec_x10.unwrap_or(0)
    }

    pub fn clear_in_packets_per_sec_x10(&mut self) {
        self.in_packets_per_sec_x10 = ::std::option::Option::None;
    }

    pub fn has_in_packets_per_sec_x10(&self) -> bool {
        self.in_packets_per_sec_x10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_packets_per_sec_x10(&mut self, v: u32) {
        self.in_packets_per_sec_x10 = ::std::option::Option::Some(v);
    }

    // optional uint32 in_bytes_per_sec = 4;

    pub fn in_bytes_per_sec(&self) -> u32 {
        self.in_bytes_per_sec.unwrap_or(0)
    }

    pub fn clear_in_bytes_per_sec(&mut self) {
        self.in_bytes_per_sec = ::std::option::Option::None;
    }

    pub fn has_in_bytes_per_sec(&self) -> bool {
        self.in_bytes_per_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_bytes_per_sec(&mut self, v: u32) {
        self.in_bytes_per_sec = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ms = 5;

    pub fn ping_ms(&self) -> u32 {
        self.ping_ms.unwrap_or(0)
    }

    pub fn clear_ping_ms(&mut self) {
        self.ping_ms = ::std::option::Option::None;
    }

    pub fn has_ping_ms(&self) -> bool {
        self.ping_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms(&mut self, v: u32) {
        self.ping_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 packets_dropped_pct = 6;

    pub fn packets_dropped_pct(&self) -> u32 {
        self.packets_dropped_pct.unwrap_or(0)
    }

    pub fn clear_packets_dropped_pct(&mut self) {
        self.packets_dropped_pct = ::std::option::Option::None;
    }

    pub fn has_packets_dropped_pct(&self) -> bool {
        self.packets_dropped_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_dropped_pct(&mut self, v: u32) {
        self.packets_dropped_pct = ::std::option::Option::Some(v);
    }

    // optional uint32 packets_weird_sequence_pct = 7;

    pub fn packets_weird_sequence_pct(&self) -> u32 {
        self.packets_weird_sequence_pct.unwrap_or(0)
    }

    pub fn clear_packets_weird_sequence_pct(&mut self) {
        self.packets_weird_sequence_pct = ::std::option::Option::None;
    }

    pub fn has_packets_weird_sequence_pct(&self) -> bool {
        self.packets_weird_sequence_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_weird_sequence_pct(&mut self, v: u32) {
        self.packets_weird_sequence_pct = ::std::option::Option::Some(v);
    }

    // optional uint32 peak_jitter_usec = 8;

    pub fn peak_jitter_usec(&self) -> u32 {
        self.peak_jitter_usec.unwrap_or(0)
    }

    pub fn clear_peak_jitter_usec(&mut self) {
        self.peak_jitter_usec = ::std::option::Option::None;
    }

    pub fn has_peak_jitter_usec(&self) -> bool {
        self.peak_jitter_usec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_peak_jitter_usec(&mut self, v: u32) {
        self.peak_jitter_usec = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "out_packets_per_sec_x10",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.out_packets_per_sec_x10 },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.out_packets_per_sec_x10 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "out_bytes_per_sec",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.out_bytes_per_sec },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.out_bytes_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_packets_per_sec_x10",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.in_packets_per_sec_x10 },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.in_packets_per_sec_x10 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_bytes_per_sec",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.in_bytes_per_sec },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.in_bytes_per_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_ms",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.ping_ms },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.ping_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_dropped_pct",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.packets_dropped_pct },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.packets_dropped_pct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_weird_sequence_pct",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.packets_weird_sequence_pct },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.packets_weird_sequence_pct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "peak_jitter_usec",
            |m: &CMsgSteamDatagramLinkInstantaneousStats| { &m.peak_jitter_usec },
            |m: &mut CMsgSteamDatagramLinkInstantaneousStats| { &mut m.peak_jitter_usec },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramLinkInstantaneousStats>(
            "CMsgSteamDatagramLinkInstantaneousStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramLinkInstantaneousStats {
    const NAME: &'static str = "CMsgSteamDatagramLinkInstantaneousStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.out_packets_per_sec_x10 = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.out_bytes_per_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.in_packets_per_sec_x10 = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.in_bytes_per_sec = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.packets_dropped_pct = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.packets_weird_sequence_pct = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.peak_jitter_usec = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.out_packets_per_sec_x10 {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.out_bytes_per_sec {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.in_packets_per_sec_x10 {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.in_bytes_per_sec {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ping_ms {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.packets_dropped_pct {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.packets_weird_sequence_pct {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.peak_jitter_usec {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.out_packets_per_sec_x10 {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.out_bytes_per_sec {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.in_packets_per_sec_x10 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_bytes_per_sec {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ping_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.packets_dropped_pct {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.packets_weird_sequence_pct {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.peak_jitter_usec {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramLinkInstantaneousStats {
        CMsgSteamDatagramLinkInstantaneousStats::new()
    }

    fn clear(&mut self) {
        self.out_packets_per_sec_x10 = ::std::option::Option::None;
        self.out_bytes_per_sec = ::std::option::Option::None;
        self.in_packets_per_sec_x10 = ::std::option::Option::None;
        self.in_bytes_per_sec = ::std::option::Option::None;
        self.ping_ms = ::std::option::Option::None;
        self.packets_dropped_pct = ::std::option::Option::None;
        self.packets_weird_sequence_pct = ::std::option::Option::None;
        self.peak_jitter_usec = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramLinkInstantaneousStats {
        static instance: CMsgSteamDatagramLinkInstantaneousStats = CMsgSteamDatagramLinkInstantaneousStats {
            out_packets_per_sec_x10: ::std::option::Option::None,
            out_bytes_per_sec: ::std::option::Option::None,
            in_packets_per_sec_x10: ::std::option::Option::None,
            in_bytes_per_sec: ::std::option::Option::None,
            ping_ms: ::std::option::Option::None,
            packets_dropped_pct: ::std::option::Option::None,
            packets_weird_sequence_pct: ::std::option::Option::None,
            peak_jitter_usec: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramLinkInstantaneousStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramLinkInstantaneousStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramLinkInstantaneousStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramLinkInstantaneousStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramLinkLifetimeStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramLinkLifetimeStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.connected_seconds)
    pub connected_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_sent)
    pub packets_sent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.kb_sent)
    pub kb_sent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv)
    pub packets_recv: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.kb_recv)
    pub kb_recv: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_sequenced)
    pub packets_recv_sequenced: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_dropped)
    pub packets_recv_dropped: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_out_of_order)
    pub packets_recv_out_of_order: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_out_of_order_corrected)
    pub packets_recv_out_of_order_corrected: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_duplicate)
    pub packets_recv_duplicate: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.packets_recv_lurch)
    pub packets_recv_lurch: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.multipath_packets_recv_sequenced)
    pub multipath_packets_recv_sequenced: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.multipath_packets_recv_later)
    pub multipath_packets_recv_later: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.multipath_send_enabled)
    pub multipath_send_enabled: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_100)
    pub quality_histogram_100: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_99)
    pub quality_histogram_99: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_97)
    pub quality_histogram_97: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_95)
    pub quality_histogram_95: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_90)
    pub quality_histogram_90: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_75)
    pub quality_histogram_75: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_50)
    pub quality_histogram_50: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_1)
    pub quality_histogram_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_histogram_dead)
    pub quality_histogram_dead: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_ntile_2nd)
    pub quality_ntile_2nd: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_ntile_5th)
    pub quality_ntile_5th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_ntile_25th)
    pub quality_ntile_25th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.quality_ntile_50th)
    pub quality_ntile_50th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_25)
    pub ping_histogram_25: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_50)
    pub ping_histogram_50: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_75)
    pub ping_histogram_75: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_100)
    pub ping_histogram_100: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_125)
    pub ping_histogram_125: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_150)
    pub ping_histogram_150: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_200)
    pub ping_histogram_200: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_300)
    pub ping_histogram_300: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_histogram_max)
    pub ping_histogram_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_ntile_5th)
    pub ping_ntile_5th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_ntile_50th)
    pub ping_ntile_50th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_ntile_75th)
    pub ping_ntile_75th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_ntile_95th)
    pub ping_ntile_95th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.ping_ntile_98th)
    pub ping_ntile_98th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_negligible)
    pub jitter_histogram_negligible: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_1)
    pub jitter_histogram_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_2)
    pub jitter_histogram_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_5)
    pub jitter_histogram_5: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_10)
    pub jitter_histogram_10: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.jitter_histogram_20)
    pub jitter_histogram_20: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_max)
    pub txspeed_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_16)
    pub txspeed_histogram_16: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_32)
    pub txspeed_histogram_32: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_64)
    pub txspeed_histogram_64: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_128)
    pub txspeed_histogram_128: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_256)
    pub txspeed_histogram_256: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_512)
    pub txspeed_histogram_512: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_1024)
    pub txspeed_histogram_1024: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_histogram_max)
    pub txspeed_histogram_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_ntile_5th)
    pub txspeed_ntile_5th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_ntile_50th)
    pub txspeed_ntile_50th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_ntile_75th)
    pub txspeed_ntile_75th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_ntile_95th)
    pub txspeed_ntile_95th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.txspeed_ntile_98th)
    pub txspeed_ntile_98th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_max)
    pub rxspeed_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_16)
    pub rxspeed_histogram_16: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_32)
    pub rxspeed_histogram_32: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_64)
    pub rxspeed_histogram_64: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_128)
    pub rxspeed_histogram_128: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_256)
    pub rxspeed_histogram_256: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_512)
    pub rxspeed_histogram_512: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_1024)
    pub rxspeed_histogram_1024: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_histogram_max)
    pub rxspeed_histogram_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_ntile_5th)
    pub rxspeed_ntile_5th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_ntile_50th)
    pub rxspeed_ntile_50th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_ntile_75th)
    pub rxspeed_ntile_75th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_ntile_95th)
    pub rxspeed_ntile_95th: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramLinkLifetimeStats.rxspeed_ntile_98th)
    pub rxspeed_ntile_98th: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramLinkLifetimeStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramLinkLifetimeStats {
    fn default() -> &'a CMsgSteamDatagramLinkLifetimeStats {
        <CMsgSteamDatagramLinkLifetimeStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramLinkLifetimeStats {
    pub fn new() -> CMsgSteamDatagramLinkLifetimeStats {
        ::std::default::Default::default()
    }

    // optional uint32 connected_seconds = 2;

    pub fn connected_seconds(&self) -> u32 {
        self.connected_seconds.unwrap_or(0)
    }

    pub fn clear_connected_seconds(&mut self) {
        self.connected_seconds = ::std::option::Option::None;
    }

    pub fn has_connected_seconds(&self) -> bool {
        self.connected_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connected_seconds(&mut self, v: u32) {
        self.connected_seconds = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_sent = 3;

    pub fn packets_sent(&self) -> u64 {
        self.packets_sent.unwrap_or(0)
    }

    pub fn clear_packets_sent(&mut self) {
        self.packets_sent = ::std::option::Option::None;
    }

    pub fn has_packets_sent(&self) -> bool {
        self.packets_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_sent(&mut self, v: u64) {
        self.packets_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 kb_sent = 4;

    pub fn kb_sent(&self) -> u64 {
        self.kb_sent.unwrap_or(0)
    }

    pub fn clear_kb_sent(&mut self) {
        self.kb_sent = ::std::option::Option::None;
    }

    pub fn has_kb_sent(&self) -> bool {
        self.kb_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kb_sent(&mut self, v: u64) {
        self.kb_sent = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv = 5;

    pub fn packets_recv(&self) -> u64 {
        self.packets_recv.unwrap_or(0)
    }

    pub fn clear_packets_recv(&mut self) {
        self.packets_recv = ::std::option::Option::None;
    }

    pub fn has_packets_recv(&self) -> bool {
        self.packets_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv(&mut self, v: u64) {
        self.packets_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 kb_recv = 6;

    pub fn kb_recv(&self) -> u64 {
        self.kb_recv.unwrap_or(0)
    }

    pub fn clear_kb_recv(&mut self) {
        self.kb_recv = ::std::option::Option::None;
    }

    pub fn has_kb_recv(&self) -> bool {
        self.kb_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kb_recv(&mut self, v: u64) {
        self.kb_recv = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_sequenced = 7;

    pub fn packets_recv_sequenced(&self) -> u64 {
        self.packets_recv_sequenced.unwrap_or(0)
    }

    pub fn clear_packets_recv_sequenced(&mut self) {
        self.packets_recv_sequenced = ::std::option::Option::None;
    }

    pub fn has_packets_recv_sequenced(&self) -> bool {
        self.packets_recv_sequenced.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_sequenced(&mut self, v: u64) {
        self.packets_recv_sequenced = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_dropped = 8;

    pub fn packets_recv_dropped(&self) -> u64 {
        self.packets_recv_dropped.unwrap_or(0)
    }

    pub fn clear_packets_recv_dropped(&mut self) {
        self.packets_recv_dropped = ::std::option::Option::None;
    }

    pub fn has_packets_recv_dropped(&self) -> bool {
        self.packets_recv_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_dropped(&mut self, v: u64) {
        self.packets_recv_dropped = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_out_of_order = 9;

    pub fn packets_recv_out_of_order(&self) -> u64 {
        self.packets_recv_out_of_order.unwrap_or(0)
    }

    pub fn clear_packets_recv_out_of_order(&mut self) {
        self.packets_recv_out_of_order = ::std::option::Option::None;
    }

    pub fn has_packets_recv_out_of_order(&self) -> bool {
        self.packets_recv_out_of_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_out_of_order(&mut self, v: u64) {
        self.packets_recv_out_of_order = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_out_of_order_corrected = 15;

    pub fn packets_recv_out_of_order_corrected(&self) -> u64 {
        self.packets_recv_out_of_order_corrected.unwrap_or(0)
    }

    pub fn clear_packets_recv_out_of_order_corrected(&mut self) {
        self.packets_recv_out_of_order_corrected = ::std::option::Option::None;
    }

    pub fn has_packets_recv_out_of_order_corrected(&self) -> bool {
        self.packets_recv_out_of_order_corrected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_out_of_order_corrected(&mut self, v: u64) {
        self.packets_recv_out_of_order_corrected = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_duplicate = 10;

    pub fn packets_recv_duplicate(&self) -> u64 {
        self.packets_recv_duplicate.unwrap_or(0)
    }

    pub fn clear_packets_recv_duplicate(&mut self) {
        self.packets_recv_duplicate = ::std::option::Option::None;
    }

    pub fn has_packets_recv_duplicate(&self) -> bool {
        self.packets_recv_duplicate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_duplicate(&mut self, v: u64) {
        self.packets_recv_duplicate = ::std::option::Option::Some(v);
    }

    // optional uint64 packets_recv_lurch = 11;

    pub fn packets_recv_lurch(&self) -> u64 {
        self.packets_recv_lurch.unwrap_or(0)
    }

    pub fn clear_packets_recv_lurch(&mut self) {
        self.packets_recv_lurch = ::std::option::Option::None;
    }

    pub fn has_packets_recv_lurch(&self) -> bool {
        self.packets_recv_lurch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets_recv_lurch(&mut self, v: u64) {
        self.packets_recv_lurch = ::std::option::Option::Some(v);
    }

    // optional uint32 multipath_send_enabled = 14;

    pub fn multipath_send_enabled(&self) -> u32 {
        self.multipath_send_enabled.unwrap_or(0)
    }

    pub fn clear_multipath_send_enabled(&mut self) {
        self.multipath_send_enabled = ::std::option::Option::None;
    }

    pub fn has_multipath_send_enabled(&self) -> bool {
        self.multipath_send_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multipath_send_enabled(&mut self, v: u32) {
        self.multipath_send_enabled = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_100 = 21;

    pub fn quality_histogram_100(&self) -> u32 {
        self.quality_histogram_100.unwrap_or(0)
    }

    pub fn clear_quality_histogram_100(&mut self) {
        self.quality_histogram_100 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_100(&self) -> bool {
        self.quality_histogram_100.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_100(&mut self, v: u32) {
        self.quality_histogram_100 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_99 = 22;

    pub fn quality_histogram_99(&self) -> u32 {
        self.quality_histogram_99.unwrap_or(0)
    }

    pub fn clear_quality_histogram_99(&mut self) {
        self.quality_histogram_99 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_99(&self) -> bool {
        self.quality_histogram_99.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_99(&mut self, v: u32) {
        self.quality_histogram_99 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_97 = 23;

    pub fn quality_histogram_97(&self) -> u32 {
        self.quality_histogram_97.unwrap_or(0)
    }

    pub fn clear_quality_histogram_97(&mut self) {
        self.quality_histogram_97 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_97(&self) -> bool {
        self.quality_histogram_97.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_97(&mut self, v: u32) {
        self.quality_histogram_97 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_95 = 24;

    pub fn quality_histogram_95(&self) -> u32 {
        self.quality_histogram_95.unwrap_or(0)
    }

    pub fn clear_quality_histogram_95(&mut self) {
        self.quality_histogram_95 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_95(&self) -> bool {
        self.quality_histogram_95.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_95(&mut self, v: u32) {
        self.quality_histogram_95 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_90 = 25;

    pub fn quality_histogram_90(&self) -> u32 {
        self.quality_histogram_90.unwrap_or(0)
    }

    pub fn clear_quality_histogram_90(&mut self) {
        self.quality_histogram_90 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_90(&self) -> bool {
        self.quality_histogram_90.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_90(&mut self, v: u32) {
        self.quality_histogram_90 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_75 = 26;

    pub fn quality_histogram_75(&self) -> u32 {
        self.quality_histogram_75.unwrap_or(0)
    }

    pub fn clear_quality_histogram_75(&mut self) {
        self.quality_histogram_75 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_75(&self) -> bool {
        self.quality_histogram_75.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_75(&mut self, v: u32) {
        self.quality_histogram_75 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_50 = 27;

    pub fn quality_histogram_50(&self) -> u32 {
        self.quality_histogram_50.unwrap_or(0)
    }

    pub fn clear_quality_histogram_50(&mut self) {
        self.quality_histogram_50 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_50(&self) -> bool {
        self.quality_histogram_50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_50(&mut self, v: u32) {
        self.quality_histogram_50 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_1 = 28;

    pub fn quality_histogram_1(&self) -> u32 {
        self.quality_histogram_1.unwrap_or(0)
    }

    pub fn clear_quality_histogram_1(&mut self) {
        self.quality_histogram_1 = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_1(&self) -> bool {
        self.quality_histogram_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_1(&mut self, v: u32) {
        self.quality_histogram_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_histogram_dead = 29;

    pub fn quality_histogram_dead(&self) -> u32 {
        self.quality_histogram_dead.unwrap_or(0)
    }

    pub fn clear_quality_histogram_dead(&mut self) {
        self.quality_histogram_dead = ::std::option::Option::None;
    }

    pub fn has_quality_histogram_dead(&self) -> bool {
        self.quality_histogram_dead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_histogram_dead(&mut self, v: u32) {
        self.quality_histogram_dead = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_2nd = 30;

    pub fn quality_ntile_2nd(&self) -> u32 {
        self.quality_ntile_2nd.unwrap_or(0)
    }

    pub fn clear_quality_ntile_2nd(&mut self) {
        self.quality_ntile_2nd = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_2nd(&self) -> bool {
        self.quality_ntile_2nd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_2nd(&mut self, v: u32) {
        self.quality_ntile_2nd = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_5th = 31;

    pub fn quality_ntile_5th(&self) -> u32 {
        self.quality_ntile_5th.unwrap_or(0)
    }

    pub fn clear_quality_ntile_5th(&mut self) {
        self.quality_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_5th(&self) -> bool {
        self.quality_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_5th(&mut self, v: u32) {
        self.quality_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_25th = 32;

    pub fn quality_ntile_25th(&self) -> u32 {
        self.quality_ntile_25th.unwrap_or(0)
    }

    pub fn clear_quality_ntile_25th(&mut self) {
        self.quality_ntile_25th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_25th(&self) -> bool {
        self.quality_ntile_25th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_25th(&mut self, v: u32) {
        self.quality_ntile_25th = ::std::option::Option::Some(v);
    }

    // optional uint32 quality_ntile_50th = 33;

    pub fn quality_ntile_50th(&self) -> u32 {
        self.quality_ntile_50th.unwrap_or(0)
    }

    pub fn clear_quality_ntile_50th(&mut self) {
        self.quality_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_quality_ntile_50th(&self) -> bool {
        self.quality_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_ntile_50th(&mut self, v: u32) {
        self.quality_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_25 = 41;

    pub fn ping_histogram_25(&self) -> u32 {
        self.ping_histogram_25.unwrap_or(0)
    }

    pub fn clear_ping_histogram_25(&mut self) {
        self.ping_histogram_25 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_25(&self) -> bool {
        self.ping_histogram_25.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_25(&mut self, v: u32) {
        self.ping_histogram_25 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_50 = 42;

    pub fn ping_histogram_50(&self) -> u32 {
        self.ping_histogram_50.unwrap_or(0)
    }

    pub fn clear_ping_histogram_50(&mut self) {
        self.ping_histogram_50 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_50(&self) -> bool {
        self.ping_histogram_50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_50(&mut self, v: u32) {
        self.ping_histogram_50 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_75 = 43;

    pub fn ping_histogram_75(&self) -> u32 {
        self.ping_histogram_75.unwrap_or(0)
    }

    pub fn clear_ping_histogram_75(&mut self) {
        self.ping_histogram_75 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_75(&self) -> bool {
        self.ping_histogram_75.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_75(&mut self, v: u32) {
        self.ping_histogram_75 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_100 = 44;

    pub fn ping_histogram_100(&self) -> u32 {
        self.ping_histogram_100.unwrap_or(0)
    }

    pub fn clear_ping_histogram_100(&mut self) {
        self.ping_histogram_100 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_100(&self) -> bool {
        self.ping_histogram_100.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_100(&mut self, v: u32) {
        self.ping_histogram_100 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_125 = 45;

    pub fn ping_histogram_125(&self) -> u32 {
        self.ping_histogram_125.unwrap_or(0)
    }

    pub fn clear_ping_histogram_125(&mut self) {
        self.ping_histogram_125 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_125(&self) -> bool {
        self.ping_histogram_125.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_125(&mut self, v: u32) {
        self.ping_histogram_125 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_150 = 46;

    pub fn ping_histogram_150(&self) -> u32 {
        self.ping_histogram_150.unwrap_or(0)
    }

    pub fn clear_ping_histogram_150(&mut self) {
        self.ping_histogram_150 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_150(&self) -> bool {
        self.ping_histogram_150.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_150(&mut self, v: u32) {
        self.ping_histogram_150 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_200 = 47;

    pub fn ping_histogram_200(&self) -> u32 {
        self.ping_histogram_200.unwrap_or(0)
    }

    pub fn clear_ping_histogram_200(&mut self) {
        self.ping_histogram_200 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_200(&self) -> bool {
        self.ping_histogram_200.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_200(&mut self, v: u32) {
        self.ping_histogram_200 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_300 = 48;

    pub fn ping_histogram_300(&self) -> u32 {
        self.ping_histogram_300.unwrap_or(0)
    }

    pub fn clear_ping_histogram_300(&mut self) {
        self.ping_histogram_300 = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_300(&self) -> bool {
        self.ping_histogram_300.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_300(&mut self, v: u32) {
        self.ping_histogram_300 = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_histogram_max = 49;

    pub fn ping_histogram_max(&self) -> u32 {
        self.ping_histogram_max.unwrap_or(0)
    }

    pub fn clear_ping_histogram_max(&mut self) {
        self.ping_histogram_max = ::std::option::Option::None;
    }

    pub fn has_ping_histogram_max(&self) -> bool {
        self.ping_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_histogram_max(&mut self, v: u32) {
        self.ping_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_5th = 50;

    pub fn ping_ntile_5th(&self) -> u32 {
        self.ping_ntile_5th.unwrap_or(0)
    }

    pub fn clear_ping_ntile_5th(&mut self) {
        self.ping_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_5th(&self) -> bool {
        self.ping_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_5th(&mut self, v: u32) {
        self.ping_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_50th = 51;

    pub fn ping_ntile_50th(&self) -> u32 {
        self.ping_ntile_50th.unwrap_or(0)
    }

    pub fn clear_ping_ntile_50th(&mut self) {
        self.ping_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_50th(&self) -> bool {
        self.ping_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_50th(&mut self, v: u32) {
        self.ping_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_75th = 52;

    pub fn ping_ntile_75th(&self) -> u32 {
        self.ping_ntile_75th.unwrap_or(0)
    }

    pub fn clear_ping_ntile_75th(&mut self) {
        self.ping_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_75th(&self) -> bool {
        self.ping_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_75th(&mut self, v: u32) {
        self.ping_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_95th = 53;

    pub fn ping_ntile_95th(&self) -> u32 {
        self.ping_ntile_95th.unwrap_or(0)
    }

    pub fn clear_ping_ntile_95th(&mut self) {
        self.ping_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_95th(&self) -> bool {
        self.ping_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_95th(&mut self, v: u32) {
        self.ping_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 ping_ntile_98th = 54;

    pub fn ping_ntile_98th(&self) -> u32 {
        self.ping_ntile_98th.unwrap_or(0)
    }

    pub fn clear_ping_ntile_98th(&mut self) {
        self.ping_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_ping_ntile_98th(&self) -> bool {
        self.ping_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ntile_98th(&mut self, v: u32) {
        self.ping_ntile_98th = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_negligible = 61;

    pub fn jitter_histogram_negligible(&self) -> u32 {
        self.jitter_histogram_negligible.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_negligible(&mut self) {
        self.jitter_histogram_negligible = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_negligible(&self) -> bool {
        self.jitter_histogram_negligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_negligible(&mut self, v: u32) {
        self.jitter_histogram_negligible = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_1 = 62;

    pub fn jitter_histogram_1(&self) -> u32 {
        self.jitter_histogram_1.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_1(&mut self) {
        self.jitter_histogram_1 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_1(&self) -> bool {
        self.jitter_histogram_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_1(&mut self, v: u32) {
        self.jitter_histogram_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_2 = 63;

    pub fn jitter_histogram_2(&self) -> u32 {
        self.jitter_histogram_2.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_2(&mut self) {
        self.jitter_histogram_2 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_2(&self) -> bool {
        self.jitter_histogram_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_2(&mut self, v: u32) {
        self.jitter_histogram_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_5 = 64;

    pub fn jitter_histogram_5(&self) -> u32 {
        self.jitter_histogram_5.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_5(&mut self) {
        self.jitter_histogram_5 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_5(&self) -> bool {
        self.jitter_histogram_5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_5(&mut self, v: u32) {
        self.jitter_histogram_5 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_10 = 65;

    pub fn jitter_histogram_10(&self) -> u32 {
        self.jitter_histogram_10.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_10(&mut self) {
        self.jitter_histogram_10 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_10(&self) -> bool {
        self.jitter_histogram_10.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_10(&mut self, v: u32) {
        self.jitter_histogram_10 = ::std::option::Option::Some(v);
    }

    // optional uint32 jitter_histogram_20 = 66;

    pub fn jitter_histogram_20(&self) -> u32 {
        self.jitter_histogram_20.unwrap_or(0)
    }

    pub fn clear_jitter_histogram_20(&mut self) {
        self.jitter_histogram_20 = ::std::option::Option::None;
    }

    pub fn has_jitter_histogram_20(&self) -> bool {
        self.jitter_histogram_20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jitter_histogram_20(&mut self, v: u32) {
        self.jitter_histogram_20 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_max = 67;

    pub fn txspeed_max(&self) -> u32 {
        self.txspeed_max.unwrap_or(0)
    }

    pub fn clear_txspeed_max(&mut self) {
        self.txspeed_max = ::std::option::Option::None;
    }

    pub fn has_txspeed_max(&self) -> bool {
        self.txspeed_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_max(&mut self, v: u32) {
        self.txspeed_max = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_16 = 68;

    pub fn txspeed_histogram_16(&self) -> u32 {
        self.txspeed_histogram_16.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_16(&mut self) {
        self.txspeed_histogram_16 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_16(&self) -> bool {
        self.txspeed_histogram_16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_16(&mut self, v: u32) {
        self.txspeed_histogram_16 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_32 = 69;

    pub fn txspeed_histogram_32(&self) -> u32 {
        self.txspeed_histogram_32.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_32(&mut self) {
        self.txspeed_histogram_32 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_32(&self) -> bool {
        self.txspeed_histogram_32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_32(&mut self, v: u32) {
        self.txspeed_histogram_32 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_64 = 70;

    pub fn txspeed_histogram_64(&self) -> u32 {
        self.txspeed_histogram_64.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_64(&mut self) {
        self.txspeed_histogram_64 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_64(&self) -> bool {
        self.txspeed_histogram_64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_64(&mut self, v: u32) {
        self.txspeed_histogram_64 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_128 = 71;

    pub fn txspeed_histogram_128(&self) -> u32 {
        self.txspeed_histogram_128.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_128(&mut self) {
        self.txspeed_histogram_128 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_128(&self) -> bool {
        self.txspeed_histogram_128.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_128(&mut self, v: u32) {
        self.txspeed_histogram_128 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_256 = 72;

    pub fn txspeed_histogram_256(&self) -> u32 {
        self.txspeed_histogram_256.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_256(&mut self) {
        self.txspeed_histogram_256 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_256(&self) -> bool {
        self.txspeed_histogram_256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_256(&mut self, v: u32) {
        self.txspeed_histogram_256 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_512 = 73;

    pub fn txspeed_histogram_512(&self) -> u32 {
        self.txspeed_histogram_512.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_512(&mut self) {
        self.txspeed_histogram_512 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_512(&self) -> bool {
        self.txspeed_histogram_512.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_512(&mut self, v: u32) {
        self.txspeed_histogram_512 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_1024 = 74;

    pub fn txspeed_histogram_1024(&self) -> u32 {
        self.txspeed_histogram_1024.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_1024(&mut self) {
        self.txspeed_histogram_1024 = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_1024(&self) -> bool {
        self.txspeed_histogram_1024.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_1024(&mut self, v: u32) {
        self.txspeed_histogram_1024 = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_histogram_max = 75;

    pub fn txspeed_histogram_max(&self) -> u32 {
        self.txspeed_histogram_max.unwrap_or(0)
    }

    pub fn clear_txspeed_histogram_max(&mut self) {
        self.txspeed_histogram_max = ::std::option::Option::None;
    }

    pub fn has_txspeed_histogram_max(&self) -> bool {
        self.txspeed_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_histogram_max(&mut self, v: u32) {
        self.txspeed_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_5th = 76;

    pub fn txspeed_ntile_5th(&self) -> u32 {
        self.txspeed_ntile_5th.unwrap_or(0)
    }

    pub fn clear_txspeed_ntile_5th(&mut self) {
        self.txspeed_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_5th(&self) -> bool {
        self.txspeed_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_5th(&mut self, v: u32) {
        self.txspeed_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_50th = 77;

    pub fn txspeed_ntile_50th(&self) -> u32 {
        self.txspeed_ntile_50th.unwrap_or(0)
    }

    pub fn clear_txspeed_ntile_50th(&mut self) {
        self.txspeed_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_50th(&self) -> bool {
        self.txspeed_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_50th(&mut self, v: u32) {
        self.txspeed_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_75th = 78;

    pub fn txspeed_ntile_75th(&self) -> u32 {
        self.txspeed_ntile_75th.unwrap_or(0)
    }

    pub fn clear_txspeed_ntile_75th(&mut self) {
        self.txspeed_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_75th(&self) -> bool {
        self.txspeed_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_75th(&mut self, v: u32) {
        self.txspeed_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_95th = 79;

    pub fn txspeed_ntile_95th(&self) -> u32 {
        self.txspeed_ntile_95th.unwrap_or(0)
    }

    pub fn clear_txspeed_ntile_95th(&mut self) {
        self.txspeed_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_95th(&self) -> bool {
        self.txspeed_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_95th(&mut self, v: u32) {
        self.txspeed_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 txspeed_ntile_98th = 80;

    pub fn txspeed_ntile_98th(&self) -> u32 {
        self.txspeed_ntile_98th.unwrap_or(0)
    }

    pub fn clear_txspeed_ntile_98th(&mut self) {
        self.txspeed_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_txspeed_ntile_98th(&self) -> bool {
        self.txspeed_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txspeed_ntile_98th(&mut self, v: u32) {
        self.txspeed_ntile_98th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_max = 81;

    pub fn rxspeed_max(&self) -> u32 {
        self.rxspeed_max.unwrap_or(0)
    }

    pub fn clear_rxspeed_max(&mut self) {
        self.rxspeed_max = ::std::option::Option::None;
    }

    pub fn has_rxspeed_max(&self) -> bool {
        self.rxspeed_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_max(&mut self, v: u32) {
        self.rxspeed_max = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_16 = 82;

    pub fn rxspeed_histogram_16(&self) -> u32 {
        self.rxspeed_histogram_16.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_16(&mut self) {
        self.rxspeed_histogram_16 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_16(&self) -> bool {
        self.rxspeed_histogram_16.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_16(&mut self, v: u32) {
        self.rxspeed_histogram_16 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_32 = 83;

    pub fn rxspeed_histogram_32(&self) -> u32 {
        self.rxspeed_histogram_32.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_32(&mut self) {
        self.rxspeed_histogram_32 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_32(&self) -> bool {
        self.rxspeed_histogram_32.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_32(&mut self, v: u32) {
        self.rxspeed_histogram_32 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_64 = 84;

    pub fn rxspeed_histogram_64(&self) -> u32 {
        self.rxspeed_histogram_64.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_64(&mut self) {
        self.rxspeed_histogram_64 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_64(&self) -> bool {
        self.rxspeed_histogram_64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_64(&mut self, v: u32) {
        self.rxspeed_histogram_64 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_128 = 85;

    pub fn rxspeed_histogram_128(&self) -> u32 {
        self.rxspeed_histogram_128.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_128(&mut self) {
        self.rxspeed_histogram_128 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_128(&self) -> bool {
        self.rxspeed_histogram_128.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_128(&mut self, v: u32) {
        self.rxspeed_histogram_128 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_256 = 86;

    pub fn rxspeed_histogram_256(&self) -> u32 {
        self.rxspeed_histogram_256.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_256(&mut self) {
        self.rxspeed_histogram_256 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_256(&self) -> bool {
        self.rxspeed_histogram_256.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_256(&mut self, v: u32) {
        self.rxspeed_histogram_256 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_512 = 87;

    pub fn rxspeed_histogram_512(&self) -> u32 {
        self.rxspeed_histogram_512.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_512(&mut self) {
        self.rxspeed_histogram_512 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_512(&self) -> bool {
        self.rxspeed_histogram_512.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_512(&mut self, v: u32) {
        self.rxspeed_histogram_512 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_1024 = 88;

    pub fn rxspeed_histogram_1024(&self) -> u32 {
        self.rxspeed_histogram_1024.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_1024(&mut self) {
        self.rxspeed_histogram_1024 = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_1024(&self) -> bool {
        self.rxspeed_histogram_1024.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_1024(&mut self, v: u32) {
        self.rxspeed_histogram_1024 = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_histogram_max = 89;

    pub fn rxspeed_histogram_max(&self) -> u32 {
        self.rxspeed_histogram_max.unwrap_or(0)
    }

    pub fn clear_rxspeed_histogram_max(&mut self) {
        self.rxspeed_histogram_max = ::std::option::Option::None;
    }

    pub fn has_rxspeed_histogram_max(&self) -> bool {
        self.rxspeed_histogram_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_histogram_max(&mut self, v: u32) {
        self.rxspeed_histogram_max = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_5th = 90;

    pub fn rxspeed_ntile_5th(&self) -> u32 {
        self.rxspeed_ntile_5th.unwrap_or(0)
    }

    pub fn clear_rxspeed_ntile_5th(&mut self) {
        self.rxspeed_ntile_5th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_5th(&self) -> bool {
        self.rxspeed_ntile_5th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_5th(&mut self, v: u32) {
        self.rxspeed_ntile_5th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_50th = 91;

    pub fn rxspeed_ntile_50th(&self) -> u32 {
        self.rxspeed_ntile_50th.unwrap_or(0)
    }

    pub fn clear_rxspeed_ntile_50th(&mut self) {
        self.rxspeed_ntile_50th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_50th(&self) -> bool {
        self.rxspeed_ntile_50th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_50th(&mut self, v: u32) {
        self.rxspeed_ntile_50th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_75th = 92;

    pub fn rxspeed_ntile_75th(&self) -> u32 {
        self.rxspeed_ntile_75th.unwrap_or(0)
    }

    pub fn clear_rxspeed_ntile_75th(&mut self) {
        self.rxspeed_ntile_75th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_75th(&self) -> bool {
        self.rxspeed_ntile_75th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_75th(&mut self, v: u32) {
        self.rxspeed_ntile_75th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_95th = 93;

    pub fn rxspeed_ntile_95th(&self) -> u32 {
        self.rxspeed_ntile_95th.unwrap_or(0)
    }

    pub fn clear_rxspeed_ntile_95th(&mut self) {
        self.rxspeed_ntile_95th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_95th(&self) -> bool {
        self.rxspeed_ntile_95th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_95th(&mut self, v: u32) {
        self.rxspeed_ntile_95th = ::std::option::Option::Some(v);
    }

    // optional uint32 rxspeed_ntile_98th = 94;

    pub fn rxspeed_ntile_98th(&self) -> u32 {
        self.rxspeed_ntile_98th.unwrap_or(0)
    }

    pub fn clear_rxspeed_ntile_98th(&mut self) {
        self.rxspeed_ntile_98th = ::std::option::Option::None;
    }

    pub fn has_rxspeed_ntile_98th(&self) -> bool {
        self.rxspeed_ntile_98th.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rxspeed_ntile_98th(&mut self, v: u32) {
        self.rxspeed_ntile_98th = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(75);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "connected_seconds",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.connected_seconds },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.connected_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_sent",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_sent },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_sent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kb_sent",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.kb_sent },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.kb_sent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kb_recv",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.kb_recv },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.kb_recv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_sequenced",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_sequenced },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_sequenced },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_dropped",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_dropped },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_dropped },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_out_of_order",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_out_of_order },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_out_of_order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_out_of_order_corrected",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_out_of_order_corrected },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_out_of_order_corrected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_duplicate",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_duplicate },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_duplicate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packets_recv_lurch",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.packets_recv_lurch },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.packets_recv_lurch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "multipath_packets_recv_sequenced",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.multipath_packets_recv_sequenced },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.multipath_packets_recv_sequenced },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "multipath_packets_recv_later",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.multipath_packets_recv_later },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.multipath_packets_recv_later },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "multipath_send_enabled",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.multipath_send_enabled },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.multipath_send_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_histogram_100",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_100 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_100 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_histogram_99",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_99 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_99 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_histogram_97",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_97 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_97 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_histogram_95",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_95 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_95 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_histogram_90",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_90 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_90 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_histogram_75",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_75 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_75 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_histogram_50",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_50 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_50 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_histogram_1",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_1 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_histogram_dead",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_histogram_dead },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_histogram_dead },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_ntile_2nd",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_2nd },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_2nd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_ntile_5th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_5th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_5th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_ntile_25th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_25th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_25th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality_ntile_50th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.quality_ntile_50th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.quality_ntile_50th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_histogram_25",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_25 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_25 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_histogram_50",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_50 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_50 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_histogram_75",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_75 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_75 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_histogram_100",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_100 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_100 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_histogram_125",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_125 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_125 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_histogram_150",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_150 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_150 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_histogram_200",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_200 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_200 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_histogram_300",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_300 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_300 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_histogram_max",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_histogram_max },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_histogram_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_ntile_5th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_5th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_5th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_ntile_50th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_50th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_50th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_ntile_75th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_75th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_75th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_ntile_95th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_95th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_95th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_ntile_98th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.ping_ntile_98th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.ping_ntile_98th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jitter_histogram_negligible",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_negligible },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_negligible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jitter_histogram_1",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_1 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jitter_histogram_2",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_2 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jitter_histogram_5",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_5 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_5 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jitter_histogram_10",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_10 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_10 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "jitter_histogram_20",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.jitter_histogram_20 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.jitter_histogram_20 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_max",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_max },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_histogram_16",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_16 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_16 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_histogram_32",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_32 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_32 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_histogram_64",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_64 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_64 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_histogram_128",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_128 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_128 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_histogram_256",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_256 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_histogram_512",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_512 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_512 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_histogram_1024",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_1024 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_1024 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_histogram_max",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_histogram_max },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_histogram_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_ntile_5th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_5th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_5th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_ntile_50th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_50th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_50th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_ntile_75th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_75th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_75th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_ntile_95th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_95th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_95th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txspeed_ntile_98th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.txspeed_ntile_98th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.txspeed_ntile_98th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_max",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_max },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_histogram_16",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_16 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_16 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_histogram_32",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_32 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_32 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_histogram_64",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_64 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_64 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_histogram_128",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_128 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_128 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_histogram_256",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_256 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_256 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_histogram_512",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_512 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_512 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_histogram_1024",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_1024 },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_1024 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_histogram_max",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_histogram_max },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_histogram_max },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_ntile_5th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_5th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_5th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_ntile_50th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_50th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_50th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_ntile_75th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_75th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_75th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_ntile_95th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_95th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_95th },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rxspeed_ntile_98th",
            |m: &CMsgSteamDatagramLinkLifetimeStats| { &m.rxspeed_ntile_98th },
            |m: &mut CMsgSteamDatagramLinkLifetimeStats| { &mut m.rxspeed_ntile_98th },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramLinkLifetimeStats>(
            "CMsgSteamDatagramLinkLifetimeStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramLinkLifetimeStats {
    const NAME: &'static str = "CMsgSteamDatagramLinkLifetimeStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.connected_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.packets_sent = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.kb_sent = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.packets_recv = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.kb_recv = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.packets_recv_sequenced = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.packets_recv_dropped = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.packets_recv_out_of_order = ::std::option::Option::Some(is.read_uint64()?);
                },
                120 => {
                    self.packets_recv_out_of_order_corrected = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.packets_recv_duplicate = ::std::option::Option::Some(is.read_uint64()?);
                },
                88 => {
                    self.packets_recv_lurch = ::std::option::Option::Some(is.read_uint64()?);
                },
                98 => {
                    is.read_repeated_packed_uint64_into(&mut self.multipath_packets_recv_sequenced)?;
                },
                96 => {
                    self.multipath_packets_recv_sequenced.push(is.read_uint64()?);
                },
                106 => {
                    is.read_repeated_packed_uint64_into(&mut self.multipath_packets_recv_later)?;
                },
                104 => {
                    self.multipath_packets_recv_later.push(is.read_uint64()?);
                },
                112 => {
                    self.multipath_send_enabled = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.quality_histogram_100 = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.quality_histogram_99 = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.quality_histogram_97 = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.quality_histogram_95 = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.quality_histogram_90 = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.quality_histogram_75 = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.quality_histogram_50 = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.quality_histogram_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.quality_histogram_dead = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.quality_ntile_2nd = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.quality_ntile_5th = ::std::option::Option::Some(is.read_uint32()?);
                },
                256 => {
                    self.quality_ntile_25th = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.quality_ntile_50th = ::std::option::Option::Some(is.read_uint32()?);
                },
                328 => {
                    self.ping_histogram_25 = ::std::option::Option::Some(is.read_uint32()?);
                },
                336 => {
                    self.ping_histogram_50 = ::std::option::Option::Some(is.read_uint32()?);
                },
                344 => {
                    self.ping_histogram_75 = ::std::option::Option::Some(is.read_uint32()?);
                },
                352 => {
                    self.ping_histogram_100 = ::std::option::Option::Some(is.read_uint32()?);
                },
                360 => {
                    self.ping_histogram_125 = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.ping_histogram_150 = ::std::option::Option::Some(is.read_uint32()?);
                },
                376 => {
                    self.ping_histogram_200 = ::std::option::Option::Some(is.read_uint32()?);
                },
                384 => {
                    self.ping_histogram_300 = ::std::option::Option::Some(is.read_uint32()?);
                },
                392 => {
                    self.ping_histogram_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                400 => {
                    self.ping_ntile_5th = ::std::option::Option::Some(is.read_uint32()?);
                },
                408 => {
                    self.ping_ntile_50th = ::std::option::Option::Some(is.read_uint32()?);
                },
                416 => {
                    self.ping_ntile_75th = ::std::option::Option::Some(is.read_uint32()?);
                },
                424 => {
                    self.ping_ntile_95th = ::std::option::Option::Some(is.read_uint32()?);
                },
                432 => {
                    self.ping_ntile_98th = ::std::option::Option::Some(is.read_uint32()?);
                },
                488 => {
                    self.jitter_histogram_negligible = ::std::option::Option::Some(is.read_uint32()?);
                },
                496 => {
                    self.jitter_histogram_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                504 => {
                    self.jitter_histogram_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                512 => {
                    self.jitter_histogram_5 = ::std::option::Option::Some(is.read_uint32()?);
                },
                520 => {
                    self.jitter_histogram_10 = ::std::option::Option::Some(is.read_uint32()?);
                },
                528 => {
                    self.jitter_histogram_20 = ::std::option::Option::Some(is.read_uint32()?);
                },
                536 => {
                    self.txspeed_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                544 => {
                    self.txspeed_histogram_16 = ::std::option::Option::Some(is.read_uint32()?);
                },
                552 => {
                    self.txspeed_histogram_32 = ::std::option::Option::Some(is.read_uint32()?);
                },
                560 => {
                    self.txspeed_histogram_64 = ::std::option::Option::Some(is.read_uint32()?);
                },
                568 => {
                    self.txspeed_histogram_128 = ::std::option::Option::Some(is.read_uint32()?);
                },
                576 => {
                    self.txspeed_histogram_256 = ::std::option::Option::Some(is.read_uint32()?);
                },
                584 => {
                    self.txspeed_histogram_512 = ::std::option::Option::Some(is.read_uint32()?);
                },
                592 => {
                    self.txspeed_histogram_1024 = ::std::option::Option::Some(is.read_uint32()?);
                },
                600 => {
                    self.txspeed_histogram_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                608 => {
                    self.txspeed_ntile_5th = ::std::option::Option::Some(is.read_uint32()?);
                },
                616 => {
                    self.txspeed_ntile_50th = ::std::option::Option::Some(is.read_uint32()?);
                },
                624 => {
                    self.txspeed_ntile_75th = ::std::option::Option::Some(is.read_uint32()?);
                },
                632 => {
                    self.txspeed_ntile_95th = ::std::option::Option::Some(is.read_uint32()?);
                },
                640 => {
                    self.txspeed_ntile_98th = ::std::option::Option::Some(is.read_uint32()?);
                },
                648 => {
                    self.rxspeed_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                656 => {
                    self.rxspeed_histogram_16 = ::std::option::Option::Some(is.read_uint32()?);
                },
                664 => {
                    self.rxspeed_histogram_32 = ::std::option::Option::Some(is.read_uint32()?);
                },
                672 => {
                    self.rxspeed_histogram_64 = ::std::option::Option::Some(is.read_uint32()?);
                },
                680 => {
                    self.rxspeed_histogram_128 = ::std::option::Option::Some(is.read_uint32()?);
                },
                688 => {
                    self.rxspeed_histogram_256 = ::std::option::Option::Some(is.read_uint32()?);
                },
                696 => {
                    self.rxspeed_histogram_512 = ::std::option::Option::Some(is.read_uint32()?);
                },
                704 => {
                    self.rxspeed_histogram_1024 = ::std::option::Option::Some(is.read_uint32()?);
                },
                712 => {
                    self.rxspeed_histogram_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                720 => {
                    self.rxspeed_ntile_5th = ::std::option::Option::Some(is.read_uint32()?);
                },
                728 => {
                    self.rxspeed_ntile_50th = ::std::option::Option::Some(is.read_uint32()?);
                },
                736 => {
                    self.rxspeed_ntile_75th = ::std::option::Option::Some(is.read_uint32()?);
                },
                744 => {
                    self.rxspeed_ntile_95th = ::std::option::Option::Some(is.read_uint32()?);
                },
                752 => {
                    self.rxspeed_ntile_98th = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connected_seconds {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.packets_sent {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.kb_sent {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.packets_recv {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.kb_recv {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.packets_recv_sequenced {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.packets_recv_dropped {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.packets_recv_out_of_order {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.packets_recv_out_of_order_corrected {
            my_size += ::protobuf::rt::uint64_size(15, v);
        }
        if let Some(v) = self.packets_recv_duplicate {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.packets_recv_lurch {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        for value in &self.multipath_packets_recv_sequenced {
            my_size += ::protobuf::rt::uint64_size(12, *value);
        };
        for value in &self.multipath_packets_recv_later {
            my_size += ::protobuf::rt::uint64_size(13, *value);
        };
        if let Some(v) = self.multipath_send_enabled {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.quality_histogram_100 {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.quality_histogram_99 {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.quality_histogram_97 {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.quality_histogram_95 {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.quality_histogram_90 {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.quality_histogram_75 {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.quality_histogram_50 {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.quality_histogram_1 {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.quality_histogram_dead {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.quality_ntile_2nd {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.quality_ntile_5th {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.quality_ntile_25th {
            my_size += ::protobuf::rt::uint32_size(32, v);
        }
        if let Some(v) = self.quality_ntile_50th {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        if let Some(v) = self.ping_histogram_25 {
            my_size += ::protobuf::rt::uint32_size(41, v);
        }
        if let Some(v) = self.ping_histogram_50 {
            my_size += ::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.ping_histogram_75 {
            my_size += ::protobuf::rt::uint32_size(43, v);
        }
        if let Some(v) = self.ping_histogram_100 {
            my_size += ::protobuf::rt::uint32_size(44, v);
        }
        if let Some(v) = self.ping_histogram_125 {
            my_size += ::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.ping_histogram_150 {
            my_size += ::protobuf::rt::uint32_size(46, v);
        }
        if let Some(v) = self.ping_histogram_200 {
            my_size += ::protobuf::rt::uint32_size(47, v);
        }
        if let Some(v) = self.ping_histogram_300 {
            my_size += ::protobuf::rt::uint32_size(48, v);
        }
        if let Some(v) = self.ping_histogram_max {
            my_size += ::protobuf::rt::uint32_size(49, v);
        }
        if let Some(v) = self.ping_ntile_5th {
            my_size += ::protobuf::rt::uint32_size(50, v);
        }
        if let Some(v) = self.ping_ntile_50th {
            my_size += ::protobuf::rt::uint32_size(51, v);
        }
        if let Some(v) = self.ping_ntile_75th {
            my_size += ::protobuf::rt::uint32_size(52, v);
        }
        if let Some(v) = self.ping_ntile_95th {
            my_size += ::protobuf::rt::uint32_size(53, v);
        }
        if let Some(v) = self.ping_ntile_98th {
            my_size += ::protobuf::rt::uint32_size(54, v);
        }
        if let Some(v) = self.jitter_histogram_negligible {
            my_size += ::protobuf::rt::uint32_size(61, v);
        }
        if let Some(v) = self.jitter_histogram_1 {
            my_size += ::protobuf::rt::uint32_size(62, v);
        }
        if let Some(v) = self.jitter_histogram_2 {
            my_size += ::protobuf::rt::uint32_size(63, v);
        }
        if let Some(v) = self.jitter_histogram_5 {
            my_size += ::protobuf::rt::uint32_size(64, v);
        }
        if let Some(v) = self.jitter_histogram_10 {
            my_size += ::protobuf::rt::uint32_size(65, v);
        }
        if let Some(v) = self.jitter_histogram_20 {
            my_size += ::protobuf::rt::uint32_size(66, v);
        }
        if let Some(v) = self.txspeed_max {
            my_size += ::protobuf::rt::uint32_size(67, v);
        }
        if let Some(v) = self.txspeed_histogram_16 {
            my_size += ::protobuf::rt::uint32_size(68, v);
        }
        if let Some(v) = self.txspeed_histogram_32 {
            my_size += ::protobuf::rt::uint32_size(69, v);
        }
        if let Some(v) = self.txspeed_histogram_64 {
            my_size += ::protobuf::rt::uint32_size(70, v);
        }
        if let Some(v) = self.txspeed_histogram_128 {
            my_size += ::protobuf::rt::uint32_size(71, v);
        }
        if let Some(v) = self.txspeed_histogram_256 {
            my_size += ::protobuf::rt::uint32_size(72, v);
        }
        if let Some(v) = self.txspeed_histogram_512 {
            my_size += ::protobuf::rt::uint32_size(73, v);
        }
        if let Some(v) = self.txspeed_histogram_1024 {
            my_size += ::protobuf::rt::uint32_size(74, v);
        }
        if let Some(v) = self.txspeed_histogram_max {
            my_size += ::protobuf::rt::uint32_size(75, v);
        }
        if let Some(v) = self.txspeed_ntile_5th {
            my_size += ::protobuf::rt::uint32_size(76, v);
        }
        if let Some(v) = self.txspeed_ntile_50th {
            my_size += ::protobuf::rt::uint32_size(77, v);
        }
        if let Some(v) = self.txspeed_ntile_75th {
            my_size += ::protobuf::rt::uint32_size(78, v);
        }
        if let Some(v) = self.txspeed_ntile_95th {
            my_size += ::protobuf::rt::uint32_size(79, v);
        }
        if let Some(v) = self.txspeed_ntile_98th {
            my_size += ::protobuf::rt::uint32_size(80, v);
        }
        if let Some(v) = self.rxspeed_max {
            my_size += ::protobuf::rt::uint32_size(81, v);
        }
        if let Some(v) = self.rxspeed_histogram_16 {
            my_size += ::protobuf::rt::uint32_size(82, v);
        }
        if let Some(v) = self.rxspeed_histogram_32 {
            my_size += ::protobuf::rt::uint32_size(83, v);
        }
        if let Some(v) = self.rxspeed_histogram_64 {
            my_size += ::protobuf::rt::uint32_size(84, v);
        }
        if let Some(v) = self.rxspeed_histogram_128 {
            my_size += ::protobuf::rt::uint32_size(85, v);
        }
        if let Some(v) = self.rxspeed_histogram_256 {
            my_size += ::protobuf::rt::uint32_size(86, v);
        }
        if let Some(v) = self.rxspeed_histogram_512 {
            my_size += ::protobuf::rt::uint32_size(87, v);
        }
        if let Some(v) = self.rxspeed_histogram_1024 {
            my_size += ::protobuf::rt::uint32_size(88, v);
        }
        if let Some(v) = self.rxspeed_histogram_max {
            my_size += ::protobuf::rt::uint32_size(89, v);
        }
        if let Some(v) = self.rxspeed_ntile_5th {
            my_size += ::protobuf::rt::uint32_size(90, v);
        }
        if let Some(v) = self.rxspeed_ntile_50th {
            my_size += ::protobuf::rt::uint32_size(91, v);
        }
        if let Some(v) = self.rxspeed_ntile_75th {
            my_size += ::protobuf::rt::uint32_size(92, v);
        }
        if let Some(v) = self.rxspeed_ntile_95th {
            my_size += ::protobuf::rt::uint32_size(93, v);
        }
        if let Some(v) = self.rxspeed_ntile_98th {
            my_size += ::protobuf::rt::uint32_size(94, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.connected_seconds {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.packets_sent {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.kb_sent {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.packets_recv {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.kb_recv {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.packets_recv_sequenced {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.packets_recv_dropped {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.packets_recv_out_of_order {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.packets_recv_out_of_order_corrected {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.packets_recv_duplicate {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.packets_recv_lurch {
            os.write_uint64(11, v)?;
        }
        for v in &self.multipath_packets_recv_sequenced {
            os.write_uint64(12, *v)?;
        };
        for v in &self.multipath_packets_recv_later {
            os.write_uint64(13, *v)?;
        };
        if let Some(v) = self.multipath_send_enabled {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.quality_histogram_100 {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.quality_histogram_99 {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.quality_histogram_97 {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.quality_histogram_95 {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.quality_histogram_90 {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.quality_histogram_75 {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.quality_histogram_50 {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.quality_histogram_1 {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.quality_histogram_dead {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.quality_ntile_2nd {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.quality_ntile_5th {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.quality_ntile_25th {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.quality_ntile_50th {
            os.write_uint32(33, v)?;
        }
        if let Some(v) = self.ping_histogram_25 {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.ping_histogram_50 {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.ping_histogram_75 {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.ping_histogram_100 {
            os.write_uint32(44, v)?;
        }
        if let Some(v) = self.ping_histogram_125 {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.ping_histogram_150 {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.ping_histogram_200 {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.ping_histogram_300 {
            os.write_uint32(48, v)?;
        }
        if let Some(v) = self.ping_histogram_max {
            os.write_uint32(49, v)?;
        }
        if let Some(v) = self.ping_ntile_5th {
            os.write_uint32(50, v)?;
        }
        if let Some(v) = self.ping_ntile_50th {
            os.write_uint32(51, v)?;
        }
        if let Some(v) = self.ping_ntile_75th {
            os.write_uint32(52, v)?;
        }
        if let Some(v) = self.ping_ntile_95th {
            os.write_uint32(53, v)?;
        }
        if let Some(v) = self.ping_ntile_98th {
            os.write_uint32(54, v)?;
        }
        if let Some(v) = self.jitter_histogram_negligible {
            os.write_uint32(61, v)?;
        }
        if let Some(v) = self.jitter_histogram_1 {
            os.write_uint32(62, v)?;
        }
        if let Some(v) = self.jitter_histogram_2 {
            os.write_uint32(63, v)?;
        }
        if let Some(v) = self.jitter_histogram_5 {
            os.write_uint32(64, v)?;
        }
        if let Some(v) = self.jitter_histogram_10 {
            os.write_uint32(65, v)?;
        }
        if let Some(v) = self.jitter_histogram_20 {
            os.write_uint32(66, v)?;
        }
        if let Some(v) = self.txspeed_max {
            os.write_uint32(67, v)?;
        }
        if let Some(v) = self.txspeed_histogram_16 {
            os.write_uint32(68, v)?;
        }
        if let Some(v) = self.txspeed_histogram_32 {
            os.write_uint32(69, v)?;
        }
        if let Some(v) = self.txspeed_histogram_64 {
            os.write_uint32(70, v)?;
        }
        if let Some(v) = self.txspeed_histogram_128 {
            os.write_uint32(71, v)?;
        }
        if let Some(v) = self.txspeed_histogram_256 {
            os.write_uint32(72, v)?;
        }
        if let Some(v) = self.txspeed_histogram_512 {
            os.write_uint32(73, v)?;
        }
        if let Some(v) = self.txspeed_histogram_1024 {
            os.write_uint32(74, v)?;
        }
        if let Some(v) = self.txspeed_histogram_max {
            os.write_uint32(75, v)?;
        }
        if let Some(v) = self.txspeed_ntile_5th {
            os.write_uint32(76, v)?;
        }
        if let Some(v) = self.txspeed_ntile_50th {
            os.write_uint32(77, v)?;
        }
        if let Some(v) = self.txspeed_ntile_75th {
            os.write_uint32(78, v)?;
        }
        if let Some(v) = self.txspeed_ntile_95th {
            os.write_uint32(79, v)?;
        }
        if let Some(v) = self.txspeed_ntile_98th {
            os.write_uint32(80, v)?;
        }
        if let Some(v) = self.rxspeed_max {
            os.write_uint32(81, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_16 {
            os.write_uint32(82, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_32 {
            os.write_uint32(83, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_64 {
            os.write_uint32(84, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_128 {
            os.write_uint32(85, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_256 {
            os.write_uint32(86, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_512 {
            os.write_uint32(87, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_1024 {
            os.write_uint32(88, v)?;
        }
        if let Some(v) = self.rxspeed_histogram_max {
            os.write_uint32(89, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_5th {
            os.write_uint32(90, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_50th {
            os.write_uint32(91, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_75th {
            os.write_uint32(92, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_95th {
            os.write_uint32(93, v)?;
        }
        if let Some(v) = self.rxspeed_ntile_98th {
            os.write_uint32(94, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramLinkLifetimeStats {
        CMsgSteamDatagramLinkLifetimeStats::new()
    }

    fn clear(&mut self) {
        self.connected_seconds = ::std::option::Option::None;
        self.packets_sent = ::std::option::Option::None;
        self.kb_sent = ::std::option::Option::None;
        self.packets_recv = ::std::option::Option::None;
        self.kb_recv = ::std::option::Option::None;
        self.packets_recv_sequenced = ::std::option::Option::None;
        self.packets_recv_dropped = ::std::option::Option::None;
        self.packets_recv_out_of_order = ::std::option::Option::None;
        self.packets_recv_out_of_order_corrected = ::std::option::Option::None;
        self.packets_recv_duplicate = ::std::option::Option::None;
        self.packets_recv_lurch = ::std::option::Option::None;
        self.multipath_packets_recv_sequenced.clear();
        self.multipath_packets_recv_later.clear();
        self.multipath_send_enabled = ::std::option::Option::None;
        self.quality_histogram_100 = ::std::option::Option::None;
        self.quality_histogram_99 = ::std::option::Option::None;
        self.quality_histogram_97 = ::std::option::Option::None;
        self.quality_histogram_95 = ::std::option::Option::None;
        self.quality_histogram_90 = ::std::option::Option::None;
        self.quality_histogram_75 = ::std::option::Option::None;
        self.quality_histogram_50 = ::std::option::Option::None;
        self.quality_histogram_1 = ::std::option::Option::None;
        self.quality_histogram_dead = ::std::option::Option::None;
        self.quality_ntile_2nd = ::std::option::Option::None;
        self.quality_ntile_5th = ::std::option::Option::None;
        self.quality_ntile_25th = ::std::option::Option::None;
        self.quality_ntile_50th = ::std::option::Option::None;
        self.ping_histogram_25 = ::std::option::Option::None;
        self.ping_histogram_50 = ::std::option::Option::None;
        self.ping_histogram_75 = ::std::option::Option::None;
        self.ping_histogram_100 = ::std::option::Option::None;
        self.ping_histogram_125 = ::std::option::Option::None;
        self.ping_histogram_150 = ::std::option::Option::None;
        self.ping_histogram_200 = ::std::option::Option::None;
        self.ping_histogram_300 = ::std::option::Option::None;
        self.ping_histogram_max = ::std::option::Option::None;
        self.ping_ntile_5th = ::std::option::Option::None;
        self.ping_ntile_50th = ::std::option::Option::None;
        self.ping_ntile_75th = ::std::option::Option::None;
        self.ping_ntile_95th = ::std::option::Option::None;
        self.ping_ntile_98th = ::std::option::Option::None;
        self.jitter_histogram_negligible = ::std::option::Option::None;
        self.jitter_histogram_1 = ::std::option::Option::None;
        self.jitter_histogram_2 = ::std::option::Option::None;
        self.jitter_histogram_5 = ::std::option::Option::None;
        self.jitter_histogram_10 = ::std::option::Option::None;
        self.jitter_histogram_20 = ::std::option::Option::None;
        self.txspeed_max = ::std::option::Option::None;
        self.txspeed_histogram_16 = ::std::option::Option::None;
        self.txspeed_histogram_32 = ::std::option::Option::None;
        self.txspeed_histogram_64 = ::std::option::Option::None;
        self.txspeed_histogram_128 = ::std::option::Option::None;
        self.txspeed_histogram_256 = ::std::option::Option::None;
        self.txspeed_histogram_512 = ::std::option::Option::None;
        self.txspeed_histogram_1024 = ::std::option::Option::None;
        self.txspeed_histogram_max = ::std::option::Option::None;
        self.txspeed_ntile_5th = ::std::option::Option::None;
        self.txspeed_ntile_50th = ::std::option::Option::None;
        self.txspeed_ntile_75th = ::std::option::Option::None;
        self.txspeed_ntile_95th = ::std::option::Option::None;
        self.txspeed_ntile_98th = ::std::option::Option::None;
        self.rxspeed_max = ::std::option::Option::None;
        self.rxspeed_histogram_16 = ::std::option::Option::None;
        self.rxspeed_histogram_32 = ::std::option::Option::None;
        self.rxspeed_histogram_64 = ::std::option::Option::None;
        self.rxspeed_histogram_128 = ::std::option::Option::None;
        self.rxspeed_histogram_256 = ::std::option::Option::None;
        self.rxspeed_histogram_512 = ::std::option::Option::None;
        self.rxspeed_histogram_1024 = ::std::option::Option::None;
        self.rxspeed_histogram_max = ::std::option::Option::None;
        self.rxspeed_ntile_5th = ::std::option::Option::None;
        self.rxspeed_ntile_50th = ::std::option::Option::None;
        self.rxspeed_ntile_75th = ::std::option::Option::None;
        self.rxspeed_ntile_95th = ::std::option::Option::None;
        self.rxspeed_ntile_98th = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramLinkLifetimeStats {
        static instance: CMsgSteamDatagramLinkLifetimeStats = CMsgSteamDatagramLinkLifetimeStats {
            connected_seconds: ::std::option::Option::None,
            packets_sent: ::std::option::Option::None,
            kb_sent: ::std::option::Option::None,
            packets_recv: ::std::option::Option::None,
            kb_recv: ::std::option::Option::None,
            packets_recv_sequenced: ::std::option::Option::None,
            packets_recv_dropped: ::std::option::Option::None,
            packets_recv_out_of_order: ::std::option::Option::None,
            packets_recv_out_of_order_corrected: ::std::option::Option::None,
            packets_recv_duplicate: ::std::option::Option::None,
            packets_recv_lurch: ::std::option::Option::None,
            multipath_packets_recv_sequenced: ::std::vec::Vec::new(),
            multipath_packets_recv_later: ::std::vec::Vec::new(),
            multipath_send_enabled: ::std::option::Option::None,
            quality_histogram_100: ::std::option::Option::None,
            quality_histogram_99: ::std::option::Option::None,
            quality_histogram_97: ::std::option::Option::None,
            quality_histogram_95: ::std::option::Option::None,
            quality_histogram_90: ::std::option::Option::None,
            quality_histogram_75: ::std::option::Option::None,
            quality_histogram_50: ::std::option::Option::None,
            quality_histogram_1: ::std::option::Option::None,
            quality_histogram_dead: ::std::option::Option::None,
            quality_ntile_2nd: ::std::option::Option::None,
            quality_ntile_5th: ::std::option::Option::None,
            quality_ntile_25th: ::std::option::Option::None,
            quality_ntile_50th: ::std::option::Option::None,
            ping_histogram_25: ::std::option::Option::None,
            ping_histogram_50: ::std::option::Option::None,
            ping_histogram_75: ::std::option::Option::None,
            ping_histogram_100: ::std::option::Option::None,
            ping_histogram_125: ::std::option::Option::None,
            ping_histogram_150: ::std::option::Option::None,
            ping_histogram_200: ::std::option::Option::None,
            ping_histogram_300: ::std::option::Option::None,
            ping_histogram_max: ::std::option::Option::None,
            ping_ntile_5th: ::std::option::Option::None,
            ping_ntile_50th: ::std::option::Option::None,
            ping_ntile_75th: ::std::option::Option::None,
            ping_ntile_95th: ::std::option::Option::None,
            ping_ntile_98th: ::std::option::Option::None,
            jitter_histogram_negligible: ::std::option::Option::None,
            jitter_histogram_1: ::std::option::Option::None,
            jitter_histogram_2: ::std::option::Option::None,
            jitter_histogram_5: ::std::option::Option::None,
            jitter_histogram_10: ::std::option::Option::None,
            jitter_histogram_20: ::std::option::Option::None,
            txspeed_max: ::std::option::Option::None,
            txspeed_histogram_16: ::std::option::Option::None,
            txspeed_histogram_32: ::std::option::Option::None,
            txspeed_histogram_64: ::std::option::Option::None,
            txspeed_histogram_128: ::std::option::Option::None,
            txspeed_histogram_256: ::std::option::Option::None,
            txspeed_histogram_512: ::std::option::Option::None,
            txspeed_histogram_1024: ::std::option::Option::None,
            txspeed_histogram_max: ::std::option::Option::None,
            txspeed_ntile_5th: ::std::option::Option::None,
            txspeed_ntile_50th: ::std::option::Option::None,
            txspeed_ntile_75th: ::std::option::Option::None,
            txspeed_ntile_95th: ::std::option::Option::None,
            txspeed_ntile_98th: ::std::option::Option::None,
            rxspeed_max: ::std::option::Option::None,
            rxspeed_histogram_16: ::std::option::Option::None,
            rxspeed_histogram_32: ::std::option::Option::None,
            rxspeed_histogram_64: ::std::option::Option::None,
            rxspeed_histogram_128: ::std::option::Option::None,
            rxspeed_histogram_256: ::std::option::Option::None,
            rxspeed_histogram_512: ::std::option::Option::None,
            rxspeed_histogram_1024: ::std::option::Option::None,
            rxspeed_histogram_max: ::std::option::Option::None,
            rxspeed_ntile_5th: ::std::option::Option::None,
            rxspeed_ntile_50th: ::std::option::Option::None,
            rxspeed_ntile_75th: ::std::option::Option::None,
            rxspeed_ntile_95th: ::std::option::Option::None,
            rxspeed_ntile_98th: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramLinkLifetimeStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramLinkLifetimeStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramLinkLifetimeStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramLinkLifetimeStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSteamDatagramConnectionQuality)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamDatagramConnectionQuality {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionQuality.instantaneous)
    pub instantaneous: ::protobuf::MessageField<CMsgSteamDatagramLinkInstantaneousStats>,
    // @@protoc_insertion_point(field:CMsgSteamDatagramConnectionQuality.lifetime)
    pub lifetime: ::protobuf::MessageField<CMsgSteamDatagramLinkLifetimeStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamDatagramConnectionQuality.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamDatagramConnectionQuality {
    fn default() -> &'a CMsgSteamDatagramConnectionQuality {
        <CMsgSteamDatagramConnectionQuality as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamDatagramConnectionQuality {
    pub fn new() -> CMsgSteamDatagramConnectionQuality {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramLinkInstantaneousStats>(
            "instantaneous",
            |m: &CMsgSteamDatagramConnectionQuality| { &m.instantaneous },
            |m: &mut CMsgSteamDatagramConnectionQuality| { &mut m.instantaneous },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgSteamDatagramLinkLifetimeStats>(
            "lifetime",
            |m: &CMsgSteamDatagramConnectionQuality| { &m.lifetime },
            |m: &mut CMsgSteamDatagramConnectionQuality| { &mut m.lifetime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamDatagramConnectionQuality>(
            "CMsgSteamDatagramConnectionQuality",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamDatagramConnectionQuality {
    const NAME: &'static str = "CMsgSteamDatagramConnectionQuality";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.instantaneous)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lifetime)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.instantaneous.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.lifetime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.instantaneous.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.lifetime.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamDatagramConnectionQuality {
        CMsgSteamDatagramConnectionQuality::new()
    }

    fn clear(&mut self) {
        self.instantaneous.clear();
        self.lifetime.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamDatagramConnectionQuality {
        static instance: CMsgSteamDatagramConnectionQuality = CMsgSteamDatagramConnectionQuality {
            instantaneous: ::protobuf::MessageField::none(),
            lifetime: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamDatagramConnectionQuality {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamDatagramConnectionQuality").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamDatagramConnectionQuality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamDatagramConnectionQuality {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgICECandidate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgICECandidate {
    // message fields
    // @@protoc_insertion_point(field:CMsgICECandidate.candidate)
    pub candidate: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgICECandidate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgICECandidate {
    fn default() -> &'a CMsgICECandidate {
        <CMsgICECandidate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgICECandidate {
    pub fn new() -> CMsgICECandidate {
        ::std::default::Default::default()
    }

    // optional string candidate = 3;

    pub fn candidate(&self) -> &str {
        match self.candidate.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_candidate(&mut self) {
        self.candidate = ::std::option::Option::None;
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        if self.candidate.is_none() {
            self.candidate = ::std::option::Option::Some(::std::string::String::new());
        }
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        self.candidate.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "candidate",
            |m: &CMsgICECandidate| { &m.candidate },
            |m: &mut CMsgICECandidate| { &mut m.candidate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgICECandidate>(
            "CMsgICECandidate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgICECandidate {
    const NAME: &'static str = "CMsgICECandidate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.candidate = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.candidate.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.candidate.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgICECandidate {
        CMsgICECandidate::new()
    }

    fn clear(&mut self) {
        self.candidate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgICECandidate {
        static instance: CMsgICECandidate = CMsgICECandidate {
            candidate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgICECandidate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgICECandidate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgICECandidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgICECandidate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgICERendezvous)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgICERendezvous {
    // message fields
    // @@protoc_insertion_point(field:CMsgICERendezvous.auth)
    pub auth: ::protobuf::MessageField<cmsg_icerendezvous::Auth>,
    // @@protoc_insertion_point(field:CMsgICERendezvous.add_candidate)
    pub add_candidate: ::protobuf::MessageField<CMsgICECandidate>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgICERendezvous.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgICERendezvous {
    fn default() -> &'a CMsgICERendezvous {
        <CMsgICERendezvous as ::protobuf::Message>::default_instance()
    }
}

impl CMsgICERendezvous {
    pub fn new() -> CMsgICERendezvous {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_icerendezvous::Auth>(
            "auth",
            |m: &CMsgICERendezvous| { &m.auth },
            |m: &mut CMsgICERendezvous| { &mut m.auth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgICECandidate>(
            "add_candidate",
            |m: &CMsgICERendezvous| { &m.add_candidate },
            |m: &mut CMsgICERendezvous| { &mut m.add_candidate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgICERendezvous>(
            "CMsgICERendezvous",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgICERendezvous {
    const NAME: &'static str = "CMsgICERendezvous";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.auth)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.add_candidate)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.auth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.add_candidate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.auth.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.add_candidate.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgICERendezvous {
        CMsgICERendezvous::new()
    }

    fn clear(&mut self) {
        self.auth.clear();
        self.add_candidate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgICERendezvous {
        static instance: CMsgICERendezvous = CMsgICERendezvous {
            auth: ::protobuf::MessageField::none(),
            add_candidate: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgICERendezvous {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgICERendezvous").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgICERendezvous {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgICERendezvous {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgICERendezvous`
pub mod cmsg_icerendezvous {
    // @@protoc_insertion_point(message:CMsgICERendezvous.Auth)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Auth {
        // message fields
        // @@protoc_insertion_point(field:CMsgICERendezvous.Auth.pwd_frag)
        pub pwd_frag: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgICERendezvous.Auth.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Auth {
        fn default() -> &'a Auth {
            <Auth as ::protobuf::Message>::default_instance()
        }
    }

    impl Auth {
        pub fn new() -> Auth {
            ::std::default::Default::default()
        }

        // optional string pwd_frag = 1;

        pub fn pwd_frag(&self) -> &str {
            match self.pwd_frag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_pwd_frag(&mut self) {
            self.pwd_frag = ::std::option::Option::None;
        }

        pub fn has_pwd_frag(&self) -> bool {
            self.pwd_frag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pwd_frag(&mut self, v: ::std::string::String) {
            self.pwd_frag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_pwd_frag(&mut self) -> &mut ::std::string::String {
            if self.pwd_frag.is_none() {
                self.pwd_frag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.pwd_frag.as_mut().unwrap()
        }

        // Take field
        pub fn take_pwd_frag(&mut self) -> ::std::string::String {
            self.pwd_frag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pwd_frag",
                |m: &Auth| { &m.pwd_frag },
                |m: &mut Auth| { &mut m.pwd_frag },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Auth>(
                "CMsgICERendezvous.Auth",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Auth {
        const NAME: &'static str = "Auth";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.pwd_frag = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.pwd_frag.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.pwd_frag.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Auth {
            Auth::new()
        }

        fn clear(&mut self) {
            self.pwd_frag = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Auth {
            static instance: Auth = Auth {
                pwd_frag: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Auth {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgICERendezvous.Auth").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Auth {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Auth {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSteamNetworkingP2PRendezvous)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamNetworkingP2PRendezvous {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.from_identity)
    pub from_identity: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.from_connection_id)
    pub from_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.to_identity)
    pub to_identity: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.to_connection_id)
    pub to_connection_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.sdr_routes)
    pub sdr_routes: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ack_peer_routes_revision)
    pub ack_peer_routes_revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ice_enabled)
    pub ice_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.hosted_server_ticket)
    pub hosted_server_ticket: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.connect_request)
    pub connect_request: ::protobuf::MessageField<cmsg_steam_networking_p2prendezvous::ConnectRequest>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.connect_ok)
    pub connect_ok: ::protobuf::MessageField<cmsg_steam_networking_p2prendezvous::ConnectOK>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.connection_closed)
    pub connection_closed: ::protobuf::MessageField<cmsg_steam_networking_p2prendezvous::ConnectionClosed>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ack_reliable_msg)
    pub ack_reliable_msg: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.first_reliable_msg)
    pub first_reliable_msg: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.reliable_messages)
    pub reliable_messages: ::std::vec::Vec<cmsg_steam_networking_p2prendezvous::ReliableMessage>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.application_messages)
    pub application_messages: ::std::vec::Vec<cmsg_steam_networking_p2prendezvous::ApplicationMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamNetworkingP2PRendezvous.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamNetworkingP2PRendezvous {
    fn default() -> &'a CMsgSteamNetworkingP2PRendezvous {
        <CMsgSteamNetworkingP2PRendezvous as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamNetworkingP2PRendezvous {
    pub fn new() -> CMsgSteamNetworkingP2PRendezvous {
        ::std::default::Default::default()
    }

    // optional string from_identity = 8;

    pub fn from_identity(&self) -> &str {
        match self.from_identity.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_from_identity(&mut self) {
        self.from_identity = ::std::option::Option::None;
    }

    pub fn has_from_identity(&self) -> bool {
        self.from_identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_identity(&mut self, v: ::std::string::String) {
        self.from_identity = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_identity(&mut self) -> &mut ::std::string::String {
        if self.from_identity.is_none() {
            self.from_identity = ::std::option::Option::Some(::std::string::String::new());
        }
        self.from_identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_from_identity(&mut self) -> ::std::string::String {
        self.from_identity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 from_connection_id = 9;

    pub fn from_connection_id(&self) -> u32 {
        self.from_connection_id.unwrap_or(0)
    }

    pub fn clear_from_connection_id(&mut self) {
        self.from_connection_id = ::std::option::Option::None;
    }

    pub fn has_from_connection_id(&self) -> bool {
        self.from_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_connection_id(&mut self, v: u32) {
        self.from_connection_id = ::std::option::Option::Some(v);
    }

    // optional string to_identity = 10;

    pub fn to_identity(&self) -> &str {
        match self.to_identity.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_to_identity(&mut self) {
        self.to_identity = ::std::option::Option::None;
    }

    pub fn has_to_identity(&self) -> bool {
        self.to_identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_identity(&mut self, v: ::std::string::String) {
        self.to_identity = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_identity(&mut self) -> &mut ::std::string::String {
        if self.to_identity.is_none() {
            self.to_identity = ::std::option::Option::Some(::std::string::String::new());
        }
        self.to_identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_to_identity(&mut self) -> ::std::string::String {
        self.to_identity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 to_connection_id = 1;

    pub fn to_connection_id(&self) -> u32 {
        self.to_connection_id.unwrap_or(0)
    }

    pub fn clear_to_connection_id(&mut self) {
        self.to_connection_id = ::std::option::Option::None;
    }

    pub fn has_to_connection_id(&self) -> bool {
        self.to_connection_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to_connection_id(&mut self, v: u32) {
        self.to_connection_id = ::std::option::Option::Some(v);
    }

    // optional bytes sdr_routes = 2;

    pub fn sdr_routes(&self) -> &[u8] {
        match self.sdr_routes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sdr_routes(&mut self) {
        self.sdr_routes = ::std::option::Option::None;
    }

    pub fn has_sdr_routes(&self) -> bool {
        self.sdr_routes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdr_routes(&mut self, v: ::bytes::Bytes) {
        self.sdr_routes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sdr_routes(&mut self) -> &mut ::bytes::Bytes {
        if self.sdr_routes.is_none() {
            self.sdr_routes = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.sdr_routes.as_mut().unwrap()
    }

    // Take field
    pub fn take_sdr_routes(&mut self) -> ::bytes::Bytes {
        self.sdr_routes.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 ack_peer_routes_revision = 3;

    pub fn ack_peer_routes_revision(&self) -> u32 {
        self.ack_peer_routes_revision.unwrap_or(0)
    }

    pub fn clear_ack_peer_routes_revision(&mut self) {
        self.ack_peer_routes_revision = ::std::option::Option::None;
    }

    pub fn has_ack_peer_routes_revision(&self) -> bool {
        self.ack_peer_routes_revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_peer_routes_revision(&mut self, v: u32) {
        self.ack_peer_routes_revision = ::std::option::Option::Some(v);
    }

    // optional bool ice_enabled = 7;

    pub fn ice_enabled(&self) -> bool {
        self.ice_enabled.unwrap_or(false)
    }

    pub fn clear_ice_enabled(&mut self) {
        self.ice_enabled = ::std::option::Option::None;
    }

    pub fn has_ice_enabled(&self) -> bool {
        self.ice_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ice_enabled(&mut self, v: bool) {
        self.ice_enabled = ::std::option::Option::Some(v);
    }

    // optional bytes hosted_server_ticket = 14;

    pub fn hosted_server_ticket(&self) -> &[u8] {
        match self.hosted_server_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hosted_server_ticket(&mut self) {
        self.hosted_server_ticket = ::std::option::Option::None;
    }

    pub fn has_hosted_server_ticket(&self) -> bool {
        self.hosted_server_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hosted_server_ticket(&mut self, v: ::bytes::Bytes) {
        self.hosted_server_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hosted_server_ticket(&mut self) -> &mut ::bytes::Bytes {
        if self.hosted_server_ticket.is_none() {
            self.hosted_server_ticket = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.hosted_server_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_hosted_server_ticket(&mut self) -> ::bytes::Bytes {
        self.hosted_server_ticket.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 ack_reliable_msg = 11;

    pub fn ack_reliable_msg(&self) -> u32 {
        self.ack_reliable_msg.unwrap_or(0)
    }

    pub fn clear_ack_reliable_msg(&mut self) {
        self.ack_reliable_msg = ::std::option::Option::None;
    }

    pub fn has_ack_reliable_msg(&self) -> bool {
        self.ack_reliable_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ack_reliable_msg(&mut self, v: u32) {
        self.ack_reliable_msg = ::std::option::Option::Some(v);
    }

    // optional uint32 first_reliable_msg = 12;

    pub fn first_reliable_msg(&self) -> u32 {
        self.first_reliable_msg.unwrap_or(0)
    }

    pub fn clear_first_reliable_msg(&mut self) {
        self.first_reliable_msg = ::std::option::Option::None;
    }

    pub fn has_first_reliable_msg(&self) -> bool {
        self.first_reliable_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_reliable_msg(&mut self, v: u32) {
        self.first_reliable_msg = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_identity",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.from_identity },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.from_identity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_connection_id",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.from_connection_id },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.from_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "to_identity",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.to_identity },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.to_identity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "to_connection_id",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.to_connection_id },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.to_connection_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sdr_routes",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.sdr_routes },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.sdr_routes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ack_peer_routes_revision",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.ack_peer_routes_revision },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.ack_peer_routes_revision },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ice_enabled",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.ice_enabled },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.ice_enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hosted_server_ticket",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.hosted_server_ticket },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.hosted_server_ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_networking_p2prendezvous::ConnectRequest>(
            "connect_request",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.connect_request },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.connect_request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_networking_p2prendezvous::ConnectOK>(
            "connect_ok",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.connect_ok },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.connect_ok },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_steam_networking_p2prendezvous::ConnectionClosed>(
            "connection_closed",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.connection_closed },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.connection_closed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ack_reliable_msg",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.ack_reliable_msg },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.ack_reliable_msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_reliable_msg",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.first_reliable_msg },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.first_reliable_msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reliable_messages",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.reliable_messages },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.reliable_messages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "application_messages",
            |m: &CMsgSteamNetworkingP2PRendezvous| { &m.application_messages },
            |m: &mut CMsgSteamNetworkingP2PRendezvous| { &mut m.application_messages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamNetworkingP2PRendezvous>(
            "CMsgSteamNetworkingP2PRendezvous",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamNetworkingP2PRendezvous {
    const NAME: &'static str = "CMsgSteamNetworkingP2PRendezvous";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                66 => {
                    self.from_identity = ::std::option::Option::Some(is.read_string()?);
                },
                77 => {
                    self.from_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                82 => {
                    self.to_identity = ::std::option::Option::Some(is.read_string()?);
                },
                13 => {
                    self.to_connection_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    self.sdr_routes = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                24 => {
                    self.ack_peer_routes_revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ice_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                114 => {
                    self.hosted_server_ticket = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.connect_request)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.connect_ok)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.connection_closed)?;
                },
                88 => {
                    self.ack_reliable_msg = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.first_reliable_msg = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.reliable_messages.push(is.read_message()?);
                },
                122 => {
                    self.application_messages.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.from_identity.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.from_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.to_identity.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.to_connection_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.sdr_routes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.ack_peer_routes_revision {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ice_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.hosted_server_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(14, &v);
        }
        if let Some(v) = self.connect_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.connect_ok.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.connection_closed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ack_reliable_msg {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.first_reliable_msg {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        for value in &self.reliable_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.application_messages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.from_identity.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.from_connection_id {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.to_identity.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.to_connection_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.sdr_routes.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.ack_peer_routes_revision {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ice_enabled {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.hosted_server_ticket.as_ref() {
            os.write_bytes(14, v)?;
        }
        if let Some(v) = self.connect_request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.connect_ok.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.connection_closed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.ack_reliable_msg {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.first_reliable_msg {
            os.write_uint32(12, v)?;
        }
        for v in &self.reliable_messages {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.application_messages {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamNetworkingP2PRendezvous {
        CMsgSteamNetworkingP2PRendezvous::new()
    }

    fn clear(&mut self) {
        self.from_identity = ::std::option::Option::None;
        self.from_connection_id = ::std::option::Option::None;
        self.to_identity = ::std::option::Option::None;
        self.to_connection_id = ::std::option::Option::None;
        self.sdr_routes = ::std::option::Option::None;
        self.ack_peer_routes_revision = ::std::option::Option::None;
        self.ice_enabled = ::std::option::Option::None;
        self.hosted_server_ticket = ::std::option::Option::None;
        self.connect_request.clear();
        self.connect_ok.clear();
        self.connection_closed.clear();
        self.ack_reliable_msg = ::std::option::Option::None;
        self.first_reliable_msg = ::std::option::Option::None;
        self.reliable_messages.clear();
        self.application_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamNetworkingP2PRendezvous {
        static instance: CMsgSteamNetworkingP2PRendezvous = CMsgSteamNetworkingP2PRendezvous {
            from_identity: ::std::option::Option::None,
            from_connection_id: ::std::option::Option::None,
            to_identity: ::std::option::Option::None,
            to_connection_id: ::std::option::Option::None,
            sdr_routes: ::std::option::Option::None,
            ack_peer_routes_revision: ::std::option::Option::None,
            ice_enabled: ::std::option::Option::None,
            hosted_server_ticket: ::std::option::Option::None,
            connect_request: ::protobuf::MessageField::none(),
            connect_ok: ::protobuf::MessageField::none(),
            connection_closed: ::protobuf::MessageField::none(),
            ack_reliable_msg: ::std::option::Option::None,
            first_reliable_msg: ::std::option::Option::None,
            reliable_messages: ::std::vec::Vec::new(),
            application_messages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamNetworkingP2PRendezvous {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamNetworkingP2PRendezvous").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamNetworkingP2PRendezvous {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamNetworkingP2PRendezvous {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSteamNetworkingP2PRendezvous`
pub mod cmsg_steam_networking_p2prendezvous {
    // @@protoc_insertion_point(message:CMsgSteamNetworkingP2PRendezvous.ConnectRequest)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ConnectRequest {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ConnectRequest.crypt)
        pub crypt: ::protobuf::MessageField<super::CMsgSteamDatagramSessionCryptInfoSigned>,
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ConnectRequest.cert)
        pub cert: ::protobuf::MessageField<super::super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ConnectRequest.to_virtual_port)
        pub to_virtual_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ConnectRequest.from_virtual_port)
        pub from_virtual_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ConnectRequest.from_fakeip)
        pub from_fakeip: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamNetworkingP2PRendezvous.ConnectRequest.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ConnectRequest {
        fn default() -> &'a ConnectRequest {
            <ConnectRequest as ::protobuf::Message>::default_instance()
        }
    }

    impl ConnectRequest {
        pub fn new() -> ConnectRequest {
            ::std::default::Default::default()
        }

        // optional uint32 to_virtual_port = 9;

        pub fn to_virtual_port(&self) -> u32 {
            self.to_virtual_port.unwrap_or(0)
        }

        pub fn clear_to_virtual_port(&mut self) {
            self.to_virtual_port = ::std::option::Option::None;
        }

        pub fn has_to_virtual_port(&self) -> bool {
            self.to_virtual_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_to_virtual_port(&mut self, v: u32) {
            self.to_virtual_port = ::std::option::Option::Some(v);
        }

        // optional uint32 from_virtual_port = 10;

        pub fn from_virtual_port(&self) -> u32 {
            self.from_virtual_port.unwrap_or(0)
        }

        pub fn clear_from_virtual_port(&mut self) {
            self.from_virtual_port = ::std::option::Option::None;
        }

        pub fn has_from_virtual_port(&self) -> bool {
            self.from_virtual_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_from_virtual_port(&mut self, v: u32) {
            self.from_virtual_port = ::std::option::Option::Some(v);
        }

        // optional string from_fakeip = 11;

        pub fn from_fakeip(&self) -> &str {
            match self.from_fakeip.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_from_fakeip(&mut self) {
            self.from_fakeip = ::std::option::Option::None;
        }

        pub fn has_from_fakeip(&self) -> bool {
            self.from_fakeip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_from_fakeip(&mut self, v: ::std::string::String) {
            self.from_fakeip = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_from_fakeip(&mut self) -> &mut ::std::string::String {
            if self.from_fakeip.is_none() {
                self.from_fakeip = ::std::option::Option::Some(::std::string::String::new());
            }
            self.from_fakeip.as_mut().unwrap()
        }

        // Take field
        pub fn take_from_fakeip(&mut self) -> ::std::string::String {
            self.from_fakeip.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgSteamDatagramSessionCryptInfoSigned>(
                "crypt",
                |m: &ConnectRequest| { &m.crypt },
                |m: &mut ConnectRequest| { &mut m.crypt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>(
                "cert",
                |m: &ConnectRequest| { &m.cert },
                |m: &mut ConnectRequest| { &mut m.cert },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "to_virtual_port",
                |m: &ConnectRequest| { &m.to_virtual_port },
                |m: &mut ConnectRequest| { &mut m.to_virtual_port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "from_virtual_port",
                |m: &ConnectRequest| { &m.from_virtual_port },
                |m: &mut ConnectRequest| { &mut m.from_virtual_port },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "from_fakeip",
                |m: &ConnectRequest| { &m.from_fakeip },
                |m: &mut ConnectRequest| { &mut m.from_fakeip },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectRequest>(
                "CMsgSteamNetworkingP2PRendezvous.ConnectRequest",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ConnectRequest {
        const NAME: &'static str = "ConnectRequest";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.crypt)?;
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                    },
                    72 => {
                        self.to_virtual_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.from_virtual_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    90 => {
                        self.from_fakeip = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.crypt.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.cert.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.to_virtual_port {
                my_size += ::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.from_virtual_port {
                my_size += ::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.from_fakeip.as_ref() {
                my_size += ::protobuf::rt::string_size(11, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.crypt.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            if let Some(v) = self.cert.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if let Some(v) = self.to_virtual_port {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.from_virtual_port {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.from_fakeip.as_ref() {
                os.write_string(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ConnectRequest {
            ConnectRequest::new()
        }

        fn clear(&mut self) {
            self.crypt.clear();
            self.cert.clear();
            self.to_virtual_port = ::std::option::Option::None;
            self.from_virtual_port = ::std::option::Option::None;
            self.from_fakeip = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ConnectRequest {
            static instance: ConnectRequest = ConnectRequest {
                crypt: ::protobuf::MessageField::none(),
                cert: ::protobuf::MessageField::none(),
                to_virtual_port: ::std::option::Option::None,
                from_virtual_port: ::std::option::Option::None,
                from_fakeip: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ConnectRequest {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamNetworkingP2PRendezvous.ConnectRequest").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ConnectRequest {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ConnectRequest {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamNetworkingP2PRendezvous.ConnectOK)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ConnectOK {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ConnectOK.crypt)
        pub crypt: ::protobuf::MessageField<super::CMsgSteamDatagramSessionCryptInfoSigned>,
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ConnectOK.cert)
        pub cert: ::protobuf::MessageField<super::super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamNetworkingP2PRendezvous.ConnectOK.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ConnectOK {
        fn default() -> &'a ConnectOK {
            <ConnectOK as ::protobuf::Message>::default_instance()
        }
    }

    impl ConnectOK {
        pub fn new() -> ConnectOK {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgSteamDatagramSessionCryptInfoSigned>(
                "crypt",
                |m: &ConnectOK| { &m.crypt },
                |m: &mut ConnectOK| { &mut m.crypt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::steamnetworkingsockets_messages_certs::CMsgSteamDatagramCertificateSigned>(
                "cert",
                |m: &ConnectOK| { &m.cert },
                |m: &mut ConnectOK| { &mut m.cert },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectOK>(
                "CMsgSteamNetworkingP2PRendezvous.ConnectOK",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ConnectOK {
        const NAME: &'static str = "ConnectOK";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.crypt)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.cert)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.crypt.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.cert.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.crypt.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.cert.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ConnectOK {
            ConnectOK::new()
        }

        fn clear(&mut self) {
            self.crypt.clear();
            self.cert.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ConnectOK {
            static instance: ConnectOK = ConnectOK {
                crypt: ::protobuf::MessageField::none(),
                cert: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ConnectOK {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamNetworkingP2PRendezvous.ConnectOK").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ConnectOK {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ConnectOK {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamNetworkingP2PRendezvous.ConnectionClosed)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ConnectionClosed {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ConnectionClosed.debug)
        pub debug: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ConnectionClosed.reason_code)
        pub reason_code: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamNetworkingP2PRendezvous.ConnectionClosed.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ConnectionClosed {
        fn default() -> &'a ConnectionClosed {
            <ConnectionClosed as ::protobuf::Message>::default_instance()
        }
    }

    impl ConnectionClosed {
        pub fn new() -> ConnectionClosed {
            ::std::default::Default::default()
        }

        // optional string debug = 5;

        pub fn debug(&self) -> &str {
            match self.debug.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_debug(&mut self) {
            self.debug = ::std::option::Option::None;
        }

        pub fn has_debug(&self) -> bool {
            self.debug.is_some()
        }

        // Param is passed by value, moved
        pub fn set_debug(&mut self, v: ::std::string::String) {
            self.debug = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_debug(&mut self) -> &mut ::std::string::String {
            if self.debug.is_none() {
                self.debug = ::std::option::Option::Some(::std::string::String::new());
            }
            self.debug.as_mut().unwrap()
        }

        // Take field
        pub fn take_debug(&mut self) -> ::std::string::String {
            self.debug.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 reason_code = 6;

        pub fn reason_code(&self) -> u32 {
            self.reason_code.unwrap_or(0)
        }

        pub fn clear_reason_code(&mut self) {
            self.reason_code = ::std::option::Option::None;
        }

        pub fn has_reason_code(&self) -> bool {
            self.reason_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reason_code(&mut self, v: u32) {
            self.reason_code = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "debug",
                |m: &ConnectionClosed| { &m.debug },
                |m: &mut ConnectionClosed| { &mut m.debug },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "reason_code",
                |m: &ConnectionClosed| { &m.reason_code },
                |m: &mut ConnectionClosed| { &mut m.reason_code },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectionClosed>(
                "CMsgSteamNetworkingP2PRendezvous.ConnectionClosed",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ConnectionClosed {
        const NAME: &'static str = "ConnectionClosed";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    42 => {
                        self.debug = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.reason_code = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.debug.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.reason_code {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.debug.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.reason_code {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ConnectionClosed {
            ConnectionClosed::new()
        }

        fn clear(&mut self) {
            self.debug = ::std::option::Option::None;
            self.reason_code = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ConnectionClosed {
            static instance: ConnectionClosed = ConnectionClosed {
                debug: ::std::option::Option::None,
                reason_code: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ConnectionClosed {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamNetworkingP2PRendezvous.ConnectionClosed").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ConnectionClosed {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ConnectionClosed {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamNetworkingP2PRendezvous.ReliableMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReliableMessage {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ReliableMessage.ice)
        pub ice: ::protobuf::MessageField<super::CMsgICERendezvous>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamNetworkingP2PRendezvous.ReliableMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReliableMessage {
        fn default() -> &'a ReliableMessage {
            <ReliableMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl ReliableMessage {
        pub fn new() -> ReliableMessage {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::CMsgICERendezvous>(
                "ice",
                |m: &ReliableMessage| { &m.ice },
                |m: &mut ReliableMessage| { &mut m.ice },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReliableMessage>(
                "CMsgSteamNetworkingP2PRendezvous.ReliableMessage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ReliableMessage {
        const NAME: &'static str = "ReliableMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.ice)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ice.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ice.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReliableMessage {
            ReliableMessage::new()
        }

        fn clear(&mut self) {
            self.ice.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReliableMessage {
            static instance: ReliableMessage = ReliableMessage {
                ice: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ReliableMessage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamNetworkingP2PRendezvous.ReliableMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReliableMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ReliableMessage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSteamNetworkingP2PRendezvous.ApplicationMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ApplicationMessage {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ApplicationMessage.data)
        pub data: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ApplicationMessage.msg_num)
        pub msg_num: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ApplicationMessage.flags)
        pub flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamNetworkingP2PRendezvous.ApplicationMessage.lane_idx)
        pub lane_idx: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamNetworkingP2PRendezvous.ApplicationMessage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ApplicationMessage {
        fn default() -> &'a ApplicationMessage {
            <ApplicationMessage as ::protobuf::Message>::default_instance()
        }
    }

    impl ApplicationMessage {
        pub fn new() -> ApplicationMessage {
            ::std::default::Default::default()
        }

        // optional bytes data = 1;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::bytes::Bytes) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::bytes::Bytes {
            self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional uint64 msg_num = 2;

        pub fn msg_num(&self) -> u64 {
            self.msg_num.unwrap_or(0)
        }

        pub fn clear_msg_num(&mut self) {
            self.msg_num = ::std::option::Option::None;
        }

        pub fn has_msg_num(&self) -> bool {
            self.msg_num.is_some()
        }

        // Param is passed by value, moved
        pub fn set_msg_num(&mut self, v: u64) {
            self.msg_num = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 3;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 lane_idx = 4;

        pub fn lane_idx(&self) -> u32 {
            self.lane_idx.unwrap_or(0)
        }

        pub fn clear_lane_idx(&mut self) {
            self.lane_idx = ::std::option::Option::None;
        }

        pub fn has_lane_idx(&self) -> bool {
            self.lane_idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane_idx(&mut self, v: u32) {
            self.lane_idx = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &ApplicationMessage| { &m.data },
                |m: &mut ApplicationMessage| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "msg_num",
                |m: &ApplicationMessage| { &m.msg_num },
                |m: &mut ApplicationMessage| { &mut m.msg_num },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &ApplicationMessage| { &m.flags },
                |m: &mut ApplicationMessage| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "lane_idx",
                |m: &ApplicationMessage| { &m.lane_idx },
                |m: &mut ApplicationMessage| { &mut m.lane_idx },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ApplicationMessage>(
                "CMsgSteamNetworkingP2PRendezvous.ApplicationMessage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ApplicationMessage {
        const NAME: &'static str = "ApplicationMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    16 => {
                        self.msg_num = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.lane_idx = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.msg_num {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.lane_idx {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.msg_num {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.lane_idx {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ApplicationMessage {
            ApplicationMessage::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.msg_num = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.lane_idx = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ApplicationMessage {
            static instance: ApplicationMessage = ApplicationMessage {
                data: ::std::option::Option::None,
                msg_num: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                lane_idx: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ApplicationMessage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSteamNetworkingP2PRendezvous.ApplicationMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ApplicationMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ApplicationMessage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSteamNetworkingICESessionSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamNetworkingICESessionSummary {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.failure_reason_code)
    pub failure_reason_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.local_candidate_types)
    pub local_candidate_types: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.remote_candidate_types)
    pub remote_candidate_types: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.initial_route_kind)
    pub initial_route_kind: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.initial_ping)
    pub initial_ping: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.initial_score)
    pub initial_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.negotiation_ms)
    pub negotiation_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.best_route_kind)
    pub best_route_kind: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.best_ping)
    pub best_ping: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.best_score)
    pub best_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.best_time)
    pub best_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.selected_seconds)
    pub selected_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.user_settings)
    pub user_settings: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.ice_enable_var)
    pub ice_enable_var: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamNetworkingICESessionSummary.local_candidate_types_allowed)
    pub local_candidate_types_allowed: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamNetworkingICESessionSummary.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamNetworkingICESessionSummary {
    fn default() -> &'a CMsgSteamNetworkingICESessionSummary {
        <CMsgSteamNetworkingICESessionSummary as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamNetworkingICESessionSummary {
    pub fn new() -> CMsgSteamNetworkingICESessionSummary {
        ::std::default::Default::default()
    }

    // optional uint32 failure_reason_code = 7;

    pub fn failure_reason_code(&self) -> u32 {
        self.failure_reason_code.unwrap_or(0)
    }

    pub fn clear_failure_reason_code(&mut self) {
        self.failure_reason_code = ::std::option::Option::None;
    }

    pub fn has_failure_reason_code(&self) -> bool {
        self.failure_reason_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failure_reason_code(&mut self, v: u32) {
        self.failure_reason_code = ::std::option::Option::Some(v);
    }

    // optional uint32 local_candidate_types = 1;

    pub fn local_candidate_types(&self) -> u32 {
        self.local_candidate_types.unwrap_or(0)
    }

    pub fn clear_local_candidate_types(&mut self) {
        self.local_candidate_types = ::std::option::Option::None;
    }

    pub fn has_local_candidate_types(&self) -> bool {
        self.local_candidate_types.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_candidate_types(&mut self, v: u32) {
        self.local_candidate_types = ::std::option::Option::Some(v);
    }

    // optional uint32 remote_candidate_types = 2;

    pub fn remote_candidate_types(&self) -> u32 {
        self.remote_candidate_types.unwrap_or(0)
    }

    pub fn clear_remote_candidate_types(&mut self) {
        self.remote_candidate_types = ::std::option::Option::None;
    }

    pub fn has_remote_candidate_types(&self) -> bool {
        self.remote_candidate_types.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remote_candidate_types(&mut self, v: u32) {
        self.remote_candidate_types = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_route_kind = 3;

    pub fn initial_route_kind(&self) -> u32 {
        self.initial_route_kind.unwrap_or(0)
    }

    pub fn clear_initial_route_kind(&mut self) {
        self.initial_route_kind = ::std::option::Option::None;
    }

    pub fn has_initial_route_kind(&self) -> bool {
        self.initial_route_kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_route_kind(&mut self, v: u32) {
        self.initial_route_kind = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_ping = 4;

    pub fn initial_ping(&self) -> u32 {
        self.initial_ping.unwrap_or(0)
    }

    pub fn clear_initial_ping(&mut self) {
        self.initial_ping = ::std::option::Option::None;
    }

    pub fn has_initial_ping(&self) -> bool {
        self.initial_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_ping(&mut self, v: u32) {
        self.initial_ping = ::std::option::Option::Some(v);
    }

    // optional uint32 initial_score = 6;

    pub fn initial_score(&self) -> u32 {
        self.initial_score.unwrap_or(0)
    }

    pub fn clear_initial_score(&mut self) {
        self.initial_score = ::std::option::Option::None;
    }

    pub fn has_initial_score(&self) -> bool {
        self.initial_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_score(&mut self, v: u32) {
        self.initial_score = ::std::option::Option::Some(v);
    }

    // optional uint32 negotiation_ms = 5;

    pub fn negotiation_ms(&self) -> u32 {
        self.negotiation_ms.unwrap_or(0)
    }

    pub fn clear_negotiation_ms(&mut self) {
        self.negotiation_ms = ::std::option::Option::None;
    }

    pub fn has_negotiation_ms(&self) -> bool {
        self.negotiation_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negotiation_ms(&mut self, v: u32) {
        self.negotiation_ms = ::std::option::Option::Some(v);
    }

    // optional uint32 best_route_kind = 16;

    pub fn best_route_kind(&self) -> u32 {
        self.best_route_kind.unwrap_or(0)
    }

    pub fn clear_best_route_kind(&mut self) {
        self.best_route_kind = ::std::option::Option::None;
    }

    pub fn has_best_route_kind(&self) -> bool {
        self.best_route_kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_route_kind(&mut self, v: u32) {
        self.best_route_kind = ::std::option::Option::Some(v);
    }

    // optional uint32 best_ping = 17;

    pub fn best_ping(&self) -> u32 {
        self.best_ping.unwrap_or(0)
    }

    pub fn clear_best_ping(&mut self) {
        self.best_ping = ::std::option::Option::None;
    }

    pub fn has_best_ping(&self) -> bool {
        self.best_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_ping(&mut self, v: u32) {
        self.best_ping = ::std::option::Option::Some(v);
    }

    // optional uint32 best_score = 18;

    pub fn best_score(&self) -> u32 {
        self.best_score.unwrap_or(0)
    }

    pub fn clear_best_score(&mut self) {
        self.best_score = ::std::option::Option::None;
    }

    pub fn has_best_score(&self) -> bool {
        self.best_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_score(&mut self, v: u32) {
        self.best_score = ::std::option::Option::Some(v);
    }

    // optional uint32 best_time = 19;

    pub fn best_time(&self) -> u32 {
        self.best_time.unwrap_or(0)
    }

    pub fn clear_best_time(&mut self) {
        self.best_time = ::std::option::Option::None;
    }

    pub fn has_best_time(&self) -> bool {
        self.best_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_time(&mut self, v: u32) {
        self.best_time = ::std::option::Option::Some(v);
    }

    // optional uint32 selected_seconds = 12;

    pub fn selected_seconds(&self) -> u32 {
        self.selected_seconds.unwrap_or(0)
    }

    pub fn clear_selected_seconds(&mut self) {
        self.selected_seconds = ::std::option::Option::None;
    }

    pub fn has_selected_seconds(&self) -> bool {
        self.selected_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_seconds(&mut self, v: u32) {
        self.selected_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 user_settings = 13;

    pub fn user_settings(&self) -> u32 {
        self.user_settings.unwrap_or(0)
    }

    pub fn clear_user_settings(&mut self) {
        self.user_settings = ::std::option::Option::None;
    }

    pub fn has_user_settings(&self) -> bool {
        self.user_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_settings(&mut self, v: u32) {
        self.user_settings = ::std::option::Option::Some(v);
    }

    // optional uint32 ice_enable_var = 14;

    pub fn ice_enable_var(&self) -> u32 {
        self.ice_enable_var.unwrap_or(0)
    }

    pub fn clear_ice_enable_var(&mut self) {
        self.ice_enable_var = ::std::option::Option::None;
    }

    pub fn has_ice_enable_var(&self) -> bool {
        self.ice_enable_var.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ice_enable_var(&mut self, v: u32) {
        self.ice_enable_var = ::std::option::Option::Some(v);
    }

    // optional uint32 local_candidate_types_allowed = 15;

    pub fn local_candidate_types_allowed(&self) -> u32 {
        self.local_candidate_types_allowed.unwrap_or(0)
    }

    pub fn clear_local_candidate_types_allowed(&mut self) {
        self.local_candidate_types_allowed = ::std::option::Option::None;
    }

    pub fn has_local_candidate_types_allowed(&self) -> bool {
        self.local_candidate_types_allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_candidate_types_allowed(&mut self, v: u32) {
        self.local_candidate_types_allowed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "failure_reason_code",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.failure_reason_code },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.failure_reason_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_candidate_types",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.local_candidate_types },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.local_candidate_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remote_candidate_types",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.remote_candidate_types },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.remote_candidate_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_route_kind",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.initial_route_kind },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.initial_route_kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_ping",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.initial_ping },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.initial_ping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "initial_score",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.initial_score },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.initial_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "negotiation_ms",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.negotiation_ms },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.negotiation_ms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "best_route_kind",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.best_route_kind },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.best_route_kind },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "best_ping",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.best_ping },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.best_ping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "best_score",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.best_score },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.best_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "best_time",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.best_time },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.best_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "selected_seconds",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.selected_seconds },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.selected_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_settings",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.user_settings },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.user_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ice_enable_var",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.ice_enable_var },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.ice_enable_var },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_candidate_types_allowed",
            |m: &CMsgSteamNetworkingICESessionSummary| { &m.local_candidate_types_allowed },
            |m: &mut CMsgSteamNetworkingICESessionSummary| { &mut m.local_candidate_types_allowed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSteamNetworkingICESessionSummary>(
            "CMsgSteamNetworkingICESessionSummary",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSteamNetworkingICESessionSummary {
    const NAME: &'static str = "CMsgSteamNetworkingICESessionSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                56 => {
                    self.failure_reason_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    self.local_candidate_types = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.remote_candidate_types = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.initial_route_kind = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.initial_ping = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.initial_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.negotiation_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.best_route_kind = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.best_ping = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.best_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.best_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.selected_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.user_settings = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.ice_enable_var = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.local_candidate_types_allowed = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.failure_reason_code {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.local_candidate_types {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.remote_candidate_types {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.initial_route_kind {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.initial_ping {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.initial_score {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.negotiation_ms {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.best_route_kind {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.best_ping {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.best_score {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.best_time {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.selected_seconds {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.user_settings {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.ice_enable_var {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.local_candidate_types_allowed {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.failure_reason_code {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.local_candidate_types {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.remote_candidate_types {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.initial_route_kind {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.initial_ping {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.initial_score {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.negotiation_ms {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.best_route_kind {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.best_ping {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.best_score {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.best_time {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.selected_seconds {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.user_settings {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.ice_enable_var {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.local_candidate_types_allowed {
            os.write_uint32(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamNetworkingICESessionSummary {
        CMsgSteamNetworkingICESessionSummary::new()
    }

    fn clear(&mut self) {
        self.failure_reason_code = ::std::option::Option::None;
        self.local_candidate_types = ::std::option::Option::None;
        self.remote_candidate_types = ::std::option::Option::None;
        self.initial_route_kind = ::std::option::Option::None;
        self.initial_ping = ::std::option::Option::None;
        self.initial_score = ::std::option::Option::None;
        self.negotiation_ms = ::std::option::Option::None;
        self.best_route_kind = ::std::option::Option::None;
        self.best_ping = ::std::option::Option::None;
        self.best_score = ::std::option::Option::None;
        self.best_time = ::std::option::Option::None;
        self.selected_seconds = ::std::option::Option::None;
        self.user_settings = ::std::option::Option::None;
        self.ice_enable_var = ::std::option::Option::None;
        self.local_candidate_types_allowed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamNetworkingICESessionSummary {
        static instance: CMsgSteamNetworkingICESessionSummary = CMsgSteamNetworkingICESessionSummary {
            failure_reason_code: ::std::option::Option::None,
            local_candidate_types: ::std::option::Option::None,
            remote_candidate_types: ::std::option::Option::None,
            initial_route_kind: ::std::option::Option::None,
            initial_ping: ::std::option::Option::None,
            initial_score: ::std::option::Option::None,
            negotiation_ms: ::std::option::Option::None,
            best_route_kind: ::std::option::Option::None,
            best_ping: ::std::option::Option::None,
            best_score: ::std::option::Option::None,
            best_time: ::std::option::Option::None,
            selected_seconds: ::std::option::Option::None,
            user_settings: ::std::option::Option::None,
            ice_enable_var: ::std::option::Option::None,
            local_candidate_types_allowed: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSteamNetworkingICESessionSummary {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSteamNetworkingICESessionSummary").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSteamNetworkingICESessionSummary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSteamNetworkingICESessionSummary {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamNetworkingSocketsCipher)
pub enum ESteamNetworkingSocketsCipher {
    // @@protoc_insertion_point(enum_value:ESteamNetworkingSocketsCipher.k_ESteamNetworkingSocketsCipher_INVALID)
    k_ESteamNetworkingSocketsCipher_INVALID = 0,
    // @@protoc_insertion_point(enum_value:ESteamNetworkingSocketsCipher.k_ESteamNetworkingSocketsCipher_NULL)
    k_ESteamNetworkingSocketsCipher_NULL = 1,
    // @@protoc_insertion_point(enum_value:ESteamNetworkingSocketsCipher.k_ESteamNetworkingSocketsCipher_AES_256_GCM)
    k_ESteamNetworkingSocketsCipher_AES_256_GCM = 2,
}

impl ::protobuf::Enum for ESteamNetworkingSocketsCipher {
    const NAME: &'static str = "ESteamNetworkingSocketsCipher";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamNetworkingSocketsCipher> {
        match value {
            0 => ::std::option::Option::Some(ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_INVALID),
            1 => ::std::option::Option::Some(ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_NULL),
            2 => ::std::option::Option::Some(ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_AES_256_GCM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamNetworkingSocketsCipher> {
        match str {
            "k_ESteamNetworkingSocketsCipher_INVALID" => ::std::option::Option::Some(ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_INVALID),
            "k_ESteamNetworkingSocketsCipher_NULL" => ::std::option::Option::Some(ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_NULL),
            "k_ESteamNetworkingSocketsCipher_AES_256_GCM" => ::std::option::Option::Some(ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_AES_256_GCM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamNetworkingSocketsCipher] = &[
        ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_INVALID,
        ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_NULL,
        ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_AES_256_GCM,
    ];
}

impl ::protobuf::EnumFull for ESteamNetworkingSocketsCipher {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamNetworkingSocketsCipher").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamNetworkingSocketsCipher {
    fn default() -> Self {
        ESteamNetworkingSocketsCipher::k_ESteamNetworkingSocketsCipher_INVALID
    }
}

impl ESteamNetworkingSocketsCipher {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESteamNetworkingSocketsCipher>("ESteamNetworkingSocketsCipher")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%steamnetworkingsockets_messages.proto\x1a+steamnetworkingsockets_mess\
    ages_certs.proto\"\xb3\x02\n!CMsgSteamDatagramSessionCryptInfo\x12O\n\
    \x08key_type\x18\x01\x20\x01(\x0e2+.CMsgSteamDatagramSessionCryptInfo.EK\
    eyType:\x07INVALIDR\x07keyType\x12\x19\n\x08key_data\x18\x02\x20\x01(\
    \x0cR\x07keyData\x12\x14\n\x05nonce\x18\x03\x20\x01(\x06R\x05nonce\x12)\
    \n\x10protocol_version\x18\x04\x20\x01(\rR\x0fprotocolVersion\x128\n\x07\
    ciphers\x18\x05\x20\x03(\x0e2\x1e.ESteamNetworkingSocketsCipherR\x07ciph\
    ers\"'\n\x08EKeyType\x12\x0b\n\x07INVALID\x10\0\x12\x0e\n\nCURVE25519\
    \x10\x01\"[\n'CMsgSteamDatagramSessionCryptInfoSigned\x12\x12\n\x04info\
    \x18\x01\x20\x01(\x0cR\x04info\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0c\
    R\tsignature\"M\n\x1bCMsgSteamDatagramDiagnostic\x12\x1a\n\x08severity\
    \x18\x01\x20\x01(\rR\x08severity\x12\x12\n\x04text\x18\x02\x20\x01(\tR\
    \x04text\"\x97\x03\n'CMsgSteamDatagramLinkInstantaneousStats\x124\n\x17o\
    ut_packets_per_sec_x10\x18\x01\x20\x01(\rR\x13outPacketsPerSecX10\x12)\n\
    \x11out_bytes_per_sec\x18\x02\x20\x01(\rR\x0eoutBytesPerSec\x122\n\x16in\
    _packets_per_sec_x10\x18\x03\x20\x01(\rR\x12inPacketsPerSecX10\x12'\n\
    \x10in_bytes_per_sec\x18\x04\x20\x01(\rR\rinBytesPerSec\x12\x17\n\x07pin\
    g_ms\x18\x05\x20\x01(\rR\x06pingMs\x12.\n\x13packets_dropped_pct\x18\x06\
    \x20\x01(\rR\x11packetsDroppedPct\x12;\n\x1apackets_weird_sequence_pct\
    \x18\x07\x20\x01(\rR\x17packetsWeirdSequencePct\x12(\n\x10peak_jitter_us\
    ec\x18\x08\x20\x01(\rR\x0epeakJitterUsec\"\xa0\x1c\n\"CMsgSteamDatagramL\
    inkLifetimeStats\x12+\n\x11connected_seconds\x18\x02\x20\x01(\rR\x10conn\
    ectedSeconds\x12!\n\x0cpackets_sent\x18\x03\x20\x01(\x04R\x0bpacketsSent\
    \x12\x17\n\x07kb_sent\x18\x04\x20\x01(\x04R\x06kbSent\x12!\n\x0cpackets_\
    recv\x18\x05\x20\x01(\x04R\x0bpacketsRecv\x12\x17\n\x07kb_recv\x18\x06\
    \x20\x01(\x04R\x06kbRecv\x124\n\x16packets_recv_sequenced\x18\x07\x20\
    \x01(\x04R\x14packetsRecvSequenced\x120\n\x14packets_recv_dropped\x18\
    \x08\x20\x01(\x04R\x12packetsRecvDropped\x128\n\x19packets_recv_out_of_o\
    rder\x18\t\x20\x01(\x04R\x15packetsRecvOutOfOrder\x12K\n#packets_recv_ou\
    t_of_order_corrected\x18\x0f\x20\x01(\x04R\x1epacketsRecvOutOfOrderCorre\
    cted\x124\n\x16packets_recv_duplicate\x18\n\x20\x01(\x04R\x14packetsRecv\
    Duplicate\x12,\n\x12packets_recv_lurch\x18\x0b\x20\x01(\x04R\x10packetsR\
    ecvLurch\x12G\n\x20multipath_packets_recv_sequenced\x18\x0c\x20\x03(\x04\
    R\x1dmultipathPacketsRecvSequenced\x12?\n\x1cmultipath_packets_recv_late\
    r\x18\r\x20\x03(\x04R\x19multipathPacketsRecvLater\x124\n\x16multipath_s\
    end_enabled\x18\x0e\x20\x01(\rR\x14multipathSendEnabled\x122\n\x15qualit\
    y_histogram_100\x18\x15\x20\x01(\rR\x13qualityHistogram100\x120\n\x14qua\
    lity_histogram_99\x18\x16\x20\x01(\rR\x12qualityHistogram99\x120\n\x14qu\
    ality_histogram_97\x18\x17\x20\x01(\rR\x12qualityHistogram97\x120\n\x14q\
    uality_histogram_95\x18\x18\x20\x01(\rR\x12qualityHistogram95\x120\n\x14\
    quality_histogram_90\x18\x19\x20\x01(\rR\x12qualityHistogram90\x120\n\
    \x14quality_histogram_75\x18\x1a\x20\x01(\rR\x12qualityHistogram75\x120\
    \n\x14quality_histogram_50\x18\x1b\x20\x01(\rR\x12qualityHistogram50\x12\
    .\n\x13quality_histogram_1\x18\x1c\x20\x01(\rR\x11qualityHistogram1\x124\
    \n\x16quality_histogram_dead\x18\x1d\x20\x01(\rR\x14qualityHistogramDead\
    \x12*\n\x11quality_ntile_2nd\x18\x1e\x20\x01(\rR\x0fqualityNtile2nd\x12*\
    \n\x11quality_ntile_5th\x18\x1f\x20\x01(\rR\x0fqualityNtile5th\x12,\n\
    \x12quality_ntile_25th\x18\x20\x20\x01(\rR\x10qualityNtile25th\x12,\n\
    \x12quality_ntile_50th\x18!\x20\x01(\rR\x10qualityNtile50th\x12*\n\x11pi\
    ng_histogram_25\x18)\x20\x01(\rR\x0fpingHistogram25\x12*\n\x11ping_histo\
    gram_50\x18*\x20\x01(\rR\x0fpingHistogram50\x12*\n\x11ping_histogram_75\
    \x18+\x20\x01(\rR\x0fpingHistogram75\x12,\n\x12ping_histogram_100\x18,\
    \x20\x01(\rR\x10pingHistogram100\x12,\n\x12ping_histogram_125\x18-\x20\
    \x01(\rR\x10pingHistogram125\x12,\n\x12ping_histogram_150\x18.\x20\x01(\
    \rR\x10pingHistogram150\x12,\n\x12ping_histogram_200\x18/\x20\x01(\rR\
    \x10pingHistogram200\x12,\n\x12ping_histogram_300\x180\x20\x01(\rR\x10pi\
    ngHistogram300\x12,\n\x12ping_histogram_max\x181\x20\x01(\rR\x10pingHist\
    ogramMax\x12$\n\x0eping_ntile_5th\x182\x20\x01(\rR\x0cpingNtile5th\x12&\
    \n\x0fping_ntile_50th\x183\x20\x01(\rR\rpingNtile50th\x12&\n\x0fping_nti\
    le_75th\x184\x20\x01(\rR\rpingNtile75th\x12&\n\x0fping_ntile_95th\x185\
    \x20\x01(\rR\rpingNtile95th\x12&\n\x0fping_ntile_98th\x186\x20\x01(\rR\r\
    pingNtile98th\x12>\n\x1bjitter_histogram_negligible\x18=\x20\x01(\rR\x19\
    jitterHistogramNegligible\x12,\n\x12jitter_histogram_1\x18>\x20\x01(\rR\
    \x10jitterHistogram1\x12,\n\x12jitter_histogram_2\x18?\x20\x01(\rR\x10ji\
    tterHistogram2\x12,\n\x12jitter_histogram_5\x18@\x20\x01(\rR\x10jitterHi\
    stogram5\x12.\n\x13jitter_histogram_10\x18A\x20\x01(\rR\x11jitterHistogr\
    am10\x12.\n\x13jitter_histogram_20\x18B\x20\x01(\rR\x11jitterHistogram20\
    \x12\x1f\n\x0btxspeed_max\x18C\x20\x01(\rR\ntxspeedMax\x120\n\x14txspeed\
    _histogram_16\x18D\x20\x01(\rR\x12txspeedHistogram16\x120\n\x14txspeed_h\
    istogram_32\x18E\x20\x01(\rR\x12txspeedHistogram32\x120\n\x14txspeed_his\
    togram_64\x18F\x20\x01(\rR\x12txspeedHistogram64\x122\n\x15txspeed_histo\
    gram_128\x18G\x20\x01(\rR\x13txspeedHistogram128\x122\n\x15txspeed_histo\
    gram_256\x18H\x20\x01(\rR\x13txspeedHistogram256\x122\n\x15txspeed_histo\
    gram_512\x18I\x20\x01(\rR\x13txspeedHistogram512\x124\n\x16txspeed_histo\
    gram_1024\x18J\x20\x01(\rR\x14txspeedHistogram1024\x122\n\x15txspeed_his\
    togram_max\x18K\x20\x01(\rR\x13txspeedHistogramMax\x12*\n\x11txspeed_nti\
    le_5th\x18L\x20\x01(\rR\x0ftxspeedNtile5th\x12,\n\x12txspeed_ntile_50th\
    \x18M\x20\x01(\rR\x10txspeedNtile50th\x12,\n\x12txspeed_ntile_75th\x18N\
    \x20\x01(\rR\x10txspeedNtile75th\x12,\n\x12txspeed_ntile_95th\x18O\x20\
    \x01(\rR\x10txspeedNtile95th\x12,\n\x12txspeed_ntile_98th\x18P\x20\x01(\
    \rR\x10txspeedNtile98th\x12\x1f\n\x0brxspeed_max\x18Q\x20\x01(\rR\nrxspe\
    edMax\x120\n\x14rxspeed_histogram_16\x18R\x20\x01(\rR\x12rxspeedHistogra\
    m16\x120\n\x14rxspeed_histogram_32\x18S\x20\x01(\rR\x12rxspeedHistogram3\
    2\x120\n\x14rxspeed_histogram_64\x18T\x20\x01(\rR\x12rxspeedHistogram64\
    \x122\n\x15rxspeed_histogram_128\x18U\x20\x01(\rR\x13rxspeedHistogram128\
    \x122\n\x15rxspeed_histogram_256\x18V\x20\x01(\rR\x13rxspeedHistogram256\
    \x122\n\x15rxspeed_histogram_512\x18W\x20\x01(\rR\x13rxspeedHistogram512\
    \x124\n\x16rxspeed_histogram_1024\x18X\x20\x01(\rR\x14rxspeedHistogram10\
    24\x122\n\x15rxspeed_histogram_max\x18Y\x20\x01(\rR\x13rxspeedHistogramM\
    ax\x12*\n\x11rxspeed_ntile_5th\x18Z\x20\x01(\rR\x0frxspeedNtile5th\x12,\
    \n\x12rxspeed_ntile_50th\x18[\x20\x01(\rR\x10rxspeedNtile50th\x12,\n\x12\
    rxspeed_ntile_75th\x18\\\x20\x01(\rR\x10rxspeedNtile75th\x12,\n\x12rxspe\
    ed_ntile_95th\x18]\x20\x01(\rR\x10rxspeedNtile95th\x12,\n\x12rxspeed_nti\
    le_98th\x18^\x20\x01(\rR\x10rxspeedNtile98th\"\xb5\x01\n\"CMsgSteamDatag\
    ramConnectionQuality\x12N\n\rinstantaneous\x18\x01\x20\x01(\x0b2(.CMsgSt\
    eamDatagramLinkInstantaneousStatsR\rinstantaneous\x12?\n\x08lifetime\x18\
    \x02\x20\x01(\x0b2#.CMsgSteamDatagramLinkLifetimeStatsR\x08lifetime\"0\n\
    \x10CMsgICECandidate\x12\x1c\n\tcandidate\x18\x03\x20\x01(\tR\tcandidate\
    \"\x9b\x01\n\x11CMsgICERendezvous\x12+\n\x04auth\x18\x02\x20\x01(\x0b2\
    \x17.CMsgICERendezvous.AuthR\x04auth\x126\n\radd_candidate\x18\x01\x20\
    \x01(\x0b2\x11.CMsgICECandidateR\x0caddCandidate\x1a!\n\x04Auth\x12\x19\
    \n\x08pwd_frag\x18\x01\x20\x01(\tR\x07pwdFrag\"\x94\x0c\n\x20CMsgSteamNe\
    tworkingP2PRendezvous\x12#\n\rfrom_identity\x18\x08\x20\x01(\tR\x0cfromI\
    dentity\x12,\n\x12from_connection_id\x18\t\x20\x01(\x07R\x10fromConnecti\
    onId\x12\x1f\n\x0bto_identity\x18\n\x20\x01(\tR\ntoIdentity\x12(\n\x10to\
    _connection_id\x18\x01\x20\x01(\x07R\x0etoConnectionId\x12\x1d\n\nsdr_ro\
    utes\x18\x02\x20\x01(\x0cR\tsdrRoutes\x127\n\x18ack_peer_routes_revision\
    \x18\x03\x20\x01(\rR\x15ackPeerRoutesRevision\x12\x1f\n\x0bice_enabled\
    \x18\x07\x20\x01(\x08R\niceEnabled\x120\n\x14hosted_server_ticket\x18\
    \x0e\x20\x01(\x0cR\x12hostedServerTicket\x12Y\n\x0fconnect_request\x18\
    \x04\x20\x01(\x0b20.CMsgSteamNetworkingP2PRendezvous.ConnectRequestR\x0e\
    connectRequest\x12J\n\nconnect_ok\x18\x05\x20\x01(\x0b2+.CMsgSteamNetwor\
    kingP2PRendezvous.ConnectOKR\tconnectOk\x12_\n\x11connection_closed\x18\
    \x06\x20\x01(\x0b22.CMsgSteamNetworkingP2PRendezvous.ConnectionClosedR\
    \x10connectionClosed\x12(\n\x10ack_reliable_msg\x18\x0b\x20\x01(\rR\x0ea\
    ckReliableMsg\x12,\n\x12first_reliable_msg\x18\x0c\x20\x01(\rR\x10firstR\
    eliableMsg\x12^\n\x11reliable_messages\x18\r\x20\x03(\x0b21.CMsgSteamNet\
    workingP2PRendezvous.ReliableMessageR\x10reliableMessages\x12g\n\x14appl\
    ication_messages\x18\x0f\x20\x03(\x0b24.CMsgSteamNetworkingP2PRendezvous\
    .ApplicationMessageR\x13applicationMessages\x1a\xfe\x01\n\x0eConnectRequ\
    est\x12>\n\x05crypt\x18\x06\x20\x01(\x0b2(.CMsgSteamDatagramSessionCrypt\
    InfoSignedR\x05crypt\x127\n\x04cert\x18\x07\x20\x01(\x0b2#.CMsgSteamData\
    gramCertificateSignedR\x04cert\x12&\n\x0fto_virtual_port\x18\t\x20\x01(\
    \rR\rtoVirtualPort\x12*\n\x11from_virtual_port\x18\n\x20\x01(\rR\x0ffrom\
    VirtualPort\x12\x1f\n\x0bfrom_fakeip\x18\x0b\x20\x01(\tR\nfromFakeip\x1a\
    \x84\x01\n\tConnectOK\x12>\n\x05crypt\x18\x05\x20\x01(\x0b2(.CMsgSteamDa\
    tagramSessionCryptInfoSignedR\x05crypt\x127\n\x04cert\x18\x06\x20\x01(\
    \x0b2#.CMsgSteamDatagramCertificateSignedR\x04cert\x1aI\n\x10ConnectionC\
    losed\x12\x14\n\x05debug\x18\x05\x20\x01(\tR\x05debug\x12\x1f\n\x0breaso\
    n_code\x18\x06\x20\x01(\rR\nreasonCode\x1a7\n\x0fReliableMessage\x12$\n\
    \x03ice\x18\x01\x20\x01(\x0b2\x12.CMsgICERendezvousR\x03ice\x1ar\n\x12Ap\
    plicationMessage\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x17\
    \n\x07msg_num\x18\x02\x20\x01(\x04R\x06msgNum\x12\x14\n\x05flags\x18\x03\
    \x20\x01(\rR\x05flags\x12\x19\n\x08lane_idx\x18\x04\x20\x01(\rR\x07laneI\
    dx\"\x97\x05\n$CMsgSteamNetworkingICESessionSummary\x12.\n\x13failure_re\
    ason_code\x18\x07\x20\x01(\rR\x11failureReasonCode\x122\n\x15local_candi\
    date_types\x18\x01\x20\x01(\rR\x13localCandidateTypes\x124\n\x16remote_c\
    andidate_types\x18\x02\x20\x01(\rR\x14remoteCandidateTypes\x12,\n\x12ini\
    tial_route_kind\x18\x03\x20\x01(\rR\x10initialRouteKind\x12!\n\x0cinitia\
    l_ping\x18\x04\x20\x01(\rR\x0binitialPing\x12#\n\rinitial_score\x18\x06\
    \x20\x01(\rR\x0cinitialScore\x12%\n\x0enegotiation_ms\x18\x05\x20\x01(\r\
    R\rnegotiationMs\x12&\n\x0fbest_route_kind\x18\x10\x20\x01(\rR\rbestRout\
    eKind\x12\x1b\n\tbest_ping\x18\x11\x20\x01(\rR\x08bestPing\x12\x1d\n\nbe\
    st_score\x18\x12\x20\x01(\rR\tbestScore\x12\x1b\n\tbest_time\x18\x13\x20\
    \x01(\rR\x08bestTime\x12)\n\x10selected_seconds\x18\x0c\x20\x01(\rR\x0fs\
    electedSeconds\x12#\n\ruser_settings\x18\r\x20\x01(\rR\x0cuserSettings\
    \x12$\n\x0eice_enable_var\x18\x0e\x20\x01(\rR\x0ciceEnableVar\x12A\n\x1d\
    local_candidate_types_allowed\x18\x0f\x20\x01(\rR\x1alocalCandidateTypes\
    Allowed*\xa7\x01\n\x1dESteamNetworkingSocketsCipher\x12+\n'k_ESteamNetwo\
    rkingSocketsCipher_INVALID\x10\0\x12(\n$k_ESteamNetworkingSocketsCipher_\
    NULL\x10\x01\x12/\n+k_ESteamNetworkingSocketsCipher_AES_256_GCM\x10\x02B\
    \x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steamnetworkingsockets_messages_certs::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(16);
            messages.push(CMsgSteamDatagramSessionCryptInfo::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramSessionCryptInfoSigned::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramDiagnostic::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramLinkInstantaneousStats::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramLinkLifetimeStats::generated_message_descriptor_data());
            messages.push(CMsgSteamDatagramConnectionQuality::generated_message_descriptor_data());
            messages.push(CMsgICECandidate::generated_message_descriptor_data());
            messages.push(CMsgICERendezvous::generated_message_descriptor_data());
            messages.push(CMsgSteamNetworkingP2PRendezvous::generated_message_descriptor_data());
            messages.push(CMsgSteamNetworkingICESessionSummary::generated_message_descriptor_data());
            messages.push(cmsg_icerendezvous::Auth::generated_message_descriptor_data());
            messages.push(cmsg_steam_networking_p2prendezvous::ConnectRequest::generated_message_descriptor_data());
            messages.push(cmsg_steam_networking_p2prendezvous::ConnectOK::generated_message_descriptor_data());
            messages.push(cmsg_steam_networking_p2prendezvous::ConnectionClosed::generated_message_descriptor_data());
            messages.push(cmsg_steam_networking_p2prendezvous::ReliableMessage::generated_message_descriptor_data());
            messages.push(cmsg_steam_networking_p2prendezvous::ApplicationMessage::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(ESteamNetworkingSocketsCipher::generated_enum_descriptor_data());
            enums.push(cmsg_steam_datagram_session_crypt_info::EKeyType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
