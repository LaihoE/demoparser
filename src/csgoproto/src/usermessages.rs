// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.12.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `usermessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CUserMessageAchievementEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageAchievementEvent {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageAchievementEvent.achievement)
    pub achievement: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageAchievementEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageAchievementEvent {
    fn default() -> &'a CUserMessageAchievementEvent {
        <CUserMessageAchievementEvent as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageAchievementEvent {
    pub fn new() -> CUserMessageAchievementEvent {
        ::std::default::Default::default()
    }

    // optional uint32 achievement = 1;

    pub fn achievement(&self) -> u32 {
        self.achievement.unwrap_or(0)
    }

    pub fn clear_achievement(&mut self) {
        self.achievement = ::std::option::Option::None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: u32) {
        self.achievement = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "achievement",
            |m: &CUserMessageAchievementEvent| { &m.achievement },
            |m: &mut CUserMessageAchievementEvent| { &mut m.achievement },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageAchievementEvent>(
            "CUserMessageAchievementEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageAchievementEvent {
    const NAME: &'static str = "CUserMessageAchievementEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.achievement = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.achievement {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.achievement {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageAchievementEvent {
        CUserMessageAchievementEvent::new()
    }

    fn clear(&mut self) {
        self.achievement = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageAchievementEvent {
        static instance: CUserMessageAchievementEvent = CUserMessageAchievementEvent {
            achievement: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageAchievementEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageAchievementEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageAchievementEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageAchievementEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageCloseCaption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCloseCaption {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCloseCaption.hash)
    pub hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaption.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaption.from_player)
    pub from_player: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaption.ent_index)
    pub ent_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCloseCaption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCloseCaption {
    fn default() -> &'a CUserMessageCloseCaption {
        <CUserMessageCloseCaption as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCloseCaption {
    pub fn new() -> CUserMessageCloseCaption {
        ::std::default::Default::default()
    }

    // optional fixed32 hash = 1;

    pub fn hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    // optional int32 ent_index = 4;

    pub fn ent_index(&self) -> i32 {
        self.ent_index.unwrap_or(-1i32)
    }

    pub fn clear_ent_index(&mut self) {
        self.ent_index = ::std::option::Option::None;
    }

    pub fn has_ent_index(&self) -> bool {
        self.ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_index(&mut self, v: i32) {
        self.ent_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &CUserMessageCloseCaption| { &m.hash },
            |m: &mut CUserMessageCloseCaption| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUserMessageCloseCaption| { &m.duration },
            |m: &mut CUserMessageCloseCaption| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_player",
            |m: &CUserMessageCloseCaption| { &m.from_player },
            |m: &mut CUserMessageCloseCaption| { &mut m.from_player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ent_index",
            |m: &CUserMessageCloseCaption| { &m.ent_index },
            |m: &mut CUserMessageCloseCaption| { &mut m.ent_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageCloseCaption>(
            "CUserMessageCloseCaption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageCloseCaption {
    const NAME: &'static str = "CUserMessageCloseCaption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.hash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ent_index {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hash {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ent_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCloseCaption {
        CUserMessageCloseCaption::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.ent_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCloseCaption {
        static instance: CUserMessageCloseCaption = CUserMessageCloseCaption {
            hash: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            ent_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageCloseCaption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageCloseCaption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageCloseCaption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageCloseCaption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageCloseCaptionDirect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCloseCaptionDirect {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionDirect.hash)
    pub hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionDirect.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionDirect.from_player)
    pub from_player: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionDirect.ent_index)
    pub ent_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCloseCaptionDirect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCloseCaptionDirect {
    fn default() -> &'a CUserMessageCloseCaptionDirect {
        <CUserMessageCloseCaptionDirect as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCloseCaptionDirect {
    pub fn new() -> CUserMessageCloseCaptionDirect {
        ::std::default::Default::default()
    }

    // optional fixed32 hash = 1;

    pub fn hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    // optional int32 ent_index = 4;

    pub fn ent_index(&self) -> i32 {
        self.ent_index.unwrap_or(-1i32)
    }

    pub fn clear_ent_index(&mut self) {
        self.ent_index = ::std::option::Option::None;
    }

    pub fn has_ent_index(&self) -> bool {
        self.ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_index(&mut self, v: i32) {
        self.ent_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &CUserMessageCloseCaptionDirect| { &m.hash },
            |m: &mut CUserMessageCloseCaptionDirect| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUserMessageCloseCaptionDirect| { &m.duration },
            |m: &mut CUserMessageCloseCaptionDirect| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_player",
            |m: &CUserMessageCloseCaptionDirect| { &m.from_player },
            |m: &mut CUserMessageCloseCaptionDirect| { &mut m.from_player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ent_index",
            |m: &CUserMessageCloseCaptionDirect| { &m.ent_index },
            |m: &mut CUserMessageCloseCaptionDirect| { &mut m.ent_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageCloseCaptionDirect>(
            "CUserMessageCloseCaptionDirect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageCloseCaptionDirect {
    const NAME: &'static str = "CUserMessageCloseCaptionDirect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.hash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ent_index {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hash {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ent_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCloseCaptionDirect {
        CUserMessageCloseCaptionDirect::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.ent_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCloseCaptionDirect {
        static instance: CUserMessageCloseCaptionDirect = CUserMessageCloseCaptionDirect {
            hash: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            ent_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageCloseCaptionDirect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageCloseCaptionDirect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageCloseCaptionDirect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageCloseCaptionDirect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageCloseCaptionPlaceholder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCloseCaptionPlaceholder {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionPlaceholder.string)
    pub string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionPlaceholder.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionPlaceholder.from_player)
    pub from_player: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionPlaceholder.ent_index)
    pub ent_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCloseCaptionPlaceholder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCloseCaptionPlaceholder {
    fn default() -> &'a CUserMessageCloseCaptionPlaceholder {
        <CUserMessageCloseCaptionPlaceholder as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCloseCaptionPlaceholder {
    pub fn new() -> CUserMessageCloseCaptionPlaceholder {
        ::std::default::Default::default()
    }

    // optional string string = 1;

    pub fn string(&self) -> &str {
        match self.string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.string = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        self.string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if self.string.is_none() {
            self.string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string.as_mut().unwrap()
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        self.string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    // optional int32 ent_index = 4;

    pub fn ent_index(&self) -> i32 {
        self.ent_index.unwrap_or(-1i32)
    }

    pub fn clear_ent_index(&mut self) {
        self.ent_index = ::std::option::Option::None;
    }

    pub fn has_ent_index(&self) -> bool {
        self.ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_index(&mut self, v: i32) {
        self.ent_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string",
            |m: &CUserMessageCloseCaptionPlaceholder| { &m.string },
            |m: &mut CUserMessageCloseCaptionPlaceholder| { &mut m.string },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUserMessageCloseCaptionPlaceholder| { &m.duration },
            |m: &mut CUserMessageCloseCaptionPlaceholder| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_player",
            |m: &CUserMessageCloseCaptionPlaceholder| { &m.from_player },
            |m: &mut CUserMessageCloseCaptionPlaceholder| { &mut m.from_player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ent_index",
            |m: &CUserMessageCloseCaptionPlaceholder| { &m.ent_index },
            |m: &mut CUserMessageCloseCaptionPlaceholder| { &mut m.ent_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageCloseCaptionPlaceholder>(
            "CUserMessageCloseCaptionPlaceholder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageCloseCaptionPlaceholder {
    const NAME: &'static str = "CUserMessageCloseCaptionPlaceholder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.string = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.string.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ent_index {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.string.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ent_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCloseCaptionPlaceholder {
        CUserMessageCloseCaptionPlaceholder::new()
    }

    fn clear(&mut self) {
        self.string = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.ent_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCloseCaptionPlaceholder {
        static instance: CUserMessageCloseCaptionPlaceholder = CUserMessageCloseCaptionPlaceholder {
            string: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            ent_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageCloseCaptionPlaceholder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageCloseCaptionPlaceholder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageCloseCaptionPlaceholder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageCloseCaptionPlaceholder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageCurrentTimescale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCurrentTimescale {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCurrentTimescale.current)
    pub current: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCurrentTimescale.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCurrentTimescale {
    fn default() -> &'a CUserMessageCurrentTimescale {
        <CUserMessageCurrentTimescale as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCurrentTimescale {
    pub fn new() -> CUserMessageCurrentTimescale {
        ::std::default::Default::default()
    }

    // optional float current = 1;

    pub fn current(&self) -> f32 {
        self.current.unwrap_or(0.)
    }

    pub fn clear_current(&mut self) {
        self.current = ::std::option::Option::None;
    }

    pub fn has_current(&self) -> bool {
        self.current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: f32) {
        self.current = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current",
            |m: &CUserMessageCurrentTimescale| { &m.current },
            |m: &mut CUserMessageCurrentTimescale| { &mut m.current },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageCurrentTimescale>(
            "CUserMessageCurrentTimescale",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageCurrentTimescale {
    const NAME: &'static str = "CUserMessageCurrentTimescale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.current = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.current {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.current {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCurrentTimescale {
        CUserMessageCurrentTimescale::new()
    }

    fn clear(&mut self) {
        self.current = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCurrentTimescale {
        static instance: CUserMessageCurrentTimescale = CUserMessageCurrentTimescale {
            current: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageCurrentTimescale {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageCurrentTimescale").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageCurrentTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageCurrentTimescale {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageDesiredTimescale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageDesiredTimescale {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageDesiredTimescale.desired)
    pub desired: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageDesiredTimescale.acceleration)
    pub acceleration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageDesiredTimescale.minblendrate)
    pub minblendrate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageDesiredTimescale.blenddeltamultiplier)
    pub blenddeltamultiplier: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageDesiredTimescale.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageDesiredTimescale {
    fn default() -> &'a CUserMessageDesiredTimescale {
        <CUserMessageDesiredTimescale as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageDesiredTimescale {
    pub fn new() -> CUserMessageDesiredTimescale {
        ::std::default::Default::default()
    }

    // optional float desired = 1;

    pub fn desired(&self) -> f32 {
        self.desired.unwrap_or(0.)
    }

    pub fn clear_desired(&mut self) {
        self.desired = ::std::option::Option::None;
    }

    pub fn has_desired(&self) -> bool {
        self.desired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired(&mut self, v: f32) {
        self.desired = ::std::option::Option::Some(v);
    }

    // optional float acceleration = 2;

    pub fn acceleration(&self) -> f32 {
        self.acceleration.unwrap_or(0.)
    }

    pub fn clear_acceleration(&mut self) {
        self.acceleration = ::std::option::Option::None;
    }

    pub fn has_acceleration(&self) -> bool {
        self.acceleration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acceleration(&mut self, v: f32) {
        self.acceleration = ::std::option::Option::Some(v);
    }

    // optional float minblendrate = 3;

    pub fn minblendrate(&self) -> f32 {
        self.minblendrate.unwrap_or(0.)
    }

    pub fn clear_minblendrate(&mut self) {
        self.minblendrate = ::std::option::Option::None;
    }

    pub fn has_minblendrate(&self) -> bool {
        self.minblendrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minblendrate(&mut self, v: f32) {
        self.minblendrate = ::std::option::Option::Some(v);
    }

    // optional float blenddeltamultiplier = 4;

    pub fn blenddeltamultiplier(&self) -> f32 {
        self.blenddeltamultiplier.unwrap_or(0.)
    }

    pub fn clear_blenddeltamultiplier(&mut self) {
        self.blenddeltamultiplier = ::std::option::Option::None;
    }

    pub fn has_blenddeltamultiplier(&self) -> bool {
        self.blenddeltamultiplier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blenddeltamultiplier(&mut self, v: f32) {
        self.blenddeltamultiplier = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired",
            |m: &CUserMessageDesiredTimescale| { &m.desired },
            |m: &mut CUserMessageDesiredTimescale| { &mut m.desired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "acceleration",
            |m: &CUserMessageDesiredTimescale| { &m.acceleration },
            |m: &mut CUserMessageDesiredTimescale| { &mut m.acceleration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minblendrate",
            |m: &CUserMessageDesiredTimescale| { &m.minblendrate },
            |m: &mut CUserMessageDesiredTimescale| { &mut m.minblendrate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "blenddeltamultiplier",
            |m: &CUserMessageDesiredTimescale| { &m.blenddeltamultiplier },
            |m: &mut CUserMessageDesiredTimescale| { &mut m.blenddeltamultiplier },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageDesiredTimescale>(
            "CUserMessageDesiredTimescale",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageDesiredTimescale {
    const NAME: &'static str = "CUserMessageDesiredTimescale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.desired = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.acceleration = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.minblendrate = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.blenddeltamultiplier = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.desired {
            my_size += 1 + 4;
        }
        if let Some(v) = self.acceleration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.minblendrate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.blenddeltamultiplier {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.desired {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.acceleration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.minblendrate {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.blenddeltamultiplier {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageDesiredTimescale {
        CUserMessageDesiredTimescale::new()
    }

    fn clear(&mut self) {
        self.desired = ::std::option::Option::None;
        self.acceleration = ::std::option::Option::None;
        self.minblendrate = ::std::option::Option::None;
        self.blenddeltamultiplier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageDesiredTimescale {
        static instance: CUserMessageDesiredTimescale = CUserMessageDesiredTimescale {
            desired: ::std::option::Option::None,
            acceleration: ::std::option::Option::None,
            minblendrate: ::std::option::Option::None,
            blenddeltamultiplier: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageDesiredTimescale {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageDesiredTimescale").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageDesiredTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageDesiredTimescale {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageFade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageFade {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageFade.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageFade.hold_time)
    pub hold_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageFade.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageFade.color)
    pub color: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageFade.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageFade {
    fn default() -> &'a CUserMessageFade {
        <CUserMessageFade as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageFade {
    pub fn new() -> CUserMessageFade {
        ::std::default::Default::default()
    }

    // optional uint32 duration = 1;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 hold_time = 2;

    pub fn hold_time(&self) -> u32 {
        self.hold_time.unwrap_or(0)
    }

    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: u32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 3;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 color = 4;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUserMessageFade| { &m.duration },
            |m: &mut CUserMessageFade| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hold_time",
            |m: &CUserMessageFade| { &m.hold_time },
            |m: &mut CUserMessageFade| { &mut m.hold_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CUserMessageFade| { &m.flags },
            |m: &mut CUserMessageFade| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CUserMessageFade| { &m.color },
            |m: &mut CUserMessageFade| { &mut m.color },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageFade>(
            "CUserMessageFade",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageFade {
    const NAME: &'static str = "CUserMessageFade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hold_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hold_time {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.duration {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageFade {
        CUserMessageFade::new()
    }

    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageFade {
        static instance: CUserMessageFade = CUserMessageFade {
            duration: ::std::option::Option::None,
            hold_time: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            color: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageFade {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageFade").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageFade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageFade {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageShake)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageShake {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageShake.command)
    pub command: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageShake.amplitude)
    pub amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageShake.frequency)
    pub frequency: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageShake.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageShake.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageShake {
    fn default() -> &'a CUserMessageShake {
        <CUserMessageShake as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageShake {
    pub fn new() -> CUserMessageShake {
        ::std::default::Default::default()
    }

    // optional uint32 command = 1;

    pub fn command(&self) -> u32 {
        self.command.unwrap_or(0)
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: u32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional float amplitude = 2;

    pub fn amplitude(&self) -> f32 {
        self.amplitude.unwrap_or(0.)
    }

    pub fn clear_amplitude(&mut self) {
        self.amplitude = ::std::option::Option::None;
    }

    pub fn has_amplitude(&self) -> bool {
        self.amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amplitude(&mut self, v: f32) {
        self.amplitude = ::std::option::Option::Some(v);
    }

    // optional float frequency = 3;

    pub fn frequency(&self) -> f32 {
        self.frequency.unwrap_or(0.)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: f32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &CUserMessageShake| { &m.command },
            |m: &mut CUserMessageShake| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amplitude",
            |m: &CUserMessageShake| { &m.amplitude },
            |m: &mut CUserMessageShake| { &mut m.amplitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frequency",
            |m: &CUserMessageShake| { &m.frequency },
            |m: &mut CUserMessageShake| { &mut m.frequency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUserMessageShake| { &m.duration },
            |m: &mut CUserMessageShake| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageShake>(
            "CUserMessageShake",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageShake {
    const NAME: &'static str = "CUserMessageShake";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.command = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.frequency = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frequency {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageShake {
        CUserMessageShake::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.amplitude = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageShake {
        static instance: CUserMessageShake = CUserMessageShake {
            command: ::std::option::Option::None,
            amplitude: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageShake {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageShake").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageShake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageShake {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageShakeDir)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageShakeDir {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageShakeDir.shake)
    pub shake: ::protobuf::MessageField<CUserMessageShake>,
    // @@protoc_insertion_point(field:CUserMessageShakeDir.direction)
    pub direction: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageShakeDir.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageShakeDir {
    fn default() -> &'a CUserMessageShakeDir {
        <CUserMessageShakeDir as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageShakeDir {
    pub fn new() -> CUserMessageShakeDir {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CUserMessageShake>(
            "shake",
            |m: &CUserMessageShakeDir| { &m.shake },
            |m: &mut CUserMessageShakeDir| { &mut m.shake },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "direction",
            |m: &CUserMessageShakeDir| { &m.direction },
            |m: &mut CUserMessageShakeDir| { &mut m.direction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageShakeDir>(
            "CUserMessageShakeDir",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageShakeDir {
    const NAME: &'static str = "CUserMessageShakeDir";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.shake)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.direction)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shake.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.shake.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.direction.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageShakeDir {
        CUserMessageShakeDir::new()
    }

    fn clear(&mut self) {
        self.shake.clear();
        self.direction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageShakeDir {
        static instance: CUserMessageShakeDir = CUserMessageShakeDir {
            shake: ::protobuf::MessageField::none(),
            direction: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageShakeDir {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageShakeDir").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageShakeDir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageShakeDir {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageWaterShake)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageWaterShake {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageWaterShake.command)
    pub command: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageWaterShake.amplitude)
    pub amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageWaterShake.frequency)
    pub frequency: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageWaterShake.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageWaterShake.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageWaterShake {
    fn default() -> &'a CUserMessageWaterShake {
        <CUserMessageWaterShake as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageWaterShake {
    pub fn new() -> CUserMessageWaterShake {
        ::std::default::Default::default()
    }

    // optional uint32 command = 1;

    pub fn command(&self) -> u32 {
        self.command.unwrap_or(0)
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: u32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional float amplitude = 2;

    pub fn amplitude(&self) -> f32 {
        self.amplitude.unwrap_or(0.)
    }

    pub fn clear_amplitude(&mut self) {
        self.amplitude = ::std::option::Option::None;
    }

    pub fn has_amplitude(&self) -> bool {
        self.amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amplitude(&mut self, v: f32) {
        self.amplitude = ::std::option::Option::Some(v);
    }

    // optional float frequency = 3;

    pub fn frequency(&self) -> f32 {
        self.frequency.unwrap_or(0.)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: f32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &CUserMessageWaterShake| { &m.command },
            |m: &mut CUserMessageWaterShake| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amplitude",
            |m: &CUserMessageWaterShake| { &m.amplitude },
            |m: &mut CUserMessageWaterShake| { &mut m.amplitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frequency",
            |m: &CUserMessageWaterShake| { &m.frequency },
            |m: &mut CUserMessageWaterShake| { &mut m.frequency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUserMessageWaterShake| { &m.duration },
            |m: &mut CUserMessageWaterShake| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageWaterShake>(
            "CUserMessageWaterShake",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageWaterShake {
    const NAME: &'static str = "CUserMessageWaterShake";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.command = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.frequency = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frequency {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageWaterShake {
        CUserMessageWaterShake::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.amplitude = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageWaterShake {
        static instance: CUserMessageWaterShake = CUserMessageWaterShake {
            command: ::std::option::Option::None,
            amplitude: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageWaterShake {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageWaterShake").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageWaterShake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageWaterShake {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageScreenTilt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageScreenTilt {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageScreenTilt.command)
    pub command: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageScreenTilt.ease_in_out)
    pub ease_in_out: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageScreenTilt.angle)
    pub angle: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CUserMessageScreenTilt.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageScreenTilt.time)
    pub time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageScreenTilt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageScreenTilt {
    fn default() -> &'a CUserMessageScreenTilt {
        <CUserMessageScreenTilt as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageScreenTilt {
    pub fn new() -> CUserMessageScreenTilt {
        ::std::default::Default::default()
    }

    // optional uint32 command = 1;

    pub fn command(&self) -> u32 {
        self.command.unwrap_or(0)
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: u32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional bool ease_in_out = 2;

    pub fn ease_in_out(&self) -> bool {
        self.ease_in_out.unwrap_or(false)
    }

    pub fn clear_ease_in_out(&mut self) {
        self.ease_in_out = ::std::option::Option::None;
    }

    pub fn has_ease_in_out(&self) -> bool {
        self.ease_in_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ease_in_out(&mut self, v: bool) {
        self.ease_in_out = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional float time = 5;

    pub fn time(&self) -> f32 {
        self.time.unwrap_or(0.)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: f32) {
        self.time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &CUserMessageScreenTilt| { &m.command },
            |m: &mut CUserMessageScreenTilt| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ease_in_out",
            |m: &CUserMessageScreenTilt| { &m.ease_in_out },
            |m: &mut CUserMessageScreenTilt| { &mut m.ease_in_out },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "angle",
            |m: &CUserMessageScreenTilt| { &m.angle },
            |m: &mut CUserMessageScreenTilt| { &mut m.angle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUserMessageScreenTilt| { &m.duration },
            |m: &mut CUserMessageScreenTilt| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time",
            |m: &CUserMessageScreenTilt| { &m.time },
            |m: &mut CUserMessageScreenTilt| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageScreenTilt>(
            "CUserMessageScreenTilt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageScreenTilt {
    const NAME: &'static str = "CUserMessageScreenTilt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.command = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.ease_in_out = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ease_in_out {
            my_size += 1 + 1;
        }
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ease_in_out {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.angle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.time {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageScreenTilt {
        CUserMessageScreenTilt::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.ease_in_out = ::std::option::Option::None;
        self.angle.clear();
        self.duration = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageScreenTilt {
        static instance: CUserMessageScreenTilt = CUserMessageScreenTilt {
            command: ::std::option::Option::None,
            ease_in_out: ::std::option::Option::None,
            angle: ::protobuf::MessageField::none(),
            duration: ::std::option::Option::None,
            time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageScreenTilt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageScreenTilt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageScreenTilt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageScreenTilt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageSayText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageSayText {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageSayText.playerindex)
    pub playerindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageSayText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSayText.chat)
    pub chat: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageSayText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageSayText {
    fn default() -> &'a CUserMessageSayText {
        <CUserMessageSayText as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageSayText {
    pub fn new() -> CUserMessageSayText {
        ::std::default::Default::default()
    }

    // optional int32 playerindex = 1;

    pub fn playerindex(&self) -> i32 {
        self.playerindex.unwrap_or(-1i32)
    }

    pub fn clear_playerindex(&mut self) {
        self.playerindex = ::std::option::Option::None;
    }

    pub fn has_playerindex(&self) -> bool {
        self.playerindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerindex(&mut self, v: i32) {
        self.playerindex = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool chat = 3;

    pub fn chat(&self) -> bool {
        self.chat.unwrap_or(false)
    }

    pub fn clear_chat(&mut self) {
        self.chat = ::std::option::Option::None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playerindex",
            |m: &CUserMessageSayText| { &m.playerindex },
            |m: &mut CUserMessageSayText| { &mut m.playerindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CUserMessageSayText| { &m.text },
            |m: &mut CUserMessageSayText| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat",
            |m: &CUserMessageSayText| { &m.chat },
            |m: &mut CUserMessageSayText| { &mut m.chat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageSayText>(
            "CUserMessageSayText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageSayText {
    const NAME: &'static str = "CUserMessageSayText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.playerindex = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.chat = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playerindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.playerindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.chat {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageSayText {
        CUserMessageSayText::new()
    }

    fn clear(&mut self) {
        self.playerindex = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.chat = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageSayText {
        static instance: CUserMessageSayText = CUserMessageSayText {
            playerindex: ::std::option::Option::None,
            text: ::std::option::Option::None,
            chat: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageSayText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageSayText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageSayText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageSayText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageSayText2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageSayText2 {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageSayText2.entityindex)
    pub entityindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.chat)
    pub chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.messagename)
    pub messagename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.param1)
    pub param1: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.param2)
    pub param2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.param3)
    pub param3: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.param4)
    pub param4: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageSayText2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageSayText2 {
    fn default() -> &'a CUserMessageSayText2 {
        <CUserMessageSayText2 as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageSayText2 {
    pub fn new() -> CUserMessageSayText2 {
        ::std::default::Default::default()
    }

    // optional int32 entityindex = 1;

    pub fn entityindex(&self) -> i32 {
        self.entityindex.unwrap_or(-1i32)
    }

    pub fn clear_entityindex(&mut self) {
        self.entityindex = ::std::option::Option::None;
    }

    pub fn has_entityindex(&self) -> bool {
        self.entityindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entityindex(&mut self, v: i32) {
        self.entityindex = ::std::option::Option::Some(v);
    }

    // optional bool chat = 2;

    pub fn chat(&self) -> bool {
        self.chat.unwrap_or(false)
    }

    pub fn clear_chat(&mut self) {
        self.chat = ::std::option::Option::None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = ::std::option::Option::Some(v);
    }

    // optional string messagename = 3;

    pub fn messagename(&self) -> &str {
        match self.messagename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_messagename(&mut self) {
        self.messagename = ::std::option::Option::None;
    }

    pub fn has_messagename(&self) -> bool {
        self.messagename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messagename(&mut self, v: ::std::string::String) {
        self.messagename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messagename(&mut self) -> &mut ::std::string::String {
        if self.messagename.is_none() {
            self.messagename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.messagename.as_mut().unwrap()
    }

    // Take field
    pub fn take_messagename(&mut self) -> ::std::string::String {
        self.messagename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param1 = 4;

    pub fn param1(&self) -> &str {
        match self.param1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param1(&mut self) {
        self.param1 = ::std::option::Option::None;
    }

    pub fn has_param1(&self) -> bool {
        self.param1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param1(&mut self, v: ::std::string::String) {
        self.param1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param1(&mut self) -> &mut ::std::string::String {
        if self.param1.is_none() {
            self.param1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param1.as_mut().unwrap()
    }

    // Take field
    pub fn take_param1(&mut self) -> ::std::string::String {
        self.param1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param2 = 5;

    pub fn param2(&self) -> &str {
        match self.param2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param2(&mut self) {
        self.param2 = ::std::option::Option::None;
    }

    pub fn has_param2(&self) -> bool {
        self.param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param2(&mut self, v: ::std::string::String) {
        self.param2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param2(&mut self) -> &mut ::std::string::String {
        if self.param2.is_none() {
            self.param2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param2.as_mut().unwrap()
    }

    // Take field
    pub fn take_param2(&mut self) -> ::std::string::String {
        self.param2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param3 = 6;

    pub fn param3(&self) -> &str {
        match self.param3.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param3(&mut self) {
        self.param3 = ::std::option::Option::None;
    }

    pub fn has_param3(&self) -> bool {
        self.param3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param3(&mut self, v: ::std::string::String) {
        self.param3 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param3(&mut self) -> &mut ::std::string::String {
        if self.param3.is_none() {
            self.param3 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param3.as_mut().unwrap()
    }

    // Take field
    pub fn take_param3(&mut self) -> ::std::string::String {
        self.param3.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param4 = 7;

    pub fn param4(&self) -> &str {
        match self.param4.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param4(&mut self) {
        self.param4 = ::std::option::Option::None;
    }

    pub fn has_param4(&self) -> bool {
        self.param4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param4(&mut self, v: ::std::string::String) {
        self.param4 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param4(&mut self) -> &mut ::std::string::String {
        if self.param4.is_none() {
            self.param4 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param4.as_mut().unwrap()
    }

    // Take field
    pub fn take_param4(&mut self) -> ::std::string::String {
        self.param4.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entityindex",
            |m: &CUserMessageSayText2| { &m.entityindex },
            |m: &mut CUserMessageSayText2| { &mut m.entityindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat",
            |m: &CUserMessageSayText2| { &m.chat },
            |m: &mut CUserMessageSayText2| { &mut m.chat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "messagename",
            |m: &CUserMessageSayText2| { &m.messagename },
            |m: &mut CUserMessageSayText2| { &mut m.messagename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param1",
            |m: &CUserMessageSayText2| { &m.param1 },
            |m: &mut CUserMessageSayText2| { &mut m.param1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param2",
            |m: &CUserMessageSayText2| { &m.param2 },
            |m: &mut CUserMessageSayText2| { &mut m.param2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param3",
            |m: &CUserMessageSayText2| { &m.param3 },
            |m: &mut CUserMessageSayText2| { &mut m.param3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param4",
            |m: &CUserMessageSayText2| { &m.param4 },
            |m: &mut CUserMessageSayText2| { &mut m.param4 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageSayText2>(
            "CUserMessageSayText2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageSayText2 {
    const NAME: &'static str = "CUserMessageSayText2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entityindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.chat = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.messagename = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.param1 = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.param2 = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.param3 = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.param4 = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entityindex {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.chat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.messagename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.param1.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.param2.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.param3.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.param4.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entityindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.chat {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.messagename.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.param1.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.param2.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.param3.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.param4.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageSayText2 {
        CUserMessageSayText2::new()
    }

    fn clear(&mut self) {
        self.entityindex = ::std::option::Option::None;
        self.chat = ::std::option::Option::None;
        self.messagename = ::std::option::Option::None;
        self.param1 = ::std::option::Option::None;
        self.param2 = ::std::option::Option::None;
        self.param3 = ::std::option::Option::None;
        self.param4 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageSayText2 {
        static instance: CUserMessageSayText2 = CUserMessageSayText2 {
            entityindex: ::std::option::Option::None,
            chat: ::std::option::Option::None,
            messagename: ::std::option::Option::None,
            param1: ::std::option::Option::None,
            param2: ::std::option::Option::None,
            param3: ::std::option::Option::None,
            param4: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageSayText2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageSayText2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageSayText2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageSayText2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageHudMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageHudMsg {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageHudMsg.channel)
    pub channel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.color1)
    pub color1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.color2)
    pub color2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.effect)
    pub effect: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageHudMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageHudMsg {
    fn default() -> &'a CUserMessageHudMsg {
        <CUserMessageHudMsg as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageHudMsg {
    pub fn new() -> CUserMessageHudMsg {
        ::std::default::Default::default()
    }

    // optional uint32 channel = 1;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional float x = 2;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 3;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional fixed32 color1 = 4;

    pub fn color1(&self) -> u32 {
        self.color1.unwrap_or(0)
    }

    pub fn clear_color1(&mut self) {
        self.color1 = ::std::option::Option::None;
    }

    pub fn has_color1(&self) -> bool {
        self.color1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color1(&mut self, v: u32) {
        self.color1 = ::std::option::Option::Some(v);
    }

    // optional fixed32 color2 = 5;

    pub fn color2(&self) -> u32 {
        self.color2.unwrap_or(0)
    }

    pub fn clear_color2(&mut self) {
        self.color2 = ::std::option::Option::None;
    }

    pub fn has_color2(&self) -> bool {
        self.color2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color2(&mut self, v: u32) {
        self.color2 = ::std::option::Option::Some(v);
    }

    // optional uint32 effect = 6;

    pub fn effect(&self) -> u32 {
        self.effect.unwrap_or(0)
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: u32) {
        self.effect = ::std::option::Option::Some(v);
    }

    // optional string message = 11;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &CUserMessageHudMsg| { &m.channel },
            |m: &mut CUserMessageHudMsg| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CUserMessageHudMsg| { &m.x },
            |m: &mut CUserMessageHudMsg| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CUserMessageHudMsg| { &m.y },
            |m: &mut CUserMessageHudMsg| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color1",
            |m: &CUserMessageHudMsg| { &m.color1 },
            |m: &mut CUserMessageHudMsg| { &mut m.color1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color2",
            |m: &CUserMessageHudMsg| { &m.color2 },
            |m: &mut CUserMessageHudMsg| { &mut m.color2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect",
            |m: &CUserMessageHudMsg| { &m.effect },
            |m: &mut CUserMessageHudMsg| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CUserMessageHudMsg| { &m.message },
            |m: &mut CUserMessageHudMsg| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageHudMsg>(
            "CUserMessageHudMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageHudMsg {
    const NAME: &'static str = "CUserMessageHudMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.color1 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.color2 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                48 => {
                    self.effect = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.color1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.color2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.effect {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.color1 {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.color2 {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.effect {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageHudMsg {
        CUserMessageHudMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.color1 = ::std::option::Option::None;
        self.color2 = ::std::option::Option::None;
        self.effect = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageHudMsg {
        static instance: CUserMessageHudMsg = CUserMessageHudMsg {
            channel: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            color1: ::std::option::Option::None,
            color2: ::std::option::Option::None,
            effect: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageHudMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageHudMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageHudMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageHudMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageHudText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageHudText {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageHudText.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageHudText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageHudText {
    fn default() -> &'a CUserMessageHudText {
        <CUserMessageHudText as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageHudText {
    pub fn new() -> CUserMessageHudText {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CUserMessageHudText| { &m.message },
            |m: &mut CUserMessageHudText| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageHudText>(
            "CUserMessageHudText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageHudText {
    const NAME: &'static str = "CUserMessageHudText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageHudText {
        CUserMessageHudText::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageHudText {
        static instance: CUserMessageHudText = CUserMessageHudText {
            message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageHudText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageHudText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageHudText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageHudText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageTextMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageTextMsg {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageTextMsg.dest)
    pub dest: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageTextMsg.param)
    pub param: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageTextMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageTextMsg {
    fn default() -> &'a CUserMessageTextMsg {
        <CUserMessageTextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageTextMsg {
    pub fn new() -> CUserMessageTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 dest = 1;

    pub fn dest(&self) -> u32 {
        self.dest.unwrap_or(0)
    }

    pub fn clear_dest(&mut self) {
        self.dest = ::std::option::Option::None;
    }

    pub fn has_dest(&self) -> bool {
        self.dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: u32) {
        self.dest = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dest",
            |m: &CUserMessageTextMsg| { &m.dest },
            |m: &mut CUserMessageTextMsg| { &mut m.dest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "param",
            |m: &CUserMessageTextMsg| { &m.param },
            |m: &mut CUserMessageTextMsg| { &mut m.param },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageTextMsg>(
            "CUserMessageTextMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageTextMsg {
    const NAME: &'static str = "CUserMessageTextMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dest = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.param.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dest {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.param {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dest {
            os.write_uint32(1, v)?;
        }
        for v in &self.param {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageTextMsg {
        CUserMessageTextMsg::new()
    }

    fn clear(&mut self) {
        self.dest = ::std::option::Option::None;
        self.param.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageTextMsg {
        static instance: CUserMessageTextMsg = CUserMessageTextMsg {
            dest: ::std::option::Option::None,
            param: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageTextMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageTextMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageTextMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageGameTitle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageGameTitle {
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageGameTitle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageGameTitle {
    fn default() -> &'a CUserMessageGameTitle {
        <CUserMessageGameTitle as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageGameTitle {
    pub fn new() -> CUserMessageGameTitle {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageGameTitle>(
            "CUserMessageGameTitle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageGameTitle {
    const NAME: &'static str = "CUserMessageGameTitle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageGameTitle {
        CUserMessageGameTitle::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageGameTitle {
        static instance: CUserMessageGameTitle = CUserMessageGameTitle {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageGameTitle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageGameTitle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageGameTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageGameTitle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageResetHUD)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageResetHUD {
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageResetHUD.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageResetHUD {
    fn default() -> &'a CUserMessageResetHUD {
        <CUserMessageResetHUD as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageResetHUD {
    pub fn new() -> CUserMessageResetHUD {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageResetHUD>(
            "CUserMessageResetHUD",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageResetHUD {
    const NAME: &'static str = "CUserMessageResetHUD";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageResetHUD {
        CUserMessageResetHUD::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageResetHUD {
        static instance: CUserMessageResetHUD = CUserMessageResetHUD {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageResetHUD {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageResetHUD").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageResetHUD {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageResetHUD {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageSendAudio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageSendAudio {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageSendAudio.soundname)
    pub soundname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSendAudio.stop)
    pub stop: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageSendAudio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageSendAudio {
    fn default() -> &'a CUserMessageSendAudio {
        <CUserMessageSendAudio as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageSendAudio {
    pub fn new() -> CUserMessageSendAudio {
        ::std::default::Default::default()
    }

    // optional string soundname = 1;

    pub fn soundname(&self) -> &str {
        match self.soundname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_soundname(&mut self) {
        self.soundname = ::std::option::Option::None;
    }

    pub fn has_soundname(&self) -> bool {
        self.soundname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundname(&mut self, v: ::std::string::String) {
        self.soundname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_soundname(&mut self) -> &mut ::std::string::String {
        if self.soundname.is_none() {
            self.soundname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.soundname.as_mut().unwrap()
    }

    // Take field
    pub fn take_soundname(&mut self) -> ::std::string::String {
        self.soundname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool stop = 2;

    pub fn stop(&self) -> bool {
        self.stop.unwrap_or(false)
    }

    pub fn clear_stop(&mut self) {
        self.stop = ::std::option::Option::None;
    }

    pub fn has_stop(&self) -> bool {
        self.stop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop(&mut self, v: bool) {
        self.stop = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soundname",
            |m: &CUserMessageSendAudio| { &m.soundname },
            |m: &mut CUserMessageSendAudio| { &mut m.soundname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stop",
            |m: &CUserMessageSendAudio| { &m.stop },
            |m: &mut CUserMessageSendAudio| { &mut m.stop },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageSendAudio>(
            "CUserMessageSendAudio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageSendAudio {
    const NAME: &'static str = "CUserMessageSendAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.soundname = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.stop = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soundname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.stop {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soundname.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.stop {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageSendAudio {
        CUserMessageSendAudio::new()
    }

    fn clear(&mut self) {
        self.soundname = ::std::option::Option::None;
        self.stop = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageSendAudio {
        static instance: CUserMessageSendAudio = CUserMessageSendAudio {
            soundname: ::std::option::Option::None,
            stop: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageSendAudio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageSendAudio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageSendAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageSendAudio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageAudioParameter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageAudioParameter {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageAudioParameter.parameter_type)
    pub parameter_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageAudioParameter.name_hash_code)
    pub name_hash_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageAudioParameter.value)
    pub value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageAudioParameter.int_value)
    pub int_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageAudioParameter.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageAudioParameter {
    fn default() -> &'a CUserMessageAudioParameter {
        <CUserMessageAudioParameter as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageAudioParameter {
    pub fn new() -> CUserMessageAudioParameter {
        ::std::default::Default::default()
    }

    // optional uint32 parameter_type = 1;

    pub fn parameter_type(&self) -> u32 {
        self.parameter_type.unwrap_or(0)
    }

    pub fn clear_parameter_type(&mut self) {
        self.parameter_type = ::std::option::Option::None;
    }

    pub fn has_parameter_type(&self) -> bool {
        self.parameter_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameter_type(&mut self, v: u32) {
        self.parameter_type = ::std::option::Option::Some(v);
    }

    // optional uint32 name_hash_code = 2;

    pub fn name_hash_code(&self) -> u32 {
        self.name_hash_code.unwrap_or(0)
    }

    pub fn clear_name_hash_code(&mut self) {
        self.name_hash_code = ::std::option::Option::None;
    }

    pub fn has_name_hash_code(&self) -> bool {
        self.name_hash_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_hash_code(&mut self, v: u32) {
        self.name_hash_code = ::std::option::Option::Some(v);
    }

    // optional float value = 3;

    pub fn value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional uint32 int_value = 4;

    pub fn int_value(&self) -> u32 {
        self.int_value.unwrap_or(0)
    }

    pub fn clear_int_value(&mut self) {
        self.int_value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        self.int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: u32) {
        self.int_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "parameter_type",
            |m: &CUserMessageAudioParameter| { &m.parameter_type },
            |m: &mut CUserMessageAudioParameter| { &mut m.parameter_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name_hash_code",
            |m: &CUserMessageAudioParameter| { &m.name_hash_code },
            |m: &mut CUserMessageAudioParameter| { &mut m.name_hash_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CUserMessageAudioParameter| { &m.value },
            |m: &mut CUserMessageAudioParameter| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "int_value",
            |m: &CUserMessageAudioParameter| { &m.int_value },
            |m: &mut CUserMessageAudioParameter| { &mut m.int_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageAudioParameter>(
            "CUserMessageAudioParameter",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageAudioParameter {
    const NAME: &'static str = "CUserMessageAudioParameter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.parameter_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.name_hash_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.value = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.int_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.parameter_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name_hash_code {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.int_value {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.parameter_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name_hash_code {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.int_value {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageAudioParameter {
        CUserMessageAudioParameter::new()
    }

    fn clear(&mut self) {
        self.parameter_type = ::std::option::Option::None;
        self.name_hash_code = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.int_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageAudioParameter {
        static instance: CUserMessageAudioParameter = CUserMessageAudioParameter {
            parameter_type: ::std::option::Option::None,
            name_hash_code: ::std::option::Option::None,
            value: ::std::option::Option::None,
            int_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageAudioParameter {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageAudioParameter").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageAudioParameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageAudioParameter {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageVoiceMask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageVoiceMask {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageVoiceMask.gamerules_masks)
    pub gamerules_masks: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CUserMessageVoiceMask.ban_masks)
    pub ban_masks: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CUserMessageVoiceMask.mod_enable)
    pub mod_enable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageVoiceMask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageVoiceMask {
    fn default() -> &'a CUserMessageVoiceMask {
        <CUserMessageVoiceMask as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageVoiceMask {
    pub fn new() -> CUserMessageVoiceMask {
        ::std::default::Default::default()
    }

    // optional bool mod_enable = 3;

    pub fn mod_enable(&self) -> bool {
        self.mod_enable.unwrap_or(false)
    }

    pub fn clear_mod_enable(&mut self) {
        self.mod_enable = ::std::option::Option::None;
    }

    pub fn has_mod_enable(&self) -> bool {
        self.mod_enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mod_enable(&mut self, v: bool) {
        self.mod_enable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gamerules_masks",
            |m: &CUserMessageVoiceMask| { &m.gamerules_masks },
            |m: &mut CUserMessageVoiceMask| { &mut m.gamerules_masks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ban_masks",
            |m: &CUserMessageVoiceMask| { &m.ban_masks },
            |m: &mut CUserMessageVoiceMask| { &mut m.ban_masks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mod_enable",
            |m: &CUserMessageVoiceMask| { &m.mod_enable },
            |m: &mut CUserMessageVoiceMask| { &mut m.mod_enable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageVoiceMask>(
            "CUserMessageVoiceMask",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageVoiceMask {
    const NAME: &'static str = "CUserMessageVoiceMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.gamerules_masks)?;
                },
                8 => {
                    self.gamerules_masks.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.ban_masks)?;
                },
                16 => {
                    self.ban_masks.push(is.read_uint32()?);
                },
                24 => {
                    self.mod_enable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.gamerules_masks {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.ban_masks {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.mod_enable {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.gamerules_masks {
            os.write_uint32(1, *v)?;
        };
        for v in &self.ban_masks {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.mod_enable {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageVoiceMask {
        CUserMessageVoiceMask::new()
    }

    fn clear(&mut self) {
        self.gamerules_masks.clear();
        self.ban_masks.clear();
        self.mod_enable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageVoiceMask {
        static instance: CUserMessageVoiceMask = CUserMessageVoiceMask {
            gamerules_masks: ::std::vec::Vec::new(),
            ban_masks: ::std::vec::Vec::new(),
            mod_enable: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageVoiceMask {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageVoiceMask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageVoiceMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageVoiceMask {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageRequestState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRequestState {
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRequestState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRequestState {
    fn default() -> &'a CUserMessageRequestState {
        <CUserMessageRequestState as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRequestState {
    pub fn new() -> CUserMessageRequestState {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageRequestState>(
            "CUserMessageRequestState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageRequestState {
    const NAME: &'static str = "CUserMessageRequestState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRequestState {
        CUserMessageRequestState::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRequestState {
        static instance: CUserMessageRequestState = CUserMessageRequestState {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageRequestState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageRequestState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageRequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageRequestState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageRumble)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRumble {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageRumble.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRumble.data)
    pub data: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRumble.flags)
    pub flags: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRumble.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRumble {
    fn default() -> &'a CUserMessageRumble {
        <CUserMessageRumble as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRumble {
    pub fn new() -> CUserMessageRumble {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 data = 2;

    pub fn data(&self) -> i32 {
        self.data.unwrap_or(0)
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CUserMessageRumble| { &m.index },
            |m: &mut CUserMessageRumble| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CUserMessageRumble| { &m.data },
            |m: &mut CUserMessageRumble| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CUserMessageRumble| { &m.flags },
            |m: &mut CUserMessageRumble| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageRumble>(
            "CUserMessageRumble",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageRumble {
    const NAME: &'static str = "CUserMessageRumble";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.data = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRumble {
        CUserMessageRumble::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRumble {
        static instance: CUserMessageRumble = CUserMessageRumble {
            index: ::std::option::Option::None,
            data: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageRumble {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageRumble").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageRumble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageRumble {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageSayTextChannel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageSayTextChannel {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageSayTextChannel.player)
    pub player: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageSayTextChannel.channel)
    pub channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageSayTextChannel.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageSayTextChannel.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageSayTextChannel {
    fn default() -> &'a CUserMessageSayTextChannel {
        <CUserMessageSayTextChannel as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageSayTextChannel {
    pub fn new() -> CUserMessageSayTextChannel {
        ::std::default::Default::default()
    }

    // optional int32 player = 1;

    pub fn player(&self) -> i32 {
        self.player.unwrap_or(0)
    }

    pub fn clear_player(&mut self) {
        self.player = ::std::option::Option::None;
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: i32) {
        self.player = ::std::option::Option::Some(v);
    }

    // optional int32 channel = 2;

    pub fn channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional string text = 3;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player",
            |m: &CUserMessageSayTextChannel| { &m.player },
            |m: &mut CUserMessageSayTextChannel| { &mut m.player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &CUserMessageSayTextChannel| { &m.channel },
            |m: &mut CUserMessageSayTextChannel| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CUserMessageSayTextChannel| { &m.text },
            |m: &mut CUserMessageSayTextChannel| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageSayTextChannel>(
            "CUserMessageSayTextChannel",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageSayTextChannel {
    const NAME: &'static str = "CUserMessageSayTextChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.channel = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.channel {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageSayTextChannel {
        CUserMessageSayTextChannel::new()
    }

    fn clear(&mut self) {
        self.player = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageSayTextChannel {
        static instance: CUserMessageSayTextChannel = CUserMessageSayTextChannel {
            player: ::std::option::Option::None,
            channel: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageSayTextChannel {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageSayTextChannel").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageSayTextChannel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageSayTextChannel {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageColoredText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageColoredText {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageColoredText.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageColoredText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageColoredText.reset)
    pub reset: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageColoredText.context_player_slot)
    pub context_player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageColoredText.context_value)
    pub context_value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageColoredText.context_team_id)
    pub context_team_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageColoredText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageColoredText {
    fn default() -> &'a CUserMessageColoredText {
        <CUserMessageColoredText as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageColoredText {
    pub fn new() -> CUserMessageColoredText {
        ::std::default::Default::default()
    }

    // optional uint32 color = 1;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool reset = 3;

    pub fn reset(&self) -> bool {
        self.reset.unwrap_or(false)
    }

    pub fn clear_reset(&mut self) {
        self.reset = ::std::option::Option::None;
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: bool) {
        self.reset = ::std::option::Option::Some(v);
    }

    // optional int32 context_player_slot = 4;

    pub fn context_player_slot(&self) -> i32 {
        self.context_player_slot.unwrap_or(-1i32)
    }

    pub fn clear_context_player_slot(&mut self) {
        self.context_player_slot = ::std::option::Option::None;
    }

    pub fn has_context_player_slot(&self) -> bool {
        self.context_player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_player_slot(&mut self, v: i32) {
        self.context_player_slot = ::std::option::Option::Some(v);
    }

    // optional int32 context_value = 5;

    pub fn context_value(&self) -> i32 {
        self.context_value.unwrap_or(0)
    }

    pub fn clear_context_value(&mut self) {
        self.context_value = ::std::option::Option::None;
    }

    pub fn has_context_value(&self) -> bool {
        self.context_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_value(&mut self, v: i32) {
        self.context_value = ::std::option::Option::Some(v);
    }

    // optional int32 context_team_id = 6;

    pub fn context_team_id(&self) -> i32 {
        self.context_team_id.unwrap_or(0)
    }

    pub fn clear_context_team_id(&mut self) {
        self.context_team_id = ::std::option::Option::None;
    }

    pub fn has_context_team_id(&self) -> bool {
        self.context_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_team_id(&mut self, v: i32) {
        self.context_team_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CUserMessageColoredText| { &m.color },
            |m: &mut CUserMessageColoredText| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CUserMessageColoredText| { &m.text },
            |m: &mut CUserMessageColoredText| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reset",
            |m: &CUserMessageColoredText| { &m.reset },
            |m: &mut CUserMessageColoredText| { &mut m.reset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context_player_slot",
            |m: &CUserMessageColoredText| { &m.context_player_slot },
            |m: &mut CUserMessageColoredText| { &mut m.context_player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context_value",
            |m: &CUserMessageColoredText| { &m.context_value },
            |m: &mut CUserMessageColoredText| { &mut m.context_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "context_team_id",
            |m: &CUserMessageColoredText| { &m.context_team_id },
            |m: &mut CUserMessageColoredText| { &mut m.context_team_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageColoredText>(
            "CUserMessageColoredText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageColoredText {
    const NAME: &'static str = "CUserMessageColoredText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.reset = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.context_player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.context_value = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.context_team_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.color {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reset {
            my_size += 1 + 1;
        }
        if let Some(v) = self.context_player_slot {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.context_value {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.context_team_id {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.color {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reset {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.context_player_slot {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.context_value {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.context_team_id {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageColoredText {
        CUserMessageColoredText::new()
    }

    fn clear(&mut self) {
        self.color = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.reset = ::std::option::Option::None;
        self.context_player_slot = ::std::option::Option::None;
        self.context_value = ::std::option::Option::None;
        self.context_team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageColoredText {
        static instance: CUserMessageColoredText = CUserMessageColoredText {
            color: ::std::option::Option::None,
            text: ::std::option::Option::None,
            reset: ::std::option::Option::None,
            context_player_slot: ::std::option::Option::None,
            context_value: ::std::option::Option::None,
            context_team_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageColoredText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageColoredText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageColoredText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageColoredText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageItemPickup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageItemPickup {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageItemPickup.itemname)
    pub itemname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageItemPickup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageItemPickup {
    fn default() -> &'a CUserMessageItemPickup {
        <CUserMessageItemPickup as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageItemPickup {
    pub fn new() -> CUserMessageItemPickup {
        ::std::default::Default::default()
    }

    // optional string itemname = 1;

    pub fn itemname(&self) -> &str {
        match self.itemname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_itemname(&mut self) {
        self.itemname = ::std::option::Option::None;
    }

    pub fn has_itemname(&self) -> bool {
        self.itemname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemname(&mut self, v: ::std::string::String) {
        self.itemname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_itemname(&mut self) -> &mut ::std::string::String {
        if self.itemname.is_none() {
            self.itemname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.itemname.as_mut().unwrap()
    }

    // Take field
    pub fn take_itemname(&mut self) -> ::std::string::String {
        self.itemname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemname",
            |m: &CUserMessageItemPickup| { &m.itemname },
            |m: &mut CUserMessageItemPickup| { &mut m.itemname },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageItemPickup>(
            "CUserMessageItemPickup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageItemPickup {
    const NAME: &'static str = "CUserMessageItemPickup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.itemname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.itemname.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.itemname.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageItemPickup {
        CUserMessageItemPickup::new()
    }

    fn clear(&mut self) {
        self.itemname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageItemPickup {
        static instance: CUserMessageItemPickup = CUserMessageItemPickup {
            itemname: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageItemPickup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageItemPickup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageItemPickup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageItemPickup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageAmmoDenied)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageAmmoDenied {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageAmmoDenied.ammo_id)
    pub ammo_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageAmmoDenied.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageAmmoDenied {
    fn default() -> &'a CUserMessageAmmoDenied {
        <CUserMessageAmmoDenied as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageAmmoDenied {
    pub fn new() -> CUserMessageAmmoDenied {
        ::std::default::Default::default()
    }

    // optional uint32 ammo_id = 1;

    pub fn ammo_id(&self) -> u32 {
        self.ammo_id.unwrap_or(0)
    }

    pub fn clear_ammo_id(&mut self) {
        self.ammo_id = ::std::option::Option::None;
    }

    pub fn has_ammo_id(&self) -> bool {
        self.ammo_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammo_id(&mut self, v: u32) {
        self.ammo_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ammo_id",
            |m: &CUserMessageAmmoDenied| { &m.ammo_id },
            |m: &mut CUserMessageAmmoDenied| { &mut m.ammo_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageAmmoDenied>(
            "CUserMessageAmmoDenied",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageAmmoDenied {
    const NAME: &'static str = "CUserMessageAmmoDenied";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ammo_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ammo_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ammo_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageAmmoDenied {
        CUserMessageAmmoDenied::new()
    }

    fn clear(&mut self) {
        self.ammo_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageAmmoDenied {
        static instance: CUserMessageAmmoDenied = CUserMessageAmmoDenied {
            ammo_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageAmmoDenied {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageAmmoDenied").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageAmmoDenied {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageAmmoDenied {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageShowMenu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageShowMenu {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageShowMenu.validslots)
    pub validslots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageShowMenu.displaytime)
    pub displaytime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageShowMenu.needmore)
    pub needmore: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageShowMenu.menustring)
    pub menustring: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageShowMenu.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageShowMenu {
    fn default() -> &'a CUserMessageShowMenu {
        <CUserMessageShowMenu as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageShowMenu {
    pub fn new() -> CUserMessageShowMenu {
        ::std::default::Default::default()
    }

    // optional uint32 validslots = 1;

    pub fn validslots(&self) -> u32 {
        self.validslots.unwrap_or(0)
    }

    pub fn clear_validslots(&mut self) {
        self.validslots = ::std::option::Option::None;
    }

    pub fn has_validslots(&self) -> bool {
        self.validslots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validslots(&mut self, v: u32) {
        self.validslots = ::std::option::Option::Some(v);
    }

    // optional uint32 displaytime = 2;

    pub fn displaytime(&self) -> u32 {
        self.displaytime.unwrap_or(0)
    }

    pub fn clear_displaytime(&mut self) {
        self.displaytime = ::std::option::Option::None;
    }

    pub fn has_displaytime(&self) -> bool {
        self.displaytime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displaytime(&mut self, v: u32) {
        self.displaytime = ::std::option::Option::Some(v);
    }

    // optional bool needmore = 3;

    pub fn needmore(&self) -> bool {
        self.needmore.unwrap_or(false)
    }

    pub fn clear_needmore(&mut self) {
        self.needmore = ::std::option::Option::None;
    }

    pub fn has_needmore(&self) -> bool {
        self.needmore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needmore(&mut self, v: bool) {
        self.needmore = ::std::option::Option::Some(v);
    }

    // optional string menustring = 4;

    pub fn menustring(&self) -> &str {
        match self.menustring.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_menustring(&mut self) {
        self.menustring = ::std::option::Option::None;
    }

    pub fn has_menustring(&self) -> bool {
        self.menustring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menustring(&mut self, v: ::std::string::String) {
        self.menustring = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menustring(&mut self) -> &mut ::std::string::String {
        if self.menustring.is_none() {
            self.menustring = ::std::option::Option::Some(::std::string::String::new());
        }
        self.menustring.as_mut().unwrap()
    }

    // Take field
    pub fn take_menustring(&mut self) -> ::std::string::String {
        self.menustring.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "validslots",
            |m: &CUserMessageShowMenu| { &m.validslots },
            |m: &mut CUserMessageShowMenu| { &mut m.validslots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displaytime",
            |m: &CUserMessageShowMenu| { &m.displaytime },
            |m: &mut CUserMessageShowMenu| { &mut m.displaytime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needmore",
            |m: &CUserMessageShowMenu| { &m.needmore },
            |m: &mut CUserMessageShowMenu| { &mut m.needmore },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "menustring",
            |m: &CUserMessageShowMenu| { &m.menustring },
            |m: &mut CUserMessageShowMenu| { &mut m.menustring },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageShowMenu>(
            "CUserMessageShowMenu",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageShowMenu {
    const NAME: &'static str = "CUserMessageShowMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.validslots = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.displaytime = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.needmore = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.menustring = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.validslots {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.displaytime {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.needmore {
            my_size += 1 + 1;
        }
        if let Some(v) = self.menustring.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.validslots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.displaytime {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.needmore {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.menustring.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageShowMenu {
        CUserMessageShowMenu::new()
    }

    fn clear(&mut self) {
        self.validslots = ::std::option::Option::None;
        self.displaytime = ::std::option::Option::None;
        self.needmore = ::std::option::Option::None;
        self.menustring = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageShowMenu {
        static instance: CUserMessageShowMenu = CUserMessageShowMenu {
            validslots: ::std::option::Option::None,
            displaytime: ::std::option::Option::None,
            needmore: ::std::option::Option::None,
            menustring: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageShowMenu {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageShowMenu").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageShowMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageShowMenu {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageCreditsMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCreditsMsg {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCreditsMsg.rolltype)
    pub rolltype: ::std::option::Option<::protobuf::EnumOrUnknown<ERollType>>,
    // @@protoc_insertion_point(field:CUserMessageCreditsMsg.logo_length)
    pub logo_length: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCreditsMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCreditsMsg {
    fn default() -> &'a CUserMessageCreditsMsg {
        <CUserMessageCreditsMsg as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCreditsMsg {
    pub fn new() -> CUserMessageCreditsMsg {
        ::std::default::Default::default()
    }

    // optional .eRollType rolltype = 1;

    pub fn rolltype(&self) -> ERollType {
        match self.rolltype {
            Some(e) => e.enum_value_or(ERollType::ROLL_NONE),
            None => ERollType::ROLL_NONE,
        }
    }

    pub fn clear_rolltype(&mut self) {
        self.rolltype = ::std::option::Option::None;
    }

    pub fn has_rolltype(&self) -> bool {
        self.rolltype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rolltype(&mut self, v: ERollType) {
        self.rolltype = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional float logo_length = 2;

    pub fn logo_length(&self) -> f32 {
        self.logo_length.unwrap_or(0.)
    }

    pub fn clear_logo_length(&mut self) {
        self.logo_length = ::std::option::Option::None;
    }

    pub fn has_logo_length(&self) -> bool {
        self.logo_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logo_length(&mut self, v: f32) {
        self.logo_length = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rolltype",
            |m: &CUserMessageCreditsMsg| { &m.rolltype },
            |m: &mut CUserMessageCreditsMsg| { &mut m.rolltype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "logo_length",
            |m: &CUserMessageCreditsMsg| { &m.logo_length },
            |m: &mut CUserMessageCreditsMsg| { &mut m.logo_length },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageCreditsMsg>(
            "CUserMessageCreditsMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageCreditsMsg {
    const NAME: &'static str = "CUserMessageCreditsMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rolltype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                21 => {
                    self.logo_length = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rolltype {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.logo_length {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rolltype {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.logo_length {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCreditsMsg {
        CUserMessageCreditsMsg::new()
    }

    fn clear(&mut self) {
        self.rolltype = ::std::option::Option::None;
        self.logo_length = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCreditsMsg {
        static instance: CUserMessageCreditsMsg = CUserMessageCreditsMsg {
            rolltype: ::std::option::Option::None,
            logo_length: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageCreditsMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageCreditsMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageCreditsMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageCreditsMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEntityMessagePlayJingle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessagePlayJingle {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessagePlayJingle.entity_msg)
    pub entity_msg: ::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessagePlayJingle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessagePlayJingle {
    fn default() -> &'a CEntityMessagePlayJingle {
        <CEntityMessagePlayJingle as ::protobuf::Message>::default_instance()
    }
}

impl CEntityMessagePlayJingle {
    pub fn new() -> CEntityMessagePlayJingle {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CEntityMsg>(
            "entity_msg",
            |m: &CEntityMessagePlayJingle| { &m.entity_msg },
            |m: &mut CEntityMessagePlayJingle| { &mut m.entity_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CEntityMessagePlayJingle>(
            "CEntityMessagePlayJingle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CEntityMessagePlayJingle {
    const NAME: &'static str = "CEntityMessagePlayJingle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessagePlayJingle {
        CEntityMessagePlayJingle::new()
    }

    fn clear(&mut self) {
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessagePlayJingle {
        static instance: CEntityMessagePlayJingle = CEntityMessagePlayJingle {
            entity_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CEntityMessagePlayJingle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEntityMessagePlayJingle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEntityMessagePlayJingle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEntityMessagePlayJingle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEntityMessageScreenOverlay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessageScreenOverlay {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessageScreenOverlay.start_effect)
    pub start_effect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CEntityMessageScreenOverlay.entity_msg)
    pub entity_msg: ::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessageScreenOverlay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessageScreenOverlay {
    fn default() -> &'a CEntityMessageScreenOverlay {
        <CEntityMessageScreenOverlay as ::protobuf::Message>::default_instance()
    }
}

impl CEntityMessageScreenOverlay {
    pub fn new() -> CEntityMessageScreenOverlay {
        ::std::default::Default::default()
    }

    // optional bool start_effect = 1;

    pub fn start_effect(&self) -> bool {
        self.start_effect.unwrap_or(false)
    }

    pub fn clear_start_effect(&mut self) {
        self.start_effect = ::std::option::Option::None;
    }

    pub fn has_start_effect(&self) -> bool {
        self.start_effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_effect(&mut self, v: bool) {
        self.start_effect = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_effect",
            |m: &CEntityMessageScreenOverlay| { &m.start_effect },
            |m: &mut CEntityMessageScreenOverlay| { &mut m.start_effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CEntityMsg>(
            "entity_msg",
            |m: &CEntityMessageScreenOverlay| { &m.entity_msg },
            |m: &mut CEntityMessageScreenOverlay| { &mut m.entity_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CEntityMessageScreenOverlay>(
            "CEntityMessageScreenOverlay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CEntityMessageScreenOverlay {
    const NAME: &'static str = "CEntityMessageScreenOverlay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_effect = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_effect {
            my_size += 1 + 1;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_effect {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessageScreenOverlay {
        CEntityMessageScreenOverlay::new()
    }

    fn clear(&mut self) {
        self.start_effect = ::std::option::Option::None;
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessageScreenOverlay {
        static instance: CEntityMessageScreenOverlay = CEntityMessageScreenOverlay {
            start_effect: ::std::option::Option::None,
            entity_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CEntityMessageScreenOverlay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEntityMessageScreenOverlay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEntityMessageScreenOverlay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEntityMessageScreenOverlay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEntityMessageRemoveAllDecals)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessageRemoveAllDecals {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessageRemoveAllDecals.remove_decals)
    pub remove_decals: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CEntityMessageRemoveAllDecals.entity_msg)
    pub entity_msg: ::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessageRemoveAllDecals.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessageRemoveAllDecals {
    fn default() -> &'a CEntityMessageRemoveAllDecals {
        <CEntityMessageRemoveAllDecals as ::protobuf::Message>::default_instance()
    }
}

impl CEntityMessageRemoveAllDecals {
    pub fn new() -> CEntityMessageRemoveAllDecals {
        ::std::default::Default::default()
    }

    // optional bool remove_decals = 1;

    pub fn remove_decals(&self) -> bool {
        self.remove_decals.unwrap_or(false)
    }

    pub fn clear_remove_decals(&mut self) {
        self.remove_decals = ::std::option::Option::None;
    }

    pub fn has_remove_decals(&self) -> bool {
        self.remove_decals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_decals(&mut self, v: bool) {
        self.remove_decals = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "remove_decals",
            |m: &CEntityMessageRemoveAllDecals| { &m.remove_decals },
            |m: &mut CEntityMessageRemoveAllDecals| { &mut m.remove_decals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CEntityMsg>(
            "entity_msg",
            |m: &CEntityMessageRemoveAllDecals| { &m.entity_msg },
            |m: &mut CEntityMessageRemoveAllDecals| { &mut m.entity_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CEntityMessageRemoveAllDecals>(
            "CEntityMessageRemoveAllDecals",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CEntityMessageRemoveAllDecals {
    const NAME: &'static str = "CEntityMessageRemoveAllDecals";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.remove_decals = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.remove_decals {
            my_size += 1 + 1;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.remove_decals {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessageRemoveAllDecals {
        CEntityMessageRemoveAllDecals::new()
    }

    fn clear(&mut self) {
        self.remove_decals = ::std::option::Option::None;
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessageRemoveAllDecals {
        static instance: CEntityMessageRemoveAllDecals = CEntityMessageRemoveAllDecals {
            remove_decals: ::std::option::Option::None,
            entity_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CEntityMessageRemoveAllDecals {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEntityMessageRemoveAllDecals").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEntityMessageRemoveAllDecals {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEntityMessageRemoveAllDecals {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEntityMessagePropagateForce)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessagePropagateForce {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessagePropagateForce.impulse)
    pub impulse: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CEntityMessagePropagateForce.entity_msg)
    pub entity_msg: ::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessagePropagateForce.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessagePropagateForce {
    fn default() -> &'a CEntityMessagePropagateForce {
        <CEntityMessagePropagateForce as ::protobuf::Message>::default_instance()
    }
}

impl CEntityMessagePropagateForce {
    pub fn new() -> CEntityMessagePropagateForce {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "impulse",
            |m: &CEntityMessagePropagateForce| { &m.impulse },
            |m: &mut CEntityMessagePropagateForce| { &mut m.impulse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CEntityMsg>(
            "entity_msg",
            |m: &CEntityMessagePropagateForce| { &m.entity_msg },
            |m: &mut CEntityMessagePropagateForce| { &mut m.entity_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CEntityMessagePropagateForce>(
            "CEntityMessagePropagateForce",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CEntityMessagePropagateForce {
    const NAME: &'static str = "CEntityMessagePropagateForce";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.impulse)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.impulse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.impulse.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessagePropagateForce {
        CEntityMessagePropagateForce::new()
    }

    fn clear(&mut self) {
        self.impulse.clear();
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessagePropagateForce {
        static instance: CEntityMessagePropagateForce = CEntityMessagePropagateForce {
            impulse: ::protobuf::MessageField::none(),
            entity_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CEntityMessagePropagateForce {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEntityMessagePropagateForce").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEntityMessagePropagateForce {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEntityMessagePropagateForce {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEntityMessageDoSpark)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessageDoSpark {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.origin)
    pub origin: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.entityindex)
    pub entityindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.radius)
    pub radius: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.beams)
    pub beams: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.thick)
    pub thick: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.entity_msg)
    pub entity_msg: ::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessageDoSpark.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessageDoSpark {
    fn default() -> &'a CEntityMessageDoSpark {
        <CEntityMessageDoSpark as ::protobuf::Message>::default_instance()
    }
}

impl CEntityMessageDoSpark {
    pub fn new() -> CEntityMessageDoSpark {
        ::std::default::Default::default()
    }

    // optional int32 entityindex = 2;

    pub fn entityindex(&self) -> i32 {
        self.entityindex.unwrap_or(-1i32)
    }

    pub fn clear_entityindex(&mut self) {
        self.entityindex = ::std::option::Option::None;
    }

    pub fn has_entityindex(&self) -> bool {
        self.entityindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entityindex(&mut self, v: i32) {
        self.entityindex = ::std::option::Option::Some(v);
    }

    // optional float radius = 3;

    pub fn radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }

    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }

    // optional fixed32 color = 4;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional uint32 beams = 5;

    pub fn beams(&self) -> u32 {
        self.beams.unwrap_or(0)
    }

    pub fn clear_beams(&mut self) {
        self.beams = ::std::option::Option::None;
    }

    pub fn has_beams(&self) -> bool {
        self.beams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beams(&mut self, v: u32) {
        self.beams = ::std::option::Option::Some(v);
    }

    // optional float thick = 6;

    pub fn thick(&self) -> f32 {
        self.thick.unwrap_or(0.)
    }

    pub fn clear_thick(&mut self) {
        self.thick = ::std::option::Option::None;
    }

    pub fn has_thick(&self) -> bool {
        self.thick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thick(&mut self, v: f32) {
        self.thick = ::std::option::Option::Some(v);
    }

    // optional float duration = 7;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "origin",
            |m: &CEntityMessageDoSpark| { &m.origin },
            |m: &mut CEntityMessageDoSpark| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entityindex",
            |m: &CEntityMessageDoSpark| { &m.entityindex },
            |m: &mut CEntityMessageDoSpark| { &mut m.entityindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radius",
            |m: &CEntityMessageDoSpark| { &m.radius },
            |m: &mut CEntityMessageDoSpark| { &mut m.radius },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CEntityMessageDoSpark| { &m.color },
            |m: &mut CEntityMessageDoSpark| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "beams",
            |m: &CEntityMessageDoSpark| { &m.beams },
            |m: &mut CEntityMessageDoSpark| { &mut m.beams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "thick",
            |m: &CEntityMessageDoSpark| { &m.thick },
            |m: &mut CEntityMessageDoSpark| { &mut m.thick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CEntityMessageDoSpark| { &m.duration },
            |m: &mut CEntityMessageDoSpark| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CEntityMsg>(
            "entity_msg",
            |m: &CEntityMessageDoSpark| { &m.entity_msg },
            |m: &mut CEntityMessageDoSpark| { &mut m.entity_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CEntityMessageDoSpark>(
            "CEntityMessageDoSpark",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CEntityMessageDoSpark {
    const NAME: &'static str = "CEntityMessageDoSpark";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                16 => {
                    self.entityindex = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.radius = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.beams = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.thick = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entityindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.radius {
            my_size += 1 + 4;
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        if let Some(v) = self.beams {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.thick {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.entityindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.radius {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.beams {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.thick {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessageDoSpark {
        CEntityMessageDoSpark::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.entityindex = ::std::option::Option::None;
        self.radius = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.beams = ::std::option::Option::None;
        self.thick = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessageDoSpark {
        static instance: CEntityMessageDoSpark = CEntityMessageDoSpark {
            origin: ::protobuf::MessageField::none(),
            entityindex: ::std::option::Option::None,
            radius: ::std::option::Option::None,
            color: ::std::option::Option::None,
            beams: ::std::option::Option::None,
            thick: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            entity_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CEntityMessageDoSpark {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEntityMessageDoSpark").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEntityMessageDoSpark {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEntityMessageDoSpark {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEntityMessageFixAngle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessageFixAngle {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessageFixAngle.relative)
    pub relative: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CEntityMessageFixAngle.angle)
    pub angle: ::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CEntityMessageFixAngle.entity_msg)
    pub entity_msg: ::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessageFixAngle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessageFixAngle {
    fn default() -> &'a CEntityMessageFixAngle {
        <CEntityMessageFixAngle as ::protobuf::Message>::default_instance()
    }
}

impl CEntityMessageFixAngle {
    pub fn new() -> CEntityMessageFixAngle {
        ::std::default::Default::default()
    }

    // optional bool relative = 1;

    pub fn relative(&self) -> bool {
        self.relative.unwrap_or(false)
    }

    pub fn clear_relative(&mut self) {
        self.relative = ::std::option::Option::None;
    }

    pub fn has_relative(&self) -> bool {
        self.relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relative(&mut self, v: bool) {
        self.relative = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relative",
            |m: &CEntityMessageFixAngle| { &m.relative },
            |m: &mut CEntityMessageFixAngle| { &mut m.relative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgQAngle>(
            "angle",
            |m: &CEntityMessageFixAngle| { &m.angle },
            |m: &mut CEntityMessageFixAngle| { &mut m.angle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CEntityMsg>(
            "entity_msg",
            |m: &CEntityMessageFixAngle| { &m.entity_msg },
            |m: &mut CEntityMessageFixAngle| { &mut m.entity_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CEntityMessageFixAngle>(
            "CEntityMessageFixAngle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CEntityMessageFixAngle {
    const NAME: &'static str = "CEntityMessageFixAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.relative = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.relative {
            my_size += 1 + 1;
        }
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.relative {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.angle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessageFixAngle {
        CEntityMessageFixAngle::new()
    }

    fn clear(&mut self) {
        self.relative = ::std::option::Option::None;
        self.angle.clear();
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessageFixAngle {
        static instance: CEntityMessageFixAngle = CEntityMessageFixAngle {
            relative: ::std::option::Option::None,
            angle: ::protobuf::MessageField::none(),
            entity_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CEntityMessageFixAngle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEntityMessageFixAngle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEntityMessageFixAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEntityMessageFixAngle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageCameraTransition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCameraTransition {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCameraTransition.camera_type)
    pub camera_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageCameraTransition.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageCameraTransition.params_data_driven)
    pub params_data_driven: ::protobuf::MessageField<cuser_message_camera_transition::Transition_DataDriven>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCameraTransition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCameraTransition {
    fn default() -> &'a CUserMessageCameraTransition {
        <CUserMessageCameraTransition as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCameraTransition {
    pub fn new() -> CUserMessageCameraTransition {
        ::std::default::Default::default()
    }

    // optional uint32 camera_type = 1;

    pub fn camera_type(&self) -> u32 {
        self.camera_type.unwrap_or(0)
    }

    pub fn clear_camera_type(&mut self) {
        self.camera_type = ::std::option::Option::None;
    }

    pub fn has_camera_type(&self) -> bool {
        self.camera_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_type(&mut self, v: u32) {
        self.camera_type = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "camera_type",
            |m: &CUserMessageCameraTransition| { &m.camera_type },
            |m: &mut CUserMessageCameraTransition| { &mut m.camera_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUserMessageCameraTransition| { &m.duration },
            |m: &mut CUserMessageCameraTransition| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_message_camera_transition::Transition_DataDriven>(
            "params_data_driven",
            |m: &CUserMessageCameraTransition| { &m.params_data_driven },
            |m: &mut CUserMessageCameraTransition| { &mut m.params_data_driven },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageCameraTransition>(
            "CUserMessageCameraTransition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageCameraTransition {
    const NAME: &'static str = "CUserMessageCameraTransition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.camera_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.params_data_driven)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.camera_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.params_data_driven.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.camera_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.params_data_driven.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCameraTransition {
        CUserMessageCameraTransition::new()
    }

    fn clear(&mut self) {
        self.camera_type = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.params_data_driven.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCameraTransition {
        static instance: CUserMessageCameraTransition = CUserMessageCameraTransition {
            camera_type: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            params_data_driven: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageCameraTransition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageCameraTransition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageCameraTransition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageCameraTransition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUserMessageCameraTransition`
pub mod cuser_message_camera_transition {
    // @@protoc_insertion_point(message:CUserMessageCameraTransition.Transition_DataDriven)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Transition_DataDriven {
        // message fields
        // @@protoc_insertion_point(field:CUserMessageCameraTransition.Transition_DataDriven.filename)
        pub filename: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessageCameraTransition.Transition_DataDriven.attach_ent_index)
        pub attach_ent_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessageCameraTransition.Transition_DataDriven.duration)
        pub duration: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessageCameraTransition.Transition_DataDriven.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Transition_DataDriven {
        fn default() -> &'a Transition_DataDriven {
            <Transition_DataDriven as ::protobuf::Message>::default_instance()
        }
    }

    impl Transition_DataDriven {
        pub fn new() -> Transition_DataDriven {
            ::std::default::Default::default()
        }

        // optional string filename = 1;

        pub fn filename(&self) -> &str {
            match self.filename.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_filename(&mut self) {
            self.filename = ::std::option::Option::None;
        }

        pub fn has_filename(&self) -> bool {
            self.filename.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filename(&mut self, v: ::std::string::String) {
            self.filename = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_filename(&mut self) -> &mut ::std::string::String {
            if self.filename.is_none() {
                self.filename = ::std::option::Option::Some(::std::string::String::new());
            }
            self.filename.as_mut().unwrap()
        }

        // Take field
        pub fn take_filename(&mut self) -> ::std::string::String {
            self.filename.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 attach_ent_index = 2;

        pub fn attach_ent_index(&self) -> i32 {
            self.attach_ent_index.unwrap_or(-1i32)
        }

        pub fn clear_attach_ent_index(&mut self) {
            self.attach_ent_index = ::std::option::Option::None;
        }

        pub fn has_attach_ent_index(&self) -> bool {
            self.attach_ent_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attach_ent_index(&mut self, v: i32) {
            self.attach_ent_index = ::std::option::Option::Some(v);
        }

        // optional float duration = 3;

        pub fn duration(&self) -> f32 {
            self.duration.unwrap_or(0.)
        }

        pub fn clear_duration(&mut self) {
            self.duration = ::std::option::Option::None;
        }

        pub fn has_duration(&self) -> bool {
            self.duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_duration(&mut self, v: f32) {
            self.duration = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "filename",
                |m: &Transition_DataDriven| { &m.filename },
                |m: &mut Transition_DataDriven| { &mut m.filename },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "attach_ent_index",
                |m: &Transition_DataDriven| { &m.attach_ent_index },
                |m: &mut Transition_DataDriven| { &mut m.attach_ent_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "duration",
                |m: &Transition_DataDriven| { &m.duration },
                |m: &mut Transition_DataDriven| { &mut m.duration },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transition_DataDriven>(
                "CUserMessageCameraTransition.Transition_DataDriven",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Transition_DataDriven {
        const NAME: &'static str = "Transition_DataDriven";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.filename = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.attach_ent_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    29 => {
                        self.duration = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.filename.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.attach_ent_index {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.duration {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.filename.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.attach_ent_index {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.duration {
                os.write_float(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Transition_DataDriven {
            Transition_DataDriven::new()
        }

        fn clear(&mut self) {
            self.filename = ::std::option::Option::None;
            self.attach_ent_index = ::std::option::Option::None;
            self.duration = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Transition_DataDriven {
            static instance: Transition_DataDriven = Transition_DataDriven {
                filename: ::std::option::Option::None,
                attach_ent_index: ::std::option::Option::None,
                duration: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Transition_DataDriven {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMessageCameraTransition.Transition_DataDriven").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Transition_DataDriven {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Transition_DataDriven {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CUserMsg_ParticleManager)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMsg_ParticleManager {
    // message fields
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<PARTICLE_MESSAGE>>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.release_particle_index)
    pub release_particle_index: ::protobuf::MessageField<cuser_msg_particle_manager::ReleaseParticleIndex>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.create_particle)
    pub create_particle: ::protobuf::MessageField<cuser_msg_particle_manager::CreateParticle>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.destroy_particle)
    pub destroy_particle: ::protobuf::MessageField<cuser_msg_particle_manager::DestroyParticle>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.destroy_particle_involving)
    pub destroy_particle_involving: ::protobuf::MessageField<cuser_msg_particle_manager::DestroyParticleInvolving>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle)
    pub update_particle: ::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticle_OBSOLETE>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_fwd)
    pub update_particle_fwd: ::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleFwd_OBSOLETE>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_orient)
    pub update_particle_orient: ::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleOrient_OBSOLETE>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_fallback)
    pub update_particle_fallback: ::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleFallback>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_offset)
    pub update_particle_offset: ::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleOffset>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_ent)
    pub update_particle_ent: ::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleEnt>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_should_draw)
    pub update_particle_should_draw: ::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleShouldDraw>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_set_frozen)
    pub update_particle_set_frozen: ::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleSetFrozen>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.change_control_point_attachment)
    pub change_control_point_attachment: ::protobuf::MessageField<cuser_msg_particle_manager::ChangeControlPointAttachment>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_entity_position)
    pub update_entity_position: ::protobuf::MessageField<cuser_msg_particle_manager::UpdateEntityPosition>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_particle_fow_properties)
    pub set_particle_fow_properties: ::protobuf::MessageField<cuser_msg_particle_manager::SetParticleFoWProperties>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_particle_text)
    pub set_particle_text: ::protobuf::MessageField<cuser_msg_particle_manager::SetParticleText>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_particle_should_check_fow)
    pub set_particle_should_check_fow: ::protobuf::MessageField<cuser_msg_particle_manager::SetParticleShouldCheckFoW>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_control_point_model)
    pub set_control_point_model: ::protobuf::MessageField<cuser_msg_particle_manager::SetControlPointModel>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_control_point_snapshot)
    pub set_control_point_snapshot: ::protobuf::MessageField<cuser_msg_particle_manager::SetControlPointSnapshot>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_texture_attribute)
    pub set_texture_attribute: ::protobuf::MessageField<cuser_msg_particle_manager::SetTextureAttribute>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_scene_object_generic_flag)
    pub set_scene_object_generic_flag: ::protobuf::MessageField<cuser_msg_particle_manager::SetSceneObjectGenericFlag>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_scene_object_tint_and_desat)
    pub set_scene_object_tint_and_desat: ::protobuf::MessageField<cuser_msg_particle_manager::SetSceneObjectTintAndDesat>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.destroy_particle_named)
    pub destroy_particle_named: ::protobuf::MessageField<cuser_msg_particle_manager::DestroyParticleNamed>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.particle_skip_to_time)
    pub particle_skip_to_time: ::protobuf::MessageField<cuser_msg_particle_manager::ParticleSkipToTime>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.particle_can_freeze)
    pub particle_can_freeze: ::protobuf::MessageField<cuser_msg_particle_manager::ParticleCanFreeze>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_named_value_context)
    pub set_named_value_context: ::protobuf::MessageField<cuser_msg_particle_manager::SetParticleNamedValueContext>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_transform)
    pub update_particle_transform: ::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleTransform>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.particle_freeze_transition_override)
    pub particle_freeze_transition_override: ::protobuf::MessageField<cuser_msg_particle_manager::ParticleFreezeTransitionOverride>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.freeze_particle_involving)
    pub freeze_particle_involving: ::protobuf::MessageField<cuser_msg_particle_manager::FreezeParticleInvolving>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMsg_ParticleManager {
    fn default() -> &'a CUserMsg_ParticleManager {
        <CUserMsg_ParticleManager as ::protobuf::Message>::default_instance()
    }
}

impl CUserMsg_ParticleManager {
    pub fn new() -> CUserMsg_ParticleManager {
        ::std::default::Default::default()
    }

    // required .PARTICLE_MESSAGE type = 1;

    pub fn type_(&self) -> PARTICLE_MESSAGE {
        match self.type_ {
            Some(e) => e.enum_value_or(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE),
            None => PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: PARTICLE_MESSAGE) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 index = 2;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(31);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CUserMsg_ParticleManager| { &m.type_ },
            |m: &mut CUserMsg_ParticleManager| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CUserMsg_ParticleManager| { &m.index },
            |m: &mut CUserMsg_ParticleManager| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::ReleaseParticleIndex>(
            "release_particle_index",
            |m: &CUserMsg_ParticleManager| { &m.release_particle_index },
            |m: &mut CUserMsg_ParticleManager| { &mut m.release_particle_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::CreateParticle>(
            "create_particle",
            |m: &CUserMsg_ParticleManager| { &m.create_particle },
            |m: &mut CUserMsg_ParticleManager| { &mut m.create_particle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::DestroyParticle>(
            "destroy_particle",
            |m: &CUserMsg_ParticleManager| { &m.destroy_particle },
            |m: &mut CUserMsg_ParticleManager| { &mut m.destroy_particle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::DestroyParticleInvolving>(
            "destroy_particle_involving",
            |m: &CUserMsg_ParticleManager| { &m.destroy_particle_involving },
            |m: &mut CUserMsg_ParticleManager| { &mut m.destroy_particle_involving },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::UpdateParticle_OBSOLETE>(
            "update_particle",
            |m: &CUserMsg_ParticleManager| { &m.update_particle },
            |m: &mut CUserMsg_ParticleManager| { &mut m.update_particle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::UpdateParticleFwd_OBSOLETE>(
            "update_particle_fwd",
            |m: &CUserMsg_ParticleManager| { &m.update_particle_fwd },
            |m: &mut CUserMsg_ParticleManager| { &mut m.update_particle_fwd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::UpdateParticleOrient_OBSOLETE>(
            "update_particle_orient",
            |m: &CUserMsg_ParticleManager| { &m.update_particle_orient },
            |m: &mut CUserMsg_ParticleManager| { &mut m.update_particle_orient },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::UpdateParticleFallback>(
            "update_particle_fallback",
            |m: &CUserMsg_ParticleManager| { &m.update_particle_fallback },
            |m: &mut CUserMsg_ParticleManager| { &mut m.update_particle_fallback },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::UpdateParticleOffset>(
            "update_particle_offset",
            |m: &CUserMsg_ParticleManager| { &m.update_particle_offset },
            |m: &mut CUserMsg_ParticleManager| { &mut m.update_particle_offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::UpdateParticleEnt>(
            "update_particle_ent",
            |m: &CUserMsg_ParticleManager| { &m.update_particle_ent },
            |m: &mut CUserMsg_ParticleManager| { &mut m.update_particle_ent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::UpdateParticleShouldDraw>(
            "update_particle_should_draw",
            |m: &CUserMsg_ParticleManager| { &m.update_particle_should_draw },
            |m: &mut CUserMsg_ParticleManager| { &mut m.update_particle_should_draw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::UpdateParticleSetFrozen>(
            "update_particle_set_frozen",
            |m: &CUserMsg_ParticleManager| { &m.update_particle_set_frozen },
            |m: &mut CUserMsg_ParticleManager| { &mut m.update_particle_set_frozen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::ChangeControlPointAttachment>(
            "change_control_point_attachment",
            |m: &CUserMsg_ParticleManager| { &m.change_control_point_attachment },
            |m: &mut CUserMsg_ParticleManager| { &mut m.change_control_point_attachment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::UpdateEntityPosition>(
            "update_entity_position",
            |m: &CUserMsg_ParticleManager| { &m.update_entity_position },
            |m: &mut CUserMsg_ParticleManager| { &mut m.update_entity_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::SetParticleFoWProperties>(
            "set_particle_fow_properties",
            |m: &CUserMsg_ParticleManager| { &m.set_particle_fow_properties },
            |m: &mut CUserMsg_ParticleManager| { &mut m.set_particle_fow_properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::SetParticleText>(
            "set_particle_text",
            |m: &CUserMsg_ParticleManager| { &m.set_particle_text },
            |m: &mut CUserMsg_ParticleManager| { &mut m.set_particle_text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::SetParticleShouldCheckFoW>(
            "set_particle_should_check_fow",
            |m: &CUserMsg_ParticleManager| { &m.set_particle_should_check_fow },
            |m: &mut CUserMsg_ParticleManager| { &mut m.set_particle_should_check_fow },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::SetControlPointModel>(
            "set_control_point_model",
            |m: &CUserMsg_ParticleManager| { &m.set_control_point_model },
            |m: &mut CUserMsg_ParticleManager| { &mut m.set_control_point_model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::SetControlPointSnapshot>(
            "set_control_point_snapshot",
            |m: &CUserMsg_ParticleManager| { &m.set_control_point_snapshot },
            |m: &mut CUserMsg_ParticleManager| { &mut m.set_control_point_snapshot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::SetTextureAttribute>(
            "set_texture_attribute",
            |m: &CUserMsg_ParticleManager| { &m.set_texture_attribute },
            |m: &mut CUserMsg_ParticleManager| { &mut m.set_texture_attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::SetSceneObjectGenericFlag>(
            "set_scene_object_generic_flag",
            |m: &CUserMsg_ParticleManager| { &m.set_scene_object_generic_flag },
            |m: &mut CUserMsg_ParticleManager| { &mut m.set_scene_object_generic_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::SetSceneObjectTintAndDesat>(
            "set_scene_object_tint_and_desat",
            |m: &CUserMsg_ParticleManager| { &m.set_scene_object_tint_and_desat },
            |m: &mut CUserMsg_ParticleManager| { &mut m.set_scene_object_tint_and_desat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::DestroyParticleNamed>(
            "destroy_particle_named",
            |m: &CUserMsg_ParticleManager| { &m.destroy_particle_named },
            |m: &mut CUserMsg_ParticleManager| { &mut m.destroy_particle_named },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::ParticleSkipToTime>(
            "particle_skip_to_time",
            |m: &CUserMsg_ParticleManager| { &m.particle_skip_to_time },
            |m: &mut CUserMsg_ParticleManager| { &mut m.particle_skip_to_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::ParticleCanFreeze>(
            "particle_can_freeze",
            |m: &CUserMsg_ParticleManager| { &m.particle_can_freeze },
            |m: &mut CUserMsg_ParticleManager| { &mut m.particle_can_freeze },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::SetParticleNamedValueContext>(
            "set_named_value_context",
            |m: &CUserMsg_ParticleManager| { &m.set_named_value_context },
            |m: &mut CUserMsg_ParticleManager| { &mut m.set_named_value_context },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::UpdateParticleTransform>(
            "update_particle_transform",
            |m: &CUserMsg_ParticleManager| { &m.update_particle_transform },
            |m: &mut CUserMsg_ParticleManager| { &mut m.update_particle_transform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::ParticleFreezeTransitionOverride>(
            "particle_freeze_transition_override",
            |m: &CUserMsg_ParticleManager| { &m.particle_freeze_transition_override },
            |m: &mut CUserMsg_ParticleManager| { &mut m.particle_freeze_transition_override },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_msg_particle_manager::FreezeParticleInvolving>(
            "freeze_particle_involving",
            |m: &CUserMsg_ParticleManager| { &m.freeze_particle_involving },
            |m: &mut CUserMsg_ParticleManager| { &mut m.freeze_particle_involving },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMsg_ParticleManager>(
            "CUserMsg_ParticleManager",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMsg_ParticleManager {
    const NAME: &'static str = "CUserMsg_ParticleManager";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        for v in &self.release_particle_index {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_particle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_particle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_particle_involving {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_fwd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_orient {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_fallback {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_ent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_should_draw {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_set_frozen {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.change_control_point_attachment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_entity_position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_particle_fow_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_particle_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_particle_should_check_fow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_control_point_model {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_control_point_snapshot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_texture_attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_scene_object_generic_flag {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_scene_object_tint_and_desat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_particle_named {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.particle_skip_to_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.particle_can_freeze {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_named_value_context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_transform {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.particle_freeze_transition_override {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.freeze_particle_involving {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.release_particle_index)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.create_particle)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.destroy_particle)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.destroy_particle_involving)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_fwd)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_orient)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_fallback)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_offset)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_ent)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_should_draw)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_set_frozen)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.change_control_point_attachment)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_entity_position)?;
                },
                146 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_particle_fow_properties)?;
                },
                154 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_particle_text)?;
                },
                162 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_particle_should_check_fow)?;
                },
                170 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_control_point_model)?;
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_control_point_snapshot)?;
                },
                186 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_texture_attribute)?;
                },
                194 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_scene_object_generic_flag)?;
                },
                202 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_scene_object_tint_and_desat)?;
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.destroy_particle_named)?;
                },
                218 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_skip_to_time)?;
                },
                226 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_can_freeze)?;
                },
                234 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.set_named_value_context)?;
                },
                242 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_transform)?;
                },
                250 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_freeze_transition_override)?;
                },
                258 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.freeze_particle_involving)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.release_particle_index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.create_particle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.destroy_particle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.destroy_particle_involving.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_fwd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_orient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_fallback.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_ent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_should_draw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_set_frozen.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.change_control_point_attachment.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_entity_position.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_particle_fow_properties.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_particle_text.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_particle_should_check_fow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_control_point_model.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_control_point_snapshot.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_texture_attribute.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_scene_object_generic_flag.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_scene_object_tint_and_desat.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.destroy_particle_named.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_skip_to_time.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_can_freeze.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_named_value_context.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_transform.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_freeze_transition_override.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.freeze_particle_involving.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.release_particle_index.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.create_particle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.destroy_particle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.destroy_particle_involving.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.update_particle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.update_particle_fwd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.update_particle_orient.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.update_particle_fallback.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.update_particle_offset.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.update_particle_ent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.update_particle_should_draw.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.update_particle_set_frozen.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.change_control_point_attachment.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.update_entity_position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.set_particle_fow_properties.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.set_particle_text.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.set_particle_should_check_fow.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.set_control_point_model.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.set_control_point_snapshot.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.set_texture_attribute.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.set_scene_object_generic_flag.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.set_scene_object_tint_and_desat.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.destroy_particle_named.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.particle_skip_to_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.particle_can_freeze.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.set_named_value_context.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.update_particle_transform.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.particle_freeze_transition_override.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.freeze_particle_involving.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMsg_ParticleManager {
        CUserMsg_ParticleManager::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.release_particle_index.clear();
        self.create_particle.clear();
        self.destroy_particle.clear();
        self.destroy_particle_involving.clear();
        self.update_particle.clear();
        self.update_particle_fwd.clear();
        self.update_particle_orient.clear();
        self.update_particle_fallback.clear();
        self.update_particle_offset.clear();
        self.update_particle_ent.clear();
        self.update_particle_should_draw.clear();
        self.update_particle_set_frozen.clear();
        self.change_control_point_attachment.clear();
        self.update_entity_position.clear();
        self.set_particle_fow_properties.clear();
        self.set_particle_text.clear();
        self.set_particle_should_check_fow.clear();
        self.set_control_point_model.clear();
        self.set_control_point_snapshot.clear();
        self.set_texture_attribute.clear();
        self.set_scene_object_generic_flag.clear();
        self.set_scene_object_tint_and_desat.clear();
        self.destroy_particle_named.clear();
        self.particle_skip_to_time.clear();
        self.particle_can_freeze.clear();
        self.set_named_value_context.clear();
        self.update_particle_transform.clear();
        self.particle_freeze_transition_override.clear();
        self.freeze_particle_involving.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMsg_ParticleManager {
        static instance: CUserMsg_ParticleManager = CUserMsg_ParticleManager {
            type_: ::std::option::Option::None,
            index: ::std::option::Option::None,
            release_particle_index: ::protobuf::MessageField::none(),
            create_particle: ::protobuf::MessageField::none(),
            destroy_particle: ::protobuf::MessageField::none(),
            destroy_particle_involving: ::protobuf::MessageField::none(),
            update_particle: ::protobuf::MessageField::none(),
            update_particle_fwd: ::protobuf::MessageField::none(),
            update_particle_orient: ::protobuf::MessageField::none(),
            update_particle_fallback: ::protobuf::MessageField::none(),
            update_particle_offset: ::protobuf::MessageField::none(),
            update_particle_ent: ::protobuf::MessageField::none(),
            update_particle_should_draw: ::protobuf::MessageField::none(),
            update_particle_set_frozen: ::protobuf::MessageField::none(),
            change_control_point_attachment: ::protobuf::MessageField::none(),
            update_entity_position: ::protobuf::MessageField::none(),
            set_particle_fow_properties: ::protobuf::MessageField::none(),
            set_particle_text: ::protobuf::MessageField::none(),
            set_particle_should_check_fow: ::protobuf::MessageField::none(),
            set_control_point_model: ::protobuf::MessageField::none(),
            set_control_point_snapshot: ::protobuf::MessageField::none(),
            set_texture_attribute: ::protobuf::MessageField::none(),
            set_scene_object_generic_flag: ::protobuf::MessageField::none(),
            set_scene_object_tint_and_desat: ::protobuf::MessageField::none(),
            destroy_particle_named: ::protobuf::MessageField::none(),
            particle_skip_to_time: ::protobuf::MessageField::none(),
            particle_can_freeze: ::protobuf::MessageField::none(),
            set_named_value_context: ::protobuf::MessageField::none(),
            update_particle_transform: ::protobuf::MessageField::none(),
            particle_freeze_transition_override: ::protobuf::MessageField::none(),
            freeze_particle_involving: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMsg_ParticleManager {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMsg_ParticleManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMsg_ParticleManager {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUserMsg_ParticleManager`
pub mod cuser_msg_particle_manager {
    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ReleaseParticleIndex)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReleaseParticleIndex {
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ReleaseParticleIndex.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReleaseParticleIndex {
        fn default() -> &'a ReleaseParticleIndex {
            <ReleaseParticleIndex as ::protobuf::Message>::default_instance()
        }
    }

    impl ReleaseParticleIndex {
        pub fn new() -> ReleaseParticleIndex {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReleaseParticleIndex>(
                "CUserMsg_ParticleManager.ReleaseParticleIndex",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ReleaseParticleIndex {
        const NAME: &'static str = "ReleaseParticleIndex";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReleaseParticleIndex {
            ReleaseParticleIndex::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReleaseParticleIndex {
            static instance: ReleaseParticleIndex = ReleaseParticleIndex {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ReleaseParticleIndex {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.ReleaseParticleIndex").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReleaseParticleIndex {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ReleaseParticleIndex {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.CreateParticle)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CreateParticle {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.particle_name_index)
        pub particle_name_index: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.attach_type)
        pub attach_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.entity_handle_for_modifiers)
        pub entity_handle_for_modifiers: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.apply_voice_ban_rules)
        pub apply_voice_ban_rules: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.team_behavior)
        pub team_behavior: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.control_point_configuration)
        pub control_point_configuration: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.cluster)
        pub cluster: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.endcap_time)
        pub endcap_time: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.CreateParticle.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CreateParticle {
        fn default() -> &'a CreateParticle {
            <CreateParticle as ::protobuf::Message>::default_instance()
        }
    }

    impl CreateParticle {
        pub fn new() -> CreateParticle {
            ::std::default::Default::default()
        }

        // optional fixed64 particle_name_index = 1;

        pub fn particle_name_index(&self) -> u64 {
            self.particle_name_index.unwrap_or(0)
        }

        pub fn clear_particle_name_index(&mut self) {
            self.particle_name_index = ::std::option::Option::None;
        }

        pub fn has_particle_name_index(&self) -> bool {
            self.particle_name_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_particle_name_index(&mut self, v: u64) {
            self.particle_name_index = ::std::option::Option::Some(v);
        }

        // optional int32 attach_type = 2;

        pub fn attach_type(&self) -> i32 {
            self.attach_type.unwrap_or(0)
        }

        pub fn clear_attach_type(&mut self) {
            self.attach_type = ::std::option::Option::None;
        }

        pub fn has_attach_type(&self) -> bool {
            self.attach_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attach_type(&mut self, v: i32) {
            self.attach_type = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 3;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle_for_modifiers = 4;

        pub fn entity_handle_for_modifiers(&self) -> u32 {
            self.entity_handle_for_modifiers.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle_for_modifiers(&mut self) {
            self.entity_handle_for_modifiers = ::std::option::Option::None;
        }

        pub fn has_entity_handle_for_modifiers(&self) -> bool {
            self.entity_handle_for_modifiers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle_for_modifiers(&mut self, v: u32) {
            self.entity_handle_for_modifiers = ::std::option::Option::Some(v);
        }

        // optional bool apply_voice_ban_rules = 5;

        pub fn apply_voice_ban_rules(&self) -> bool {
            self.apply_voice_ban_rules.unwrap_or(false)
        }

        pub fn clear_apply_voice_ban_rules(&mut self) {
            self.apply_voice_ban_rules = ::std::option::Option::None;
        }

        pub fn has_apply_voice_ban_rules(&self) -> bool {
            self.apply_voice_ban_rules.is_some()
        }

        // Param is passed by value, moved
        pub fn set_apply_voice_ban_rules(&mut self, v: bool) {
            self.apply_voice_ban_rules = ::std::option::Option::Some(v);
        }

        // optional int32 team_behavior = 6;

        pub fn team_behavior(&self) -> i32 {
            self.team_behavior.unwrap_or(0)
        }

        pub fn clear_team_behavior(&mut self) {
            self.team_behavior = ::std::option::Option::None;
        }

        pub fn has_team_behavior(&self) -> bool {
            self.team_behavior.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_behavior(&mut self, v: i32) {
            self.team_behavior = ::std::option::Option::Some(v);
        }

        // optional string control_point_configuration = 7;

        pub fn control_point_configuration(&self) -> &str {
            match self.control_point_configuration.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_control_point_configuration(&mut self) {
            self.control_point_configuration = ::std::option::Option::None;
        }

        pub fn has_control_point_configuration(&self) -> bool {
            self.control_point_configuration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point_configuration(&mut self, v: ::std::string::String) {
            self.control_point_configuration = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_control_point_configuration(&mut self) -> &mut ::std::string::String {
            if self.control_point_configuration.is_none() {
                self.control_point_configuration = ::std::option::Option::Some(::std::string::String::new());
            }
            self.control_point_configuration.as_mut().unwrap()
        }

        // Take field
        pub fn take_control_point_configuration(&mut self) -> ::std::string::String {
            self.control_point_configuration.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool cluster = 8;

        pub fn cluster(&self) -> bool {
            self.cluster.unwrap_or(false)
        }

        pub fn clear_cluster(&mut self) {
            self.cluster = ::std::option::Option::None;
        }

        pub fn has_cluster(&self) -> bool {
            self.cluster.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cluster(&mut self, v: bool) {
            self.cluster = ::std::option::Option::Some(v);
        }

        // optional float endcap_time = 9;

        pub fn endcap_time(&self) -> f32 {
            self.endcap_time.unwrap_or(0.)
        }

        pub fn clear_endcap_time(&mut self) {
            self.endcap_time = ::std::option::Option::None;
        }

        pub fn has_endcap_time(&self) -> bool {
            self.endcap_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_endcap_time(&mut self, v: f32) {
            self.endcap_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "particle_name_index",
                |m: &CreateParticle| { &m.particle_name_index },
                |m: &mut CreateParticle| { &mut m.particle_name_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "attach_type",
                |m: &CreateParticle| { &m.attach_type },
                |m: &mut CreateParticle| { &mut m.attach_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_handle",
                |m: &CreateParticle| { &m.entity_handle },
                |m: &mut CreateParticle| { &mut m.entity_handle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_handle_for_modifiers",
                |m: &CreateParticle| { &m.entity_handle_for_modifiers },
                |m: &mut CreateParticle| { &mut m.entity_handle_for_modifiers },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "apply_voice_ban_rules",
                |m: &CreateParticle| { &m.apply_voice_ban_rules },
                |m: &mut CreateParticle| { &mut m.apply_voice_ban_rules },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_behavior",
                |m: &CreateParticle| { &m.team_behavior },
                |m: &mut CreateParticle| { &mut m.team_behavior },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control_point_configuration",
                |m: &CreateParticle| { &m.control_point_configuration },
                |m: &mut CreateParticle| { &mut m.control_point_configuration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "cluster",
                |m: &CreateParticle| { &m.cluster },
                |m: &mut CreateParticle| { &mut m.cluster },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "endcap_time",
                |m: &CreateParticle| { &m.endcap_time },
                |m: &mut CreateParticle| { &mut m.endcap_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateParticle>(
                "CUserMsg_ParticleManager.CreateParticle",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CreateParticle {
        const NAME: &'static str = "CreateParticle";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.particle_name_index = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.attach_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.entity_handle_for_modifiers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.apply_voice_ban_rules = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.team_behavior = ::std::option::Option::Some(is.read_int32()?);
                    },
                    58 => {
                        self.control_point_configuration = ::std::option::Option::Some(is.read_string()?);
                    },
                    64 => {
                        self.cluster = ::std::option::Option::Some(is.read_bool()?);
                    },
                    77 => {
                        self.endcap_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.particle_name_index {
                my_size += 1 + 8;
            }
            if let Some(v) = self.attach_type {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.entity_handle {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.entity_handle_for_modifiers {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.apply_voice_ban_rules {
                my_size += 1 + 1;
            }
            if let Some(v) = self.team_behavior {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.control_point_configuration.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.cluster {
                my_size += 1 + 1;
            }
            if let Some(v) = self.endcap_time {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.particle_name_index {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.attach_type {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.entity_handle_for_modifiers {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.apply_voice_ban_rules {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.team_behavior {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.control_point_configuration.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.cluster {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.endcap_time {
                os.write_float(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CreateParticle {
            CreateParticle::new()
        }

        fn clear(&mut self) {
            self.particle_name_index = ::std::option::Option::None;
            self.attach_type = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.entity_handle_for_modifiers = ::std::option::Option::None;
            self.apply_voice_ban_rules = ::std::option::Option::None;
            self.team_behavior = ::std::option::Option::None;
            self.control_point_configuration = ::std::option::Option::None;
            self.cluster = ::std::option::Option::None;
            self.endcap_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CreateParticle {
            static instance: CreateParticle = CreateParticle {
                particle_name_index: ::std::option::Option::None,
                attach_type: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                entity_handle_for_modifiers: ::std::option::Option::None,
                apply_voice_ban_rules: ::std::option::Option::None,
                team_behavior: ::std::option::Option::None,
                control_point_configuration: ::std::option::Option::None,
                cluster: ::std::option::Option::None,
                endcap_time: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CreateParticle {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.CreateParticle").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CreateParticle {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CreateParticle {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.DestroyParticle)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DestroyParticle {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticle.destroy_immediately)
        pub destroy_immediately: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.DestroyParticle.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DestroyParticle {
        fn default() -> &'a DestroyParticle {
            <DestroyParticle as ::protobuf::Message>::default_instance()
        }
    }

    impl DestroyParticle {
        pub fn new() -> DestroyParticle {
            ::std::default::Default::default()
        }

        // optional bool destroy_immediately = 1;

        pub fn destroy_immediately(&self) -> bool {
            self.destroy_immediately.unwrap_or(false)
        }

        pub fn clear_destroy_immediately(&mut self) {
            self.destroy_immediately = ::std::option::Option::None;
        }

        pub fn has_destroy_immediately(&self) -> bool {
            self.destroy_immediately.is_some()
        }

        // Param is passed by value, moved
        pub fn set_destroy_immediately(&mut self, v: bool) {
            self.destroy_immediately = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "destroy_immediately",
                |m: &DestroyParticle| { &m.destroy_immediately },
                |m: &mut DestroyParticle| { &mut m.destroy_immediately },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DestroyParticle>(
                "CUserMsg_ParticleManager.DestroyParticle",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DestroyParticle {
        const NAME: &'static str = "DestroyParticle";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.destroy_immediately = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.destroy_immediately {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.destroy_immediately {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DestroyParticle {
            DestroyParticle::new()
        }

        fn clear(&mut self) {
            self.destroy_immediately = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DestroyParticle {
            static instance: DestroyParticle = DestroyParticle {
                destroy_immediately: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DestroyParticle {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.DestroyParticle").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DestroyParticle {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DestroyParticle {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.DestroyParticleInvolving)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DestroyParticleInvolving {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleInvolving.destroy_immediately)
        pub destroy_immediately: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleInvolving.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.DestroyParticleInvolving.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DestroyParticleInvolving {
        fn default() -> &'a DestroyParticleInvolving {
            <DestroyParticleInvolving as ::protobuf::Message>::default_instance()
        }
    }

    impl DestroyParticleInvolving {
        pub fn new() -> DestroyParticleInvolving {
            ::std::default::Default::default()
        }

        // optional bool destroy_immediately = 1;

        pub fn destroy_immediately(&self) -> bool {
            self.destroy_immediately.unwrap_or(false)
        }

        pub fn clear_destroy_immediately(&mut self) {
            self.destroy_immediately = ::std::option::Option::None;
        }

        pub fn has_destroy_immediately(&self) -> bool {
            self.destroy_immediately.is_some()
        }

        // Param is passed by value, moved
        pub fn set_destroy_immediately(&mut self, v: bool) {
            self.destroy_immediately = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 3;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "destroy_immediately",
                |m: &DestroyParticleInvolving| { &m.destroy_immediately },
                |m: &mut DestroyParticleInvolving| { &mut m.destroy_immediately },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_handle",
                |m: &DestroyParticleInvolving| { &m.entity_handle },
                |m: &mut DestroyParticleInvolving| { &mut m.entity_handle },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DestroyParticleInvolving>(
                "CUserMsg_ParticleManager.DestroyParticleInvolving",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DestroyParticleInvolving {
        const NAME: &'static str = "DestroyParticleInvolving";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.destroy_immediately = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.destroy_immediately {
                my_size += 1 + 1;
            }
            if let Some(v) = self.entity_handle {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.destroy_immediately {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DestroyParticleInvolving {
            DestroyParticleInvolving::new()
        }

        fn clear(&mut self) {
            self.destroy_immediately = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DestroyParticleInvolving {
            static instance: DestroyParticleInvolving = DestroyParticleInvolving {
                destroy_immediately: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DestroyParticleInvolving {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.DestroyParticleInvolving").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DestroyParticleInvolving {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DestroyParticleInvolving {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.DestroyParticleNamed)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DestroyParticleNamed {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleNamed.particle_name_index)
        pub particle_name_index: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleNamed.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleNamed.destroy_immediately)
        pub destroy_immediately: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleNamed.play_endcap)
        pub play_endcap: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.DestroyParticleNamed.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DestroyParticleNamed {
        fn default() -> &'a DestroyParticleNamed {
            <DestroyParticleNamed as ::protobuf::Message>::default_instance()
        }
    }

    impl DestroyParticleNamed {
        pub fn new() -> DestroyParticleNamed {
            ::std::default::Default::default()
        }

        // optional fixed64 particle_name_index = 1;

        pub fn particle_name_index(&self) -> u64 {
            self.particle_name_index.unwrap_or(0)
        }

        pub fn clear_particle_name_index(&mut self) {
            self.particle_name_index = ::std::option::Option::None;
        }

        pub fn has_particle_name_index(&self) -> bool {
            self.particle_name_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_particle_name_index(&mut self, v: u64) {
            self.particle_name_index = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 2;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }

        // optional bool destroy_immediately = 3;

        pub fn destroy_immediately(&self) -> bool {
            self.destroy_immediately.unwrap_or(false)
        }

        pub fn clear_destroy_immediately(&mut self) {
            self.destroy_immediately = ::std::option::Option::None;
        }

        pub fn has_destroy_immediately(&self) -> bool {
            self.destroy_immediately.is_some()
        }

        // Param is passed by value, moved
        pub fn set_destroy_immediately(&mut self, v: bool) {
            self.destroy_immediately = ::std::option::Option::Some(v);
        }

        // optional bool play_endcap = 4;

        pub fn play_endcap(&self) -> bool {
            self.play_endcap.unwrap_or(false)
        }

        pub fn clear_play_endcap(&mut self) {
            self.play_endcap = ::std::option::Option::None;
        }

        pub fn has_play_endcap(&self) -> bool {
            self.play_endcap.is_some()
        }

        // Param is passed by value, moved
        pub fn set_play_endcap(&mut self, v: bool) {
            self.play_endcap = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "particle_name_index",
                |m: &DestroyParticleNamed| { &m.particle_name_index },
                |m: &mut DestroyParticleNamed| { &mut m.particle_name_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_handle",
                |m: &DestroyParticleNamed| { &m.entity_handle },
                |m: &mut DestroyParticleNamed| { &mut m.entity_handle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "destroy_immediately",
                |m: &DestroyParticleNamed| { &m.destroy_immediately },
                |m: &mut DestroyParticleNamed| { &mut m.destroy_immediately },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "play_endcap",
                |m: &DestroyParticleNamed| { &m.play_endcap },
                |m: &mut DestroyParticleNamed| { &mut m.play_endcap },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DestroyParticleNamed>(
                "CUserMsg_ParticleManager.DestroyParticleNamed",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DestroyParticleNamed {
        const NAME: &'static str = "DestroyParticleNamed";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.particle_name_index = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.destroy_immediately = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.play_endcap = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.particle_name_index {
                my_size += 1 + 8;
            }
            if let Some(v) = self.entity_handle {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.destroy_immediately {
                my_size += 1 + 1;
            }
            if let Some(v) = self.play_endcap {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.particle_name_index {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.destroy_immediately {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.play_endcap {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DestroyParticleNamed {
            DestroyParticleNamed::new()
        }

        fn clear(&mut self) {
            self.particle_name_index = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.destroy_immediately = ::std::option::Option::None;
            self.play_endcap = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DestroyParticleNamed {
            static instance: DestroyParticleNamed = DestroyParticleNamed {
                particle_name_index: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                destroy_immediately: ::std::option::Option::None,
                play_endcap: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DestroyParticleNamed {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.DestroyParticleNamed").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DestroyParticleNamed {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DestroyParticleNamed {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticle_OBSOLETE)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticle_OBSOLETE {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.position)
        pub position: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticle_OBSOLETE {
        fn default() -> &'a UpdateParticle_OBSOLETE {
            <UpdateParticle_OBSOLETE as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticle_OBSOLETE {
        pub fn new() -> UpdateParticle_OBSOLETE {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control_point",
                |m: &UpdateParticle_OBSOLETE| { &m.control_point },
                |m: &mut UpdateParticle_OBSOLETE| { &mut m.control_point },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "position",
                |m: &UpdateParticle_OBSOLETE| { &m.position },
                |m: &mut UpdateParticle_OBSOLETE| { &mut m.position },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateParticle_OBSOLETE>(
                "CUserMsg_ParticleManager.UpdateParticle_OBSOLETE",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UpdateParticle_OBSOLETE {
        const NAME: &'static str = "UpdateParticle_OBSOLETE";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticle_OBSOLETE {
            UpdateParticle_OBSOLETE::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.position.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticle_OBSOLETE {
            static instance: UpdateParticle_OBSOLETE = UpdateParticle_OBSOLETE {
                control_point: ::std::option::Option::None,
                position: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UpdateParticle_OBSOLETE {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.UpdateParticle_OBSOLETE").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateParticle_OBSOLETE {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UpdateParticle_OBSOLETE {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleFwd_OBSOLETE {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.forward)
        pub forward: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleFwd_OBSOLETE {
        fn default() -> &'a UpdateParticleFwd_OBSOLETE {
            <UpdateParticleFwd_OBSOLETE as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleFwd_OBSOLETE {
        pub fn new() -> UpdateParticleFwd_OBSOLETE {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control_point",
                |m: &UpdateParticleFwd_OBSOLETE| { &m.control_point },
                |m: &mut UpdateParticleFwd_OBSOLETE| { &mut m.control_point },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "forward",
                |m: &UpdateParticleFwd_OBSOLETE| { &m.forward },
                |m: &mut UpdateParticleFwd_OBSOLETE| { &mut m.forward },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateParticleFwd_OBSOLETE>(
                "CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UpdateParticleFwd_OBSOLETE {
        const NAME: &'static str = "UpdateParticleFwd_OBSOLETE";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.forward)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.forward.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.forward.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleFwd_OBSOLETE {
            UpdateParticleFwd_OBSOLETE::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.forward.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleFwd_OBSOLETE {
            static instance: UpdateParticleFwd_OBSOLETE = UpdateParticleFwd_OBSOLETE {
                control_point: ::std::option::Option::None,
                forward: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UpdateParticleFwd_OBSOLETE {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateParticleFwd_OBSOLETE {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UpdateParticleFwd_OBSOLETE {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleOrient_OBSOLETE {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.forward)
        pub forward: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.deprecated_right)
        pub deprecated_right: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.up)
        pub up: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.left)
        pub left: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleOrient_OBSOLETE {
        fn default() -> &'a UpdateParticleOrient_OBSOLETE {
            <UpdateParticleOrient_OBSOLETE as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleOrient_OBSOLETE {
        pub fn new() -> UpdateParticleOrient_OBSOLETE {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control_point",
                |m: &UpdateParticleOrient_OBSOLETE| { &m.control_point },
                |m: &mut UpdateParticleOrient_OBSOLETE| { &mut m.control_point },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "forward",
                |m: &UpdateParticleOrient_OBSOLETE| { &m.forward },
                |m: &mut UpdateParticleOrient_OBSOLETE| { &mut m.forward },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "deprecated_right",
                |m: &UpdateParticleOrient_OBSOLETE| { &m.deprecated_right },
                |m: &mut UpdateParticleOrient_OBSOLETE| { &mut m.deprecated_right },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "up",
                |m: &UpdateParticleOrient_OBSOLETE| { &m.up },
                |m: &mut UpdateParticleOrient_OBSOLETE| { &mut m.up },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "left",
                |m: &UpdateParticleOrient_OBSOLETE| { &m.left },
                |m: &mut UpdateParticleOrient_OBSOLETE| { &mut m.left },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateParticleOrient_OBSOLETE>(
                "CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UpdateParticleOrient_OBSOLETE {
        const NAME: &'static str = "UpdateParticleOrient_OBSOLETE";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.forward)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.deprecated_right)?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.up)?;
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.left)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.forward.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.deprecated_right.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.up.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.left.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.forward.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.deprecated_right.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.up.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.left.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleOrient_OBSOLETE {
            UpdateParticleOrient_OBSOLETE::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.forward.clear();
            self.deprecated_right.clear();
            self.up.clear();
            self.left.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleOrient_OBSOLETE {
            static instance: UpdateParticleOrient_OBSOLETE = UpdateParticleOrient_OBSOLETE {
                control_point: ::std::option::Option::None,
                forward: ::protobuf::MessageField::none(),
                deprecated_right: ::protobuf::MessageField::none(),
                up: ::protobuf::MessageField::none(),
                left: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UpdateParticleOrient_OBSOLETE {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateParticleOrient_OBSOLETE {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UpdateParticleOrient_OBSOLETE {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleTransform)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleTransform {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleTransform.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleTransform.position)
        pub position: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleTransform.orientation)
        pub orientation: ::protobuf::MessageField<super::super::networkbasetypes::CMsgQuaternion>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleTransform.interpolation_interval)
        pub interpolation_interval: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleTransform.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleTransform {
        fn default() -> &'a UpdateParticleTransform {
            <UpdateParticleTransform as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleTransform {
        pub fn new() -> UpdateParticleTransform {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        // optional float interpolation_interval = 4;

        pub fn interpolation_interval(&self) -> f32 {
            self.interpolation_interval.unwrap_or(0.)
        }

        pub fn clear_interpolation_interval(&mut self) {
            self.interpolation_interval = ::std::option::Option::None;
        }

        pub fn has_interpolation_interval(&self) -> bool {
            self.interpolation_interval.is_some()
        }

        // Param is passed by value, moved
        pub fn set_interpolation_interval(&mut self, v: f32) {
            self.interpolation_interval = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control_point",
                |m: &UpdateParticleTransform| { &m.control_point },
                |m: &mut UpdateParticleTransform| { &mut m.control_point },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "position",
                |m: &UpdateParticleTransform| { &m.position },
                |m: &mut UpdateParticleTransform| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgQuaternion>(
                "orientation",
                |m: &UpdateParticleTransform| { &m.orientation },
                |m: &mut UpdateParticleTransform| { &mut m.orientation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "interpolation_interval",
                |m: &UpdateParticleTransform| { &m.interpolation_interval },
                |m: &mut UpdateParticleTransform| { &mut m.interpolation_interval },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateParticleTransform>(
                "CUserMsg_ParticleManager.UpdateParticleTransform",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UpdateParticleTransform {
        const NAME: &'static str = "UpdateParticleTransform";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.orientation)?;
                    },
                    37 => {
                        self.interpolation_interval = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.orientation.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.interpolation_interval {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.orientation.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.interpolation_interval {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleTransform {
            UpdateParticleTransform::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.position.clear();
            self.orientation.clear();
            self.interpolation_interval = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleTransform {
            static instance: UpdateParticleTransform = UpdateParticleTransform {
                control_point: ::std::option::Option::None,
                position: ::protobuf::MessageField::none(),
                orientation: ::protobuf::MessageField::none(),
                interpolation_interval: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UpdateParticleTransform {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.UpdateParticleTransform").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateParticleTransform {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UpdateParticleTransform {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleFallback)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleFallback {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleFallback.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleFallback.position)
        pub position: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleFallback.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleFallback {
        fn default() -> &'a UpdateParticleFallback {
            <UpdateParticleFallback as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleFallback {
        pub fn new() -> UpdateParticleFallback {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control_point",
                |m: &UpdateParticleFallback| { &m.control_point },
                |m: &mut UpdateParticleFallback| { &mut m.control_point },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "position",
                |m: &UpdateParticleFallback| { &m.position },
                |m: &mut UpdateParticleFallback| { &mut m.position },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateParticleFallback>(
                "CUserMsg_ParticleManager.UpdateParticleFallback",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UpdateParticleFallback {
        const NAME: &'static str = "UpdateParticleFallback";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleFallback {
            UpdateParticleFallback::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.position.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleFallback {
            static instance: UpdateParticleFallback = UpdateParticleFallback {
                control_point: ::std::option::Option::None,
                position: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UpdateParticleFallback {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.UpdateParticleFallback").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateParticleFallback {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UpdateParticleFallback {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleOffset)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleOffset {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOffset.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOffset.origin_offset)
        pub origin_offset: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOffset.angle_offset)
        pub angle_offset: ::protobuf::MessageField<super::super::networkbasetypes::CMsgQAngle>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleOffset.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleOffset {
        fn default() -> &'a UpdateParticleOffset {
            <UpdateParticleOffset as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleOffset {
        pub fn new() -> UpdateParticleOffset {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control_point",
                |m: &UpdateParticleOffset| { &m.control_point },
                |m: &mut UpdateParticleOffset| { &mut m.control_point },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "origin_offset",
                |m: &UpdateParticleOffset| { &m.origin_offset },
                |m: &mut UpdateParticleOffset| { &mut m.origin_offset },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgQAngle>(
                "angle_offset",
                |m: &UpdateParticleOffset| { &m.angle_offset },
                |m: &mut UpdateParticleOffset| { &mut m.angle_offset },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateParticleOffset>(
                "CUserMsg_ParticleManager.UpdateParticleOffset",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UpdateParticleOffset {
        const NAME: &'static str = "UpdateParticleOffset";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.origin_offset)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.angle_offset)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.origin_offset.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.angle_offset.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.origin_offset.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.angle_offset.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleOffset {
            UpdateParticleOffset::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.origin_offset.clear();
            self.angle_offset.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleOffset {
            static instance: UpdateParticleOffset = UpdateParticleOffset {
                control_point: ::std::option::Option::None,
                origin_offset: ::protobuf::MessageField::none(),
                angle_offset: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UpdateParticleOffset {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.UpdateParticleOffset").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateParticleOffset {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UpdateParticleOffset {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleEnt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleEnt {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.attach_type)
        pub attach_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.attachment)
        pub attachment: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.fallback_position)
        pub fallback_position: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.include_wearables)
        pub include_wearables: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.offset_position)
        pub offset_position: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.offset_angles)
        pub offset_angles: ::protobuf::MessageField<super::super::networkbasetypes::CMsgQAngle>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleEnt.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleEnt {
        fn default() -> &'a UpdateParticleEnt {
            <UpdateParticleEnt as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleEnt {
        pub fn new() -> UpdateParticleEnt {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 2;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }

        // optional int32 attach_type = 3;

        pub fn attach_type(&self) -> i32 {
            self.attach_type.unwrap_or(0)
        }

        pub fn clear_attach_type(&mut self) {
            self.attach_type = ::std::option::Option::None;
        }

        pub fn has_attach_type(&self) -> bool {
            self.attach_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attach_type(&mut self, v: i32) {
            self.attach_type = ::std::option::Option::Some(v);
        }

        // optional int32 attachment = 4;

        pub fn attachment(&self) -> i32 {
            self.attachment.unwrap_or(0)
        }

        pub fn clear_attachment(&mut self) {
            self.attachment = ::std::option::Option::None;
        }

        pub fn has_attachment(&self) -> bool {
            self.attachment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attachment(&mut self, v: i32) {
            self.attachment = ::std::option::Option::Some(v);
        }

        // optional bool include_wearables = 6;

        pub fn include_wearables(&self) -> bool {
            self.include_wearables.unwrap_or(false)
        }

        pub fn clear_include_wearables(&mut self) {
            self.include_wearables = ::std::option::Option::None;
        }

        pub fn has_include_wearables(&self) -> bool {
            self.include_wearables.is_some()
        }

        // Param is passed by value, moved
        pub fn set_include_wearables(&mut self, v: bool) {
            self.include_wearables = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control_point",
                |m: &UpdateParticleEnt| { &m.control_point },
                |m: &mut UpdateParticleEnt| { &mut m.control_point },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_handle",
                |m: &UpdateParticleEnt| { &m.entity_handle },
                |m: &mut UpdateParticleEnt| { &mut m.entity_handle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "attach_type",
                |m: &UpdateParticleEnt| { &m.attach_type },
                |m: &mut UpdateParticleEnt| { &mut m.attach_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "attachment",
                |m: &UpdateParticleEnt| { &m.attachment },
                |m: &mut UpdateParticleEnt| { &mut m.attachment },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "fallback_position",
                |m: &UpdateParticleEnt| { &m.fallback_position },
                |m: &mut UpdateParticleEnt| { &mut m.fallback_position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "include_wearables",
                |m: &UpdateParticleEnt| { &m.include_wearables },
                |m: &mut UpdateParticleEnt| { &mut m.include_wearables },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "offset_position",
                |m: &UpdateParticleEnt| { &m.offset_position },
                |m: &mut UpdateParticleEnt| { &mut m.offset_position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgQAngle>(
                "offset_angles",
                |m: &UpdateParticleEnt| { &m.offset_angles },
                |m: &mut UpdateParticleEnt| { &mut m.offset_angles },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateParticleEnt>(
                "CUserMsg_ParticleManager.UpdateParticleEnt",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UpdateParticleEnt {
        const NAME: &'static str = "UpdateParticleEnt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.attach_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.attachment = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.fallback_position)?;
                    },
                    48 => {
                        self.include_wearables = ::std::option::Option::Some(is.read_bool()?);
                    },
                    58 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.offset_position)?;
                    },
                    66 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.offset_angles)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.entity_handle {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.attach_type {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.attachment {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.fallback_position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.include_wearables {
                my_size += 1 + 1;
            }
            if let Some(v) = self.offset_position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.offset_angles.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.attach_type {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.attachment {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.fallback_position.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.include_wearables {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.offset_position.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if let Some(v) = self.offset_angles.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleEnt {
            UpdateParticleEnt::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.attach_type = ::std::option::Option::None;
            self.attachment = ::std::option::Option::None;
            self.fallback_position.clear();
            self.include_wearables = ::std::option::Option::None;
            self.offset_position.clear();
            self.offset_angles.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleEnt {
            static instance: UpdateParticleEnt = UpdateParticleEnt {
                control_point: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                attach_type: ::std::option::Option::None,
                attachment: ::std::option::Option::None,
                fallback_position: ::protobuf::MessageField::none(),
                include_wearables: ::std::option::Option::None,
                offset_position: ::protobuf::MessageField::none(),
                offset_angles: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UpdateParticleEnt {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.UpdateParticleEnt").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateParticleEnt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UpdateParticleEnt {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleSetFrozen)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleSetFrozen {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleSetFrozen.set_frozen)
        pub set_frozen: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleSetFrozen.transition_duration)
        pub transition_duration: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleSetFrozen.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleSetFrozen {
        fn default() -> &'a UpdateParticleSetFrozen {
            <UpdateParticleSetFrozen as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleSetFrozen {
        pub fn new() -> UpdateParticleSetFrozen {
            ::std::default::Default::default()
        }

        // optional bool set_frozen = 1;

        pub fn set_frozen(&self) -> bool {
            self.set_frozen.unwrap_or(false)
        }

        pub fn clear_set_frozen(&mut self) {
            self.set_frozen = ::std::option::Option::None;
        }

        pub fn has_set_frozen(&self) -> bool {
            self.set_frozen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_set_frozen(&mut self, v: bool) {
            self.set_frozen = ::std::option::Option::Some(v);
        }

        // optional float transition_duration = 2;

        pub fn transition_duration(&self) -> f32 {
            self.transition_duration.unwrap_or(0.)
        }

        pub fn clear_transition_duration(&mut self) {
            self.transition_duration = ::std::option::Option::None;
        }

        pub fn has_transition_duration(&self) -> bool {
            self.transition_duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_transition_duration(&mut self, v: f32) {
            self.transition_duration = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "set_frozen",
                |m: &UpdateParticleSetFrozen| { &m.set_frozen },
                |m: &mut UpdateParticleSetFrozen| { &mut m.set_frozen },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "transition_duration",
                |m: &UpdateParticleSetFrozen| { &m.transition_duration },
                |m: &mut UpdateParticleSetFrozen| { &mut m.transition_duration },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateParticleSetFrozen>(
                "CUserMsg_ParticleManager.UpdateParticleSetFrozen",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UpdateParticleSetFrozen {
        const NAME: &'static str = "UpdateParticleSetFrozen";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.set_frozen = ::std::option::Option::Some(is.read_bool()?);
                    },
                    21 => {
                        self.transition_duration = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.set_frozen {
                my_size += 1 + 1;
            }
            if let Some(v) = self.transition_duration {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.set_frozen {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.transition_duration {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleSetFrozen {
            UpdateParticleSetFrozen::new()
        }

        fn clear(&mut self) {
            self.set_frozen = ::std::option::Option::None;
            self.transition_duration = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleSetFrozen {
            static instance: UpdateParticleSetFrozen = UpdateParticleSetFrozen {
                set_frozen: ::std::option::Option::None,
                transition_duration: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UpdateParticleSetFrozen {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.UpdateParticleSetFrozen").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateParticleSetFrozen {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UpdateParticleSetFrozen {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleShouldDraw)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleShouldDraw {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleShouldDraw.should_draw)
        pub should_draw: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleShouldDraw.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleShouldDraw {
        fn default() -> &'a UpdateParticleShouldDraw {
            <UpdateParticleShouldDraw as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleShouldDraw {
        pub fn new() -> UpdateParticleShouldDraw {
            ::std::default::Default::default()
        }

        // optional bool should_draw = 1;

        pub fn should_draw(&self) -> bool {
            self.should_draw.unwrap_or(false)
        }

        pub fn clear_should_draw(&mut self) {
            self.should_draw = ::std::option::Option::None;
        }

        pub fn has_should_draw(&self) -> bool {
            self.should_draw.is_some()
        }

        // Param is passed by value, moved
        pub fn set_should_draw(&mut self, v: bool) {
            self.should_draw = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "should_draw",
                |m: &UpdateParticleShouldDraw| { &m.should_draw },
                |m: &mut UpdateParticleShouldDraw| { &mut m.should_draw },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateParticleShouldDraw>(
                "CUserMsg_ParticleManager.UpdateParticleShouldDraw",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UpdateParticleShouldDraw {
        const NAME: &'static str = "UpdateParticleShouldDraw";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.should_draw = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.should_draw {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.should_draw {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleShouldDraw {
            UpdateParticleShouldDraw::new()
        }

        fn clear(&mut self) {
            self.should_draw = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleShouldDraw {
            static instance: UpdateParticleShouldDraw = UpdateParticleShouldDraw {
                should_draw: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UpdateParticleShouldDraw {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.UpdateParticleShouldDraw").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateParticleShouldDraw {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UpdateParticleShouldDraw {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ChangeControlPointAttachment)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChangeControlPointAttachment {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ChangeControlPointAttachment.attachment_old)
        pub attachment_old: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ChangeControlPointAttachment.attachment_new)
        pub attachment_new: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ChangeControlPointAttachment.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ChangeControlPointAttachment.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChangeControlPointAttachment {
        fn default() -> &'a ChangeControlPointAttachment {
            <ChangeControlPointAttachment as ::protobuf::Message>::default_instance()
        }
    }

    impl ChangeControlPointAttachment {
        pub fn new() -> ChangeControlPointAttachment {
            ::std::default::Default::default()
        }

        // optional int32 attachment_old = 1;

        pub fn attachment_old(&self) -> i32 {
            self.attachment_old.unwrap_or(0)
        }

        pub fn clear_attachment_old(&mut self) {
            self.attachment_old = ::std::option::Option::None;
        }

        pub fn has_attachment_old(&self) -> bool {
            self.attachment_old.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attachment_old(&mut self, v: i32) {
            self.attachment_old = ::std::option::Option::Some(v);
        }

        // optional int32 attachment_new = 2;

        pub fn attachment_new(&self) -> i32 {
            self.attachment_new.unwrap_or(0)
        }

        pub fn clear_attachment_new(&mut self) {
            self.attachment_new = ::std::option::Option::None;
        }

        pub fn has_attachment_new(&self) -> bool {
            self.attachment_new.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attachment_new(&mut self, v: i32) {
            self.attachment_new = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 3;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "attachment_old",
                |m: &ChangeControlPointAttachment| { &m.attachment_old },
                |m: &mut ChangeControlPointAttachment| { &mut m.attachment_old },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "attachment_new",
                |m: &ChangeControlPointAttachment| { &m.attachment_new },
                |m: &mut ChangeControlPointAttachment| { &mut m.attachment_new },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_handle",
                |m: &ChangeControlPointAttachment| { &m.entity_handle },
                |m: &mut ChangeControlPointAttachment| { &mut m.entity_handle },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChangeControlPointAttachment>(
                "CUserMsg_ParticleManager.ChangeControlPointAttachment",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ChangeControlPointAttachment {
        const NAME: &'static str = "ChangeControlPointAttachment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.attachment_old = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.attachment_new = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.attachment_old {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.attachment_new {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.entity_handle {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.attachment_old {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.attachment_new {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChangeControlPointAttachment {
            ChangeControlPointAttachment::new()
        }

        fn clear(&mut self) {
            self.attachment_old = ::std::option::Option::None;
            self.attachment_new = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChangeControlPointAttachment {
            static instance: ChangeControlPointAttachment = ChangeControlPointAttachment {
                attachment_old: ::std::option::Option::None,
                attachment_new: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ChangeControlPointAttachment {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.ChangeControlPointAttachment").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChangeControlPointAttachment {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ChangeControlPointAttachment {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateEntityPosition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateEntityPosition {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateEntityPosition.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateEntityPosition.position)
        pub position: ::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateEntityPosition.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateEntityPosition {
        fn default() -> &'a UpdateEntityPosition {
            <UpdateEntityPosition as ::protobuf::Message>::default_instance()
        }
    }

    impl UpdateEntityPosition {
        pub fn new() -> UpdateEntityPosition {
            ::std::default::Default::default()
        }

        // optional uint32 entity_handle = 1;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_handle",
                |m: &UpdateEntityPosition| { &m.entity_handle },
                |m: &mut UpdateEntityPosition| { &mut m.entity_handle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::networkbasetypes::CMsgVector>(
                "position",
                |m: &UpdateEntityPosition| { &m.position },
                |m: &mut UpdateEntityPosition| { &mut m.position },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateEntityPosition>(
                "CUserMsg_ParticleManager.UpdateEntityPosition",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for UpdateEntityPosition {
        const NAME: &'static str = "UpdateEntityPosition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entity_handle {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.entity_handle {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateEntityPosition {
            UpdateEntityPosition::new()
        }

        fn clear(&mut self) {
            self.entity_handle = ::std::option::Option::None;
            self.position.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateEntityPosition {
            static instance: UpdateEntityPosition = UpdateEntityPosition {
                entity_handle: ::std::option::Option::None,
                position: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for UpdateEntityPosition {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.UpdateEntityPosition").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateEntityPosition {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for UpdateEntityPosition {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleFoWProperties)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetParticleFoWProperties {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleFoWProperties.fow_control_point)
        pub fow_control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleFoWProperties.fow_control_point2)
        pub fow_control_point2: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleFoWProperties.fow_radius)
        pub fow_radius: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleFoWProperties.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetParticleFoWProperties {
        fn default() -> &'a SetParticleFoWProperties {
            <SetParticleFoWProperties as ::protobuf::Message>::default_instance()
        }
    }

    impl SetParticleFoWProperties {
        pub fn new() -> SetParticleFoWProperties {
            ::std::default::Default::default()
        }

        // optional int32 fow_control_point = 1;

        pub fn fow_control_point(&self) -> i32 {
            self.fow_control_point.unwrap_or(0)
        }

        pub fn clear_fow_control_point(&mut self) {
            self.fow_control_point = ::std::option::Option::None;
        }

        pub fn has_fow_control_point(&self) -> bool {
            self.fow_control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fow_control_point(&mut self, v: i32) {
            self.fow_control_point = ::std::option::Option::Some(v);
        }

        // optional int32 fow_control_point2 = 2;

        pub fn fow_control_point2(&self) -> i32 {
            self.fow_control_point2.unwrap_or(0)
        }

        pub fn clear_fow_control_point2(&mut self) {
            self.fow_control_point2 = ::std::option::Option::None;
        }

        pub fn has_fow_control_point2(&self) -> bool {
            self.fow_control_point2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fow_control_point2(&mut self, v: i32) {
            self.fow_control_point2 = ::std::option::Option::Some(v);
        }

        // optional float fow_radius = 3;

        pub fn fow_radius(&self) -> f32 {
            self.fow_radius.unwrap_or(0.)
        }

        pub fn clear_fow_radius(&mut self) {
            self.fow_radius = ::std::option::Option::None;
        }

        pub fn has_fow_radius(&self) -> bool {
            self.fow_radius.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fow_radius(&mut self, v: f32) {
            self.fow_radius = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fow_control_point",
                |m: &SetParticleFoWProperties| { &m.fow_control_point },
                |m: &mut SetParticleFoWProperties| { &mut m.fow_control_point },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fow_control_point2",
                |m: &SetParticleFoWProperties| { &m.fow_control_point2 },
                |m: &mut SetParticleFoWProperties| { &mut m.fow_control_point2 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "fow_radius",
                |m: &SetParticleFoWProperties| { &m.fow_radius },
                |m: &mut SetParticleFoWProperties| { &mut m.fow_radius },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetParticleFoWProperties>(
                "CUserMsg_ParticleManager.SetParticleFoWProperties",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetParticleFoWProperties {
        const NAME: &'static str = "SetParticleFoWProperties";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.fow_control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.fow_control_point2 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    29 => {
                        self.fow_radius = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.fow_control_point {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.fow_control_point2 {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.fow_radius {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.fow_control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.fow_control_point2 {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.fow_radius {
                os.write_float(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetParticleFoWProperties {
            SetParticleFoWProperties::new()
        }

        fn clear(&mut self) {
            self.fow_control_point = ::std::option::Option::None;
            self.fow_control_point2 = ::std::option::Option::None;
            self.fow_radius = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetParticleFoWProperties {
            static instance: SetParticleFoWProperties = SetParticleFoWProperties {
                fow_control_point: ::std::option::Option::None,
                fow_control_point2: ::std::option::Option::None,
                fow_radius: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetParticleFoWProperties {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetParticleFoWProperties").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetParticleFoWProperties {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetParticleFoWProperties {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleShouldCheckFoW)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetParticleShouldCheckFoW {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleShouldCheckFoW.check_fow)
        pub check_fow: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleShouldCheckFoW.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetParticleShouldCheckFoW {
        fn default() -> &'a SetParticleShouldCheckFoW {
            <SetParticleShouldCheckFoW as ::protobuf::Message>::default_instance()
        }
    }

    impl SetParticleShouldCheckFoW {
        pub fn new() -> SetParticleShouldCheckFoW {
            ::std::default::Default::default()
        }

        // optional bool check_fow = 1;

        pub fn check_fow(&self) -> bool {
            self.check_fow.unwrap_or(false)
        }

        pub fn clear_check_fow(&mut self) {
            self.check_fow = ::std::option::Option::None;
        }

        pub fn has_check_fow(&self) -> bool {
            self.check_fow.is_some()
        }

        // Param is passed by value, moved
        pub fn set_check_fow(&mut self, v: bool) {
            self.check_fow = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "check_fow",
                |m: &SetParticleShouldCheckFoW| { &m.check_fow },
                |m: &mut SetParticleShouldCheckFoW| { &mut m.check_fow },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetParticleShouldCheckFoW>(
                "CUserMsg_ParticleManager.SetParticleShouldCheckFoW",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetParticleShouldCheckFoW {
        const NAME: &'static str = "SetParticleShouldCheckFoW";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.check_fow = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.check_fow {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.check_fow {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetParticleShouldCheckFoW {
            SetParticleShouldCheckFoW::new()
        }

        fn clear(&mut self) {
            self.check_fow = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetParticleShouldCheckFoW {
            static instance: SetParticleShouldCheckFoW = SetParticleShouldCheckFoW {
                check_fow: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetParticleShouldCheckFoW {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetParticleShouldCheckFoW").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetParticleShouldCheckFoW {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetParticleShouldCheckFoW {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetControlPointModel)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetControlPointModel {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetControlPointModel.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetControlPointModel.model_name)
        pub model_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetControlPointModel.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetControlPointModel {
        fn default() -> &'a SetControlPointModel {
            <SetControlPointModel as ::protobuf::Message>::default_instance()
        }
    }

    impl SetControlPointModel {
        pub fn new() -> SetControlPointModel {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        // optional string model_name = 2;

        pub fn model_name(&self) -> &str {
            match self.model_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_model_name(&mut self) {
            self.model_name = ::std::option::Option::None;
        }

        pub fn has_model_name(&self) -> bool {
            self.model_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_model_name(&mut self, v: ::std::string::String) {
            self.model_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_model_name(&mut self) -> &mut ::std::string::String {
            if self.model_name.is_none() {
                self.model_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.model_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_model_name(&mut self) -> ::std::string::String {
            self.model_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control_point",
                |m: &SetControlPointModel| { &m.control_point },
                |m: &mut SetControlPointModel| { &mut m.control_point },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "model_name",
                |m: &SetControlPointModel| { &m.model_name },
                |m: &mut SetControlPointModel| { &mut m.model_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetControlPointModel>(
                "CUserMsg_ParticleManager.SetControlPointModel",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetControlPointModel {
        const NAME: &'static str = "SetControlPointModel";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.model_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.model_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.model_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetControlPointModel {
            SetControlPointModel::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.model_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetControlPointModel {
            static instance: SetControlPointModel = SetControlPointModel {
                control_point: ::std::option::Option::None,
                model_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetControlPointModel {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetControlPointModel").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetControlPointModel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetControlPointModel {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetControlPointSnapshot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetControlPointSnapshot {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetControlPointSnapshot.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetControlPointSnapshot.snapshot_name)
        pub snapshot_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetControlPointSnapshot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetControlPointSnapshot {
        fn default() -> &'a SetControlPointSnapshot {
            <SetControlPointSnapshot as ::protobuf::Message>::default_instance()
        }
    }

    impl SetControlPointSnapshot {
        pub fn new() -> SetControlPointSnapshot {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        // optional string snapshot_name = 2;

        pub fn snapshot_name(&self) -> &str {
            match self.snapshot_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_snapshot_name(&mut self) {
            self.snapshot_name = ::std::option::Option::None;
        }

        pub fn has_snapshot_name(&self) -> bool {
            self.snapshot_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_snapshot_name(&mut self, v: ::std::string::String) {
            self.snapshot_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_snapshot_name(&mut self) -> &mut ::std::string::String {
            if self.snapshot_name.is_none() {
                self.snapshot_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.snapshot_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_snapshot_name(&mut self) -> ::std::string::String {
            self.snapshot_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control_point",
                |m: &SetControlPointSnapshot| { &m.control_point },
                |m: &mut SetControlPointSnapshot| { &mut m.control_point },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "snapshot_name",
                |m: &SetControlPointSnapshot| { &m.snapshot_name },
                |m: &mut SetControlPointSnapshot| { &mut m.snapshot_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetControlPointSnapshot>(
                "CUserMsg_ParticleManager.SetControlPointSnapshot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetControlPointSnapshot {
        const NAME: &'static str = "SetControlPointSnapshot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.snapshot_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.snapshot_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.snapshot_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetControlPointSnapshot {
            SetControlPointSnapshot::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.snapshot_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetControlPointSnapshot {
            static instance: SetControlPointSnapshot = SetControlPointSnapshot {
                control_point: ::std::option::Option::None,
                snapshot_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetControlPointSnapshot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetControlPointSnapshot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetControlPointSnapshot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetControlPointSnapshot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleText)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetParticleText {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleText.text)
        pub text: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleText.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetParticleText {
        fn default() -> &'a SetParticleText {
            <SetParticleText as ::protobuf::Message>::default_instance()
        }
    }

    impl SetParticleText {
        pub fn new() -> SetParticleText {
            ::std::default::Default::default()
        }

        // optional string text = 1;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "text",
                |m: &SetParticleText| { &m.text },
                |m: &mut SetParticleText| { &mut m.text },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetParticleText>(
                "CUserMsg_ParticleManager.SetParticleText",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetParticleText {
        const NAME: &'static str = "SetParticleText";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.text.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.text.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetParticleText {
            SetParticleText::new()
        }

        fn clear(&mut self) {
            self.text = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetParticleText {
            static instance: SetParticleText = SetParticleText {
                text: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetParticleText {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetParticleText").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetParticleText {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetParticleText {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetTextureAttribute)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetTextureAttribute {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetTextureAttribute.attribute_name)
        pub attribute_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetTextureAttribute.texture_name)
        pub texture_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetTextureAttribute.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetTextureAttribute {
        fn default() -> &'a SetTextureAttribute {
            <SetTextureAttribute as ::protobuf::Message>::default_instance()
        }
    }

    impl SetTextureAttribute {
        pub fn new() -> SetTextureAttribute {
            ::std::default::Default::default()
        }

        // optional string attribute_name = 1;

        pub fn attribute_name(&self) -> &str {
            match self.attribute_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_attribute_name(&mut self) {
            self.attribute_name = ::std::option::Option::None;
        }

        pub fn has_attribute_name(&self) -> bool {
            self.attribute_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attribute_name(&mut self, v: ::std::string::String) {
            self.attribute_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_attribute_name(&mut self) -> &mut ::std::string::String {
            if self.attribute_name.is_none() {
                self.attribute_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.attribute_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_attribute_name(&mut self) -> ::std::string::String {
            self.attribute_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string texture_name = 2;

        pub fn texture_name(&self) -> &str {
            match self.texture_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_texture_name(&mut self) {
            self.texture_name = ::std::option::Option::None;
        }

        pub fn has_texture_name(&self) -> bool {
            self.texture_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_texture_name(&mut self, v: ::std::string::String) {
            self.texture_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_texture_name(&mut self) -> &mut ::std::string::String {
            if self.texture_name.is_none() {
                self.texture_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.texture_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_texture_name(&mut self) -> ::std::string::String {
            self.texture_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "attribute_name",
                |m: &SetTextureAttribute| { &m.attribute_name },
                |m: &mut SetTextureAttribute| { &mut m.attribute_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "texture_name",
                |m: &SetTextureAttribute| { &m.texture_name },
                |m: &mut SetTextureAttribute| { &mut m.texture_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetTextureAttribute>(
                "CUserMsg_ParticleManager.SetTextureAttribute",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetTextureAttribute {
        const NAME: &'static str = "SetTextureAttribute";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.attribute_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.texture_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.attribute_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.texture_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.attribute_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.texture_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetTextureAttribute {
            SetTextureAttribute::new()
        }

        fn clear(&mut self) {
            self.attribute_name = ::std::option::Option::None;
            self.texture_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetTextureAttribute {
            static instance: SetTextureAttribute = SetTextureAttribute {
                attribute_name: ::std::option::Option::None,
                texture_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetTextureAttribute {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetTextureAttribute").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetTextureAttribute {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetTextureAttribute {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetSceneObjectGenericFlag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetSceneObjectGenericFlag {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetSceneObjectGenericFlag.flag_value)
        pub flag_value: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetSceneObjectGenericFlag.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetSceneObjectGenericFlag {
        fn default() -> &'a SetSceneObjectGenericFlag {
            <SetSceneObjectGenericFlag as ::protobuf::Message>::default_instance()
        }
    }

    impl SetSceneObjectGenericFlag {
        pub fn new() -> SetSceneObjectGenericFlag {
            ::std::default::Default::default()
        }

        // optional bool flag_value = 1;

        pub fn flag_value(&self) -> bool {
            self.flag_value.unwrap_or(false)
        }

        pub fn clear_flag_value(&mut self) {
            self.flag_value = ::std::option::Option::None;
        }

        pub fn has_flag_value(&self) -> bool {
            self.flag_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flag_value(&mut self, v: bool) {
            self.flag_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flag_value",
                |m: &SetSceneObjectGenericFlag| { &m.flag_value },
                |m: &mut SetSceneObjectGenericFlag| { &mut m.flag_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetSceneObjectGenericFlag>(
                "CUserMsg_ParticleManager.SetSceneObjectGenericFlag",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetSceneObjectGenericFlag {
        const NAME: &'static str = "SetSceneObjectGenericFlag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.flag_value = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.flag_value {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.flag_value {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetSceneObjectGenericFlag {
            SetSceneObjectGenericFlag::new()
        }

        fn clear(&mut self) {
            self.flag_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetSceneObjectGenericFlag {
            static instance: SetSceneObjectGenericFlag = SetSceneObjectGenericFlag {
                flag_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetSceneObjectGenericFlag {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetSceneObjectGenericFlag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetSceneObjectGenericFlag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetSceneObjectGenericFlag {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetSceneObjectTintAndDesat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetSceneObjectTintAndDesat {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.tint)
        pub tint: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.desat)
        pub desat: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetSceneObjectTintAndDesat {
        fn default() -> &'a SetSceneObjectTintAndDesat {
            <SetSceneObjectTintAndDesat as ::protobuf::Message>::default_instance()
        }
    }

    impl SetSceneObjectTintAndDesat {
        pub fn new() -> SetSceneObjectTintAndDesat {
            ::std::default::Default::default()
        }

        // optional fixed32 tint = 1;

        pub fn tint(&self) -> u32 {
            self.tint.unwrap_or(0)
        }

        pub fn clear_tint(&mut self) {
            self.tint = ::std::option::Option::None;
        }

        pub fn has_tint(&self) -> bool {
            self.tint.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tint(&mut self, v: u32) {
            self.tint = ::std::option::Option::Some(v);
        }

        // optional float desat = 2;

        pub fn desat(&self) -> f32 {
            self.desat.unwrap_or(0.)
        }

        pub fn clear_desat(&mut self) {
            self.desat = ::std::option::Option::None;
        }

        pub fn has_desat(&self) -> bool {
            self.desat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_desat(&mut self, v: f32) {
            self.desat = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tint",
                |m: &SetSceneObjectTintAndDesat| { &m.tint },
                |m: &mut SetSceneObjectTintAndDesat| { &mut m.tint },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "desat",
                |m: &SetSceneObjectTintAndDesat| { &m.desat },
                |m: &mut SetSceneObjectTintAndDesat| { &mut m.desat },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetSceneObjectTintAndDesat>(
                "CUserMsg_ParticleManager.SetSceneObjectTintAndDesat",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetSceneObjectTintAndDesat {
        const NAME: &'static str = "SetSceneObjectTintAndDesat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.tint = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    21 => {
                        self.desat = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tint {
                my_size += 1 + 4;
            }
            if let Some(v) = self.desat {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tint {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.desat {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetSceneObjectTintAndDesat {
            SetSceneObjectTintAndDesat::new()
        }

        fn clear(&mut self) {
            self.tint = ::std::option::Option::None;
            self.desat = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetSceneObjectTintAndDesat {
            static instance: SetSceneObjectTintAndDesat = SetSceneObjectTintAndDesat {
                tint: ::std::option::Option::None,
                desat: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetSceneObjectTintAndDesat {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetSceneObjectTintAndDesat").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetSceneObjectTintAndDesat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetSceneObjectTintAndDesat {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ParticleSkipToTime)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ParticleSkipToTime {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ParticleSkipToTime.skip_to_time)
        pub skip_to_time: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ParticleSkipToTime.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ParticleSkipToTime {
        fn default() -> &'a ParticleSkipToTime {
            <ParticleSkipToTime as ::protobuf::Message>::default_instance()
        }
    }

    impl ParticleSkipToTime {
        pub fn new() -> ParticleSkipToTime {
            ::std::default::Default::default()
        }

        // optional float skip_to_time = 1;

        pub fn skip_to_time(&self) -> f32 {
            self.skip_to_time.unwrap_or(0.)
        }

        pub fn clear_skip_to_time(&mut self) {
            self.skip_to_time = ::std::option::Option::None;
        }

        pub fn has_skip_to_time(&self) -> bool {
            self.skip_to_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_skip_to_time(&mut self, v: f32) {
            self.skip_to_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "skip_to_time",
                |m: &ParticleSkipToTime| { &m.skip_to_time },
                |m: &mut ParticleSkipToTime| { &mut m.skip_to_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParticleSkipToTime>(
                "CUserMsg_ParticleManager.ParticleSkipToTime",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ParticleSkipToTime {
        const NAME: &'static str = "ParticleSkipToTime";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.skip_to_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.skip_to_time {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.skip_to_time {
                os.write_float(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ParticleSkipToTime {
            ParticleSkipToTime::new()
        }

        fn clear(&mut self) {
            self.skip_to_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ParticleSkipToTime {
            static instance: ParticleSkipToTime = ParticleSkipToTime {
                skip_to_time: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ParticleSkipToTime {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.ParticleSkipToTime").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ParticleSkipToTime {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ParticleSkipToTime {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ParticleCanFreeze)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ParticleCanFreeze {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ParticleCanFreeze.can_freeze)
        pub can_freeze: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ParticleCanFreeze.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ParticleCanFreeze {
        fn default() -> &'a ParticleCanFreeze {
            <ParticleCanFreeze as ::protobuf::Message>::default_instance()
        }
    }

    impl ParticleCanFreeze {
        pub fn new() -> ParticleCanFreeze {
            ::std::default::Default::default()
        }

        // optional bool can_freeze = 1;

        pub fn can_freeze(&self) -> bool {
            self.can_freeze.unwrap_or(false)
        }

        pub fn clear_can_freeze(&mut self) {
            self.can_freeze = ::std::option::Option::None;
        }

        pub fn has_can_freeze(&self) -> bool {
            self.can_freeze.is_some()
        }

        // Param is passed by value, moved
        pub fn set_can_freeze(&mut self, v: bool) {
            self.can_freeze = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "can_freeze",
                |m: &ParticleCanFreeze| { &m.can_freeze },
                |m: &mut ParticleCanFreeze| { &mut m.can_freeze },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParticleCanFreeze>(
                "CUserMsg_ParticleManager.ParticleCanFreeze",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ParticleCanFreeze {
        const NAME: &'static str = "ParticleCanFreeze";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.can_freeze = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.can_freeze {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.can_freeze {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ParticleCanFreeze {
            ParticleCanFreeze::new()
        }

        fn clear(&mut self) {
            self.can_freeze = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ParticleCanFreeze {
            static instance: ParticleCanFreeze = ParticleCanFreeze {
                can_freeze: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ParticleCanFreeze {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.ParticleCanFreeze").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ParticleCanFreeze {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ParticleCanFreeze {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ParticleFreezeTransitionOverride)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ParticleFreezeTransitionOverride {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.freeze_transition_override)
        pub freeze_transition_override: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ParticleFreezeTransitionOverride {
        fn default() -> &'a ParticleFreezeTransitionOverride {
            <ParticleFreezeTransitionOverride as ::protobuf::Message>::default_instance()
        }
    }

    impl ParticleFreezeTransitionOverride {
        pub fn new() -> ParticleFreezeTransitionOverride {
            ::std::default::Default::default()
        }

        // optional float freeze_transition_override = 1;

        pub fn freeze_transition_override(&self) -> f32 {
            self.freeze_transition_override.unwrap_or(0.)
        }

        pub fn clear_freeze_transition_override(&mut self) {
            self.freeze_transition_override = ::std::option::Option::None;
        }

        pub fn has_freeze_transition_override(&self) -> bool {
            self.freeze_transition_override.is_some()
        }

        // Param is passed by value, moved
        pub fn set_freeze_transition_override(&mut self, v: f32) {
            self.freeze_transition_override = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "freeze_transition_override",
                |m: &ParticleFreezeTransitionOverride| { &m.freeze_transition_override },
                |m: &mut ParticleFreezeTransitionOverride| { &mut m.freeze_transition_override },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ParticleFreezeTransitionOverride>(
                "CUserMsg_ParticleManager.ParticleFreezeTransitionOverride",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ParticleFreezeTransitionOverride {
        const NAME: &'static str = "ParticleFreezeTransitionOverride";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.freeze_transition_override = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.freeze_transition_override {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.freeze_transition_override {
                os.write_float(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ParticleFreezeTransitionOverride {
            ParticleFreezeTransitionOverride::new()
        }

        fn clear(&mut self) {
            self.freeze_transition_override = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ParticleFreezeTransitionOverride {
            static instance: ParticleFreezeTransitionOverride = ParticleFreezeTransitionOverride {
                freeze_transition_override: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ParticleFreezeTransitionOverride {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.ParticleFreezeTransitionOverride").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ParticleFreezeTransitionOverride {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ParticleFreezeTransitionOverride {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.FreezeParticleInvolving)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FreezeParticleInvolving {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.FreezeParticleInvolving.set_frozen)
        pub set_frozen: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.FreezeParticleInvolving.transition_duration)
        pub transition_duration: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.FreezeParticleInvolving.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.FreezeParticleInvolving.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FreezeParticleInvolving {
        fn default() -> &'a FreezeParticleInvolving {
            <FreezeParticleInvolving as ::protobuf::Message>::default_instance()
        }
    }

    impl FreezeParticleInvolving {
        pub fn new() -> FreezeParticleInvolving {
            ::std::default::Default::default()
        }

        // optional bool set_frozen = 1;

        pub fn set_frozen(&self) -> bool {
            self.set_frozen.unwrap_or(false)
        }

        pub fn clear_set_frozen(&mut self) {
            self.set_frozen = ::std::option::Option::None;
        }

        pub fn has_set_frozen(&self) -> bool {
            self.set_frozen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_set_frozen(&mut self, v: bool) {
            self.set_frozen = ::std::option::Option::Some(v);
        }

        // optional float transition_duration = 2;

        pub fn transition_duration(&self) -> f32 {
            self.transition_duration.unwrap_or(0.)
        }

        pub fn clear_transition_duration(&mut self) {
            self.transition_duration = ::std::option::Option::None;
        }

        pub fn has_transition_duration(&self) -> bool {
            self.transition_duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_transition_duration(&mut self, v: f32) {
            self.transition_duration = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 3;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "set_frozen",
                |m: &FreezeParticleInvolving| { &m.set_frozen },
                |m: &mut FreezeParticleInvolving| { &mut m.set_frozen },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "transition_duration",
                |m: &FreezeParticleInvolving| { &m.transition_duration },
                |m: &mut FreezeParticleInvolving| { &mut m.transition_duration },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_handle",
                |m: &FreezeParticleInvolving| { &m.entity_handle },
                |m: &mut FreezeParticleInvolving| { &mut m.entity_handle },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FreezeParticleInvolving>(
                "CUserMsg_ParticleManager.FreezeParticleInvolving",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FreezeParticleInvolving {
        const NAME: &'static str = "FreezeParticleInvolving";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.set_frozen = ::std::option::Option::Some(is.read_bool()?);
                    },
                    21 => {
                        self.transition_duration = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.set_frozen {
                my_size += 1 + 1;
            }
            if let Some(v) = self.transition_duration {
                my_size += 1 + 4;
            }
            if let Some(v) = self.entity_handle {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.set_frozen {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.transition_duration {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FreezeParticleInvolving {
            FreezeParticleInvolving::new()
        }

        fn clear(&mut self) {
            self.set_frozen = ::std::option::Option::None;
            self.transition_duration = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FreezeParticleInvolving {
            static instance: FreezeParticleInvolving = FreezeParticleInvolving {
                set_frozen: ::std::option::Option::None,
                transition_duration: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FreezeParticleInvolving {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.FreezeParticleInvolving").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FreezeParticleInvolving {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FreezeParticleInvolving {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleNamedValueContext)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetParticleNamedValueContext {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.float_values)
        pub float_values: ::std::vec::Vec<set_particle_named_value_context::FloatContextValue>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.vector_values)
        pub vector_values: ::std::vec::Vec<set_particle_named_value_context::VectorContextValue>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.transform_values)
        pub transform_values: ::std::vec::Vec<set_particle_named_value_context::TransformContextValue>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.ehandle_values)
        pub ehandle_values: ::std::vec::Vec<set_particle_named_value_context::EHandleContext>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleNamedValueContext.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetParticleNamedValueContext {
        fn default() -> &'a SetParticleNamedValueContext {
            <SetParticleNamedValueContext as ::protobuf::Message>::default_instance()
        }
    }

    impl SetParticleNamedValueContext {
        pub fn new() -> SetParticleNamedValueContext {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "float_values",
                |m: &SetParticleNamedValueContext| { &m.float_values },
                |m: &mut SetParticleNamedValueContext| { &mut m.float_values },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "vector_values",
                |m: &SetParticleNamedValueContext| { &m.vector_values },
                |m: &mut SetParticleNamedValueContext| { &mut m.vector_values },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "transform_values",
                |m: &SetParticleNamedValueContext| { &m.transform_values },
                |m: &mut SetParticleNamedValueContext| { &mut m.transform_values },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "ehandle_values",
                |m: &SetParticleNamedValueContext| { &m.ehandle_values },
                |m: &mut SetParticleNamedValueContext| { &mut m.ehandle_values },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SetParticleNamedValueContext>(
                "CUserMsg_ParticleManager.SetParticleNamedValueContext",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SetParticleNamedValueContext {
        const NAME: &'static str = "SetParticleNamedValueContext";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.float_values.push(is.read_message()?);
                    },
                    18 => {
                        self.vector_values.push(is.read_message()?);
                    },
                    26 => {
                        self.transform_values.push(is.read_message()?);
                    },
                    34 => {
                        self.ehandle_values.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.float_values {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.vector_values {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.transform_values {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.ehandle_values {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.float_values {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for v in &self.vector_values {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.transform_values {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.ehandle_values {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetParticleNamedValueContext {
            SetParticleNamedValueContext::new()
        }

        fn clear(&mut self) {
            self.float_values.clear();
            self.vector_values.clear();
            self.transform_values.clear();
            self.ehandle_values.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetParticleNamedValueContext {
            static instance: SetParticleNamedValueContext = SetParticleNamedValueContext {
                float_values: ::std::vec::Vec::new(),
                vector_values: ::std::vec::Vec::new(),
                transform_values: ::std::vec::Vec::new(),
                ehandle_values: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SetParticleNamedValueContext {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetParticleNamedValueContext").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SetParticleNamedValueContext {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SetParticleNamedValueContext {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `SetParticleNamedValueContext`
    pub mod set_particle_named_value_context {
        // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct FloatContextValue {
            // message fields
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.value_name_hash)
            pub value_name_hash: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.value)
            pub value: ::std::option::Option<f32>,
            // special fields
            // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a FloatContextValue {
            fn default() -> &'a FloatContextValue {
                <FloatContextValue as ::protobuf::Message>::default_instance()
            }
        }

        impl FloatContextValue {
            pub fn new() -> FloatContextValue {
                ::std::default::Default::default()
            }

            // optional uint32 value_name_hash = 1;

            pub fn value_name_hash(&self) -> u32 {
                self.value_name_hash.unwrap_or(0)
            }

            pub fn clear_value_name_hash(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
            }

            pub fn has_value_name_hash(&self) -> bool {
                self.value_name_hash.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_name_hash(&mut self, v: u32) {
                self.value_name_hash = ::std::option::Option::Some(v);
            }

            // optional float value = 2;

            pub fn value(&self) -> f32 {
                self.value.unwrap_or(0.)
            }

            pub fn clear_value(&mut self) {
                self.value = ::std::option::Option::None;
            }

            pub fn has_value(&self) -> bool {
                self.value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: f32) {
                self.value = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value_name_hash",
                    |m: &FloatContextValue| { &m.value_name_hash },
                    |m: &mut FloatContextValue| { &mut m.value_name_hash },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value",
                    |m: &FloatContextValue| { &m.value },
                    |m: &mut FloatContextValue| { &mut m.value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FloatContextValue>(
                    "CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for FloatContextValue {
            const NAME: &'static str = "FloatContextValue";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.value_name_hash = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        21 => {
                            self.value = ::std::option::Option::Some(is.read_float()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.value_name_hash {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.value {
                    my_size += 1 + 4;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.value_name_hash {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.value {
                    os.write_float(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> FloatContextValue {
                FloatContextValue::new()
            }

            fn clear(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
                self.value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static FloatContextValue {
                static instance: FloatContextValue = FloatContextValue {
                    value_name_hash: ::std::option::Option::None,
                    value: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for FloatContextValue {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for FloatContextValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for FloatContextValue {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct VectorContextValue {
            // message fields
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.value_name_hash)
            pub value_name_hash: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.value)
            pub value: ::protobuf::MessageField<super::super::super::networkbasetypes::CMsgVector>,
            // special fields
            // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a VectorContextValue {
            fn default() -> &'a VectorContextValue {
                <VectorContextValue as ::protobuf::Message>::default_instance()
            }
        }

        impl VectorContextValue {
            pub fn new() -> VectorContextValue {
                ::std::default::Default::default()
            }

            // optional uint32 value_name_hash = 1;

            pub fn value_name_hash(&self) -> u32 {
                self.value_name_hash.unwrap_or(0)
            }

            pub fn clear_value_name_hash(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
            }

            pub fn has_value_name_hash(&self) -> bool {
                self.value_name_hash.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_name_hash(&mut self, v: u32) {
                self.value_name_hash = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value_name_hash",
                    |m: &VectorContextValue| { &m.value_name_hash },
                    |m: &mut VectorContextValue| { &mut m.value_name_hash },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::super::networkbasetypes::CMsgVector>(
                    "value",
                    |m: &VectorContextValue| { &m.value },
                    |m: &mut VectorContextValue| { &mut m.value },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VectorContextValue>(
                    "CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for VectorContextValue {
            const NAME: &'static str = "VectorContextValue";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.value_name_hash = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.value_name_hash {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.value.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.value_name_hash {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.value.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> VectorContextValue {
                VectorContextValue::new()
            }

            fn clear(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
                self.value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static VectorContextValue {
                static instance: VectorContextValue = VectorContextValue {
                    value_name_hash: ::std::option::Option::None,
                    value: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for VectorContextValue {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for VectorContextValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for VectorContextValue {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TransformContextValue {
            // message fields
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.value_name_hash)
            pub value_name_hash: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.angles)
            pub angles: ::protobuf::MessageField<super::super::super::networkbasetypes::CMsgQAngle>,
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.translation)
            pub translation: ::protobuf::MessageField<super::super::super::networkbasetypes::CMsgVector>,
            // special fields
            // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TransformContextValue {
            fn default() -> &'a TransformContextValue {
                <TransformContextValue as ::protobuf::Message>::default_instance()
            }
        }

        impl TransformContextValue {
            pub fn new() -> TransformContextValue {
                ::std::default::Default::default()
            }

            // optional uint32 value_name_hash = 1;

            pub fn value_name_hash(&self) -> u32 {
                self.value_name_hash.unwrap_or(0)
            }

            pub fn clear_value_name_hash(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
            }

            pub fn has_value_name_hash(&self) -> bool {
                self.value_name_hash.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_name_hash(&mut self, v: u32) {
                self.value_name_hash = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value_name_hash",
                    |m: &TransformContextValue| { &m.value_name_hash },
                    |m: &mut TransformContextValue| { &mut m.value_name_hash },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::super::networkbasetypes::CMsgQAngle>(
                    "angles",
                    |m: &TransformContextValue| { &m.angles },
                    |m: &mut TransformContextValue| { &mut m.angles },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::super::super::networkbasetypes::CMsgVector>(
                    "translation",
                    |m: &TransformContextValue| { &m.translation },
                    |m: &mut TransformContextValue| { &mut m.translation },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransformContextValue>(
                    "CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for TransformContextValue {
            const NAME: &'static str = "TransformContextValue";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.value_name_hash = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                        },
                        26 => {
                            ::protobuf::rt::read_singular_message_into_field(is, &mut self.translation)?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.value_name_hash {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.angles.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.translation.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.value_name_hash {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.angles.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                if let Some(v) = self.translation.as_ref() {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TransformContextValue {
                TransformContextValue::new()
            }

            fn clear(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
                self.angles.clear();
                self.translation.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TransformContextValue {
                static instance: TransformContextValue = TransformContextValue {
                    value_name_hash: ::std::option::Option::None,
                    angles: ::protobuf::MessageField::none(),
                    translation: ::protobuf::MessageField::none(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for TransformContextValue {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for TransformContextValue {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for TransformContextValue {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct EHandleContext {
            // message fields
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.value_name_hash)
            pub value_name_hash: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.ent_index)
            pub ent_index: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a EHandleContext {
            fn default() -> &'a EHandleContext {
                <EHandleContext as ::protobuf::Message>::default_instance()
            }
        }

        impl EHandleContext {
            pub fn new() -> EHandleContext {
                ::std::default::Default::default()
            }

            // optional uint32 value_name_hash = 1;

            pub fn value_name_hash(&self) -> u32 {
                self.value_name_hash.unwrap_or(0)
            }

            pub fn clear_value_name_hash(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
            }

            pub fn has_value_name_hash(&self) -> bool {
                self.value_name_hash.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_name_hash(&mut self, v: u32) {
                self.value_name_hash = ::std::option::Option::Some(v);
            }

            // optional uint32 ent_index = 2;

            pub fn ent_index(&self) -> u32 {
                self.ent_index.unwrap_or(16777215u32)
            }

            pub fn clear_ent_index(&mut self) {
                self.ent_index = ::std::option::Option::None;
            }

            pub fn has_ent_index(&self) -> bool {
                self.ent_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ent_index(&mut self, v: u32) {
                self.ent_index = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "value_name_hash",
                    |m: &EHandleContext| { &m.value_name_hash },
                    |m: &mut EHandleContext| { &mut m.value_name_hash },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "ent_index",
                    |m: &EHandleContext| { &m.ent_index },
                    |m: &mut EHandleContext| { &mut m.ent_index },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EHandleContext>(
                    "CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for EHandleContext {
            const NAME: &'static str = "EHandleContext";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.value_name_hash = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.ent_index = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.value_name_hash {
                    my_size += ::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.ent_index {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.value_name_hash {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.ent_index {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> EHandleContext {
                EHandleContext::new()
            }

            fn clear(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
                self.ent_index = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static EHandleContext {
                static instance: EHandleContext = EHandleContext {
                    value_name_hash: ::std::option::Option::None,
                    ent_index: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for EHandleContext {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for EHandleContext {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for EHandleContext {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CUserMsg_HudError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMsg_HudError {
    // message fields
    // @@protoc_insertion_point(field:CUserMsg_HudError.order_id)
    pub order_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMsg_HudError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMsg_HudError {
    fn default() -> &'a CUserMsg_HudError {
        <CUserMsg_HudError as ::protobuf::Message>::default_instance()
    }
}

impl CUserMsg_HudError {
    pub fn new() -> CUserMsg_HudError {
        ::std::default::Default::default()
    }

    // optional int32 order_id = 1;

    pub fn order_id(&self) -> i32 {
        self.order_id.unwrap_or(0)
    }

    pub fn clear_order_id(&mut self) {
        self.order_id = ::std::option::Option::None;
    }

    pub fn has_order_id(&self) -> bool {
        self.order_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_id(&mut self, v: i32) {
        self.order_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "order_id",
            |m: &CUserMsg_HudError| { &m.order_id },
            |m: &mut CUserMsg_HudError| { &mut m.order_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMsg_HudError>(
            "CUserMsg_HudError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMsg_HudError {
    const NAME: &'static str = "CUserMsg_HudError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.order_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMsg_HudError {
        CUserMsg_HudError::new()
    }

    fn clear(&mut self) {
        self.order_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMsg_HudError {
        static instance: CUserMsg_HudError = CUserMsg_HudError {
            order_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMsg_HudError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMsg_HudError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMsg_HudError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMsg_HudError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMsg_CustomGameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMsg_CustomGameEvent {
    // message fields
    // @@protoc_insertion_point(field:CUserMsg_CustomGameEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMsg_CustomGameEvent.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMsg_CustomGameEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMsg_CustomGameEvent {
    fn default() -> &'a CUserMsg_CustomGameEvent {
        <CUserMsg_CustomGameEvent as ::protobuf::Message>::default_instance()
    }
}

impl CUserMsg_CustomGameEvent {
    pub fn new() -> CUserMsg_CustomGameEvent {
        ::std::default::Default::default()
    }

    // optional string event_name = 1;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_name",
            |m: &CUserMsg_CustomGameEvent| { &m.event_name },
            |m: &mut CUserMsg_CustomGameEvent| { &mut m.event_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CUserMsg_CustomGameEvent| { &m.data },
            |m: &mut CUserMsg_CustomGameEvent| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMsg_CustomGameEvent>(
            "CUserMsg_CustomGameEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMsg_CustomGameEvent {
    const NAME: &'static str = "CUserMsg_CustomGameEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMsg_CustomGameEvent {
        CUserMsg_CustomGameEvent::new()
    }

    fn clear(&mut self) {
        self.event_name = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMsg_CustomGameEvent {
        static instance: CUserMsg_CustomGameEvent = CUserMsg_CustomGameEvent {
            event_name: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMsg_CustomGameEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMsg_CustomGameEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMsg_CustomGameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMsg_CustomGameEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageHapticsManagerPulse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageHapticsManagerPulse {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerPulse.hand_id)
    pub hand_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerPulse.effect_amplitude)
    pub effect_amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerPulse.effect_frequency)
    pub effect_frequency: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerPulse.effect_duration)
    pub effect_duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageHapticsManagerPulse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageHapticsManagerPulse {
    fn default() -> &'a CUserMessageHapticsManagerPulse {
        <CUserMessageHapticsManagerPulse as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageHapticsManagerPulse {
    pub fn new() -> CUserMessageHapticsManagerPulse {
        ::std::default::Default::default()
    }

    // optional int32 hand_id = 1;

    pub fn hand_id(&self) -> i32 {
        self.hand_id.unwrap_or(0)
    }

    pub fn clear_hand_id(&mut self) {
        self.hand_id = ::std::option::Option::None;
    }

    pub fn has_hand_id(&self) -> bool {
        self.hand_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hand_id(&mut self, v: i32) {
        self.hand_id = ::std::option::Option::Some(v);
    }

    // optional float effect_amplitude = 2;

    pub fn effect_amplitude(&self) -> f32 {
        self.effect_amplitude.unwrap_or(0.)
    }

    pub fn clear_effect_amplitude(&mut self) {
        self.effect_amplitude = ::std::option::Option::None;
    }

    pub fn has_effect_amplitude(&self) -> bool {
        self.effect_amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_amplitude(&mut self, v: f32) {
        self.effect_amplitude = ::std::option::Option::Some(v);
    }

    // optional float effect_frequency = 3;

    pub fn effect_frequency(&self) -> f32 {
        self.effect_frequency.unwrap_or(0.)
    }

    pub fn clear_effect_frequency(&mut self) {
        self.effect_frequency = ::std::option::Option::None;
    }

    pub fn has_effect_frequency(&self) -> bool {
        self.effect_frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_frequency(&mut self, v: f32) {
        self.effect_frequency = ::std::option::Option::Some(v);
    }

    // optional float effect_duration = 4;

    pub fn effect_duration(&self) -> f32 {
        self.effect_duration.unwrap_or(0.)
    }

    pub fn clear_effect_duration(&mut self) {
        self.effect_duration = ::std::option::Option::None;
    }

    pub fn has_effect_duration(&self) -> bool {
        self.effect_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_duration(&mut self, v: f32) {
        self.effect_duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hand_id",
            |m: &CUserMessageHapticsManagerPulse| { &m.hand_id },
            |m: &mut CUserMessageHapticsManagerPulse| { &mut m.hand_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect_amplitude",
            |m: &CUserMessageHapticsManagerPulse| { &m.effect_amplitude },
            |m: &mut CUserMessageHapticsManagerPulse| { &mut m.effect_amplitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect_frequency",
            |m: &CUserMessageHapticsManagerPulse| { &m.effect_frequency },
            |m: &mut CUserMessageHapticsManagerPulse| { &mut m.effect_frequency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect_duration",
            |m: &CUserMessageHapticsManagerPulse| { &m.effect_duration },
            |m: &mut CUserMessageHapticsManagerPulse| { &mut m.effect_duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageHapticsManagerPulse>(
            "CUserMessageHapticsManagerPulse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageHapticsManagerPulse {
    const NAME: &'static str = "CUserMessageHapticsManagerPulse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hand_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.effect_amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.effect_frequency = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.effect_duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hand_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.effect_amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.effect_frequency {
            my_size += 1 + 4;
        }
        if let Some(v) = self.effect_duration {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hand_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.effect_amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.effect_frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.effect_duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageHapticsManagerPulse {
        CUserMessageHapticsManagerPulse::new()
    }

    fn clear(&mut self) {
        self.hand_id = ::std::option::Option::None;
        self.effect_amplitude = ::std::option::Option::None;
        self.effect_frequency = ::std::option::Option::None;
        self.effect_duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageHapticsManagerPulse {
        static instance: CUserMessageHapticsManagerPulse = CUserMessageHapticsManagerPulse {
            hand_id: ::std::option::Option::None,
            effect_amplitude: ::std::option::Option::None,
            effect_frequency: ::std::option::Option::None,
            effect_duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageHapticsManagerPulse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageHapticsManagerPulse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageHapticsManagerPulse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageHapticsManagerPulse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageHapticsManagerEffect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageHapticsManagerEffect {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerEffect.hand_id)
    pub hand_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerEffect.effect_name_hash_code)
    pub effect_name_hash_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerEffect.effect_scale)
    pub effect_scale: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageHapticsManagerEffect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageHapticsManagerEffect {
    fn default() -> &'a CUserMessageHapticsManagerEffect {
        <CUserMessageHapticsManagerEffect as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageHapticsManagerEffect {
    pub fn new() -> CUserMessageHapticsManagerEffect {
        ::std::default::Default::default()
    }

    // optional int32 hand_id = 1;

    pub fn hand_id(&self) -> i32 {
        self.hand_id.unwrap_or(0)
    }

    pub fn clear_hand_id(&mut self) {
        self.hand_id = ::std::option::Option::None;
    }

    pub fn has_hand_id(&self) -> bool {
        self.hand_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hand_id(&mut self, v: i32) {
        self.hand_id = ::std::option::Option::Some(v);
    }

    // optional uint32 effect_name_hash_code = 2;

    pub fn effect_name_hash_code(&self) -> u32 {
        self.effect_name_hash_code.unwrap_or(0)
    }

    pub fn clear_effect_name_hash_code(&mut self) {
        self.effect_name_hash_code = ::std::option::Option::None;
    }

    pub fn has_effect_name_hash_code(&self) -> bool {
        self.effect_name_hash_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_name_hash_code(&mut self, v: u32) {
        self.effect_name_hash_code = ::std::option::Option::Some(v);
    }

    // optional float effect_scale = 3;

    pub fn effect_scale(&self) -> f32 {
        self.effect_scale.unwrap_or(0.)
    }

    pub fn clear_effect_scale(&mut self) {
        self.effect_scale = ::std::option::Option::None;
    }

    pub fn has_effect_scale(&self) -> bool {
        self.effect_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_scale(&mut self, v: f32) {
        self.effect_scale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hand_id",
            |m: &CUserMessageHapticsManagerEffect| { &m.hand_id },
            |m: &mut CUserMessageHapticsManagerEffect| { &mut m.hand_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect_name_hash_code",
            |m: &CUserMessageHapticsManagerEffect| { &m.effect_name_hash_code },
            |m: &mut CUserMessageHapticsManagerEffect| { &mut m.effect_name_hash_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect_scale",
            |m: &CUserMessageHapticsManagerEffect| { &m.effect_scale },
            |m: &mut CUserMessageHapticsManagerEffect| { &mut m.effect_scale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageHapticsManagerEffect>(
            "CUserMessageHapticsManagerEffect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageHapticsManagerEffect {
    const NAME: &'static str = "CUserMessageHapticsManagerEffect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hand_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.effect_name_hash_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.effect_scale = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hand_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.effect_name_hash_code {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.effect_scale {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hand_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.effect_name_hash_code {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.effect_scale {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageHapticsManagerEffect {
        CUserMessageHapticsManagerEffect::new()
    }

    fn clear(&mut self) {
        self.hand_id = ::std::option::Option::None;
        self.effect_name_hash_code = ::std::option::Option::None;
        self.effect_scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageHapticsManagerEffect {
        static instance: CUserMessageHapticsManagerEffect = CUserMessageHapticsManagerEffect {
            hand_id: ::std::option::Option::None,
            effect_name_hash_code: ::std::option::Option::None,
            effect_scale: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageHapticsManagerEffect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageHapticsManagerEffect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageHapticsManagerEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageHapticsManagerEffect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageAnimStateGraphState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageAnimStateGraphState {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageAnimStateGraphState.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageAnimStateGraphState.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageAnimStateGraphState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageAnimStateGraphState {
    fn default() -> &'a CUserMessageAnimStateGraphState {
        <CUserMessageAnimStateGraphState as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageAnimStateGraphState {
    pub fn new() -> CUserMessageAnimStateGraphState {
        ::std::default::Default::default()
    }

    // optional int32 entity_index = 1;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_index",
            |m: &CUserMessageAnimStateGraphState| { &m.entity_index },
            |m: &mut CUserMessageAnimStateGraphState| { &mut m.entity_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CUserMessageAnimStateGraphState| { &m.data },
            |m: &mut CUserMessageAnimStateGraphState| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageAnimStateGraphState>(
            "CUserMessageAnimStateGraphState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageAnimStateGraphState {
    const NAME: &'static str = "CUserMessageAnimStateGraphState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageAnimStateGraphState {
        CUserMessageAnimStateGraphState::new()
    }

    fn clear(&mut self) {
        self.entity_index = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageAnimStateGraphState {
        static instance: CUserMessageAnimStateGraphState = CUserMessageAnimStateGraphState {
            entity_index: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageAnimStateGraphState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageAnimStateGraphState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageAnimStateGraphState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageAnimStateGraphState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageCommandQueueState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCommandQueueState {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCommandQueueState.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageCommandQueueState.command_queue_info)
    pub command_queue_info: ::protobuf::MessageField<cuser_message_command_queue_state::Command_queue_info_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCommandQueueState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCommandQueueState {
    fn default() -> &'a CUserMessageCommandQueueState {
        <CUserMessageCommandQueueState as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCommandQueueState {
    pub fn new() -> CUserMessageCommandQueueState {
        ::std::default::Default::default()
    }

    // optional int32 player_slot = 1;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &CUserMessageCommandQueueState| { &m.player_slot },
            |m: &mut CUserMessageCommandQueueState| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cuser_message_command_queue_state::Command_queue_info_t>(
            "command_queue_info",
            |m: &CUserMessageCommandQueueState| { &m.command_queue_info },
            |m: &mut CUserMessageCommandQueueState| { &mut m.command_queue_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageCommandQueueState>(
            "CUserMessageCommandQueueState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageCommandQueueState {
    const NAME: &'static str = "CUserMessageCommandQueueState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.command_queue_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.command_queue_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_slot {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.command_queue_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCommandQueueState {
        CUserMessageCommandQueueState::new()
    }

    fn clear(&mut self) {
        self.player_slot = ::std::option::Option::None;
        self.command_queue_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCommandQueueState {
        static instance: CUserMessageCommandQueueState = CUserMessageCommandQueueState {
            player_slot: ::std::option::Option::None,
            command_queue_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageCommandQueueState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageCommandQueueState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageCommandQueueState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageCommandQueueState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUserMessageCommandQueueState`
pub mod cuser_message_command_queue_state {
    // @@protoc_insertion_point(message:CUserMessageCommandQueueState.command_queue_info_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Command_queue_info_t {
        // message fields
        // @@protoc_insertion_point(field:CUserMessageCommandQueueState.command_queue_info_t.commands_queued)
        pub commands_queued: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMessageCommandQueueState.command_queue_info_t.command_queue_desired_size)
        pub command_queue_desired_size: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMessageCommandQueueState.command_queue_info_t.starved_command_ticks)
        pub starved_command_ticks: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMessageCommandQueueState.command_queue_info_t.time_dilation_percent)
        pub time_dilation_percent: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessageCommandQueueState.command_queue_info_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Command_queue_info_t {
        fn default() -> &'a Command_queue_info_t {
            <Command_queue_info_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Command_queue_info_t {
        pub fn new() -> Command_queue_info_t {
            ::std::default::Default::default()
        }

        // optional uint32 commands_queued = 1;

        pub fn commands_queued(&self) -> u32 {
            self.commands_queued.unwrap_or(0)
        }

        pub fn clear_commands_queued(&mut self) {
            self.commands_queued = ::std::option::Option::None;
        }

        pub fn has_commands_queued(&self) -> bool {
            self.commands_queued.is_some()
        }

        // Param is passed by value, moved
        pub fn set_commands_queued(&mut self, v: u32) {
            self.commands_queued = ::std::option::Option::Some(v);
        }

        // optional uint32 command_queue_desired_size = 2;

        pub fn command_queue_desired_size(&self) -> u32 {
            self.command_queue_desired_size.unwrap_or(0)
        }

        pub fn clear_command_queue_desired_size(&mut self) {
            self.command_queue_desired_size = ::std::option::Option::None;
        }

        pub fn has_command_queue_desired_size(&self) -> bool {
            self.command_queue_desired_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_command_queue_desired_size(&mut self, v: u32) {
            self.command_queue_desired_size = ::std::option::Option::Some(v);
        }

        // optional uint32 starved_command_ticks = 3;

        pub fn starved_command_ticks(&self) -> u32 {
            self.starved_command_ticks.unwrap_or(0)
        }

        pub fn clear_starved_command_ticks(&mut self) {
            self.starved_command_ticks = ::std::option::Option::None;
        }

        pub fn has_starved_command_ticks(&self) -> bool {
            self.starved_command_ticks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_starved_command_ticks(&mut self, v: u32) {
            self.starved_command_ticks = ::std::option::Option::Some(v);
        }

        // optional int32 time_dilation_percent = 4;

        pub fn time_dilation_percent(&self) -> i32 {
            self.time_dilation_percent.unwrap_or(0)
        }

        pub fn clear_time_dilation_percent(&mut self) {
            self.time_dilation_percent = ::std::option::Option::None;
        }

        pub fn has_time_dilation_percent(&self) -> bool {
            self.time_dilation_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_dilation_percent(&mut self, v: i32) {
            self.time_dilation_percent = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "commands_queued",
                |m: &Command_queue_info_t| { &m.commands_queued },
                |m: &mut Command_queue_info_t| { &mut m.commands_queued },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "command_queue_desired_size",
                |m: &Command_queue_info_t| { &m.command_queue_desired_size },
                |m: &mut Command_queue_info_t| { &mut m.command_queue_desired_size },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "starved_command_ticks",
                |m: &Command_queue_info_t| { &m.starved_command_ticks },
                |m: &mut Command_queue_info_t| { &mut m.starved_command_ticks },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_dilation_percent",
                |m: &Command_queue_info_t| { &m.time_dilation_percent },
                |m: &mut Command_queue_info_t| { &mut m.time_dilation_percent },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Command_queue_info_t>(
                "CUserMessageCommandQueueState.command_queue_info_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Command_queue_info_t {
        const NAME: &'static str = "command_queue_info_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.commands_queued = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.command_queue_desired_size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.starved_command_ticks = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.time_dilation_percent = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.commands_queued {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.command_queue_desired_size {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.starved_command_ticks {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.time_dilation_percent {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.commands_queued {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.command_queue_desired_size {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.starved_command_ticks {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.time_dilation_percent {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Command_queue_info_t {
            Command_queue_info_t::new()
        }

        fn clear(&mut self) {
            self.commands_queued = ::std::option::Option::None;
            self.command_queue_desired_size = ::std::option::Option::None;
            self.starved_command_ticks = ::std::option::Option::None;
            self.time_dilation_percent = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Command_queue_info_t {
            static instance: Command_queue_info_t = Command_queue_info_t {
                commands_queued: ::std::option::Option::None,
                command_queue_desired_size: ::std::option::Option::None,
                starved_command_ticks: ::std::option::Option::None,
                time_dilation_percent: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Command_queue_info_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMessageCommandQueueState.command_queue_info_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Command_queue_info_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Command_queue_info_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CUserMessageUpdateCssClasses)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageUpdateCssClasses {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageUpdateCssClasses.target_world_panel)
    pub target_world_panel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageUpdateCssClasses.css_classes)
    pub css_classes: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageUpdateCssClasses.is_add)
    pub is_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageUpdateCssClasses.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageUpdateCssClasses {
    fn default() -> &'a CUserMessageUpdateCssClasses {
        <CUserMessageUpdateCssClasses as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageUpdateCssClasses {
    pub fn new() -> CUserMessageUpdateCssClasses {
        ::std::default::Default::default()
    }

    // optional int32 target_world_panel = 1;

    pub fn target_world_panel(&self) -> i32 {
        self.target_world_panel.unwrap_or(0)
    }

    pub fn clear_target_world_panel(&mut self) {
        self.target_world_panel = ::std::option::Option::None;
    }

    pub fn has_target_world_panel(&self) -> bool {
        self.target_world_panel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_world_panel(&mut self, v: i32) {
        self.target_world_panel = ::std::option::Option::Some(v);
    }

    // optional string css_classes = 2;

    pub fn css_classes(&self) -> &str {
        match self.css_classes.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_css_classes(&mut self) {
        self.css_classes = ::std::option::Option::None;
    }

    pub fn has_css_classes(&self) -> bool {
        self.css_classes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_css_classes(&mut self, v: ::std::string::String) {
        self.css_classes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_css_classes(&mut self) -> &mut ::std::string::String {
        if self.css_classes.is_none() {
            self.css_classes = ::std::option::Option::Some(::std::string::String::new());
        }
        self.css_classes.as_mut().unwrap()
    }

    // Take field
    pub fn take_css_classes(&mut self) -> ::std::string::String {
        self.css_classes.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_add = 3;

    pub fn is_add(&self) -> bool {
        self.is_add.unwrap_or(false)
    }

    pub fn clear_is_add(&mut self) {
        self.is_add = ::std::option::Option::None;
    }

    pub fn has_is_add(&self) -> bool {
        self.is_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_add(&mut self, v: bool) {
        self.is_add = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "target_world_panel",
            |m: &CUserMessageUpdateCssClasses| { &m.target_world_panel },
            |m: &mut CUserMessageUpdateCssClasses| { &mut m.target_world_panel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "css_classes",
            |m: &CUserMessageUpdateCssClasses| { &m.css_classes },
            |m: &mut CUserMessageUpdateCssClasses| { &mut m.css_classes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_add",
            |m: &CUserMessageUpdateCssClasses| { &m.is_add },
            |m: &mut CUserMessageUpdateCssClasses| { &mut m.is_add },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageUpdateCssClasses>(
            "CUserMessageUpdateCssClasses",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageUpdateCssClasses {
    const NAME: &'static str = "CUserMessageUpdateCssClasses";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_world_panel = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.css_classes = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.is_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_world_panel {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.css_classes.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_add {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.target_world_panel {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.css_classes.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_add {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageUpdateCssClasses {
        CUserMessageUpdateCssClasses::new()
    }

    fn clear(&mut self) {
        self.target_world_panel = ::std::option::Option::None;
        self.css_classes = ::std::option::Option::None;
        self.is_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageUpdateCssClasses {
        static instance: CUserMessageUpdateCssClasses = CUserMessageUpdateCssClasses {
            target_world_panel: ::std::option::Option::None,
            css_classes: ::std::option::Option::None,
            is_add: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageUpdateCssClasses {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageUpdateCssClasses").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageUpdateCssClasses {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageUpdateCssClasses {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageServerFrameTime)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageServerFrameTime {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageServerFrameTime.frame_time)
    pub frame_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageServerFrameTime.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageServerFrameTime {
    fn default() -> &'a CUserMessageServerFrameTime {
        <CUserMessageServerFrameTime as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageServerFrameTime {
    pub fn new() -> CUserMessageServerFrameTime {
        ::std::default::Default::default()
    }

    // optional float frame_time = 1;

    pub fn frame_time(&self) -> f32 {
        self.frame_time.unwrap_or(0.)
    }

    pub fn clear_frame_time(&mut self) {
        self.frame_time = ::std::option::Option::None;
    }

    pub fn has_frame_time(&self) -> bool {
        self.frame_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_time(&mut self, v: f32) {
        self.frame_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frame_time",
            |m: &CUserMessageServerFrameTime| { &m.frame_time },
            |m: &mut CUserMessageServerFrameTime| { &mut m.frame_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageServerFrameTime>(
            "CUserMessageServerFrameTime",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageServerFrameTime {
    const NAME: &'static str = "CUserMessageServerFrameTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.frame_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.frame_time {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageServerFrameTime {
        CUserMessageServerFrameTime::new()
    }

    fn clear(&mut self) {
        self.frame_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageServerFrameTime {
        static instance: CUserMessageServerFrameTime = CUserMessageServerFrameTime {
            frame_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageServerFrameTime {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageServerFrameTime").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageServerFrameTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageServerFrameTime {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageLagCompensationError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageLagCompensationError {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageLagCompensationError.distance)
    pub distance: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageLagCompensationError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageLagCompensationError {
    fn default() -> &'a CUserMessageLagCompensationError {
        <CUserMessageLagCompensationError as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageLagCompensationError {
    pub fn new() -> CUserMessageLagCompensationError {
        ::std::default::Default::default()
    }

    // optional float distance = 1;

    pub fn distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "distance",
            |m: &CUserMessageLagCompensationError| { &m.distance },
            |m: &mut CUserMessageLagCompensationError| { &mut m.distance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageLagCompensationError>(
            "CUserMessageLagCompensationError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageLagCompensationError {
    const NAME: &'static str = "CUserMessageLagCompensationError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.distance = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.distance {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.distance {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageLagCompensationError {
        CUserMessageLagCompensationError::new()
    }

    fn clear(&mut self) {
        self.distance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageLagCompensationError {
        static instance: CUserMessageLagCompensationError = CUserMessageLagCompensationError {
            distance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageLagCompensationError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageLagCompensationError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageLagCompensationError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageLagCompensationError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageRequestDllStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRequestDllStatus {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageRequestDllStatus.dll_action)
    pub dll_action: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageRequestDllStatus.full_report)
    pub full_report: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRequestDllStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRequestDllStatus {
    fn default() -> &'a CUserMessageRequestDllStatus {
        <CUserMessageRequestDllStatus as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRequestDllStatus {
    pub fn new() -> CUserMessageRequestDllStatus {
        ::std::default::Default::default()
    }

    // optional string dll_action = 1;

    pub fn dll_action(&self) -> &str {
        match self.dll_action.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dll_action(&mut self) {
        self.dll_action = ::std::option::Option::None;
    }

    pub fn has_dll_action(&self) -> bool {
        self.dll_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dll_action(&mut self, v: ::std::string::String) {
        self.dll_action = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dll_action(&mut self) -> &mut ::std::string::String {
        if self.dll_action.is_none() {
            self.dll_action = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dll_action.as_mut().unwrap()
    }

    // Take field
    pub fn take_dll_action(&mut self) -> ::std::string::String {
        self.dll_action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool full_report = 2;

    pub fn full_report(&self) -> bool {
        self.full_report.unwrap_or(false)
    }

    pub fn clear_full_report(&mut self) {
        self.full_report = ::std::option::Option::None;
    }

    pub fn has_full_report(&self) -> bool {
        self.full_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_report(&mut self, v: bool) {
        self.full_report = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dll_action",
            |m: &CUserMessageRequestDllStatus| { &m.dll_action },
            |m: &mut CUserMessageRequestDllStatus| { &mut m.dll_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "full_report",
            |m: &CUserMessageRequestDllStatus| { &m.full_report },
            |m: &mut CUserMessageRequestDllStatus| { &mut m.full_report },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageRequestDllStatus>(
            "CUserMessageRequestDllStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageRequestDllStatus {
    const NAME: &'static str = "CUserMessageRequestDllStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dll_action = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.full_report = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dll_action.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.full_report {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dll_action.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.full_report {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRequestDllStatus {
        CUserMessageRequestDllStatus::new()
    }

    fn clear(&mut self) {
        self.dll_action = ::std::option::Option::None;
        self.full_report = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRequestDllStatus {
        static instance: CUserMessageRequestDllStatus = CUserMessageRequestDllStatus {
            dll_action: ::std::option::Option::None,
            full_report: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageRequestDllStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageRequestDllStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageRequestDllStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageRequestDllStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessageRequestUtilAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRequestUtilAction {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageRequestUtilAction.util1)
    pub util1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestUtilAction.util2)
    pub util2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestUtilAction.util3)
    pub util3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestUtilAction.util4)
    pub util4: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestUtilAction.util5)
    pub util5: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRequestUtilAction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRequestUtilAction {
    fn default() -> &'a CUserMessageRequestUtilAction {
        <CUserMessageRequestUtilAction as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRequestUtilAction {
    pub fn new() -> CUserMessageRequestUtilAction {
        ::std::default::Default::default()
    }

    // optional int32 util1 = 2;

    pub fn util1(&self) -> i32 {
        self.util1.unwrap_or(0)
    }

    pub fn clear_util1(&mut self) {
        self.util1 = ::std::option::Option::None;
    }

    pub fn has_util1(&self) -> bool {
        self.util1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util1(&mut self, v: i32) {
        self.util1 = ::std::option::Option::Some(v);
    }

    // optional int32 util2 = 3;

    pub fn util2(&self) -> i32 {
        self.util2.unwrap_or(0)
    }

    pub fn clear_util2(&mut self) {
        self.util2 = ::std::option::Option::None;
    }

    pub fn has_util2(&self) -> bool {
        self.util2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util2(&mut self, v: i32) {
        self.util2 = ::std::option::Option::Some(v);
    }

    // optional int32 util3 = 4;

    pub fn util3(&self) -> i32 {
        self.util3.unwrap_or(0)
    }

    pub fn clear_util3(&mut self) {
        self.util3 = ::std::option::Option::None;
    }

    pub fn has_util3(&self) -> bool {
        self.util3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util3(&mut self, v: i32) {
        self.util3 = ::std::option::Option::Some(v);
    }

    // optional int32 util4 = 5;

    pub fn util4(&self) -> i32 {
        self.util4.unwrap_or(0)
    }

    pub fn clear_util4(&mut self) {
        self.util4 = ::std::option::Option::None;
    }

    pub fn has_util4(&self) -> bool {
        self.util4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util4(&mut self, v: i32) {
        self.util4 = ::std::option::Option::Some(v);
    }

    // optional int32 util5 = 6;

    pub fn util5(&self) -> i32 {
        self.util5.unwrap_or(0)
    }

    pub fn clear_util5(&mut self) {
        self.util5 = ::std::option::Option::None;
    }

    pub fn has_util5(&self) -> bool {
        self.util5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util5(&mut self, v: i32) {
        self.util5 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util1",
            |m: &CUserMessageRequestUtilAction| { &m.util1 },
            |m: &mut CUserMessageRequestUtilAction| { &mut m.util1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util2",
            |m: &CUserMessageRequestUtilAction| { &m.util2 },
            |m: &mut CUserMessageRequestUtilAction| { &mut m.util2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util3",
            |m: &CUserMessageRequestUtilAction| { &m.util3 },
            |m: &mut CUserMessageRequestUtilAction| { &mut m.util3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util4",
            |m: &CUserMessageRequestUtilAction| { &m.util4 },
            |m: &mut CUserMessageRequestUtilAction| { &mut m.util4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util5",
            |m: &CUserMessageRequestUtilAction| { &m.util5 },
            |m: &mut CUserMessageRequestUtilAction| { &mut m.util5 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageRequestUtilAction>(
            "CUserMessageRequestUtilAction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageRequestUtilAction {
    const NAME: &'static str = "CUserMessageRequestUtilAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.util1 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.util2 = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.util3 = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.util4 = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.util5 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.util1 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.util2 {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.util3 {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.util4 {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.util5 {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.util1 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.util2 {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.util3 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.util4 {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.util5 {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRequestUtilAction {
        CUserMessageRequestUtilAction::new()
    }

    fn clear(&mut self) {
        self.util1 = ::std::option::Option::None;
        self.util2 = ::std::option::Option::None;
        self.util3 = ::std::option::Option::None;
        self.util4 = ::std::option::Option::None;
        self.util5 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRequestUtilAction {
        static instance: CUserMessageRequestUtilAction = CUserMessageRequestUtilAction {
            util1: ::std::option::Option::None,
            util2: ::std::option::Option::None,
            util3: ::std::option::Option::None,
            util4: ::std::option::Option::None,
            util5: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageRequestUtilAction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageRequestUtilAction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageRequestUtilAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageRequestUtilAction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessage_UtilMsg_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_UtilMsg_Response {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.crc)
    pub crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.item_count)
    pub item_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.crc2)
    pub crc2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.item_count2)
    pub item_count2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.crc_part)
    pub crc_part: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.crc_part2)
    pub crc_part2: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.client_timestamp)
    pub client_timestamp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.platform)
    pub platform: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.itemdetails)
    pub itemdetails: ::std::vec::Vec<cuser_message_util_msg_response::ItemDetail>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.itemgroup)
    pub itemgroup: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.total_count)
    pub total_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.total_count2)
    pub total_count2: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_UtilMsg_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_UtilMsg_Response {
    fn default() -> &'a CUserMessage_UtilMsg_Response {
        <CUserMessage_UtilMsg_Response as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_UtilMsg_Response {
    pub fn new() -> CUserMessage_UtilMsg_Response {
        ::std::default::Default::default()
    }

    // optional fixed32 crc = 1;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    // optional int32 item_count = 2;

    pub fn item_count(&self) -> i32 {
        self.item_count.unwrap_or(0)
    }

    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: i32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    // optional fixed32 crc2 = 3;

    pub fn crc2(&self) -> u32 {
        self.crc2.unwrap_or(0)
    }

    pub fn clear_crc2(&mut self) {
        self.crc2 = ::std::option::Option::None;
    }

    pub fn has_crc2(&self) -> bool {
        self.crc2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc2(&mut self, v: u32) {
        self.crc2 = ::std::option::Option::Some(v);
    }

    // optional int32 item_count2 = 4;

    pub fn item_count2(&self) -> i32 {
        self.item_count2.unwrap_or(0)
    }

    pub fn clear_item_count2(&mut self) {
        self.item_count2 = ::std::option::Option::None;
    }

    pub fn has_item_count2(&self) -> bool {
        self.item_count2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count2(&mut self, v: i32) {
        self.item_count2 = ::std::option::Option::Some(v);
    }

    // optional int32 client_timestamp = 7;

    pub fn client_timestamp(&self) -> i32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: i32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 platform = 8;

    pub fn platform(&self) -> i32 {
        self.platform.unwrap_or(0)
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: i32) {
        self.platform = ::std::option::Option::Some(v);
    }

    // optional int32 itemgroup = 10;

    pub fn itemgroup(&self) -> i32 {
        self.itemgroup.unwrap_or(0)
    }

    pub fn clear_itemgroup(&mut self) {
        self.itemgroup = ::std::option::Option::None;
    }

    pub fn has_itemgroup(&self) -> bool {
        self.itemgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemgroup(&mut self, v: i32) {
        self.itemgroup = ::std::option::Option::Some(v);
    }

    // optional int32 total_count = 11;

    pub fn total_count(&self) -> i32 {
        self.total_count.unwrap_or(0)
    }

    pub fn clear_total_count(&mut self) {
        self.total_count = ::std::option::Option::None;
    }

    pub fn has_total_count(&self) -> bool {
        self.total_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i32) {
        self.total_count = ::std::option::Option::Some(v);
    }

    // optional int32 total_count2 = 12;

    pub fn total_count2(&self) -> i32 {
        self.total_count2.unwrap_or(0)
    }

    pub fn clear_total_count2(&mut self) {
        self.total_count2 = ::std::option::Option::None;
    }

    pub fn has_total_count2(&self) -> bool {
        self.total_count2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_count2(&mut self, v: i32) {
        self.total_count2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc",
            |m: &CUserMessage_UtilMsg_Response| { &m.crc },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_count",
            |m: &CUserMessage_UtilMsg_Response| { &m.item_count },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.item_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc2",
            |m: &CUserMessage_UtilMsg_Response| { &m.crc2 },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.crc2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_count2",
            |m: &CUserMessage_UtilMsg_Response| { &m.item_count2 },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.item_count2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "crc_part",
            |m: &CUserMessage_UtilMsg_Response| { &m.crc_part },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.crc_part },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "crc_part2",
            |m: &CUserMessage_UtilMsg_Response| { &m.crc_part2 },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.crc_part2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_timestamp",
            |m: &CUserMessage_UtilMsg_Response| { &m.client_timestamp },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.client_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform",
            |m: &CUserMessage_UtilMsg_Response| { &m.platform },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "itemdetails",
            |m: &CUserMessage_UtilMsg_Response| { &m.itemdetails },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.itemdetails },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemgroup",
            |m: &CUserMessage_UtilMsg_Response| { &m.itemgroup },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.itemgroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_count",
            |m: &CUserMessage_UtilMsg_Response| { &m.total_count },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.total_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_count2",
            |m: &CUserMessage_UtilMsg_Response| { &m.total_count2 },
            |m: &mut CUserMessage_UtilMsg_Response| { &mut m.total_count2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessage_UtilMsg_Response>(
            "CUserMessage_UtilMsg_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessage_UtilMsg_Response {
    const NAME: &'static str = "CUserMessage_UtilMsg_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.item_count = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.crc2 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.item_count2 = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.crc_part)?;
                },
                40 => {
                    self.crc_part.push(is.read_int32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.crc_part2)?;
                },
                48 => {
                    self.crc_part2.push(is.read_int32()?);
                },
                56 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.platform = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.itemdetails.push(is.read_message()?);
                },
                80 => {
                    self.itemgroup = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.total_count = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.total_count2 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.crc2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_count2 {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        for value in &self.crc_part {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        for value in &self.crc_part2 {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        if let Some(v) = self.client_timestamp {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.platform {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        for value in &self.itemdetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.itemgroup {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.total_count {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.total_count2 {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.crc {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.item_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.crc2 {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.item_count2 {
            os.write_int32(4, v)?;
        }
        for v in &self.crc_part {
            os.write_int32(5, *v)?;
        };
        for v in &self.crc_part2 {
            os.write_int32(6, *v)?;
        };
        if let Some(v) = self.client_timestamp {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.platform {
            os.write_int32(8, v)?;
        }
        for v in &self.itemdetails {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.itemgroup {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.total_count {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.total_count2 {
            os.write_int32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_UtilMsg_Response {
        CUserMessage_UtilMsg_Response::new()
    }

    fn clear(&mut self) {
        self.crc = ::std::option::Option::None;
        self.item_count = ::std::option::Option::None;
        self.crc2 = ::std::option::Option::None;
        self.item_count2 = ::std::option::Option::None;
        self.crc_part.clear();
        self.crc_part2.clear();
        self.client_timestamp = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.itemdetails.clear();
        self.itemgroup = ::std::option::Option::None;
        self.total_count = ::std::option::Option::None;
        self.total_count2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_UtilMsg_Response {
        static instance: CUserMessage_UtilMsg_Response = CUserMessage_UtilMsg_Response {
            crc: ::std::option::Option::None,
            item_count: ::std::option::Option::None,
            crc2: ::std::option::Option::None,
            item_count2: ::std::option::Option::None,
            crc_part: ::std::vec::Vec::new(),
            crc_part2: ::std::vec::Vec::new(),
            client_timestamp: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            itemdetails: ::std::vec::Vec::new(),
            itemgroup: ::std::option::Option::None,
            total_count: ::std::option::Option::None,
            total_count2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessage_UtilMsg_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessage_UtilMsg_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessage_UtilMsg_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessage_UtilMsg_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUserMessage_UtilMsg_Response`
pub mod cuser_message_util_msg_response {
    // @@protoc_insertion_point(message:CUserMessage_UtilMsg_Response.ItemDetail)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemDetail {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.ItemDetail.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.ItemDetail.hash)
        pub hash: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.ItemDetail.crc)
        pub crc: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.ItemDetail.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_UtilMsg_Response.ItemDetail.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDetail {
        fn default() -> &'a ItemDetail {
            <ItemDetail as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemDetail {
        pub fn new() -> ItemDetail {
            ::std::default::Default::default()
        }

        // optional int32 index = 1;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int32 hash = 2;

        pub fn hash(&self) -> i32 {
            self.hash.unwrap_or(0)
        }

        pub fn clear_hash(&mut self) {
            self.hash = ::std::option::Option::None;
        }

        pub fn has_hash(&self) -> bool {
            self.hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hash(&mut self, v: i32) {
            self.hash = ::std::option::Option::Some(v);
        }

        // optional int32 crc = 3;

        pub fn crc(&self) -> i32 {
            self.crc.unwrap_or(0)
        }

        pub fn clear_crc(&mut self) {
            self.crc = ::std::option::Option::None;
        }

        pub fn has_crc(&self) -> bool {
            self.crc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_crc(&mut self, v: i32) {
            self.crc = ::std::option::Option::Some(v);
        }

        // optional string name = 4;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "index",
                |m: &ItemDetail| { &m.index },
                |m: &mut ItemDetail| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hash",
                |m: &ItemDetail| { &m.hash },
                |m: &mut ItemDetail| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "crc",
                |m: &ItemDetail| { &m.crc },
                |m: &mut ItemDetail| { &mut m.crc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &ItemDetail| { &m.name },
                |m: &mut ItemDetail| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemDetail>(
                "CUserMessage_UtilMsg_Response.ItemDetail",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemDetail {
        const NAME: &'static str = "ItemDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.hash = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.crc = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.hash {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.crc {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.hash {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.crc {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDetail {
            ItemDetail::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.hash = ::std::option::Option::None;
            self.crc = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDetail {
            static instance: ItemDetail = ItemDetail {
                index: ::std::option::Option::None,
                hash: ::std::option::Option::None,
                crc: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemDetail {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMessage_UtilMsg_Response.ItemDetail").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemDetail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemDetail {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CUserMessage_DllStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_DllStatus {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.file_report)
    pub file_report: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.command_line)
    pub command_line: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.total_files)
    pub total_files: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.process_id)
    pub process_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.osversion)
    pub osversion: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.client_time)
    pub client_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.diagnostics)
    pub diagnostics: ::std::vec::Vec<cuser_message_dll_status::CVDiagnostic>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.modules)
    pub modules: ::std::vec::Vec<cuser_message_dll_status::CModule>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_DllStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_DllStatus {
    fn default() -> &'a CUserMessage_DllStatus {
        <CUserMessage_DllStatus as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_DllStatus {
    pub fn new() -> CUserMessage_DllStatus {
        ::std::default::Default::default()
    }

    // optional string file_report = 1;

    pub fn file_report(&self) -> &str {
        match self.file_report.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_report(&mut self) {
        self.file_report = ::std::option::Option::None;
    }

    pub fn has_file_report(&self) -> bool {
        self.file_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_report(&mut self, v: ::std::string::String) {
        self.file_report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_report(&mut self) -> &mut ::std::string::String {
        if self.file_report.is_none() {
            self.file_report = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_report(&mut self) -> ::std::string::String {
        self.file_report.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string command_line = 2;

    pub fn command_line(&self) -> &str {
        match self.command_line.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command_line(&mut self) {
        self.command_line = ::std::option::Option::None;
    }

    pub fn has_command_line(&self) -> bool {
        self.command_line.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command_line(&mut self, v: ::std::string::String) {
        self.command_line = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command_line(&mut self) -> &mut ::std::string::String {
        if self.command_line.is_none() {
            self.command_line = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command_line.as_mut().unwrap()
    }

    // Take field
    pub fn take_command_line(&mut self) -> ::std::string::String {
        self.command_line.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 total_files = 3;

    pub fn total_files(&self) -> u32 {
        self.total_files.unwrap_or(0)
    }

    pub fn clear_total_files(&mut self) {
        self.total_files = ::std::option::Option::None;
    }

    pub fn has_total_files(&self) -> bool {
        self.total_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_files(&mut self, v: u32) {
        self.total_files = ::std::option::Option::Some(v);
    }

    // optional uint32 process_id = 4;

    pub fn process_id(&self) -> u32 {
        self.process_id.unwrap_or(0)
    }

    pub fn clear_process_id(&mut self) {
        self.process_id = ::std::option::Option::None;
    }

    pub fn has_process_id(&self) -> bool {
        self.process_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_id(&mut self, v: u32) {
        self.process_id = ::std::option::Option::Some(v);
    }

    // optional int32 osversion = 5;

    pub fn osversion(&self) -> i32 {
        self.osversion.unwrap_or(0)
    }

    pub fn clear_osversion(&mut self) {
        self.osversion = ::std::option::Option::None;
    }

    pub fn has_osversion(&self) -> bool {
        self.osversion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osversion(&mut self, v: i32) {
        self.osversion = ::std::option::Option::Some(v);
    }

    // optional uint64 client_time = 6;

    pub fn client_time(&self) -> u64 {
        self.client_time.unwrap_or(0)
    }

    pub fn clear_client_time(&mut self) {
        self.client_time = ::std::option::Option::None;
    }

    pub fn has_client_time(&self) -> bool {
        self.client_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_time(&mut self, v: u64) {
        self.client_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_report",
            |m: &CUserMessage_DllStatus| { &m.file_report },
            |m: &mut CUserMessage_DllStatus| { &mut m.file_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command_line",
            |m: &CUserMessage_DllStatus| { &m.command_line },
            |m: &mut CUserMessage_DllStatus| { &mut m.command_line },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_files",
            |m: &CUserMessage_DllStatus| { &m.total_files },
            |m: &mut CUserMessage_DllStatus| { &mut m.total_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "process_id",
            |m: &CUserMessage_DllStatus| { &m.process_id },
            |m: &mut CUserMessage_DllStatus| { &mut m.process_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osversion",
            |m: &CUserMessage_DllStatus| { &m.osversion },
            |m: &mut CUserMessage_DllStatus| { &mut m.osversion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_time",
            |m: &CUserMessage_DllStatus| { &m.client_time },
            |m: &mut CUserMessage_DllStatus| { &mut m.client_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "diagnostics",
            |m: &CUserMessage_DllStatus| { &m.diagnostics },
            |m: &mut CUserMessage_DllStatus| { &mut m.diagnostics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &CUserMessage_DllStatus| { &m.modules },
            |m: &mut CUserMessage_DllStatus| { &mut m.modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessage_DllStatus>(
            "CUserMessage_DllStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessage_DllStatus {
    const NAME: &'static str = "CUserMessage_DllStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_report = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.command_line = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.total_files = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.osversion = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.client_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                58 => {
                    self.diagnostics.push(is.read_message()?);
                },
                66 => {
                    self.modules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_report.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.command_line.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.total_files {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.process_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.osversion {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.client_time {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.file_report.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.command_line.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.total_files {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.process_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.osversion {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.client_time {
            os.write_uint64(6, v)?;
        }
        for v in &self.diagnostics {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_DllStatus {
        CUserMessage_DllStatus::new()
    }

    fn clear(&mut self) {
        self.file_report = ::std::option::Option::None;
        self.command_line = ::std::option::Option::None;
        self.total_files = ::std::option::Option::None;
        self.process_id = ::std::option::Option::None;
        self.osversion = ::std::option::Option::None;
        self.client_time = ::std::option::Option::None;
        self.diagnostics.clear();
        self.modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_DllStatus {
        static instance: CUserMessage_DllStatus = CUserMessage_DllStatus {
            file_report: ::std::option::Option::None,
            command_line: ::std::option::Option::None,
            total_files: ::std::option::Option::None,
            process_id: ::std::option::Option::None,
            osversion: ::std::option::Option::None,
            client_time: ::std::option::Option::None,
            diagnostics: ::std::vec::Vec::new(),
            modules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessage_DllStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessage_DllStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessage_DllStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessage_DllStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUserMessage_DllStatus`
pub mod cuser_message_dll_status {
    // @@protoc_insertion_point(message:CUserMessage_DllStatus.CVDiagnostic)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CVDiagnostic {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CVDiagnostic.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CVDiagnostic.extended)
        pub extended: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CVDiagnostic.value)
        pub value: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CVDiagnostic.string_value)
        pub string_value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_DllStatus.CVDiagnostic.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CVDiagnostic {
        fn default() -> &'a CVDiagnostic {
            <CVDiagnostic as ::protobuf::Message>::default_instance()
        }
    }

    impl CVDiagnostic {
        pub fn new() -> CVDiagnostic {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 extended = 2;

        pub fn extended(&self) -> u32 {
            self.extended.unwrap_or(0)
        }

        pub fn clear_extended(&mut self) {
            self.extended = ::std::option::Option::None;
        }

        pub fn has_extended(&self) -> bool {
            self.extended.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extended(&mut self, v: u32) {
            self.extended = ::std::option::Option::Some(v);
        }

        // optional uint64 value = 3;

        pub fn value(&self) -> u64 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u64) {
            self.value = ::std::option::Option::Some(v);
        }

        // optional string string_value = 4;

        pub fn string_value(&self) -> &str {
            match self.string_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_string_value(&mut self) {
            self.string_value = ::std::option::Option::None;
        }

        pub fn has_string_value(&self) -> bool {
            self.string_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_string_value(&mut self, v: ::std::string::String) {
            self.string_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
            if self.string_value.is_none() {
                self.string_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.string_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_string_value(&mut self) -> ::std::string::String {
            self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &CVDiagnostic| { &m.id },
                |m: &mut CVDiagnostic| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "extended",
                |m: &CVDiagnostic| { &m.extended },
                |m: &mut CVDiagnostic| { &mut m.extended },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &CVDiagnostic| { &m.value },
                |m: &mut CVDiagnostic| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "string_value",
                |m: &CVDiagnostic| { &m.string_value },
                |m: &mut CVDiagnostic| { &mut m.string_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CVDiagnostic>(
                "CUserMessage_DllStatus.CVDiagnostic",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CVDiagnostic {
        const NAME: &'static str = "CVDiagnostic";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.extended = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.value = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.string_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.extended {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.value {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.string_value.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.extended {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.string_value.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CVDiagnostic {
            CVDiagnostic::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.extended = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.string_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CVDiagnostic {
            static instance: CVDiagnostic = CVDiagnostic {
                id: ::std::option::Option::None,
                extended: ::std::option::Option::None,
                value: ::std::option::Option::None,
                string_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CVDiagnostic {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMessage_DllStatus.CVDiagnostic").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CVDiagnostic {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CVDiagnostic {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CUserMessage_DllStatus.CModule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CModule {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CModule.base_addr)
        pub base_addr: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CModule.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CModule.size)
        pub size: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CModule.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_DllStatus.CModule.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CModule {
        fn default() -> &'a CModule {
            <CModule as ::protobuf::Message>::default_instance()
        }
    }

    impl CModule {
        pub fn new() -> CModule {
            ::std::default::Default::default()
        }

        // optional uint64 base_addr = 1;

        pub fn base_addr(&self) -> u64 {
            self.base_addr.unwrap_or(0)
        }

        pub fn clear_base_addr(&mut self) {
            self.base_addr = ::std::option::Option::None;
        }

        pub fn has_base_addr(&self) -> bool {
            self.base_addr.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_addr(&mut self, v: u64) {
            self.base_addr = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 size = 3;

        pub fn size(&self) -> u32 {
            self.size.unwrap_or(0)
        }

        pub fn clear_size(&mut self) {
            self.size = ::std::option::Option::None;
        }

        pub fn has_size(&self) -> bool {
            self.size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size(&mut self, v: u32) {
            self.size = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 4;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_addr",
                |m: &CModule| { &m.base_addr },
                |m: &mut CModule| { &mut m.base_addr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &CModule| { &m.name },
                |m: &mut CModule| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "size",
                |m: &CModule| { &m.size },
                |m: &mut CModule| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &CModule| { &m.timestamp },
                |m: &mut CModule| { &mut m.timestamp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CModule>(
                "CUserMessage_DllStatus.CModule",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CModule {
        const NAME: &'static str = "CModule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.base_addr = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.base_addr {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.size {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.base_addr {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.size {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CModule {
            CModule::new()
        }

        fn clear(&mut self) {
            self.base_addr = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.size = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CModule {
            static instance: CModule = CModule {
                base_addr: ::std::option::Option::None,
                name: ::std::option::Option::None,
                size: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CModule {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMessage_DllStatus.CModule").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CModule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CModule {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CUserMessageRequestInventory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRequestInventory {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageRequestInventory.inventory)
    pub inventory: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestInventory.offset)
    pub offset: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestInventory.options)
    pub options: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRequestInventory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRequestInventory {
    fn default() -> &'a CUserMessageRequestInventory {
        <CUserMessageRequestInventory as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRequestInventory {
    pub fn new() -> CUserMessageRequestInventory {
        ::std::default::Default::default()
    }

    // optional int32 inventory = 1;

    pub fn inventory(&self) -> i32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: i32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional int32 offset = 2;

    pub fn offset(&self) -> i32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional int32 options = 3;

    pub fn options(&self) -> i32 {
        self.options.unwrap_or(0)
    }

    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: i32) {
        self.options = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory",
            |m: &CUserMessageRequestInventory| { &m.inventory },
            |m: &mut CUserMessageRequestInventory| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset",
            |m: &CUserMessageRequestInventory| { &m.offset },
            |m: &mut CUserMessageRequestInventory| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "options",
            |m: &CUserMessageRequestInventory| { &m.options },
            |m: &mut CUserMessageRequestInventory| { &mut m.options },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageRequestInventory>(
            "CUserMessageRequestInventory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageRequestInventory {
    const NAME: &'static str = "CUserMessageRequestInventory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.inventory = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.options = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.options {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.inventory {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.options {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRequestInventory {
        CUserMessageRequestInventory::new()
    }

    fn clear(&mut self) {
        self.inventory = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRequestInventory {
        static instance: CUserMessageRequestInventory = CUserMessageRequestInventory {
            inventory: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            options: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageRequestInventory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageRequestInventory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageRequestInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageRequestInventory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserMessage_Inventory_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_Inventory_Response {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.crc)
    pub crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.item_count)
    pub item_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.osversion)
    pub osversion: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.perf_time)
    pub perf_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.client_timestamp)
    pub client_timestamp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.platform)
    pub platform: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.inventories)
    pub inventories: ::std::vec::Vec<cuser_message_inventory_response::InventoryDetail>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.inventories2)
    pub inventories2: ::std::vec::Vec<cuser_message_inventory_response::InventoryDetail>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.inventories3)
    pub inventories3: ::std::vec::Vec<cuser_message_inventory_response::InventoryDetail>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.inv_type)
    pub inv_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.build_version)
    pub build_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.instance)
    pub instance: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.start_time)
    pub start_time: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_Inventory_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_Inventory_Response {
    fn default() -> &'a CUserMessage_Inventory_Response {
        <CUserMessage_Inventory_Response as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_Inventory_Response {
    pub fn new() -> CUserMessage_Inventory_Response {
        ::std::default::Default::default()
    }

    // optional fixed32 crc = 1;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    // optional int32 item_count = 2;

    pub fn item_count(&self) -> i32 {
        self.item_count.unwrap_or(0)
    }

    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: i32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    // optional int32 osversion = 5;

    pub fn osversion(&self) -> i32 {
        self.osversion.unwrap_or(0)
    }

    pub fn clear_osversion(&mut self) {
        self.osversion = ::std::option::Option::None;
    }

    pub fn has_osversion(&self) -> bool {
        self.osversion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osversion(&mut self, v: i32) {
        self.osversion = ::std::option::Option::Some(v);
    }

    // optional int32 perf_time = 6;

    pub fn perf_time(&self) -> i32 {
        self.perf_time.unwrap_or(0)
    }

    pub fn clear_perf_time(&mut self) {
        self.perf_time = ::std::option::Option::None;
    }

    pub fn has_perf_time(&self) -> bool {
        self.perf_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_time(&mut self, v: i32) {
        self.perf_time = ::std::option::Option::Some(v);
    }

    // optional int32 client_timestamp = 7;

    pub fn client_timestamp(&self) -> i32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: i32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 platform = 8;

    pub fn platform(&self) -> i32 {
        self.platform.unwrap_or(0)
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: i32) {
        self.platform = ::std::option::Option::Some(v);
    }

    // optional int32 inv_type = 11;

    pub fn inv_type(&self) -> i32 {
        self.inv_type.unwrap_or(0)
    }

    pub fn clear_inv_type(&mut self) {
        self.inv_type = ::std::option::Option::None;
    }

    pub fn has_inv_type(&self) -> bool {
        self.inv_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inv_type(&mut self, v: i32) {
        self.inv_type = ::std::option::Option::Some(v);
    }

    // optional int32 build_version = 12;

    pub fn build_version(&self) -> i32 {
        self.build_version.unwrap_or(0)
    }

    pub fn clear_build_version(&mut self) {
        self.build_version = ::std::option::Option::None;
    }

    pub fn has_build_version(&self) -> bool {
        self.build_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_version(&mut self, v: i32) {
        self.build_version = ::std::option::Option::Some(v);
    }

    // optional int32 instance = 13;

    pub fn instance(&self) -> i32 {
        self.instance.unwrap_or(0)
    }

    pub fn clear_instance(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: i32) {
        self.instance = ::std::option::Option::Some(v);
    }

    // optional int64 start_time = 15;

    pub fn start_time(&self) -> i64 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc",
            |m: &CUserMessage_Inventory_Response| { &m.crc },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_count",
            |m: &CUserMessage_Inventory_Response| { &m.item_count },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.item_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osversion",
            |m: &CUserMessage_Inventory_Response| { &m.osversion },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.osversion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "perf_time",
            |m: &CUserMessage_Inventory_Response| { &m.perf_time },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.perf_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_timestamp",
            |m: &CUserMessage_Inventory_Response| { &m.client_timestamp },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.client_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform",
            |m: &CUserMessage_Inventory_Response| { &m.platform },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inventories",
            |m: &CUserMessage_Inventory_Response| { &m.inventories },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.inventories },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inventories2",
            |m: &CUserMessage_Inventory_Response| { &m.inventories2 },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.inventories2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "inventories3",
            |m: &CUserMessage_Inventory_Response| { &m.inventories3 },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.inventories3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inv_type",
            |m: &CUserMessage_Inventory_Response| { &m.inv_type },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.inv_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_version",
            |m: &CUserMessage_Inventory_Response| { &m.build_version },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.build_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "instance",
            |m: &CUserMessage_Inventory_Response| { &m.instance },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.instance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CUserMessage_Inventory_Response| { &m.start_time },
            |m: &mut CUserMessage_Inventory_Response| { &mut m.start_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessage_Inventory_Response>(
            "CUserMessage_Inventory_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessage_Inventory_Response {
    const NAME: &'static str = "CUserMessage_Inventory_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.item_count = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.osversion = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.perf_time = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.platform = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.inventories.push(is.read_message()?);
                },
                82 => {
                    self.inventories2.push(is.read_message()?);
                },
                114 => {
                    self.inventories3.push(is.read_message()?);
                },
                88 => {
                    self.inv_type = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.build_version = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.instance = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.start_time = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.osversion {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.perf_time {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.client_timestamp {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.platform {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        for value in &self.inventories {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.inventories2 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.inventories3 {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.inv_type {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.build_version {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.instance {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::int64_size(15, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.crc {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.item_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.osversion {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.perf_time {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.client_timestamp {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.platform {
            os.write_int32(8, v)?;
        }
        for v in &self.inventories {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.inventories2 {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.inventories3 {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if let Some(v) = self.inv_type {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.build_version {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.instance {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_int64(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_Inventory_Response {
        CUserMessage_Inventory_Response::new()
    }

    fn clear(&mut self) {
        self.crc = ::std::option::Option::None;
        self.item_count = ::std::option::Option::None;
        self.osversion = ::std::option::Option::None;
        self.perf_time = ::std::option::Option::None;
        self.client_timestamp = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.inventories.clear();
        self.inventories2.clear();
        self.inventories3.clear();
        self.inv_type = ::std::option::Option::None;
        self.build_version = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_Inventory_Response {
        static instance: CUserMessage_Inventory_Response = CUserMessage_Inventory_Response {
            crc: ::std::option::Option::None,
            item_count: ::std::option::Option::None,
            osversion: ::std::option::Option::None,
            perf_time: ::std::option::Option::None,
            client_timestamp: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            inventories: ::std::vec::Vec::new(),
            inventories2: ::std::vec::Vec::new(),
            inventories3: ::std::vec::Vec::new(),
            inv_type: ::std::option::Option::None,
            build_version: ::std::option::Option::None,
            instance: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessage_Inventory_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessage_Inventory_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessage_Inventory_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessage_Inventory_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUserMessage_Inventory_Response`
pub mod cuser_message_inventory_response {
    // @@protoc_insertion_point(message:CUserMessage_Inventory_Response.InventoryDetail)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InventoryDetail {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.primary)
        pub primary: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.offset)
        pub offset: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.first)
        pub first: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.base)
        pub base: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.base_name)
        pub base_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.base_detail)
        pub base_detail: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.base_time)
        pub base_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.base_hash)
        pub base_hash: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_Inventory_Response.InventoryDetail.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InventoryDetail {
        fn default() -> &'a InventoryDetail {
            <InventoryDetail as ::protobuf::Message>::default_instance()
        }
    }

    impl InventoryDetail {
        pub fn new() -> InventoryDetail {
            ::std::default::Default::default()
        }

        // optional int32 index = 1;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int64 primary = 2;

        pub fn primary(&self) -> i64 {
            self.primary.unwrap_or(0)
        }

        pub fn clear_primary(&mut self) {
            self.primary = ::std::option::Option::None;
        }

        pub fn has_primary(&self) -> bool {
            self.primary.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary(&mut self, v: i64) {
            self.primary = ::std::option::Option::Some(v);
        }

        // optional int64 offset = 3;

        pub fn offset(&self) -> i64 {
            self.offset.unwrap_or(0)
        }

        pub fn clear_offset(&mut self) {
            self.offset = ::std::option::Option::None;
        }

        pub fn has_offset(&self) -> bool {
            self.offset.is_some()
        }

        // Param is passed by value, moved
        pub fn set_offset(&mut self, v: i64) {
            self.offset = ::std::option::Option::Some(v);
        }

        // optional int64 first = 4;

        pub fn first(&self) -> i64 {
            self.first.unwrap_or(0)
        }

        pub fn clear_first(&mut self) {
            self.first = ::std::option::Option::None;
        }

        pub fn has_first(&self) -> bool {
            self.first.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first(&mut self, v: i64) {
            self.first = ::std::option::Option::Some(v);
        }

        // optional int64 base = 5;

        pub fn base(&self) -> i64 {
            self.base.unwrap_or(0)
        }

        pub fn clear_base(&mut self) {
            self.base = ::std::option::Option::None;
        }

        pub fn has_base(&self) -> bool {
            self.base.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: i64) {
            self.base = ::std::option::Option::Some(v);
        }

        // optional string name = 6;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string base_name = 7;

        pub fn base_name(&self) -> &str {
            match self.base_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_base_name(&mut self) {
            self.base_name = ::std::option::Option::None;
        }

        pub fn has_base_name(&self) -> bool {
            self.base_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_name(&mut self, v: ::std::string::String) {
            self.base_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_base_name(&mut self) -> &mut ::std::string::String {
            if self.base_name.is_none() {
                self.base_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.base_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_base_name(&mut self) -> ::std::string::String {
            self.base_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 base_detail = 8;

        pub fn base_detail(&self) -> i32 {
            self.base_detail.unwrap_or(0)
        }

        pub fn clear_base_detail(&mut self) {
            self.base_detail = ::std::option::Option::None;
        }

        pub fn has_base_detail(&self) -> bool {
            self.base_detail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_detail(&mut self, v: i32) {
            self.base_detail = ::std::option::Option::Some(v);
        }

        // optional int32 base_time = 9;

        pub fn base_time(&self) -> i32 {
            self.base_time.unwrap_or(0)
        }

        pub fn clear_base_time(&mut self) {
            self.base_time = ::std::option::Option::None;
        }

        pub fn has_base_time(&self) -> bool {
            self.base_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_time(&mut self, v: i32) {
            self.base_time = ::std::option::Option::Some(v);
        }

        // optional int32 base_hash = 10;

        pub fn base_hash(&self) -> i32 {
            self.base_hash.unwrap_or(0)
        }

        pub fn clear_base_hash(&mut self) {
            self.base_hash = ::std::option::Option::None;
        }

        pub fn has_base_hash(&self) -> bool {
            self.base_hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_hash(&mut self, v: i32) {
            self.base_hash = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "index",
                |m: &InventoryDetail| { &m.index },
                |m: &mut InventoryDetail| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "primary",
                |m: &InventoryDetail| { &m.primary },
                |m: &mut InventoryDetail| { &mut m.primary },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "offset",
                |m: &InventoryDetail| { &m.offset },
                |m: &mut InventoryDetail| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "first",
                |m: &InventoryDetail| { &m.first },
                |m: &mut InventoryDetail| { &mut m.first },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base",
                |m: &InventoryDetail| { &m.base },
                |m: &mut InventoryDetail| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &InventoryDetail| { &m.name },
                |m: &mut InventoryDetail| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_name",
                |m: &InventoryDetail| { &m.base_name },
                |m: &mut InventoryDetail| { &mut m.base_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_detail",
                |m: &InventoryDetail| { &m.base_detail },
                |m: &mut InventoryDetail| { &mut m.base_detail },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_time",
                |m: &InventoryDetail| { &m.base_time },
                |m: &mut InventoryDetail| { &mut m.base_time },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base_hash",
                |m: &InventoryDetail| { &m.base_hash },
                |m: &mut InventoryDetail| { &mut m.base_hash },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InventoryDetail>(
                "CUserMessage_Inventory_Response.InventoryDetail",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for InventoryDetail {
        const NAME: &'static str = "InventoryDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.primary = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.offset = ::std::option::Option::Some(is.read_int64()?);
                    },
                    32 => {
                        self.first = ::std::option::Option::Some(is.read_int64()?);
                    },
                    40 => {
                        self.base = ::std::option::Option::Some(is.read_int64()?);
                    },
                    50 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.base_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    64 => {
                        self.base_detail = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.base_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.base_hash = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.primary {
                my_size += ::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.offset {
                my_size += ::protobuf::rt::int64_size(3, v);
            }
            if let Some(v) = self.first {
                my_size += ::protobuf::rt::int64_size(4, v);
            }
            if let Some(v) = self.base {
                my_size += ::protobuf::rt::int64_size(5, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.base_name.as_ref() {
                my_size += ::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.base_detail {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.base_time {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.base_hash {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.primary {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.offset {
                os.write_int64(3, v)?;
            }
            if let Some(v) = self.first {
                os.write_int64(4, v)?;
            }
            if let Some(v) = self.base {
                os.write_int64(5, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.base_name.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.base_detail {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.base_time {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.base_hash {
                os.write_int32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InventoryDetail {
            InventoryDetail::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.primary = ::std::option::Option::None;
            self.offset = ::std::option::Option::None;
            self.first = ::std::option::Option::None;
            self.base = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.base_name = ::std::option::Option::None;
            self.base_detail = ::std::option::Option::None;
            self.base_time = ::std::option::Option::None;
            self.base_hash = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InventoryDetail {
            static instance: InventoryDetail = InventoryDetail {
                index: ::std::option::Option::None,
                primary: ::std::option::Option::None,
                offset: ::std::option::Option::None,
                first: ::std::option::Option::None,
                base: ::std::option::Option::None,
                name: ::std::option::Option::None,
                base_name: ::std::option::Option::None,
                base_detail: ::std::option::Option::None,
                base_time: ::std::option::Option::None,
                base_hash: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for InventoryDetail {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMessage_Inventory_Response.InventoryDetail").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for InventoryDetail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for InventoryDetail {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CUserMessageRequestDiagnostic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRequestDiagnostic {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.diagnostics)
    pub diagnostics: ::std::vec::Vec<cuser_message_request_diagnostic::Diagnostic>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRequestDiagnostic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRequestDiagnostic {
    fn default() -> &'a CUserMessageRequestDiagnostic {
        <CUserMessageRequestDiagnostic as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRequestDiagnostic {
    pub fn new() -> CUserMessageRequestDiagnostic {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "diagnostics",
            |m: &CUserMessageRequestDiagnostic| { &m.diagnostics },
            |m: &mut CUserMessageRequestDiagnostic| { &mut m.diagnostics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessageRequestDiagnostic>(
            "CUserMessageRequestDiagnostic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessageRequestDiagnostic {
    const NAME: &'static str = "CUserMessageRequestDiagnostic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.diagnostics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.diagnostics {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRequestDiagnostic {
        CUserMessageRequestDiagnostic::new()
    }

    fn clear(&mut self) {
        self.diagnostics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRequestDiagnostic {
        static instance: CUserMessageRequestDiagnostic = CUserMessageRequestDiagnostic {
            diagnostics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessageRequestDiagnostic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessageRequestDiagnostic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessageRequestDiagnostic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessageRequestDiagnostic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUserMessageRequestDiagnostic`
pub mod cuser_message_request_diagnostic {
    // @@protoc_insertion_point(message:CUserMessageRequestDiagnostic.Diagnostic)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Diagnostic {
        // message fields
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.offset)
        pub offset: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.param)
        pub param: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.length)
        pub length: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.base)
        pub base: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.range)
        pub range: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.extent)
        pub extent: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.detail)
        pub detail: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.alias)
        pub alias: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.vardetail)
        pub vardetail: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.context)
        pub context: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessageRequestDiagnostic.Diagnostic.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Diagnostic {
        fn default() -> &'a Diagnostic {
            <Diagnostic as ::protobuf::Message>::default_instance()
        }
    }

    impl Diagnostic {
        pub fn new() -> Diagnostic {
            ::std::default::Default::default()
        }

        // optional int32 index = 1;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int64 offset = 2;

        pub fn offset(&self) -> i64 {
            self.offset.unwrap_or(0)
        }

        pub fn clear_offset(&mut self) {
            self.offset = ::std::option::Option::None;
        }

        pub fn has_offset(&self) -> bool {
            self.offset.is_some()
        }

        // Param is passed by value, moved
        pub fn set_offset(&mut self, v: i64) {
            self.offset = ::std::option::Option::Some(v);
        }

        // optional int32 param = 3;

        pub fn param(&self) -> i32 {
            self.param.unwrap_or(0)
        }

        pub fn clear_param(&mut self) {
            self.param = ::std::option::Option::None;
        }

        pub fn has_param(&self) -> bool {
            self.param.is_some()
        }

        // Param is passed by value, moved
        pub fn set_param(&mut self, v: i32) {
            self.param = ::std::option::Option::Some(v);
        }

        // optional int32 length = 4;

        pub fn length(&self) -> i32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: i32) {
            self.length = ::std::option::Option::Some(v);
        }

        // optional int32 type = 5;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional int64 base = 6;

        pub fn base(&self) -> i64 {
            self.base.unwrap_or(0)
        }

        pub fn clear_base(&mut self) {
            self.base = ::std::option::Option::None;
        }

        pub fn has_base(&self) -> bool {
            self.base.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: i64) {
            self.base = ::std::option::Option::Some(v);
        }

        // optional int64 range = 7;

        pub fn range(&self) -> i64 {
            self.range.unwrap_or(0)
        }

        pub fn clear_range(&mut self) {
            self.range = ::std::option::Option::None;
        }

        pub fn has_range(&self) -> bool {
            self.range.is_some()
        }

        // Param is passed by value, moved
        pub fn set_range(&mut self, v: i64) {
            self.range = ::std::option::Option::Some(v);
        }

        // optional int64 extent = 8;

        pub fn extent(&self) -> i64 {
            self.extent.unwrap_or(0)
        }

        pub fn clear_extent(&mut self) {
            self.extent = ::std::option::Option::None;
        }

        pub fn has_extent(&self) -> bool {
            self.extent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extent(&mut self, v: i64) {
            self.extent = ::std::option::Option::Some(v);
        }

        // optional int64 detail = 9;

        pub fn detail(&self) -> i64 {
            self.detail.unwrap_or(0)
        }

        pub fn clear_detail(&mut self) {
            self.detail = ::std::option::Option::None;
        }

        pub fn has_detail(&self) -> bool {
            self.detail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_detail(&mut self, v: i64) {
            self.detail = ::std::option::Option::Some(v);
        }

        // optional string name = 10;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string alias = 11;

        pub fn alias(&self) -> &str {
            match self.alias.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_alias(&mut self) {
            self.alias = ::std::option::Option::None;
        }

        pub fn has_alias(&self) -> bool {
            self.alias.is_some()
        }

        // Param is passed by value, moved
        pub fn set_alias(&mut self, v: ::std::string::String) {
            self.alias = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_alias(&mut self) -> &mut ::std::string::String {
            if self.alias.is_none() {
                self.alias = ::std::option::Option::Some(::std::string::String::new());
            }
            self.alias.as_mut().unwrap()
        }

        // Take field
        pub fn take_alias(&mut self) -> ::std::string::String {
            self.alias.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes vardetail = 12;

        pub fn vardetail(&self) -> &[u8] {
            match self.vardetail.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_vardetail(&mut self) {
            self.vardetail = ::std::option::Option::None;
        }

        pub fn has_vardetail(&self) -> bool {
            self.vardetail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vardetail(&mut self, v: ::bytes::Bytes) {
            self.vardetail = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vardetail(&mut self) -> &mut ::bytes::Bytes {
            if self.vardetail.is_none() {
                self.vardetail = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.vardetail.as_mut().unwrap()
        }

        // Take field
        pub fn take_vardetail(&mut self) -> ::bytes::Bytes {
            self.vardetail.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional int32 context = 13;

        pub fn context(&self) -> i32 {
            self.context.unwrap_or(0)
        }

        pub fn clear_context(&mut self) {
            self.context = ::std::option::Option::None;
        }

        pub fn has_context(&self) -> bool {
            self.context.is_some()
        }

        // Param is passed by value, moved
        pub fn set_context(&mut self, v: i32) {
            self.context = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(13);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "index",
                |m: &Diagnostic| { &m.index },
                |m: &mut Diagnostic| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "offset",
                |m: &Diagnostic| { &m.offset },
                |m: &mut Diagnostic| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "param",
                |m: &Diagnostic| { &m.param },
                |m: &mut Diagnostic| { &mut m.param },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "length",
                |m: &Diagnostic| { &m.length },
                |m: &mut Diagnostic| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Diagnostic| { &m.type_ },
                |m: &mut Diagnostic| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base",
                |m: &Diagnostic| { &m.base },
                |m: &mut Diagnostic| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "range",
                |m: &Diagnostic| { &m.range },
                |m: &mut Diagnostic| { &mut m.range },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "extent",
                |m: &Diagnostic| { &m.extent },
                |m: &mut Diagnostic| { &mut m.extent },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "detail",
                |m: &Diagnostic| { &m.detail },
                |m: &mut Diagnostic| { &mut m.detail },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Diagnostic| { &m.name },
                |m: &mut Diagnostic| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "alias",
                |m: &Diagnostic| { &m.alias },
                |m: &mut Diagnostic| { &mut m.alias },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "vardetail",
                |m: &Diagnostic| { &m.vardetail },
                |m: &mut Diagnostic| { &mut m.vardetail },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "context",
                |m: &Diagnostic| { &m.context },
                |m: &mut Diagnostic| { &mut m.context },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Diagnostic>(
                "CUserMessageRequestDiagnostic.Diagnostic",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Diagnostic {
        const NAME: &'static str = "Diagnostic";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.offset = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.param = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.length = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.base = ::std::option::Option::Some(is.read_int64()?);
                    },
                    56 => {
                        self.range = ::std::option::Option::Some(is.read_int64()?);
                    },
                    64 => {
                        self.extent = ::std::option::Option::Some(is.read_int64()?);
                    },
                    72 => {
                        self.detail = ::std::option::Option::Some(is.read_int64()?);
                    },
                    82 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    90 => {
                        self.alias = ::std::option::Option::Some(is.read_string()?);
                    },
                    98 => {
                        self.vardetail = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    104 => {
                        self.context = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.offset {
                my_size += ::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.param {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.length {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.base {
                my_size += ::protobuf::rt::int64_size(6, v);
            }
            if let Some(v) = self.range {
                my_size += ::protobuf::rt::int64_size(7, v);
            }
            if let Some(v) = self.extent {
                my_size += ::protobuf::rt::int64_size(8, v);
            }
            if let Some(v) = self.detail {
                my_size += ::protobuf::rt::int64_size(9, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.alias.as_ref() {
                my_size += ::protobuf::rt::string_size(11, &v);
            }
            if let Some(v) = self.vardetail.as_ref() {
                my_size += ::protobuf::rt::bytes_size(12, &v);
            }
            if let Some(v) = self.context {
                my_size += ::protobuf::rt::int32_size(13, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.offset {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.param {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.length {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.base {
                os.write_int64(6, v)?;
            }
            if let Some(v) = self.range {
                os.write_int64(7, v)?;
            }
            if let Some(v) = self.extent {
                os.write_int64(8, v)?;
            }
            if let Some(v) = self.detail {
                os.write_int64(9, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.alias.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.vardetail.as_ref() {
                os.write_bytes(12, v)?;
            }
            if let Some(v) = self.context {
                os.write_int32(13, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Diagnostic {
            Diagnostic::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.offset = ::std::option::Option::None;
            self.param = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.base = ::std::option::Option::None;
            self.range = ::std::option::Option::None;
            self.extent = ::std::option::Option::None;
            self.detail = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.alias = ::std::option::Option::None;
            self.vardetail = ::std::option::Option::None;
            self.context = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Diagnostic {
            static instance: Diagnostic = Diagnostic {
                index: ::std::option::Option::None,
                offset: ::std::option::Option::None,
                param: ::std::option::Option::None,
                length: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                base: ::std::option::Option::None,
                range: ::std::option::Option::None,
                extent: ::std::option::Option::None,
                detail: ::std::option::Option::None,
                name: ::std::option::Option::None,
                alias: ::std::option::Option::None,
                vardetail: ::std::option::Option::None,
                context: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Diagnostic {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMessageRequestDiagnostic.Diagnostic").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Diagnostic {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Diagnostic {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CUserMessage_Diagnostic_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_Diagnostic_Response {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.diagnostics)
    pub diagnostics: ::std::vec::Vec<cuser_message_diagnostic_response::Diagnostic>,
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.build_version)
    pub build_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.instance)
    pub instance: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.start_time)
    pub start_time: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.osversion)
    pub osversion: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.platform)
    pub platform: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_Diagnostic_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_Diagnostic_Response {
    fn default() -> &'a CUserMessage_Diagnostic_Response {
        <CUserMessage_Diagnostic_Response as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_Diagnostic_Response {
    pub fn new() -> CUserMessage_Diagnostic_Response {
        ::std::default::Default::default()
    }

    // optional int32 build_version = 2;

    pub fn build_version(&self) -> i32 {
        self.build_version.unwrap_or(0)
    }

    pub fn clear_build_version(&mut self) {
        self.build_version = ::std::option::Option::None;
    }

    pub fn has_build_version(&self) -> bool {
        self.build_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_version(&mut self, v: i32) {
        self.build_version = ::std::option::Option::Some(v);
    }

    // optional int32 instance = 3;

    pub fn instance(&self) -> i32 {
        self.instance.unwrap_or(0)
    }

    pub fn clear_instance(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: i32) {
        self.instance = ::std::option::Option::Some(v);
    }

    // optional int64 start_time = 4;

    pub fn start_time(&self) -> i64 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional int32 osversion = 5;

    pub fn osversion(&self) -> i32 {
        self.osversion.unwrap_or(0)
    }

    pub fn clear_osversion(&mut self) {
        self.osversion = ::std::option::Option::None;
    }

    pub fn has_osversion(&self) -> bool {
        self.osversion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osversion(&mut self, v: i32) {
        self.osversion = ::std::option::Option::Some(v);
    }

    // optional int32 platform = 6;

    pub fn platform(&self) -> i32 {
        self.platform.unwrap_or(0)
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: i32) {
        self.platform = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "diagnostics",
            |m: &CUserMessage_Diagnostic_Response| { &m.diagnostics },
            |m: &mut CUserMessage_Diagnostic_Response| { &mut m.diagnostics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_version",
            |m: &CUserMessage_Diagnostic_Response| { &m.build_version },
            |m: &mut CUserMessage_Diagnostic_Response| { &mut m.build_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "instance",
            |m: &CUserMessage_Diagnostic_Response| { &m.instance },
            |m: &mut CUserMessage_Diagnostic_Response| { &mut m.instance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CUserMessage_Diagnostic_Response| { &m.start_time },
            |m: &mut CUserMessage_Diagnostic_Response| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osversion",
            |m: &CUserMessage_Diagnostic_Response| { &m.osversion },
            |m: &mut CUserMessage_Diagnostic_Response| { &mut m.osversion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform",
            |m: &CUserMessage_Diagnostic_Response| { &m.platform },
            |m: &mut CUserMessage_Diagnostic_Response| { &mut m.platform },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessage_Diagnostic_Response>(
            "CUserMessage_Diagnostic_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessage_Diagnostic_Response {
    const NAME: &'static str = "CUserMessage_Diagnostic_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.diagnostics.push(is.read_message()?);
                },
                16 => {
                    self.build_version = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.instance = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.start_time = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.osversion = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.platform = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.build_version {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.instance {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.osversion {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.platform {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.diagnostics {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.build_version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.instance {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.osversion {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.platform {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_Diagnostic_Response {
        CUserMessage_Diagnostic_Response::new()
    }

    fn clear(&mut self) {
        self.diagnostics.clear();
        self.build_version = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.osversion = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_Diagnostic_Response {
        static instance: CUserMessage_Diagnostic_Response = CUserMessage_Diagnostic_Response {
            diagnostics: ::std::vec::Vec::new(),
            build_version: ::std::option::Option::None,
            instance: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            osversion: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessage_Diagnostic_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessage_Diagnostic_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessage_Diagnostic_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessage_Diagnostic_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUserMessage_Diagnostic_Response`
pub mod cuser_message_diagnostic_response {
    // @@protoc_insertion_point(message:CUserMessage_Diagnostic_Response.Diagnostic)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Diagnostic {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.offset)
        pub offset: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.param)
        pub param: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.length)
        pub length: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.detail)
        pub detail: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.base)
        pub base: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.range)
        pub range: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.alias)
        pub alias: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.backup)
        pub backup: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.context)
        pub context: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.control)
        pub control: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.augment)
        pub augment: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.placebo)
        pub placebo: ::std::option::Option<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_Diagnostic_Response.Diagnostic.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Diagnostic {
        fn default() -> &'a Diagnostic {
            <Diagnostic as ::protobuf::Message>::default_instance()
        }
    }

    impl Diagnostic {
        pub fn new() -> Diagnostic {
            ::std::default::Default::default()
        }

        // optional int32 index = 1;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int64 offset = 2;

        pub fn offset(&self) -> i64 {
            self.offset.unwrap_or(0)
        }

        pub fn clear_offset(&mut self) {
            self.offset = ::std::option::Option::None;
        }

        pub fn has_offset(&self) -> bool {
            self.offset.is_some()
        }

        // Param is passed by value, moved
        pub fn set_offset(&mut self, v: i64) {
            self.offset = ::std::option::Option::Some(v);
        }

        // optional int32 param = 3;

        pub fn param(&self) -> i32 {
            self.param.unwrap_or(0)
        }

        pub fn clear_param(&mut self) {
            self.param = ::std::option::Option::None;
        }

        pub fn has_param(&self) -> bool {
            self.param.is_some()
        }

        // Param is passed by value, moved
        pub fn set_param(&mut self, v: i32) {
            self.param = ::std::option::Option::Some(v);
        }

        // optional int32 length = 4;

        pub fn length(&self) -> i32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: i32) {
            self.length = ::std::option::Option::Some(v);
        }

        // optional bytes detail = 5;

        pub fn detail(&self) -> &[u8] {
            match self.detail.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_detail(&mut self) {
            self.detail = ::std::option::Option::None;
        }

        pub fn has_detail(&self) -> bool {
            self.detail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_detail(&mut self, v: ::bytes::Bytes) {
            self.detail = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_detail(&mut self) -> &mut ::bytes::Bytes {
            if self.detail.is_none() {
                self.detail = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.detail.as_mut().unwrap()
        }

        // Take field
        pub fn take_detail(&mut self) -> ::bytes::Bytes {
            self.detail.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional int64 base = 6;

        pub fn base(&self) -> i64 {
            self.base.unwrap_or(0)
        }

        pub fn clear_base(&mut self) {
            self.base = ::std::option::Option::None;
        }

        pub fn has_base(&self) -> bool {
            self.base.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: i64) {
            self.base = ::std::option::Option::Some(v);
        }

        // optional int64 range = 7;

        pub fn range(&self) -> i64 {
            self.range.unwrap_or(0)
        }

        pub fn clear_range(&mut self) {
            self.range = ::std::option::Option::None;
        }

        pub fn has_range(&self) -> bool {
            self.range.is_some()
        }

        // Param is passed by value, moved
        pub fn set_range(&mut self, v: i64) {
            self.range = ::std::option::Option::Some(v);
        }

        // optional int32 type = 8;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string name = 10;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string alias = 11;

        pub fn alias(&self) -> &str {
            match self.alias.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_alias(&mut self) {
            self.alias = ::std::option::Option::None;
        }

        pub fn has_alias(&self) -> bool {
            self.alias.is_some()
        }

        // Param is passed by value, moved
        pub fn set_alias(&mut self, v: ::std::string::String) {
            self.alias = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_alias(&mut self) -> &mut ::std::string::String {
            if self.alias.is_none() {
                self.alias = ::std::option::Option::Some(::std::string::String::new());
            }
            self.alias.as_mut().unwrap()
        }

        // Take field
        pub fn take_alias(&mut self) -> ::std::string::String {
            self.alias.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes backup = 12;

        pub fn backup(&self) -> &[u8] {
            match self.backup.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_backup(&mut self) {
            self.backup = ::std::option::Option::None;
        }

        pub fn has_backup(&self) -> bool {
            self.backup.is_some()
        }

        // Param is passed by value, moved
        pub fn set_backup(&mut self, v: ::bytes::Bytes) {
            self.backup = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_backup(&mut self) -> &mut ::bytes::Bytes {
            if self.backup.is_none() {
                self.backup = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.backup.as_mut().unwrap()
        }

        // Take field
        pub fn take_backup(&mut self) -> ::bytes::Bytes {
            self.backup.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional int32 context = 13;

        pub fn context(&self) -> i32 {
            self.context.unwrap_or(0)
        }

        pub fn clear_context(&mut self) {
            self.context = ::std::option::Option::None;
        }

        pub fn has_context(&self) -> bool {
            self.context.is_some()
        }

        // Param is passed by value, moved
        pub fn set_context(&mut self, v: i32) {
            self.context = ::std::option::Option::Some(v);
        }

        // optional int64 control = 14;

        pub fn control(&self) -> i64 {
            self.control.unwrap_or(0)
        }

        pub fn clear_control(&mut self) {
            self.control = ::std::option::Option::None;
        }

        pub fn has_control(&self) -> bool {
            self.control.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control(&mut self, v: i64) {
            self.control = ::std::option::Option::Some(v);
        }

        // optional int64 augment = 15;

        pub fn augment(&self) -> i64 {
            self.augment.unwrap_or(0)
        }

        pub fn clear_augment(&mut self) {
            self.augment = ::std::option::Option::None;
        }

        pub fn has_augment(&self) -> bool {
            self.augment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_augment(&mut self, v: i64) {
            self.augment = ::std::option::Option::Some(v);
        }

        // optional int64 placebo = 16;

        pub fn placebo(&self) -> i64 {
            self.placebo.unwrap_or(0)
        }

        pub fn clear_placebo(&mut self) {
            self.placebo = ::std::option::Option::None;
        }

        pub fn has_placebo(&self) -> bool {
            self.placebo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_placebo(&mut self, v: i64) {
            self.placebo = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(15);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "index",
                |m: &Diagnostic| { &m.index },
                |m: &mut Diagnostic| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "offset",
                |m: &Diagnostic| { &m.offset },
                |m: &mut Diagnostic| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "param",
                |m: &Diagnostic| { &m.param },
                |m: &mut Diagnostic| { &mut m.param },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "length",
                |m: &Diagnostic| { &m.length },
                |m: &mut Diagnostic| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "detail",
                |m: &Diagnostic| { &m.detail },
                |m: &mut Diagnostic| { &mut m.detail },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "base",
                |m: &Diagnostic| { &m.base },
                |m: &mut Diagnostic| { &mut m.base },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "range",
                |m: &Diagnostic| { &m.range },
                |m: &mut Diagnostic| { &mut m.range },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Diagnostic| { &m.type_ },
                |m: &mut Diagnostic| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Diagnostic| { &m.name },
                |m: &mut Diagnostic| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "alias",
                |m: &Diagnostic| { &m.alias },
                |m: &mut Diagnostic| { &mut m.alias },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "backup",
                |m: &Diagnostic| { &m.backup },
                |m: &mut Diagnostic| { &mut m.backup },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "context",
                |m: &Diagnostic| { &m.context },
                |m: &mut Diagnostic| { &mut m.context },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "control",
                |m: &Diagnostic| { &m.control },
                |m: &mut Diagnostic| { &mut m.control },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "augment",
                |m: &Diagnostic| { &m.augment },
                |m: &mut Diagnostic| { &mut m.augment },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "placebo",
                |m: &Diagnostic| { &m.placebo },
                |m: &mut Diagnostic| { &mut m.placebo },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Diagnostic>(
                "CUserMessage_Diagnostic_Response.Diagnostic",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Diagnostic {
        const NAME: &'static str = "Diagnostic";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.offset = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.param = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.length = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        self.detail = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    48 => {
                        self.base = ::std::option::Option::Some(is.read_int64()?);
                    },
                    56 => {
                        self.range = ::std::option::Option::Some(is.read_int64()?);
                    },
                    64 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    82 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    90 => {
                        self.alias = ::std::option::Option::Some(is.read_string()?);
                    },
                    98 => {
                        self.backup = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    104 => {
                        self.context = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.control = ::std::option::Option::Some(is.read_int64()?);
                    },
                    120 => {
                        self.augment = ::std::option::Option::Some(is.read_int64()?);
                    },
                    128 => {
                        self.placebo = ::std::option::Option::Some(is.read_int64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.offset {
                my_size += ::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.param {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.length {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.detail.as_ref() {
                my_size += ::protobuf::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.base {
                my_size += ::protobuf::rt::int64_size(6, v);
            }
            if let Some(v) = self.range {
                my_size += ::protobuf::rt::int64_size(7, v);
            }
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.alias.as_ref() {
                my_size += ::protobuf::rt::string_size(11, &v);
            }
            if let Some(v) = self.backup.as_ref() {
                my_size += ::protobuf::rt::bytes_size(12, &v);
            }
            if let Some(v) = self.context {
                my_size += ::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.control {
                my_size += ::protobuf::rt::int64_size(14, v);
            }
            if let Some(v) = self.augment {
                my_size += ::protobuf::rt::int64_size(15, v);
            }
            if let Some(v) = self.placebo {
                my_size += ::protobuf::rt::int64_size(16, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.offset {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.param {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.length {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.detail.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.base {
                os.write_int64(6, v)?;
            }
            if let Some(v) = self.range {
                os.write_int64(7, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.alias.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.backup.as_ref() {
                os.write_bytes(12, v)?;
            }
            if let Some(v) = self.context {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.control {
                os.write_int64(14, v)?;
            }
            if let Some(v) = self.augment {
                os.write_int64(15, v)?;
            }
            if let Some(v) = self.placebo {
                os.write_int64(16, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Diagnostic {
            Diagnostic::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.offset = ::std::option::Option::None;
            self.param = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.detail = ::std::option::Option::None;
            self.base = ::std::option::Option::None;
            self.range = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.alias = ::std::option::Option::None;
            self.backup = ::std::option::Option::None;
            self.context = ::std::option::Option::None;
            self.control = ::std::option::Option::None;
            self.augment = ::std::option::Option::None;
            self.placebo = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Diagnostic {
            static instance: Diagnostic = Diagnostic {
                index: ::std::option::Option::None,
                offset: ::std::option::Option::None,
                param: ::std::option::Option::None,
                length: ::std::option::Option::None,
                detail: ::std::option::Option::None,
                base: ::std::option::Option::None,
                range: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                name: ::std::option::Option::None,
                alias: ::std::option::Option::None,
                backup: ::std::option::Option::None,
                context: ::std::option::Option::None,
                control: ::std::option::Option::None,
                augment: ::std::option::Option::None,
                placebo: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Diagnostic {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUserMessage_Diagnostic_Response.Diagnostic").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Diagnostic {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Diagnostic {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CUserMessage_ExtraUserData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_ExtraUserData {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_ExtraUserData.item)
    pub item: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_ExtraUserData.value1)
    pub value1: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CUserMessage_ExtraUserData.value2)
    pub value2: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CUserMessage_ExtraUserData.detail1)
    pub detail1: ::std::vec::Vec<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CUserMessage_ExtraUserData.detail2)
    pub detail2: ::std::vec::Vec<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_ExtraUserData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_ExtraUserData {
    fn default() -> &'a CUserMessage_ExtraUserData {
        <CUserMessage_ExtraUserData as ::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_ExtraUserData {
    pub fn new() -> CUserMessage_ExtraUserData {
        ::std::default::Default::default()
    }

    // optional int32 item = 1;

    pub fn item(&self) -> i32 {
        self.item.unwrap_or(0)
    }

    pub fn clear_item(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: i32) {
        self.item = ::std::option::Option::Some(v);
    }

    // optional int64 value1 = 2;

    pub fn value1(&self) -> i64 {
        self.value1.unwrap_or(0)
    }

    pub fn clear_value1(&mut self) {
        self.value1 = ::std::option::Option::None;
    }

    pub fn has_value1(&self) -> bool {
        self.value1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value1(&mut self, v: i64) {
        self.value1 = ::std::option::Option::Some(v);
    }

    // optional int64 value2 = 3;

    pub fn value2(&self) -> i64 {
        self.value2.unwrap_or(0)
    }

    pub fn clear_value2(&mut self) {
        self.value2 = ::std::option::Option::None;
    }

    pub fn has_value2(&self) -> bool {
        self.value2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value2(&mut self, v: i64) {
        self.value2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item",
            |m: &CUserMessage_ExtraUserData| { &m.item },
            |m: &mut CUserMessage_ExtraUserData| { &mut m.item },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value1",
            |m: &CUserMessage_ExtraUserData| { &m.value1 },
            |m: &mut CUserMessage_ExtraUserData| { &mut m.value1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value2",
            |m: &CUserMessage_ExtraUserData| { &m.value2 },
            |m: &mut CUserMessage_ExtraUserData| { &mut m.value2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "detail1",
            |m: &CUserMessage_ExtraUserData| { &m.detail1 },
            |m: &mut CUserMessage_ExtraUserData| { &mut m.detail1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "detail2",
            |m: &CUserMessage_ExtraUserData| { &m.detail2 },
            |m: &mut CUserMessage_ExtraUserData| { &mut m.detail2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUserMessage_ExtraUserData>(
            "CUserMessage_ExtraUserData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUserMessage_ExtraUserData {
    const NAME: &'static str = "CUserMessage_ExtraUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.value1 = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.value2 = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    self.detail1.push(is.read_tokio_bytes()?);
                },
                42 => {
                    self.detail2.push(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.value1 {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.value2 {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        for value in &self.detail1 {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in &self.detail2 {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.value1 {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.value2 {
            os.write_int64(3, v)?;
        }
        for v in &self.detail1 {
            os.write_bytes(4, &v)?;
        };
        for v in &self.detail2 {
            os.write_bytes(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_ExtraUserData {
        CUserMessage_ExtraUserData::new()
    }

    fn clear(&mut self) {
        self.item = ::std::option::Option::None;
        self.value1 = ::std::option::Option::None;
        self.value2 = ::std::option::Option::None;
        self.detail1.clear();
        self.detail2.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_ExtraUserData {
        static instance: CUserMessage_ExtraUserData = CUserMessage_ExtraUserData {
            item: ::std::option::Option::None,
            value1: ::std::option::Option::None,
            value2: ::std::option::Option::None,
            detail1: ::std::vec::Vec::new(),
            detail2: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUserMessage_ExtraUserData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserMessage_ExtraUserData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserMessage_ExtraUserData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUserMessage_ExtraUserData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBaseUserMessages)
pub enum EBaseUserMessages {
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_AchievementEvent)
    UM_AchievementEvent = 101,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CloseCaption)
    UM_CloseCaption = 102,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CloseCaptionDirect)
    UM_CloseCaptionDirect = 103,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CurrentTimescale)
    UM_CurrentTimescale = 104,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_DesiredTimescale)
    UM_DesiredTimescale = 105,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_Fade)
    UM_Fade = 106,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_GameTitle)
    UM_GameTitle = 107,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_HudMsg)
    UM_HudMsg = 110,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_HudText)
    UM_HudText = 111,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ColoredText)
    UM_ColoredText = 113,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_RequestState)
    UM_RequestState = 114,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ResetHUD)
    UM_ResetHUD = 115,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_Rumble)
    UM_Rumble = 116,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_SayText)
    UM_SayText = 117,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_SayText2)
    UM_SayText2 = 118,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_SayTextChannel)
    UM_SayTextChannel = 119,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_Shake)
    UM_Shake = 120,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ShakeDir)
    UM_ShakeDir = 121,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_WaterShake)
    UM_WaterShake = 122,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_TextMsg)
    UM_TextMsg = 124,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ScreenTilt)
    UM_ScreenTilt = 125,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_VoiceMask)
    UM_VoiceMask = 128,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_SendAudio)
    UM_SendAudio = 130,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ItemPickup)
    UM_ItemPickup = 131,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_AmmoDenied)
    UM_AmmoDenied = 132,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ShowMenu)
    UM_ShowMenu = 134,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CreditsMsg)
    UM_CreditsMsg = 135,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CloseCaptionPlaceholder)
    UM_CloseCaptionPlaceholder = 142,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CameraTransition)
    UM_CameraTransition = 143,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_AudioParameter)
    UM_AudioParameter = 144,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ParticleManager)
    UM_ParticleManager = 145,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_HudError)
    UM_HudError = 146,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CustomGameEvent)
    UM_CustomGameEvent = 148,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_AnimGraphUpdate)
    UM_AnimGraphUpdate = 149,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_HapticsManagerPulse)
    UM_HapticsManagerPulse = 150,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_HapticsManagerEffect)
    UM_HapticsManagerEffect = 151,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CommandQueueState)
    UM_CommandQueueState = 152,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_UpdateCssClasses)
    UM_UpdateCssClasses = 153,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ServerFrameTime)
    UM_ServerFrameTime = 154,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_LagCompensationError)
    UM_LagCompensationError = 155,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_RequestDllStatus)
    UM_RequestDllStatus = 156,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_RequestUtilAction)
    UM_RequestUtilAction = 157,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_UtilActionResponse)
    UM_UtilActionResponse = 158,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_DllStatusResponse)
    UM_DllStatusResponse = 159,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_RequestInventory)
    UM_RequestInventory = 160,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_InventoryResponse)
    UM_InventoryResponse = 161,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_RequestDiagnostic)
    UM_RequestDiagnostic = 162,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_DiagnosticResponse)
    UM_DiagnosticResponse = 163,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ExtraUserData)
    UM_ExtraUserData = 164,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_MAX_BASE)
    UM_MAX_BASE = 200,
}

impl ::protobuf::Enum for EBaseUserMessages {
    const NAME: &'static str = "EBaseUserMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBaseUserMessages> {
        match value {
            101 => ::std::option::Option::Some(EBaseUserMessages::UM_AchievementEvent),
            102 => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaption),
            103 => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaptionDirect),
            104 => ::std::option::Option::Some(EBaseUserMessages::UM_CurrentTimescale),
            105 => ::std::option::Option::Some(EBaseUserMessages::UM_DesiredTimescale),
            106 => ::std::option::Option::Some(EBaseUserMessages::UM_Fade),
            107 => ::std::option::Option::Some(EBaseUserMessages::UM_GameTitle),
            110 => ::std::option::Option::Some(EBaseUserMessages::UM_HudMsg),
            111 => ::std::option::Option::Some(EBaseUserMessages::UM_HudText),
            113 => ::std::option::Option::Some(EBaseUserMessages::UM_ColoredText),
            114 => ::std::option::Option::Some(EBaseUserMessages::UM_RequestState),
            115 => ::std::option::Option::Some(EBaseUserMessages::UM_ResetHUD),
            116 => ::std::option::Option::Some(EBaseUserMessages::UM_Rumble),
            117 => ::std::option::Option::Some(EBaseUserMessages::UM_SayText),
            118 => ::std::option::Option::Some(EBaseUserMessages::UM_SayText2),
            119 => ::std::option::Option::Some(EBaseUserMessages::UM_SayTextChannel),
            120 => ::std::option::Option::Some(EBaseUserMessages::UM_Shake),
            121 => ::std::option::Option::Some(EBaseUserMessages::UM_ShakeDir),
            122 => ::std::option::Option::Some(EBaseUserMessages::UM_WaterShake),
            124 => ::std::option::Option::Some(EBaseUserMessages::UM_TextMsg),
            125 => ::std::option::Option::Some(EBaseUserMessages::UM_ScreenTilt),
            128 => ::std::option::Option::Some(EBaseUserMessages::UM_VoiceMask),
            130 => ::std::option::Option::Some(EBaseUserMessages::UM_SendAudio),
            131 => ::std::option::Option::Some(EBaseUserMessages::UM_ItemPickup),
            132 => ::std::option::Option::Some(EBaseUserMessages::UM_AmmoDenied),
            134 => ::std::option::Option::Some(EBaseUserMessages::UM_ShowMenu),
            135 => ::std::option::Option::Some(EBaseUserMessages::UM_CreditsMsg),
            142 => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaptionPlaceholder),
            143 => ::std::option::Option::Some(EBaseUserMessages::UM_CameraTransition),
            144 => ::std::option::Option::Some(EBaseUserMessages::UM_AudioParameter),
            145 => ::std::option::Option::Some(EBaseUserMessages::UM_ParticleManager),
            146 => ::std::option::Option::Some(EBaseUserMessages::UM_HudError),
            148 => ::std::option::Option::Some(EBaseUserMessages::UM_CustomGameEvent),
            149 => ::std::option::Option::Some(EBaseUserMessages::UM_AnimGraphUpdate),
            150 => ::std::option::Option::Some(EBaseUserMessages::UM_HapticsManagerPulse),
            151 => ::std::option::Option::Some(EBaseUserMessages::UM_HapticsManagerEffect),
            152 => ::std::option::Option::Some(EBaseUserMessages::UM_CommandQueueState),
            153 => ::std::option::Option::Some(EBaseUserMessages::UM_UpdateCssClasses),
            154 => ::std::option::Option::Some(EBaseUserMessages::UM_ServerFrameTime),
            155 => ::std::option::Option::Some(EBaseUserMessages::UM_LagCompensationError),
            156 => ::std::option::Option::Some(EBaseUserMessages::UM_RequestDllStatus),
            157 => ::std::option::Option::Some(EBaseUserMessages::UM_RequestUtilAction),
            158 => ::std::option::Option::Some(EBaseUserMessages::UM_UtilActionResponse),
            159 => ::std::option::Option::Some(EBaseUserMessages::UM_DllStatusResponse),
            160 => ::std::option::Option::Some(EBaseUserMessages::UM_RequestInventory),
            161 => ::std::option::Option::Some(EBaseUserMessages::UM_InventoryResponse),
            162 => ::std::option::Option::Some(EBaseUserMessages::UM_RequestDiagnostic),
            163 => ::std::option::Option::Some(EBaseUserMessages::UM_DiagnosticResponse),
            164 => ::std::option::Option::Some(EBaseUserMessages::UM_ExtraUserData),
            200 => ::std::option::Option::Some(EBaseUserMessages::UM_MAX_BASE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBaseUserMessages> {
        match str {
            "UM_AchievementEvent" => ::std::option::Option::Some(EBaseUserMessages::UM_AchievementEvent),
            "UM_CloseCaption" => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaption),
            "UM_CloseCaptionDirect" => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaptionDirect),
            "UM_CurrentTimescale" => ::std::option::Option::Some(EBaseUserMessages::UM_CurrentTimescale),
            "UM_DesiredTimescale" => ::std::option::Option::Some(EBaseUserMessages::UM_DesiredTimescale),
            "UM_Fade" => ::std::option::Option::Some(EBaseUserMessages::UM_Fade),
            "UM_GameTitle" => ::std::option::Option::Some(EBaseUserMessages::UM_GameTitle),
            "UM_HudMsg" => ::std::option::Option::Some(EBaseUserMessages::UM_HudMsg),
            "UM_HudText" => ::std::option::Option::Some(EBaseUserMessages::UM_HudText),
            "UM_ColoredText" => ::std::option::Option::Some(EBaseUserMessages::UM_ColoredText),
            "UM_RequestState" => ::std::option::Option::Some(EBaseUserMessages::UM_RequestState),
            "UM_ResetHUD" => ::std::option::Option::Some(EBaseUserMessages::UM_ResetHUD),
            "UM_Rumble" => ::std::option::Option::Some(EBaseUserMessages::UM_Rumble),
            "UM_SayText" => ::std::option::Option::Some(EBaseUserMessages::UM_SayText),
            "UM_SayText2" => ::std::option::Option::Some(EBaseUserMessages::UM_SayText2),
            "UM_SayTextChannel" => ::std::option::Option::Some(EBaseUserMessages::UM_SayTextChannel),
            "UM_Shake" => ::std::option::Option::Some(EBaseUserMessages::UM_Shake),
            "UM_ShakeDir" => ::std::option::Option::Some(EBaseUserMessages::UM_ShakeDir),
            "UM_WaterShake" => ::std::option::Option::Some(EBaseUserMessages::UM_WaterShake),
            "UM_TextMsg" => ::std::option::Option::Some(EBaseUserMessages::UM_TextMsg),
            "UM_ScreenTilt" => ::std::option::Option::Some(EBaseUserMessages::UM_ScreenTilt),
            "UM_VoiceMask" => ::std::option::Option::Some(EBaseUserMessages::UM_VoiceMask),
            "UM_SendAudio" => ::std::option::Option::Some(EBaseUserMessages::UM_SendAudio),
            "UM_ItemPickup" => ::std::option::Option::Some(EBaseUserMessages::UM_ItemPickup),
            "UM_AmmoDenied" => ::std::option::Option::Some(EBaseUserMessages::UM_AmmoDenied),
            "UM_ShowMenu" => ::std::option::Option::Some(EBaseUserMessages::UM_ShowMenu),
            "UM_CreditsMsg" => ::std::option::Option::Some(EBaseUserMessages::UM_CreditsMsg),
            "UM_CloseCaptionPlaceholder" => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaptionPlaceholder),
            "UM_CameraTransition" => ::std::option::Option::Some(EBaseUserMessages::UM_CameraTransition),
            "UM_AudioParameter" => ::std::option::Option::Some(EBaseUserMessages::UM_AudioParameter),
            "UM_ParticleManager" => ::std::option::Option::Some(EBaseUserMessages::UM_ParticleManager),
            "UM_HudError" => ::std::option::Option::Some(EBaseUserMessages::UM_HudError),
            "UM_CustomGameEvent" => ::std::option::Option::Some(EBaseUserMessages::UM_CustomGameEvent),
            "UM_AnimGraphUpdate" => ::std::option::Option::Some(EBaseUserMessages::UM_AnimGraphUpdate),
            "UM_HapticsManagerPulse" => ::std::option::Option::Some(EBaseUserMessages::UM_HapticsManagerPulse),
            "UM_HapticsManagerEffect" => ::std::option::Option::Some(EBaseUserMessages::UM_HapticsManagerEffect),
            "UM_CommandQueueState" => ::std::option::Option::Some(EBaseUserMessages::UM_CommandQueueState),
            "UM_UpdateCssClasses" => ::std::option::Option::Some(EBaseUserMessages::UM_UpdateCssClasses),
            "UM_ServerFrameTime" => ::std::option::Option::Some(EBaseUserMessages::UM_ServerFrameTime),
            "UM_LagCompensationError" => ::std::option::Option::Some(EBaseUserMessages::UM_LagCompensationError),
            "UM_RequestDllStatus" => ::std::option::Option::Some(EBaseUserMessages::UM_RequestDllStatus),
            "UM_RequestUtilAction" => ::std::option::Option::Some(EBaseUserMessages::UM_RequestUtilAction),
            "UM_UtilActionResponse" => ::std::option::Option::Some(EBaseUserMessages::UM_UtilActionResponse),
            "UM_DllStatusResponse" => ::std::option::Option::Some(EBaseUserMessages::UM_DllStatusResponse),
            "UM_RequestInventory" => ::std::option::Option::Some(EBaseUserMessages::UM_RequestInventory),
            "UM_InventoryResponse" => ::std::option::Option::Some(EBaseUserMessages::UM_InventoryResponse),
            "UM_RequestDiagnostic" => ::std::option::Option::Some(EBaseUserMessages::UM_RequestDiagnostic),
            "UM_DiagnosticResponse" => ::std::option::Option::Some(EBaseUserMessages::UM_DiagnosticResponse),
            "UM_ExtraUserData" => ::std::option::Option::Some(EBaseUserMessages::UM_ExtraUserData),
            "UM_MAX_BASE" => ::std::option::Option::Some(EBaseUserMessages::UM_MAX_BASE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBaseUserMessages] = &[
        EBaseUserMessages::UM_AchievementEvent,
        EBaseUserMessages::UM_CloseCaption,
        EBaseUserMessages::UM_CloseCaptionDirect,
        EBaseUserMessages::UM_CurrentTimescale,
        EBaseUserMessages::UM_DesiredTimescale,
        EBaseUserMessages::UM_Fade,
        EBaseUserMessages::UM_GameTitle,
        EBaseUserMessages::UM_HudMsg,
        EBaseUserMessages::UM_HudText,
        EBaseUserMessages::UM_ColoredText,
        EBaseUserMessages::UM_RequestState,
        EBaseUserMessages::UM_ResetHUD,
        EBaseUserMessages::UM_Rumble,
        EBaseUserMessages::UM_SayText,
        EBaseUserMessages::UM_SayText2,
        EBaseUserMessages::UM_SayTextChannel,
        EBaseUserMessages::UM_Shake,
        EBaseUserMessages::UM_ShakeDir,
        EBaseUserMessages::UM_WaterShake,
        EBaseUserMessages::UM_TextMsg,
        EBaseUserMessages::UM_ScreenTilt,
        EBaseUserMessages::UM_VoiceMask,
        EBaseUserMessages::UM_SendAudio,
        EBaseUserMessages::UM_ItemPickup,
        EBaseUserMessages::UM_AmmoDenied,
        EBaseUserMessages::UM_ShowMenu,
        EBaseUserMessages::UM_CreditsMsg,
        EBaseUserMessages::UM_CloseCaptionPlaceholder,
        EBaseUserMessages::UM_CameraTransition,
        EBaseUserMessages::UM_AudioParameter,
        EBaseUserMessages::UM_ParticleManager,
        EBaseUserMessages::UM_HudError,
        EBaseUserMessages::UM_CustomGameEvent,
        EBaseUserMessages::UM_AnimGraphUpdate,
        EBaseUserMessages::UM_HapticsManagerPulse,
        EBaseUserMessages::UM_HapticsManagerEffect,
        EBaseUserMessages::UM_CommandQueueState,
        EBaseUserMessages::UM_UpdateCssClasses,
        EBaseUserMessages::UM_ServerFrameTime,
        EBaseUserMessages::UM_LagCompensationError,
        EBaseUserMessages::UM_RequestDllStatus,
        EBaseUserMessages::UM_RequestUtilAction,
        EBaseUserMessages::UM_UtilActionResponse,
        EBaseUserMessages::UM_DllStatusResponse,
        EBaseUserMessages::UM_RequestInventory,
        EBaseUserMessages::UM_InventoryResponse,
        EBaseUserMessages::UM_RequestDiagnostic,
        EBaseUserMessages::UM_DiagnosticResponse,
        EBaseUserMessages::UM_ExtraUserData,
        EBaseUserMessages::UM_MAX_BASE,
    ];
}

impl ::protobuf::EnumFull for EBaseUserMessages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBaseUserMessages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EBaseUserMessages::UM_AchievementEvent => 0,
            EBaseUserMessages::UM_CloseCaption => 1,
            EBaseUserMessages::UM_CloseCaptionDirect => 2,
            EBaseUserMessages::UM_CurrentTimescale => 3,
            EBaseUserMessages::UM_DesiredTimescale => 4,
            EBaseUserMessages::UM_Fade => 5,
            EBaseUserMessages::UM_GameTitle => 6,
            EBaseUserMessages::UM_HudMsg => 7,
            EBaseUserMessages::UM_HudText => 8,
            EBaseUserMessages::UM_ColoredText => 9,
            EBaseUserMessages::UM_RequestState => 10,
            EBaseUserMessages::UM_ResetHUD => 11,
            EBaseUserMessages::UM_Rumble => 12,
            EBaseUserMessages::UM_SayText => 13,
            EBaseUserMessages::UM_SayText2 => 14,
            EBaseUserMessages::UM_SayTextChannel => 15,
            EBaseUserMessages::UM_Shake => 16,
            EBaseUserMessages::UM_ShakeDir => 17,
            EBaseUserMessages::UM_WaterShake => 18,
            EBaseUserMessages::UM_TextMsg => 19,
            EBaseUserMessages::UM_ScreenTilt => 20,
            EBaseUserMessages::UM_VoiceMask => 21,
            EBaseUserMessages::UM_SendAudio => 22,
            EBaseUserMessages::UM_ItemPickup => 23,
            EBaseUserMessages::UM_AmmoDenied => 24,
            EBaseUserMessages::UM_ShowMenu => 25,
            EBaseUserMessages::UM_CreditsMsg => 26,
            EBaseUserMessages::UM_CloseCaptionPlaceholder => 27,
            EBaseUserMessages::UM_CameraTransition => 28,
            EBaseUserMessages::UM_AudioParameter => 29,
            EBaseUserMessages::UM_ParticleManager => 30,
            EBaseUserMessages::UM_HudError => 31,
            EBaseUserMessages::UM_CustomGameEvent => 32,
            EBaseUserMessages::UM_AnimGraphUpdate => 33,
            EBaseUserMessages::UM_HapticsManagerPulse => 34,
            EBaseUserMessages::UM_HapticsManagerEffect => 35,
            EBaseUserMessages::UM_CommandQueueState => 36,
            EBaseUserMessages::UM_UpdateCssClasses => 37,
            EBaseUserMessages::UM_ServerFrameTime => 38,
            EBaseUserMessages::UM_LagCompensationError => 39,
            EBaseUserMessages::UM_RequestDllStatus => 40,
            EBaseUserMessages::UM_RequestUtilAction => 41,
            EBaseUserMessages::UM_UtilActionResponse => 42,
            EBaseUserMessages::UM_DllStatusResponse => 43,
            EBaseUserMessages::UM_RequestInventory => 44,
            EBaseUserMessages::UM_InventoryResponse => 45,
            EBaseUserMessages::UM_RequestDiagnostic => 46,
            EBaseUserMessages::UM_DiagnosticResponse => 47,
            EBaseUserMessages::UM_ExtraUserData => 48,
            EBaseUserMessages::UM_MAX_BASE => 49,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EBaseUserMessages {
    fn default() -> Self {
        EBaseUserMessages::UM_AchievementEvent
    }
}

impl EBaseUserMessages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EBaseUserMessages>("EBaseUserMessages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBaseEntityMessages)
pub enum EBaseEntityMessages {
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_PlayJingle)
    EM_PlayJingle = 136,
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_ScreenOverlay)
    EM_ScreenOverlay = 137,
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_RemoveAllDecals)
    EM_RemoveAllDecals = 138,
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_PropagateForce)
    EM_PropagateForce = 139,
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_DoSpark)
    EM_DoSpark = 140,
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_FixAngle)
    EM_FixAngle = 141,
}

impl ::protobuf::Enum for EBaseEntityMessages {
    const NAME: &'static str = "EBaseEntityMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBaseEntityMessages> {
        match value {
            136 => ::std::option::Option::Some(EBaseEntityMessages::EM_PlayJingle),
            137 => ::std::option::Option::Some(EBaseEntityMessages::EM_ScreenOverlay),
            138 => ::std::option::Option::Some(EBaseEntityMessages::EM_RemoveAllDecals),
            139 => ::std::option::Option::Some(EBaseEntityMessages::EM_PropagateForce),
            140 => ::std::option::Option::Some(EBaseEntityMessages::EM_DoSpark),
            141 => ::std::option::Option::Some(EBaseEntityMessages::EM_FixAngle),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBaseEntityMessages> {
        match str {
            "EM_PlayJingle" => ::std::option::Option::Some(EBaseEntityMessages::EM_PlayJingle),
            "EM_ScreenOverlay" => ::std::option::Option::Some(EBaseEntityMessages::EM_ScreenOverlay),
            "EM_RemoveAllDecals" => ::std::option::Option::Some(EBaseEntityMessages::EM_RemoveAllDecals),
            "EM_PropagateForce" => ::std::option::Option::Some(EBaseEntityMessages::EM_PropagateForce),
            "EM_DoSpark" => ::std::option::Option::Some(EBaseEntityMessages::EM_DoSpark),
            "EM_FixAngle" => ::std::option::Option::Some(EBaseEntityMessages::EM_FixAngle),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBaseEntityMessages] = &[
        EBaseEntityMessages::EM_PlayJingle,
        EBaseEntityMessages::EM_ScreenOverlay,
        EBaseEntityMessages::EM_RemoveAllDecals,
        EBaseEntityMessages::EM_PropagateForce,
        EBaseEntityMessages::EM_DoSpark,
        EBaseEntityMessages::EM_FixAngle,
    ];
}

impl ::protobuf::EnumFull for EBaseEntityMessages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBaseEntityMessages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EBaseEntityMessages::EM_PlayJingle => 0,
            EBaseEntityMessages::EM_ScreenOverlay => 1,
            EBaseEntityMessages::EM_RemoveAllDecals => 2,
            EBaseEntityMessages::EM_PropagateForce => 3,
            EBaseEntityMessages::EM_DoSpark => 4,
            EBaseEntityMessages::EM_FixAngle => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EBaseEntityMessages {
    fn default() -> Self {
        EBaseEntityMessages::EM_PlayJingle
    }
}

impl EBaseEntityMessages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EBaseEntityMessages>("EBaseEntityMessages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:eRollType)
pub enum ERollType {
    // @@protoc_insertion_point(enum_value:eRollType.ROLL_NONE)
    ROLL_NONE = -1,
    // @@protoc_insertion_point(enum_value:eRollType.ROLL_STATS)
    ROLL_STATS = 0,
    // @@protoc_insertion_point(enum_value:eRollType.ROLL_CREDITS)
    ROLL_CREDITS = 1,
    // @@protoc_insertion_point(enum_value:eRollType.ROLL_LATE_JOIN_LOGO)
    ROLL_LATE_JOIN_LOGO = 2,
    // @@protoc_insertion_point(enum_value:eRollType.ROLL_OUTTRO)
    ROLL_OUTTRO = 3,
}

impl ::protobuf::Enum for ERollType {
    const NAME: &'static str = "eRollType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERollType> {
        match value {
            -1 => ::std::option::Option::Some(ERollType::ROLL_NONE),
            0 => ::std::option::Option::Some(ERollType::ROLL_STATS),
            1 => ::std::option::Option::Some(ERollType::ROLL_CREDITS),
            2 => ::std::option::Option::Some(ERollType::ROLL_LATE_JOIN_LOGO),
            3 => ::std::option::Option::Some(ERollType::ROLL_OUTTRO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERollType> {
        match str {
            "ROLL_NONE" => ::std::option::Option::Some(ERollType::ROLL_NONE),
            "ROLL_STATS" => ::std::option::Option::Some(ERollType::ROLL_STATS),
            "ROLL_CREDITS" => ::std::option::Option::Some(ERollType::ROLL_CREDITS),
            "ROLL_LATE_JOIN_LOGO" => ::std::option::Option::Some(ERollType::ROLL_LATE_JOIN_LOGO),
            "ROLL_OUTTRO" => ::std::option::Option::Some(ERollType::ROLL_OUTTRO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERollType] = &[
        ERollType::ROLL_NONE,
        ERollType::ROLL_STATS,
        ERollType::ROLL_CREDITS,
        ERollType::ROLL_LATE_JOIN_LOGO,
        ERollType::ROLL_OUTTRO,
    ];
}

impl ::protobuf::EnumFull for ERollType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("eRollType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ERollType::ROLL_NONE => 0,
            ERollType::ROLL_STATS => 1,
            ERollType::ROLL_CREDITS => 2,
            ERollType::ROLL_LATE_JOIN_LOGO => 3,
            ERollType::ROLL_OUTTRO => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ERollType {
    fn default() -> Self {
        ERollType::ROLL_NONE
    }
}

impl ERollType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ERollType>("eRollType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PARTICLE_MESSAGE)
pub enum PARTICLE_MESSAGE {
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_CREATE)
    GAME_PARTICLE_MANAGER_EVENT_CREATE = 0,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE = 1,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD = 2,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION = 3,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK = 4,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT = 5,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET = 6,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_DESTROY)
    GAME_PARTICLE_MANAGER_EVENT_DESTROY = 7,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING)
    GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING = 8,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_RELEASE)
    GAME_PARTICLE_MANAGER_EVENT_RELEASE = 9,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_LATENCY)
    GAME_PARTICLE_MANAGER_EVENT_LATENCY = 10,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW)
    GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW = 11,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_FROZEN)
    GAME_PARTICLE_MANAGER_EVENT_FROZEN = 12,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT)
    GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT = 13,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION = 14,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES)
    GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES = 15,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_TEXT)
    GAME_PARTICLE_MANAGER_EVENT_SET_TEXT = 16,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW)
    GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW = 17,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL)
    GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL = 18,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT)
    GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT = 19,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE)
    GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE = 20,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG)
    GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG = 21,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT)
    GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT = 22,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED)
    GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED = 23,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME)
    GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME = 24,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE)
    GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE = 25,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT)
    GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT = 26,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM = 27,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE)
    GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE = 28,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING)
    GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING = 29,
}

impl ::protobuf::Enum for PARTICLE_MESSAGE {
    const NAME: &'static str = "PARTICLE_MESSAGE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PARTICLE_MESSAGE> {
        match value {
            0 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE),
            1 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE),
            2 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD),
            3 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION),
            4 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK),
            5 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT),
            6 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET),
            7 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY),
            8 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING),
            9 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_RELEASE),
            10 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_LATENCY),
            11 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW),
            12 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FROZEN),
            13 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT),
            14 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION),
            15 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES),
            16 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXT),
            17 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW),
            18 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL),
            19 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT),
            20 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE),
            21 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG),
            22 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT),
            23 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED),
            24 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME),
            25 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE),
            26 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT),
            27 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM),
            28 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE),
            29 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PARTICLE_MESSAGE> {
        match str {
            "GAME_PARTICLE_MANAGER_EVENT_CREATE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING),
            "GAME_PARTICLE_MANAGER_EVENT_RELEASE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_RELEASE),
            "GAME_PARTICLE_MANAGER_EVENT_LATENCY" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_LATENCY),
            "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW),
            "GAME_PARTICLE_MANAGER_EVENT_FROZEN" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FROZEN),
            "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION),
            "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES),
            "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXT),
            "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW),
            "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL),
            "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT),
            "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE),
            "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG),
            "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED),
            "GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME),
            "GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE),
            "GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM),
            "GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE),
            "GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PARTICLE_MESSAGE] = &[
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_RELEASE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_LATENCY,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FROZEN,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING,
    ];
}

impl ::protobuf::EnumFull for PARTICLE_MESSAGE {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PARTICLE_MESSAGE").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PARTICLE_MESSAGE {
    fn default() -> Self {
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE
    }
}

impl PARTICLE_MESSAGE {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PARTICLE_MESSAGE>("PARTICLE_MESSAGE")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHapticPulseType)
pub enum EHapticPulseType {
    // @@protoc_insertion_point(enum_value:EHapticPulseType.VR_HAND_HAPTIC_PULSE_LIGHT)
    VR_HAND_HAPTIC_PULSE_LIGHT = 0,
    // @@protoc_insertion_point(enum_value:EHapticPulseType.VR_HAND_HAPTIC_PULSE_MEDIUM)
    VR_HAND_HAPTIC_PULSE_MEDIUM = 1,
    // @@protoc_insertion_point(enum_value:EHapticPulseType.VR_HAND_HAPTIC_PULSE_STRONG)
    VR_HAND_HAPTIC_PULSE_STRONG = 2,
}

impl ::protobuf::Enum for EHapticPulseType {
    const NAME: &'static str = "EHapticPulseType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHapticPulseType> {
        match value {
            0 => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_LIGHT),
            1 => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_MEDIUM),
            2 => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_STRONG),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHapticPulseType> {
        match str {
            "VR_HAND_HAPTIC_PULSE_LIGHT" => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_LIGHT),
            "VR_HAND_HAPTIC_PULSE_MEDIUM" => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_MEDIUM),
            "VR_HAND_HAPTIC_PULSE_STRONG" => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_STRONG),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHapticPulseType] = &[
        EHapticPulseType::VR_HAND_HAPTIC_PULSE_LIGHT,
        EHapticPulseType::VR_HAND_HAPTIC_PULSE_MEDIUM,
        EHapticPulseType::VR_HAND_HAPTIC_PULSE_STRONG,
    ];
}

impl ::protobuf::EnumFull for EHapticPulseType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EHapticPulseType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EHapticPulseType {
    fn default() -> Self {
        EHapticPulseType::VR_HAND_HAPTIC_PULSE_LIGHT
    }
}

impl EHapticPulseType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EHapticPulseType>("EHapticPulseType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12usermessages.proto\x1a\x16networkbasetypes.proto\"@\n\x1cCUserMess\
    ageAchievementEvent\x12\x20\n\x0bachievement\x18\x01\x20\x01(\rR\x0bachi\
    evement\"\x8c\x01\n\x18CUserMessageCloseCaption\x12\x12\n\x04hash\x18\
    \x01\x20\x01(\x07R\x04hash\x12\x1a\n\x08duration\x18\x02\x20\x01(\x02R\
    \x08duration\x12\x1f\n\x0bfrom_player\x18\x03\x20\x01(\x08R\nfromPlayer\
    \x12\x1f\n\tent_index\x18\x04\x20\x01(\x05:\x02-1R\x08entIndex\"\x92\x01\
    \n\x1eCUserMessageCloseCaptionDirect\x12\x12\n\x04hash\x18\x01\x20\x01(\
    \x07R\x04hash\x12\x1a\n\x08duration\x18\x02\x20\x01(\x02R\x08duration\
    \x12\x1f\n\x0bfrom_player\x18\x03\x20\x01(\x08R\nfromPlayer\x12\x1f\n\te\
    nt_index\x18\x04\x20\x01(\x05:\x02-1R\x08entIndex\"\x9b\x01\n#CUserMessa\
    geCloseCaptionPlaceholder\x12\x16\n\x06string\x18\x01\x20\x01(\tR\x06str\
    ing\x12\x1a\n\x08duration\x18\x02\x20\x01(\x02R\x08duration\x12\x1f\n\
    \x0bfrom_player\x18\x03\x20\x01(\x08R\nfromPlayer\x12\x1f\n\tent_index\
    \x18\x04\x20\x01(\x05:\x02-1R\x08entIndex\"8\n\x1cCUserMessageCurrentTim\
    escale\x12\x18\n\x07current\x18\x01\x20\x01(\x02R\x07current\"\xb4\x01\n\
    \x1cCUserMessageDesiredTimescale\x12\x18\n\x07desired\x18\x01\x20\x01(\
    \x02R\x07desired\x12\"\n\x0cacceleration\x18\x02\x20\x01(\x02R\x0caccele\
    ration\x12\"\n\x0cminblendrate\x18\x03\x20\x01(\x02R\x0cminblendrate\x12\
    2\n\x14blenddeltamultiplier\x18\x04\x20\x01(\x02R\x14blenddeltamultiplie\
    r\"w\n\x10CUserMessageFade\x12\x1a\n\x08duration\x18\x01\x20\x01(\rR\x08\
    duration\x12\x1b\n\thold_time\x18\x02\x20\x01(\rR\x08holdTime\x12\x14\n\
    \x05flags\x18\x03\x20\x01(\rR\x05flags\x12\x14\n\x05color\x18\x04\x20\
    \x01(\x07R\x05color\"\x85\x01\n\x11CUserMessageShake\x12\x18\n\x07comman\
    d\x18\x01\x20\x01(\rR\x07command\x12\x1c\n\tamplitude\x18\x02\x20\x01(\
    \x02R\tamplitude\x12\x1c\n\tfrequency\x18\x03\x20\x01(\x02R\tfrequency\
    \x12\x1a\n\x08duration\x18\x04\x20\x01(\x02R\x08duration\"k\n\x14CUserMe\
    ssageShakeDir\x12(\n\x05shake\x18\x01\x20\x01(\x0b2\x12.CUserMessageShak\
    eR\x05shake\x12)\n\tdirection\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\tdir\
    ection\"\x8a\x01\n\x16CUserMessageWaterShake\x12\x18\n\x07command\x18\
    \x01\x20\x01(\rR\x07command\x12\x1c\n\tamplitude\x18\x02\x20\x01(\x02R\t\
    amplitude\x12\x1c\n\tfrequency\x18\x03\x20\x01(\x02R\tfrequency\x12\x1a\
    \n\x08duration\x18\x04\x20\x01(\x02R\x08duration\"\xa5\x01\n\x16CUserMes\
    sageScreenTilt\x12\x18\n\x07command\x18\x01\x20\x01(\rR\x07command\x12\
    \x1e\n\x0bease_in_out\x18\x02\x20\x01(\x08R\teaseInOut\x12!\n\x05angle\
    \x18\x03\x20\x01(\x0b2\x0b.CMsgVectorR\x05angle\x12\x1a\n\x08duration\
    \x18\x04\x20\x01(\x02R\x08duration\x12\x12\n\x04time\x18\x05\x20\x01(\
    \x02R\x04time\"c\n\x13CUserMessageSayText\x12$\n\x0bplayerindex\x18\x01\
    \x20\x01(\x05:\x02-1R\x0bplayerindex\x12\x12\n\x04text\x18\x02\x20\x01(\
    \tR\x04text\x12\x12\n\x04chat\x18\x03\x20\x01(\x08R\x04chat\"\xd2\x01\n\
    \x14CUserMessageSayText2\x12$\n\x0bentityindex\x18\x01\x20\x01(\x05:\x02\
    -1R\x0bentityindex\x12\x12\n\x04chat\x18\x02\x20\x01(\x08R\x04chat\x12\
    \x20\n\x0bmessagename\x18\x03\x20\x01(\tR\x0bmessagename\x12\x16\n\x06pa\
    ram1\x18\x04\x20\x01(\tR\x06param1\x12\x16\n\x06param2\x18\x05\x20\x01(\
    \tR\x06param2\x12\x16\n\x06param3\x18\x06\x20\x01(\tR\x06param3\x12\x16\
    \n\x06param4\x18\x07\x20\x01(\tR\x06param4\"\xac\x01\n\x12CUserMessageHu\
    dMsg\x12\x18\n\x07channel\x18\x01\x20\x01(\rR\x07channel\x12\x0c\n\x01x\
    \x18\x02\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\x02R\x01y\
    \x12\x16\n\x06color1\x18\x04\x20\x01(\x07R\x06color1\x12\x16\n\x06color2\
    \x18\x05\x20\x01(\x07R\x06color2\x12\x16\n\x06effect\x18\x06\x20\x01(\rR\
    \x06effect\x12\x18\n\x07message\x18\x0b\x20\x01(\tR\x07message\"/\n\x13C\
    UserMessageHudText\x12\x18\n\x07message\x18\x01\x20\x01(\tR\x07message\"\
    ?\n\x13CUserMessageTextMsg\x12\x12\n\x04dest\x18\x01\x20\x01(\rR\x04dest\
    \x12\x14\n\x05param\x18\x02\x20\x03(\tR\x05param\"\x17\n\x15CUserMessage\
    GameTitle\"\x16\n\x14CUserMessageResetHUD\"I\n\x15CUserMessageSendAudio\
    \x12\x1c\n\tsoundname\x18\x01\x20\x01(\tR\tsoundname\x12\x12\n\x04stop\
    \x18\x02\x20\x01(\x08R\x04stop\"\x9c\x01\n\x1aCUserMessageAudioParameter\
    \x12%\n\x0eparameter_type\x18\x01\x20\x01(\rR\rparameterType\x12$\n\x0en\
    ame_hash_code\x18\x02\x20\x01(\rR\x0cnameHashCode\x12\x14\n\x05value\x18\
    \x03\x20\x01(\x02R\x05value\x12\x1b\n\tint_value\x18\x04\x20\x01(\rR\x08\
    intValue\"|\n\x15CUserMessageVoiceMask\x12'\n\x0fgamerules_masks\x18\x01\
    \x20\x03(\rR\x0egamerulesMasks\x12\x1b\n\tban_masks\x18\x02\x20\x03(\rR\
    \x08banMasks\x12\x1d\n\nmod_enable\x18\x03\x20\x01(\x08R\tmodEnable\"\
    \x1a\n\x18CUserMessageRequestState\"T\n\x12CUserMessageRumble\x12\x14\n\
    \x05index\x18\x01\x20\x01(\x05R\x05index\x12\x12\n\x04data\x18\x02\x20\
    \x01(\x05R\x04data\x12\x14\n\x05flags\x18\x03\x20\x01(\x05R\x05flags\"b\
    \n\x1aCUserMessageSayTextChannel\x12\x16\n\x06player\x18\x01\x20\x01(\
    \x05R\x06player\x12\x18\n\x07channel\x18\x02\x20\x01(\x05R\x07channel\
    \x12\x12\n\x04text\x18\x03\x20\x01(\tR\x04text\"\xda\x01\n\x17CUserMessa\
    geColoredText\x12\x14\n\x05color\x18\x01\x20\x01(\rR\x05color\x12\x12\n\
    \x04text\x18\x02\x20\x01(\tR\x04text\x12\x14\n\x05reset\x18\x03\x20\x01(\
    \x08R\x05reset\x122\n\x13context_player_slot\x18\x04\x20\x01(\x05:\x02-1\
    R\x11contextPlayerSlot\x12#\n\rcontext_value\x18\x05\x20\x01(\x05R\x0cco\
    ntextValue\x12&\n\x0fcontext_team_id\x18\x06\x20\x01(\x05R\rcontextTeamI\
    d\"4\n\x16CUserMessageItemPickup\x12\x1a\n\x08itemname\x18\x01\x20\x01(\
    \tR\x08itemname\"1\n\x16CUserMessageAmmoDenied\x12\x17\n\x07ammo_id\x18\
    \x01\x20\x01(\rR\x06ammoId\"\x94\x01\n\x14CUserMessageShowMenu\x12\x1e\n\
    \nvalidslots\x18\x01\x20\x01(\rR\nvalidslots\x12\x20\n\x0bdisplaytime\
    \x18\x02\x20\x01(\rR\x0bdisplaytime\x12\x1a\n\x08needmore\x18\x03\x20\
    \x01(\x08R\x08needmore\x12\x1e\n\nmenustring\x18\x04\x20\x01(\tR\nmenust\
    ring\"l\n\x16CUserMessageCreditsMsg\x121\n\x08rolltype\x18\x01\x20\x01(\
    \x0e2\n.eRollType:\tROLL_NONER\x08rolltype\x12\x1f\n\x0blogo_length\x18\
    \x02\x20\x01(\x02R\nlogoLength\"F\n\x18CEntityMessagePlayJingle\x12*\n\n\
    entity_msg\x18\x01\x20\x01(\x0b2\x0b.CEntityMsgR\tentityMsg\"l\n\x1bCEnt\
    ityMessageScreenOverlay\x12!\n\x0cstart_effect\x18\x01\x20\x01(\x08R\x0b\
    startEffect\x12*\n\nentity_msg\x18\x02\x20\x01(\x0b2\x0b.CEntityMsgR\ten\
    tityMsg\"p\n\x1dCEntityMessageRemoveAllDecals\x12#\n\rremove_decals\x18\
    \x01\x20\x01(\x08R\x0cremoveDecals\x12*\n\nentity_msg\x18\x02\x20\x01(\
    \x0b2\x0b.CEntityMsgR\tentityMsg\"q\n\x1cCEntityMessagePropagateForce\
    \x12%\n\x07impulse\x18\x01\x20\x01(\x0b2\x0b.CMsgVectorR\x07impulse\x12*\
    \n\nentity_msg\x18\x02\x20\x01(\x0b2\x0b.CEntityMsgR\tentityMsg\"\x84\
    \x02\n\x15CEntityMessageDoSpark\x12#\n\x06origin\x18\x01\x20\x01(\x0b2\
    \x0b.CMsgVectorR\x06origin\x12$\n\x0bentityindex\x18\x02\x20\x01(\x05:\
    \x02-1R\x0bentityindex\x12\x16\n\x06radius\x18\x03\x20\x01(\x02R\x06radi\
    us\x12\x14\n\x05color\x18\x04\x20\x01(\x07R\x05color\x12\x14\n\x05beams\
    \x18\x05\x20\x01(\rR\x05beams\x12\x14\n\x05thick\x18\x06\x20\x01(\x02R\
    \x05thick\x12\x1a\n\x08duration\x18\x07\x20\x01(\x02R\x08duration\x12*\n\
    \nentity_msg\x18\x08\x20\x01(\x0b2\x0b.CEntityMsgR\tentityMsg\"\x83\x01\
    \n\x16CEntityMessageFixAngle\x12\x1a\n\x08relative\x18\x01\x20\x01(\x08R\
    \x08relative\x12!\n\x05angle\x18\x02\x20\x01(\x0b2\x0b.CMsgQAngleR\x05an\
    gle\x12*\n\nentity_msg\x18\x03\x20\x01(\x0b2\x0b.CEntityMsgR\tentityMsg\
    \"\xbd\x02\n\x1cCUserMessageCameraTransition\x12\x1f\n\x0bcamera_type\
    \x18\x01\x20\x01(\rR\ncameraType\x12\x1a\n\x08duration\x18\x02\x20\x01(\
    \x02R\x08duration\x12a\n\x12params_data_driven\x18\x03\x20\x01(\x0b23.CU\
    serMessageCameraTransition.Transition_DataDrivenR\x10paramsDataDriven\
    \x1a}\n\x15Transition_DataDriven\x12\x1a\n\x08filename\x18\x01\x20\x01(\
    \tR\x08filename\x12,\n\x10attach_ent_index\x18\x02\x20\x01(\x05:\x02-1R\
    \x0eattachEntIndex\x12\x1a\n\x08duration\x18\x03\x20\x01(\x02R\x08durati\
    on\"\xbf<\n\x18CUserMsg_ParticleManager\x12I\n\x04type\x18\x01\x20\x02(\
    \x0e2\x11.PARTICLE_MESSAGE:\"GAME_PARTICLE_MANAGER_EVENT_CREATER\x04type\
    \x12\x14\n\x05index\x18\x02\x20\x02(\rR\x05index\x12d\n\x16release_parti\
    cle_index\x18\x03\x20\x01(\x0b2..CUserMsg_ParticleManager.ReleaseParticl\
    eIndexR\x14releaseParticleIndex\x12Q\n\x0fcreate_particle\x18\x04\x20\
    \x01(\x0b2(.CUserMsg_ParticleManager.CreateParticleR\x0ecreateParticle\
    \x12T\n\x10destroy_particle\x18\x05\x20\x01(\x0b2).CUserMsg_ParticleMana\
    ger.DestroyParticleR\x0fdestroyParticle\x12p\n\x1adestroy_particle_invol\
    ving\x18\x06\x20\x01(\x0b22.CUserMsg_ParticleManager.DestroyParticleInvo\
    lvingR\x18destroyParticleInvolving\x12Z\n\x0fupdate_particle\x18\x07\x20\
    \x01(\x0b21.CUserMsg_ParticleManager.UpdateParticle_OBSOLETER\x0eupdateP\
    article\x12d\n\x13update_particle_fwd\x18\x08\x20\x01(\x0b24.CUserMsg_Pa\
    rticleManager.UpdateParticleFwd_OBSOLETER\x11updateParticleFwd\x12m\n\
    \x16update_particle_orient\x18\t\x20\x01(\x0b27.CUserMsg_ParticleManager\
    .UpdateParticleOrient_OBSOLETER\x14updateParticleOrient\x12j\n\x18update\
    _particle_fallback\x18\n\x20\x01(\x0b20.CUserMsg_ParticleManager.UpdateP\
    articleFallbackR\x16updateParticleFallback\x12d\n\x16update_particle_off\
    set\x18\x0b\x20\x01(\x0b2..CUserMsg_ParticleManager.UpdateParticleOffset\
    R\x14updateParticleOffset\x12[\n\x13update_particle_ent\x18\x0c\x20\x01(\
    \x0b2+.CUserMsg_ParticleManager.UpdateParticleEntR\x11updateParticleEnt\
    \x12q\n\x1bupdate_particle_should_draw\x18\x0e\x20\x01(\x0b22.CUserMsg_P\
    articleManager.UpdateParticleShouldDrawR\x18updateParticleShouldDraw\x12\
    n\n\x1aupdate_particle_set_frozen\x18\x0f\x20\x01(\x0b21.CUserMsg_Partic\
    leManager.UpdateParticleSetFrozenR\x17updateParticleSetFrozen\x12}\n\x1f\
    change_control_point_attachment\x18\x10\x20\x01(\x0b26.CUserMsg_Particle\
    Manager.ChangeControlPointAttachmentR\x1cchangeControlPointAttachment\
    \x12d\n\x16update_entity_position\x18\x11\x20\x01(\x0b2..CUserMsg_Partic\
    leManager.UpdateEntityPositionR\x14updateEntityPosition\x12q\n\x1bset_pa\
    rticle_fow_properties\x18\x12\x20\x01(\x0b22.CUserMsg_ParticleManager.Se\
    tParticleFoWPropertiesR\x18setParticleFowProperties\x12U\n\x11set_partic\
    le_text\x18\x13\x20\x01(\x0b2).CUserMsg_ParticleManager.SetParticleTextR\
    \x0fsetParticleText\x12u\n\x1dset_particle_should_check_fow\x18\x14\x20\
    \x01(\x0b23.CUserMsg_ParticleManager.SetParticleShouldCheckFoWR\x19setPa\
    rticleShouldCheckFow\x12e\n\x17set_control_point_model\x18\x15\x20\x01(\
    \x0b2..CUserMsg_ParticleManager.SetControlPointModelR\x14setControlPoint\
    Model\x12n\n\x1aset_control_point_snapshot\x18\x16\x20\x01(\x0b21.CUserM\
    sg_ParticleManager.SetControlPointSnapshotR\x17setControlPointSnapshot\
    \x12a\n\x15set_texture_attribute\x18\x17\x20\x01(\x0b2-.CUserMsg_Particl\
    eManager.SetTextureAttributeR\x13setTextureAttribute\x12u\n\x1dset_scene\
    _object_generic_flag\x18\x18\x20\x01(\x0b23.CUserMsg_ParticleManager.Set\
    SceneObjectGenericFlagR\x19setSceneObjectGenericFlag\x12y\n\x1fset_scene\
    _object_tint_and_desat\x18\x19\x20\x01(\x0b24.CUserMsg_ParticleManager.S\
    etSceneObjectTintAndDesatR\x1asetSceneObjectTintAndDesat\x12d\n\x16destr\
    oy_particle_named\x18\x1a\x20\x01(\x0b2..CUserMsg_ParticleManager.Destro\
    yParticleNamedR\x14destroyParticleNamed\x12_\n\x15particle_skip_to_time\
    \x18\x1b\x20\x01(\x0b2,.CUserMsg_ParticleManager.ParticleSkipToTimeR\x12\
    particleSkipToTime\x12[\n\x13particle_can_freeze\x18\x1c\x20\x01(\x0b2+.\
    CUserMsg_ParticleManager.ParticleCanFreezeR\x11particleCanFreeze\x12m\n\
    \x17set_named_value_context\x18\x1d\x20\x01(\x0b26.CUserMsg_ParticleMana\
    ger.SetParticleNamedValueContextR\x14setNamedValueContext\x12m\n\x19upda\
    te_particle_transform\x18\x1e\x20\x01(\x0b21.CUserMsg_ParticleManager.Up\
    dateParticleTransformR\x17updateParticleTransform\x12\x89\x01\n#particle\
    _freeze_transition_override\x18\x1f\x20\x01(\x0b2:.CUserMsg_ParticleMana\
    ger.ParticleFreezeTransitionOverrideR\x20particleFreezeTransitionOverrid\
    e\x12m\n\x19freeze_particle_involving\x18\x20\x20\x01(\x0b21.CUserMsg_Pa\
    rticleManager.FreezeParticleInvolvingR\x17freezeParticleInvolving\x1a\
    \x16\n\x14ReleaseParticleIndex\x1a\xac\x03\n\x0eCreateParticle\x12.\n\
    \x13particle_name_index\x18\x01\x20\x01(\x06R\x11particleNameIndex\x12\
    \x1f\n\x0battach_type\x18\x02\x20\x01(\x05R\nattachType\x12-\n\rentity_h\
    andle\x18\x03\x20\x01(\r:\x0816777215R\x0centityHandle\x12G\n\x1bentity_\
    handle_for_modifiers\x18\x04\x20\x01(\r:\x0816777215R\x18entityHandleFor\
    Modifiers\x121\n\x15apply_voice_ban_rules\x18\x05\x20\x01(\x08R\x12apply\
    VoiceBanRules\x12#\n\rteam_behavior\x18\x06\x20\x01(\x05R\x0cteamBehavio\
    r\x12>\n\x1bcontrol_point_configuration\x18\x07\x20\x01(\tR\x19controlPo\
    intConfiguration\x12\x18\n\x07cluster\x18\x08\x20\x01(\x08R\x07cluster\
    \x12\x1f\n\x0bendcap_time\x18\t\x20\x01(\x02R\nendcapTime\x1aB\n\x0fDest\
    royParticle\x12/\n\x13destroy_immediately\x18\x01\x20\x01(\x08R\x12destr\
    oyImmediately\x1az\n\x18DestroyParticleInvolving\x12/\n\x13destroy_immed\
    iately\x18\x01\x20\x01(\x08R\x12destroyImmediately\x12-\n\rentity_handle\
    \x18\x03\x20\x01(\r:\x0816777215R\x0centityHandle\x1a\xc7\x01\n\x14Destr\
    oyParticleNamed\x12.\n\x13particle_name_index\x18\x01\x20\x01(\x06R\x11p\
    articleNameIndex\x12-\n\rentity_handle\x18\x02\x20\x01(\r:\x0816777215R\
    \x0centityHandle\x12/\n\x13destroy_immediately\x18\x03\x20\x01(\x08R\x12\
    destroyImmediately\x12\x1f\n\x0bplay_endcap\x18\x04\x20\x01(\x08R\nplayE\
    ndcap\x1ag\n\x17UpdateParticle_OBSOLETE\x12#\n\rcontrol_point\x18\x01\
    \x20\x01(\x05R\x0ccontrolPoint\x12'\n\x08position\x18\x02\x20\x01(\x0b2\
    \x0b.CMsgVectorR\x08position\x1ah\n\x1aUpdateParticleFwd_OBSOLETE\x12#\n\
    \rcontrol_point\x18\x01\x20\x01(\x05R\x0ccontrolPoint\x12%\n\x07forward\
    \x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x07forward\x1a\xe1\x01\n\x1dUpdat\
    eParticleOrient_OBSOLETE\x12#\n\rcontrol_point\x18\x01\x20\x01(\x05R\x0c\
    controlPoint\x12%\n\x07forward\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x07\
    forward\x126\n\x10deprecated_right\x18\x03\x20\x01(\x0b2\x0b.CMsgVectorR\
    \x0fdeprecatedRight\x12\x1b\n\x02up\x18\x04\x20\x01(\x0b2\x0b.CMsgVector\
    R\x02up\x12\x1f\n\x04left\x18\x05\x20\x01(\x0b2\x0b.CMsgVectorR\x04left\
    \x1a\xd1\x01\n\x17UpdateParticleTransform\x12#\n\rcontrol_point\x18\x01\
    \x20\x01(\x05R\x0ccontrolPoint\x12'\n\x08position\x18\x02\x20\x01(\x0b2\
    \x0b.CMsgVectorR\x08position\x121\n\x0borientation\x18\x03\x20\x01(\x0b2\
    \x0f.CMsgQuaternionR\x0borientation\x125\n\x16interpolation_interval\x18\
    \x04\x20\x01(\x02R\x15interpolationInterval\x1af\n\x16UpdateParticleFall\
    back\x12#\n\rcontrol_point\x18\x01\x20\x01(\x05R\x0ccontrolPoint\x12'\n\
    \x08position\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x08position\x1a\x9d\
    \x01\n\x14UpdateParticleOffset\x12#\n\rcontrol_point\x18\x01\x20\x01(\
    \x05R\x0ccontrolPoint\x120\n\rorigin_offset\x18\x02\x20\x01(\x0b2\x0b.CM\
    sgVectorR\x0coriginOffset\x12.\n\x0cangle_offset\x18\x03\x20\x01(\x0b2\
    \x0b.CMsgQAngleR\x0bangleOffset\x1a\xf7\x02\n\x11UpdateParticleEnt\x12#\
    \n\rcontrol_point\x18\x01\x20\x01(\x05R\x0ccontrolPoint\x12-\n\rentity_h\
    andle\x18\x02\x20\x01(\r:\x0816777215R\x0centityHandle\x12\x1f\n\x0batta\
    ch_type\x18\x03\x20\x01(\x05R\nattachType\x12\x1e\n\nattachment\x18\x04\
    \x20\x01(\x05R\nattachment\x128\n\x11fallback_position\x18\x05\x20\x01(\
    \x0b2\x0b.CMsgVectorR\x10fallbackPosition\x12+\n\x11include_wearables\
    \x18\x06\x20\x01(\x08R\x10includeWearables\x124\n\x0foffset_position\x18\
    \x07\x20\x01(\x0b2\x0b.CMsgVectorR\x0eoffsetPosition\x120\n\roffset_angl\
    es\x18\x08\x20\x01(\x0b2\x0b.CMsgQAngleR\x0coffsetAngles\x1ai\n\x17Updat\
    eParticleSetFrozen\x12\x1d\n\nset_frozen\x18\x01\x20\x01(\x08R\tsetFroze\
    n\x12/\n\x13transition_duration\x18\x02\x20\x01(\x02R\x12transitionDurat\
    ion\x1a;\n\x18UpdateParticleShouldDraw\x12\x1f\n\x0bshould_draw\x18\x01\
    \x20\x01(\x08R\nshouldDraw\x1a\x9b\x01\n\x1cChangeControlPointAttachment\
    \x12%\n\x0eattachment_old\x18\x01\x20\x01(\x05R\rattachmentOld\x12%\n\
    \x0eattachment_new\x18\x02\x20\x01(\x05R\rattachmentNew\x12-\n\rentity_h\
    andle\x18\x03\x20\x01(\r:\x0816777215R\x0centityHandle\x1an\n\x14UpdateE\
    ntityPosition\x12-\n\rentity_handle\x18\x01\x20\x01(\r:\x0816777215R\x0c\
    entityHandle\x12'\n\x08position\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\
    \x08position\x1a\x93\x01\n\x18SetParticleFoWProperties\x12*\n\x11fow_con\
    trol_point\x18\x01\x20\x01(\x05R\x0ffowControlPoint\x12,\n\x12fow_contro\
    l_point2\x18\x02\x20\x01(\x05R\x10fowControlPoint2\x12\x1d\n\nfow_radius\
    \x18\x03\x20\x01(\x02R\tfowRadius\x1a8\n\x19SetParticleShouldCheckFoW\
    \x12\x1b\n\tcheck_fow\x18\x01\x20\x01(\x08R\x08checkFow\x1aZ\n\x14SetCon\
    trolPointModel\x12#\n\rcontrol_point\x18\x01\x20\x01(\x05R\x0ccontrolPoi\
    nt\x12\x1d\n\nmodel_name\x18\x02\x20\x01(\tR\tmodelName\x1ac\n\x17SetCon\
    trolPointSnapshot\x12#\n\rcontrol_point\x18\x01\x20\x01(\x05R\x0ccontrol\
    Point\x12#\n\rsnapshot_name\x18\x02\x20\x01(\tR\x0csnapshotName\x1a%\n\
    \x0fSetParticleText\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\x1a_\n\
    \x13SetTextureAttribute\x12%\n\x0eattribute_name\x18\x01\x20\x01(\tR\rat\
    tributeName\x12!\n\x0ctexture_name\x18\x02\x20\x01(\tR\x0btextureName\
    \x1a:\n\x19SetSceneObjectGenericFlag\x12\x1d\n\nflag_value\x18\x01\x20\
    \x01(\x08R\tflagValue\x1aF\n\x1aSetSceneObjectTintAndDesat\x12\x12\n\x04\
    tint\x18\x01\x20\x01(\x07R\x04tint\x12\x14\n\x05desat\x18\x02\x20\x01(\
    \x02R\x05desat\x1a6\n\x12ParticleSkipToTime\x12\x20\n\x0cskip_to_time\
    \x18\x01\x20\x01(\x02R\nskipToTime\x1a2\n\x11ParticleCanFreeze\x12\x1d\n\
    \ncan_freeze\x18\x01\x20\x01(\x08R\tcanFreeze\x1a`\n\x20ParticleFreezeTr\
    ansitionOverride\x12<\n\x1afreeze_transition_override\x18\x01\x20\x01(\
    \x02R\x18freezeTransitionOverride\x1a\x98\x01\n\x17FreezeParticleInvolvi\
    ng\x12\x1d\n\nset_frozen\x18\x01\x20\x01(\x08R\tsetFrozen\x12/\n\x13tran\
    sition_duration\x18\x02\x20\x01(\x02R\x12transitionDuration\x12-\n\renti\
    ty_handle\x18\x03\x20\x01(\r:\x0816777215R\x0centityHandle\x1a\x8d\x07\n\
    \x1cSetParticleNamedValueContext\x12k\n\x0cfloat_values\x18\x01\x20\x03(\
    \x0b2H.CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContex\
    tValueR\x0bfloatValues\x12n\n\rvector_values\x18\x02\x20\x03(\x0b2I.CUse\
    rMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValueR\
    \x0cvectorValues\x12w\n\x10transform_values\x18\x03\x20\x03(\x0b2L.CUser\
    Msg_ParticleManager.SetParticleNamedValueContext.TransformContextValueR\
    \x0ftransformValues\x12l\n\x0eehandle_values\x18\x04\x20\x03(\x0b2E.CUse\
    rMsg_ParticleManager.SetParticleNamedValueContext.EHandleContextR\rehand\
    leValues\x1aQ\n\x11FloatContextValue\x12&\n\x0fvalue_name_hash\x18\x01\
    \x20\x01(\rR\rvalueNameHash\x12\x14\n\x05value\x18\x02\x20\x01(\x02R\x05\
    value\x1a_\n\x12VectorContextValue\x12&\n\x0fvalue_name_hash\x18\x01\x20\
    \x01(\rR\rvalueNameHash\x12!\n\x05value\x18\x02\x20\x01(\x0b2\x0b.CMsgVe\
    ctorR\x05value\x1a\x93\x01\n\x15TransformContextValue\x12&\n\x0fvalue_na\
    me_hash\x18\x01\x20\x01(\rR\rvalueNameHash\x12#\n\x06angles\x18\x02\x20\
    \x01(\x0b2\x0b.CMsgQAngleR\x06angles\x12-\n\x0btranslation\x18\x03\x20\
    \x01(\x0b2\x0b.CMsgVectorR\x0btranslation\x1a_\n\x0eEHandleContext\x12&\
    \n\x0fvalue_name_hash\x18\x01\x20\x01(\rR\rvalueNameHash\x12%\n\tent_ind\
    ex\x18\x02\x20\x01(\r:\x0816777215R\x08entIndex*\x05\x08d\x10\xca\x01\".\
    \n\x11CUserMsg_HudError\x12\x19\n\x08order_id\x18\x01\x20\x01(\x05R\x07o\
    rderId\"M\n\x18CUserMsg_CustomGameEvent\x12\x1d\n\nevent_name\x18\x01\
    \x20\x01(\tR\teventName\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\
    \"\xb9\x01\n\x1fCUserMessageHapticsManagerPulse\x12\x17\n\x07hand_id\x18\
    \x01\x20\x01(\x05R\x06handId\x12)\n\x10effect_amplitude\x18\x02\x20\x01(\
    \x02R\x0feffectAmplitude\x12)\n\x10effect_frequency\x18\x03\x20\x01(\x02\
    R\x0feffectFrequency\x12'\n\x0feffect_duration\x18\x04\x20\x01(\x02R\x0e\
    effectDuration\"\x91\x01\n\x20CUserMessageHapticsManagerEffect\x12\x17\n\
    \x07hand_id\x18\x01\x20\x01(\x05R\x06handId\x121\n\x15effect_name_hash_c\
    ode\x18\x02\x20\x01(\rR\x12effectNameHashCode\x12!\n\x0ceffect_scale\x18\
    \x03\x20\x01(\x02R\x0beffectScale\"X\n\x1fCUserMessageAnimStateGraphStat\
    e\x12!\n\x0centity_index\x18\x01\x20\x01(\x05R\x0bentityIndex\x12\x12\n\
    \x04data\x18\x02\x20\x01(\x0cR\x04data\"\x8e\x03\n\x1dCUserMessageComman\
    dQueueState\x12#\n\x0bplayer_slot\x18\x01\x20\x01(\x05:\x02-1R\nplayerSl\
    ot\x12a\n\x12command_queue_info\x18\x02\x20\x01(\x0b23.CUserMessageComma\
    ndQueueState.command_queue_info_tR\x10commandQueueInfo\x1a\xe4\x01\n\x14\
    command_queue_info_t\x12'\n\x0fcommands_queued\x18\x01\x20\x01(\rR\x0eco\
    mmandsQueued\x12;\n\x1acommand_queue_desired_size\x18\x02\x20\x01(\rR\
    \x17commandQueueDesiredSize\x122\n\x15starved_command_ticks\x18\x03\x20\
    \x01(\rR\x13starvedCommandTicks\x122\n\x15time_dilation_percent\x18\x04\
    \x20\x01(\x05R\x13timeDilationPercent\"\x84\x01\n\x1cCUserMessageUpdateC\
    ssClasses\x12,\n\x12target_world_panel\x18\x01\x20\x01(\x05R\x10targetWo\
    rldPanel\x12\x1f\n\x0bcss_classes\x18\x02\x20\x01(\tR\ncssClasses\x12\
    \x15\n\x06is_add\x18\x03\x20\x01(\x08R\x05isAdd\"<\n\x1bCUserMessageServ\
    erFrameTime\x12\x1d\n\nframe_time\x18\x01\x20\x01(\x02R\tframeTime\">\n\
    \x20CUserMessageLagCompensationError\x12\x1a\n\x08distance\x18\x01\x20\
    \x01(\x02R\x08distance\"^\n\x1cCUserMessageRequestDllStatus\x12\x1d\n\nd\
    ll_action\x18\x01\x20\x01(\tR\tdllAction\x12\x1f\n\x0bfull_report\x18\
    \x02\x20\x01(\x08R\nfullReport\"\x8d\x01\n\x1dCUserMessageRequestUtilAct\
    ion\x12\x14\n\x05util1\x18\x02\x20\x01(\x05R\x05util1\x12\x14\n\x05util2\
    \x18\x03\x20\x01(\x05R\x05util2\x12\x14\n\x05util3\x18\x04\x20\x01(\x05R\
    \x05util3\x12\x14\n\x05util4\x18\x05\x20\x01(\x05R\x05util4\x12\x14\n\
    \x05util5\x18\x06\x20\x01(\x05R\x05util5\"\x91\x04\n\x1dCUserMessage_Uti\
    lMsg_Response\x12\x10\n\x03crc\x18\x01\x20\x01(\x07R\x03crc\x12\x1d\n\ni\
    tem_count\x18\x02\x20\x01(\x05R\titemCount\x12\x12\n\x04crc2\x18\x03\x20\
    \x01(\x07R\x04crc2\x12\x1f\n\x0bitem_count2\x18\x04\x20\x01(\x05R\nitemC\
    ount2\x12\x19\n\x08crc_part\x18\x05\x20\x03(\x05R\x07crcPart\x12\x1b\n\t\
    crc_part2\x18\x06\x20\x03(\x05R\x08crcPart2\x12)\n\x10client_timestamp\
    \x18\x07\x20\x01(\x05R\x0fclientTimestamp\x12\x1a\n\x08platform\x18\x08\
    \x20\x01(\x05R\x08platform\x12K\n\x0bitemdetails\x18\t\x20\x03(\x0b2).CU\
    serMessage_UtilMsg_Response.ItemDetailR\x0bitemdetails\x12\x1c\n\titemgr\
    oup\x18\n\x20\x01(\x05R\titemgroup\x12\x1f\n\x0btotal_count\x18\x0b\x20\
    \x01(\x05R\ntotalCount\x12!\n\x0ctotal_count2\x18\x0c\x20\x01(\x05R\x0bt\
    otalCount2\x1a\\\n\nItemDetail\x12\x14\n\x05index\x18\x01\x20\x01(\x05R\
    \x05index\x12\x12\n\x04hash\x18\x02\x20\x01(\x05R\x04hash\x12\x10\n\x03c\
    rc\x18\x03\x20\x01(\x05R\x03crc\x12\x12\n\x04name\x18\x04\x20\x01(\tR\
    \x04name\"\xc1\x04\n\x16CUserMessage_DllStatus\x12\x1f\n\x0bfile_report\
    \x18\x01\x20\x01(\tR\nfileReport\x12!\n\x0ccommand_line\x18\x02\x20\x01(\
    \tR\x0bcommandLine\x12\x1f\n\x0btotal_files\x18\x03\x20\x01(\rR\ntotalFi\
    les\x12\x1d\n\nprocess_id\x18\x04\x20\x01(\rR\tprocessId\x12\x1c\n\tosve\
    rsion\x18\x05\x20\x01(\x05R\tosversion\x12\x1f\n\x0bclient_time\x18\x06\
    \x20\x01(\x04R\nclientTime\x12F\n\x0bdiagnostics\x18\x07\x20\x03(\x0b2$.\
    CUserMessage_DllStatus.CVDiagnosticR\x0bdiagnostics\x129\n\x07modules\
    \x18\x08\x20\x03(\x0b2\x1f.CUserMessage_DllStatus.CModuleR\x07modules\
    \x1as\n\x0cCVDiagnostic\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\
    \x1a\n\x08extended\x18\x02\x20\x01(\rR\x08extended\x12\x14\n\x05value\
    \x18\x03\x20\x01(\x04R\x05value\x12!\n\x0cstring_value\x18\x04\x20\x01(\
    \tR\x0bstringValue\x1al\n\x07CModule\x12\x1b\n\tbase_addr\x18\x01\x20\
    \x01(\x04R\x08baseAddr\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x12\n\x04size\x18\x03\x20\x01(\rR\x04size\x12\x1c\n\ttimestamp\x18\x04\
    \x20\x01(\rR\ttimestamp\"n\n\x1cCUserMessageRequestInventory\x12\x1c\n\t\
    inventory\x18\x01\x20\x01(\x05R\tinventory\x12\x16\n\x06offset\x18\x02\
    \x20\x01(\x05R\x06offset\x12\x18\n\x07options\x18\x03\x20\x01(\x05R\x07o\
    ptions\"\xe1\x06\n\x1fCUserMessage_Inventory_Response\x12\x10\n\x03crc\
    \x18\x01\x20\x01(\x07R\x03crc\x12\x1d\n\nitem_count\x18\x02\x20\x01(\x05\
    R\titemCount\x12\x1c\n\tosversion\x18\x05\x20\x01(\x05R\tosversion\x12\
    \x1b\n\tperf_time\x18\x06\x20\x01(\x05R\x08perfTime\x12)\n\x10client_tim\
    estamp\x18\x07\x20\x01(\x05R\x0fclientTimestamp\x12\x1a\n\x08platform\
    \x18\x08\x20\x01(\x05R\x08platform\x12R\n\x0binventories\x18\t\x20\x03(\
    \x0b20.CUserMessage_Inventory_Response.InventoryDetailR\x0binventories\
    \x12T\n\x0cinventories2\x18\n\x20\x03(\x0b20.CUserMessage_Inventory_Resp\
    onse.InventoryDetailR\x0cinventories2\x12T\n\x0cinventories3\x18\x0e\x20\
    \x03(\x0b20.CUserMessage_Inventory_Response.InventoryDetailR\x0cinventor\
    ies3\x12\x19\n\x08inv_type\x18\x0b\x20\x01(\x05R\x07invType\x12#\n\rbuil\
    d_version\x18\x0c\x20\x01(\x05R\x0cbuildVersion\x12\x1a\n\x08instance\
    \x18\r\x20\x01(\x05R\x08instance\x12\x1d\n\nstart_time\x18\x0f\x20\x01(\
    \x03R\tstartTime\x1a\x8f\x02\n\x0fInventoryDetail\x12\x14\n\x05index\x18\
    \x01\x20\x01(\x05R\x05index\x12\x18\n\x07primary\x18\x02\x20\x01(\x03R\
    \x07primary\x12\x16\n\x06offset\x18\x03\x20\x01(\x03R\x06offset\x12\x14\
    \n\x05first\x18\x04\x20\x01(\x03R\x05first\x12\x12\n\x04base\x18\x05\x20\
    \x01(\x03R\x04base\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\x12\x1b\
    \n\tbase_name\x18\x07\x20\x01(\tR\x08baseName\x12\x1f\n\x0bbase_detail\
    \x18\x08\x20\x01(\x05R\nbaseDetail\x12\x1b\n\tbase_time\x18\t\x20\x01(\
    \x05R\x08baseTime\x12\x1b\n\tbase_hash\x18\n\x20\x01(\x05R\x08baseHash\"\
    \xa7\x03\n\x1dCUserMessageRequestDiagnostic\x12K\n\x0bdiagnostics\x18\
    \x01\x20\x03(\x0b2).CUserMessageRequestDiagnostic.DiagnosticR\x0bdiagnos\
    tics\x1a\xb8\x02\n\nDiagnostic\x12\x14\n\x05index\x18\x01\x20\x01(\x05R\
    \x05index\x12\x16\n\x06offset\x18\x02\x20\x01(\x03R\x06offset\x12\x14\n\
    \x05param\x18\x03\x20\x01(\x05R\x05param\x12\x16\n\x06length\x18\x04\x20\
    \x01(\x05R\x06length\x12\x12\n\x04type\x18\x05\x20\x01(\x05R\x04type\x12\
    \x12\n\x04base\x18\x06\x20\x01(\x03R\x04base\x12\x14\n\x05range\x18\x07\
    \x20\x01(\x03R\x05range\x12\x16\n\x06extent\x18\x08\x20\x01(\x03R\x06ext\
    ent\x12\x16\n\x06detail\x18\t\x20\x01(\x03R\x06detail\x12\x12\n\x04name\
    \x18\n\x20\x01(\tR\x04name\x12\x14\n\x05alias\x18\x0b\x20\x01(\tR\x05ali\
    as\x12\x1c\n\tvardetail\x18\x0c\x20\x01(\x0cR\tvardetail\x12\x18\n\x07co\
    ntext\x18\r\x20\x01(\x05R\x07context\"\xf7\x04\n\x20CUserMessage_Diagnos\
    tic_Response\x12N\n\x0bdiagnostics\x18\x01\x20\x03(\x0b2,.CUserMessage_D\
    iagnostic_Response.DiagnosticR\x0bdiagnostics\x12#\n\rbuild_version\x18\
    \x02\x20\x01(\x05R\x0cbuildVersion\x12\x1a\n\x08instance\x18\x03\x20\x01\
    (\x05R\x08instance\x12\x1d\n\nstart_time\x18\x04\x20\x01(\x03R\tstartTim\
    e\x12\x1c\n\tosversion\x18\x05\x20\x01(\x05R\tosversion\x12\x1a\n\x08pla\
    tform\x18\x06\x20\x01(\x05R\x08platform\x1a\xe8\x02\n\nDiagnostic\x12\
    \x14\n\x05index\x18\x01\x20\x01(\x05R\x05index\x12\x16\n\x06offset\x18\
    \x02\x20\x01(\x03R\x06offset\x12\x14\n\x05param\x18\x03\x20\x01(\x05R\
    \x05param\x12\x16\n\x06length\x18\x04\x20\x01(\x05R\x06length\x12\x16\n\
    \x06detail\x18\x05\x20\x01(\x0cR\x06detail\x12\x12\n\x04base\x18\x06\x20\
    \x01(\x03R\x04base\x12\x14\n\x05range\x18\x07\x20\x01(\x03R\x05range\x12\
    \x12\n\x04type\x18\x08\x20\x01(\x05R\x04type\x12\x12\n\x04name\x18\n\x20\
    \x01(\tR\x04name\x12\x14\n\x05alias\x18\x0b\x20\x01(\tR\x05alias\x12\x16\
    \n\x06backup\x18\x0c\x20\x01(\x0cR\x06backup\x12\x18\n\x07context\x18\r\
    \x20\x01(\x05R\x07context\x12\x18\n\x07control\x18\x0e\x20\x01(\x03R\x07\
    control\x12\x18\n\x07augment\x18\x0f\x20\x01(\x03R\x07augment\x12\x18\n\
    \x07placebo\x18\x10\x20\x01(\x03R\x07placebo\"\x94\x01\n\x1aCUserMessage\
    _ExtraUserData\x12\x12\n\x04item\x18\x01\x20\x01(\x05R\x04item\x12\x16\n\
    \x06value1\x18\x02\x20\x01(\x03R\x06value1\x12\x16\n\x06value2\x18\x03\
    \x20\x01(\x03R\x06value2\x12\x18\n\x07detail1\x18\x04\x20\x03(\x0cR\x07d\
    etail1\x12\x18\n\x07detail2\x18\x05\x20\x03(\x0cR\x07detail2*\xee\x08\n\
    \x11EBaseUserMessages\x12\x17\n\x13UM_AchievementEvent\x10e\x12\x13\n\
    \x0fUM_CloseCaption\x10f\x12\x19\n\x15UM_CloseCaptionDirect\x10g\x12\x17\
    \n\x13UM_CurrentTimescale\x10h\x12\x17\n\x13UM_DesiredTimescale\x10i\x12\
    \x0b\n\x07UM_Fade\x10j\x12\x10\n\x0cUM_GameTitle\x10k\x12\r\n\tUM_HudMsg\
    \x10n\x12\x0e\n\nUM_HudText\x10o\x12\x12\n\x0eUM_ColoredText\x10q\x12\
    \x13\n\x0fUM_RequestState\x10r\x12\x0f\n\x0bUM_ResetHUD\x10s\x12\r\n\tUM\
    _Rumble\x10t\x12\x0e\n\nUM_SayText\x10u\x12\x0f\n\x0bUM_SayText2\x10v\
    \x12\x15\n\x11UM_SayTextChannel\x10w\x12\x0c\n\x08UM_Shake\x10x\x12\x0f\
    \n\x0bUM_ShakeDir\x10y\x12\x11\n\rUM_WaterShake\x10z\x12\x0e\n\nUM_TextM\
    sg\x10|\x12\x11\n\rUM_ScreenTilt\x10}\x12\x11\n\x0cUM_VoiceMask\x10\x80\
    \x01\x12\x11\n\x0cUM_SendAudio\x10\x82\x01\x12\x12\n\rUM_ItemPickup\x10\
    \x83\x01\x12\x12\n\rUM_AmmoDenied\x10\x84\x01\x12\x10\n\x0bUM_ShowMenu\
    \x10\x86\x01\x12\x12\n\rUM_CreditsMsg\x10\x87\x01\x12\x1f\n\x1aUM_CloseC\
    aptionPlaceholder\x10\x8e\x01\x12\x18\n\x13UM_CameraTransition\x10\x8f\
    \x01\x12\x16\n\x11UM_AudioParameter\x10\x90\x01\x12\x17\n\x12UM_Particle\
    Manager\x10\x91\x01\x12\x10\n\x0bUM_HudError\x10\x92\x01\x12\x17\n\x12UM\
    _CustomGameEvent\x10\x94\x01\x12\x17\n\x12UM_AnimGraphUpdate\x10\x95\x01\
    \x12\x1b\n\x16UM_HapticsManagerPulse\x10\x96\x01\x12\x1c\n\x17UM_Haptics\
    ManagerEffect\x10\x97\x01\x12\x19\n\x14UM_CommandQueueState\x10\x98\x01\
    \x12\x18\n\x13UM_UpdateCssClasses\x10\x99\x01\x12\x17\n\x12UM_ServerFram\
    eTime\x10\x9a\x01\x12\x1c\n\x17UM_LagCompensationError\x10\x9b\x01\x12\
    \x18\n\x13UM_RequestDllStatus\x10\x9c\x01\x12\x19\n\x14UM_RequestUtilAct\
    ion\x10\x9d\x01\x12\x1a\n\x15UM_UtilActionResponse\x10\x9e\x01\x12\x19\n\
    \x14UM_DllStatusResponse\x10\x9f\x01\x12\x18\n\x13UM_RequestInventory\
    \x10\xa0\x01\x12\x19\n\x14UM_InventoryResponse\x10\xa1\x01\x12\x19\n\x14\
    UM_RequestDiagnostic\x10\xa2\x01\x12\x1a\n\x15UM_DiagnosticResponse\x10\
    \xa3\x01\x12\x15\n\x10UM_ExtraUserData\x10\xa4\x01\x12\x10\n\x0bUM_MAX_B\
    ASE\x10\xc8\x01*\x94\x01\n\x13EBaseEntityMessages\x12\x12\n\rEM_PlayJing\
    le\x10\x88\x01\x12\x15\n\x10EM_ScreenOverlay\x10\x89\x01\x12\x17\n\x12EM\
    _RemoveAllDecals\x10\x8a\x01\x12\x16\n\x11EM_PropagateForce\x10\x8b\x01\
    \x12\x0f\n\nEM_DoSpark\x10\x8c\x01\x12\x10\n\x0bEM_FixAngle\x10\x8d\x01*\
    o\n\teRollType\x12\x16\n\tROLL_NONE\x10\xff\xff\xff\xff\xff\xff\xff\xff\
    \xff\x01\x12\x0e\n\nROLL_STATS\x10\0\x12\x10\n\x0cROLL_CREDITS\x10\x01\
    \x12\x17\n\x13ROLL_LATE_JOIN_LOGO\x10\x02\x12\x0f\n\x0bROLL_OUTTRO\x10\
    \x03*\xf0\x0b\n\x10PARTICLE_MESSAGE\x12&\n\"GAME_PARTICLE_MANAGER_EVENT_\
    CREATE\x10\0\x12&\n\"GAME_PARTICLE_MANAGER_EVENT_UPDATE\x10\x01\x12.\n*G\
    AME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD\x10\x02\x122\n.GAME_PARTICLE_M\
    ANAGER_EVENT_UPDATE_ORIENTATION\x10\x03\x12/\n+GAME_PARTICLE_MANAGER_EVE\
    NT_UPDATE_FALLBACK\x10\x04\x12*\n&GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT\
    \x10\x05\x12-\n)GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET\x10\x06\x12'\n\
    #GAME_PARTICLE_MANAGER_EVENT_DESTROY\x10\x07\x121\n-GAME_PARTICLE_MANAGE\
    R_EVENT_DESTROY_INVOLVING\x10\x08\x12'\n#GAME_PARTICLE_MANAGER_EVENT_REL\
    EASE\x10\t\x12'\n#GAME_PARTICLE_MANAGER_EVENT_LATENCY\x10\n\x12+\n'GAME_\
    PARTICLE_MANAGER_EVENT_SHOULD_DRAW\x10\x0b\x12&\n\"GAME_PARTICLE_MANAGER\
    _EVENT_FROZEN\x10\x0c\x12?\n;GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_\
    POINT_ATTACHMENT\x10\r\x126\n2GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_\
    POSITION\x10\x0e\x122\n.GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES\
    \x10\x0f\x12(\n$GAME_PARTICLE_MANAGER_EVENT_SET_TEXT\x10\x10\x124\n0GAME\
    _PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW\x10\x11\x127\n3GAME_PARTICL\
    E_MANAGER_EVENT_SET_CONTROL_POINT_MODEL\x10\x12\x12:\n6GAME_PARTICLE_MAN\
    AGER_EVENT_SET_CONTROL_POINT_SNAPSHOT\x10\x13\x125\n1GAME_PARTICLE_MANAG\
    ER_EVENT_SET_TEXTURE_ATTRIBUTE\x10\x14\x12=\n9GAME_PARTICLE_MANAGER_EVEN\
    T_SET_SCENE_OBJECT_GENERIC_FLAG\x10\x15\x12?\n;GAME_PARTICLE_MANAGER_EVE\
    NT_SET_SCENE_OBJECT_TINT_AND_DESAT\x10\x16\x12-\n)GAME_PARTICLE_MANAGER_\
    EVENT_DESTROY_NAMED\x10\x17\x12,\n(GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_T\
    IME\x10\x18\x12*\n&GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE\x10\x19\x127\n\
    3GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT\x10\x1a\x120\n,GAME\
    _PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM\x10\x1b\x12:\n6GAME_PARTICLE_MA\
    NAGER_EVENT_FREEZE_TRANSITION_OVERRIDE\x10\x1c\x120\n,GAME_PARTICLE_MANA\
    GER_EVENT_FREEZE_INVOLVING\x10\x1d*t\n\x10EHapticPulseType\x12\x1e\n\x1a\
    VR_HAND_HAPTIC_PULSE_LIGHT\x10\0\x12\x1f\n\x1bVR_HAND_HAPTIC_PULSE_MEDIU\
    M\x10\x01\x12\x1f\n\x1bVR_HAND_HAPTIC_PULSE_STRONG\x10\x02\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::networkbasetypes::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(96);
            messages.push(CUserMessageAchievementEvent::generated_message_descriptor_data());
            messages.push(CUserMessageCloseCaption::generated_message_descriptor_data());
            messages.push(CUserMessageCloseCaptionDirect::generated_message_descriptor_data());
            messages.push(CUserMessageCloseCaptionPlaceholder::generated_message_descriptor_data());
            messages.push(CUserMessageCurrentTimescale::generated_message_descriptor_data());
            messages.push(CUserMessageDesiredTimescale::generated_message_descriptor_data());
            messages.push(CUserMessageFade::generated_message_descriptor_data());
            messages.push(CUserMessageShake::generated_message_descriptor_data());
            messages.push(CUserMessageShakeDir::generated_message_descriptor_data());
            messages.push(CUserMessageWaterShake::generated_message_descriptor_data());
            messages.push(CUserMessageScreenTilt::generated_message_descriptor_data());
            messages.push(CUserMessageSayText::generated_message_descriptor_data());
            messages.push(CUserMessageSayText2::generated_message_descriptor_data());
            messages.push(CUserMessageHudMsg::generated_message_descriptor_data());
            messages.push(CUserMessageHudText::generated_message_descriptor_data());
            messages.push(CUserMessageTextMsg::generated_message_descriptor_data());
            messages.push(CUserMessageGameTitle::generated_message_descriptor_data());
            messages.push(CUserMessageResetHUD::generated_message_descriptor_data());
            messages.push(CUserMessageSendAudio::generated_message_descriptor_data());
            messages.push(CUserMessageAudioParameter::generated_message_descriptor_data());
            messages.push(CUserMessageVoiceMask::generated_message_descriptor_data());
            messages.push(CUserMessageRequestState::generated_message_descriptor_data());
            messages.push(CUserMessageRumble::generated_message_descriptor_data());
            messages.push(CUserMessageSayTextChannel::generated_message_descriptor_data());
            messages.push(CUserMessageColoredText::generated_message_descriptor_data());
            messages.push(CUserMessageItemPickup::generated_message_descriptor_data());
            messages.push(CUserMessageAmmoDenied::generated_message_descriptor_data());
            messages.push(CUserMessageShowMenu::generated_message_descriptor_data());
            messages.push(CUserMessageCreditsMsg::generated_message_descriptor_data());
            messages.push(CEntityMessagePlayJingle::generated_message_descriptor_data());
            messages.push(CEntityMessageScreenOverlay::generated_message_descriptor_data());
            messages.push(CEntityMessageRemoveAllDecals::generated_message_descriptor_data());
            messages.push(CEntityMessagePropagateForce::generated_message_descriptor_data());
            messages.push(CEntityMessageDoSpark::generated_message_descriptor_data());
            messages.push(CEntityMessageFixAngle::generated_message_descriptor_data());
            messages.push(CUserMessageCameraTransition::generated_message_descriptor_data());
            messages.push(CUserMsg_ParticleManager::generated_message_descriptor_data());
            messages.push(CUserMsg_HudError::generated_message_descriptor_data());
            messages.push(CUserMsg_CustomGameEvent::generated_message_descriptor_data());
            messages.push(CUserMessageHapticsManagerPulse::generated_message_descriptor_data());
            messages.push(CUserMessageHapticsManagerEffect::generated_message_descriptor_data());
            messages.push(CUserMessageAnimStateGraphState::generated_message_descriptor_data());
            messages.push(CUserMessageCommandQueueState::generated_message_descriptor_data());
            messages.push(CUserMessageUpdateCssClasses::generated_message_descriptor_data());
            messages.push(CUserMessageServerFrameTime::generated_message_descriptor_data());
            messages.push(CUserMessageLagCompensationError::generated_message_descriptor_data());
            messages.push(CUserMessageRequestDllStatus::generated_message_descriptor_data());
            messages.push(CUserMessageRequestUtilAction::generated_message_descriptor_data());
            messages.push(CUserMessage_UtilMsg_Response::generated_message_descriptor_data());
            messages.push(CUserMessage_DllStatus::generated_message_descriptor_data());
            messages.push(CUserMessageRequestInventory::generated_message_descriptor_data());
            messages.push(CUserMessage_Inventory_Response::generated_message_descriptor_data());
            messages.push(CUserMessageRequestDiagnostic::generated_message_descriptor_data());
            messages.push(CUserMessage_Diagnostic_Response::generated_message_descriptor_data());
            messages.push(CUserMessage_ExtraUserData::generated_message_descriptor_data());
            messages.push(cuser_message_camera_transition::Transition_DataDriven::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::ReleaseParticleIndex::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::CreateParticle::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::DestroyParticle::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::DestroyParticleInvolving::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::DestroyParticleNamed::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::UpdateParticle_OBSOLETE::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::UpdateParticleFwd_OBSOLETE::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::UpdateParticleOrient_OBSOLETE::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::UpdateParticleTransform::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::UpdateParticleFallback::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::UpdateParticleOffset::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::UpdateParticleEnt::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::UpdateParticleSetFrozen::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::UpdateParticleShouldDraw::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::ChangeControlPointAttachment::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::UpdateEntityPosition::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::SetParticleFoWProperties::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::SetParticleShouldCheckFoW::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::SetControlPointModel::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::SetControlPointSnapshot::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::SetParticleText::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::SetTextureAttribute::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::SetSceneObjectGenericFlag::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::SetSceneObjectTintAndDesat::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::ParticleSkipToTime::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::ParticleCanFreeze::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::ParticleFreezeTransitionOverride::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::FreezeParticleInvolving::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::SetParticleNamedValueContext::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::set_particle_named_value_context::FloatContextValue::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::set_particle_named_value_context::VectorContextValue::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::set_particle_named_value_context::TransformContextValue::generated_message_descriptor_data());
            messages.push(cuser_msg_particle_manager::set_particle_named_value_context::EHandleContext::generated_message_descriptor_data());
            messages.push(cuser_message_command_queue_state::Command_queue_info_t::generated_message_descriptor_data());
            messages.push(cuser_message_util_msg_response::ItemDetail::generated_message_descriptor_data());
            messages.push(cuser_message_dll_status::CVDiagnostic::generated_message_descriptor_data());
            messages.push(cuser_message_dll_status::CModule::generated_message_descriptor_data());
            messages.push(cuser_message_inventory_response::InventoryDetail::generated_message_descriptor_data());
            messages.push(cuser_message_request_diagnostic::Diagnostic::generated_message_descriptor_data());
            messages.push(cuser_message_diagnostic_response::Diagnostic::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(EBaseUserMessages::generated_enum_descriptor_data());
            enums.push(EBaseEntityMessages::generated_enum_descriptor_data());
            enums.push(ERollType::generated_enum_descriptor_data());
            enums.push(PARTICLE_MESSAGE::generated_enum_descriptor_data());
            enums.push(EHapticPulseType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
