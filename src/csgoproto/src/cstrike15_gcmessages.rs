// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cstrike15_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:GameServerPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GameServerPing {
    // message fields
    // @@protoc_insertion_point(field:GameServerPing.ping)
    pub ping: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GameServerPing.ip)
    pub ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GameServerPing.instances)
    pub instances: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:GameServerPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GameServerPing {
    fn default() -> &'a GameServerPing {
        <GameServerPing as ::protobuf::Message>::default_instance()
    }
}

impl GameServerPing {
    pub fn new() -> GameServerPing {
        ::std::default::Default::default()
    }

    // optional int32 ping = 2;

    pub fn ping(&self) -> i32 {
        self.ping.unwrap_or(0)
    }

    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: i32) {
        self.ping = ::std::option::Option::Some(v);
    }

    // optional uint32 ip = 3;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional uint32 instances = 5;

    pub fn instances(&self) -> u32 {
        self.instances.unwrap_or(0)
    }

    pub fn clear_instances(&mut self) {
        self.instances = ::std::option::Option::None;
    }

    pub fn has_instances(&self) -> bool {
        self.instances.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instances(&mut self, v: u32) {
        self.instances = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping",
            |m: &GameServerPing| { &m.ping },
            |m: &mut GameServerPing| { &mut m.ping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &GameServerPing| { &m.ip },
            |m: &mut GameServerPing| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "instances",
            |m: &GameServerPing| { &m.instances },
            |m: &mut GameServerPing| { &mut m.instances },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GameServerPing>(
            "GameServerPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GameServerPing {
    const NAME: &'static str = "GameServerPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.ping = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.instances = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.instances {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ping {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.instances {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GameServerPing {
        GameServerPing::new()
    }

    fn clear(&mut self) {
        self.ping = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.instances = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GameServerPing {
        static instance: GameServerPing = GameServerPing {
            ping: ::std::option::Option::None,
            ip: ::std::option::Option::None,
            instances: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GameServerPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GameServerPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GameServerPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameServerPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DataCenterPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DataCenterPing {
    // message fields
    // @@protoc_insertion_point(field:DataCenterPing.data_center_id)
    pub data_center_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DataCenterPing.ping)
    pub ping: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:DataCenterPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DataCenterPing {
    fn default() -> &'a DataCenterPing {
        <DataCenterPing as ::protobuf::Message>::default_instance()
    }
}

impl DataCenterPing {
    pub fn new() -> DataCenterPing {
        ::std::default::Default::default()
    }

    // optional fixed32 data_center_id = 1;

    pub fn data_center_id(&self) -> u32 {
        self.data_center_id.unwrap_or(0)
    }

    pub fn clear_data_center_id(&mut self) {
        self.data_center_id = ::std::option::Option::None;
    }

    pub fn has_data_center_id(&self) -> bool {
        self.data_center_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_center_id(&mut self, v: u32) {
        self.data_center_id = ::std::option::Option::Some(v);
    }

    // optional sint32 ping = 2;

    pub fn ping(&self) -> i32 {
        self.ping.unwrap_or(0)
    }

    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: i32) {
        self.ping = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_center_id",
            |m: &DataCenterPing| { &m.data_center_id },
            |m: &mut DataCenterPing| { &mut m.data_center_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping",
            |m: &DataCenterPing| { &m.ping },
            |m: &mut DataCenterPing| { &mut m.ping },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DataCenterPing>(
            "DataCenterPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DataCenterPing {
    const NAME: &'static str = "DataCenterPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.data_center_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.ping = ::std::option::Option::Some(is.read_sint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data_center_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::sint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data_center_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.ping {
            os.write_sint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DataCenterPing {
        DataCenterPing::new()
    }

    fn clear(&mut self) {
        self.data_center_id = ::std::option::Option::None;
        self.ping = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DataCenterPing {
        static instance: DataCenterPing = DataCenterPing {
            data_center_id: ::std::option::Option::None,
            ping: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DataCenterPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DataCenterPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DataCenterPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DataCenterPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DetailedSearchStatistic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DetailedSearchStatistic {
    // message fields
    // @@protoc_insertion_point(field:DetailedSearchStatistic.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DetailedSearchStatistic.search_time_avg)
    pub search_time_avg: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DetailedSearchStatistic.players_searching)
    pub players_searching: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:DetailedSearchStatistic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DetailedSearchStatistic {
    fn default() -> &'a DetailedSearchStatistic {
        <DetailedSearchStatistic as ::protobuf::Message>::default_instance()
    }
}

impl DetailedSearchStatistic {
    pub fn new() -> DetailedSearchStatistic {
        ::std::default::Default::default()
    }

    // optional uint32 game_type = 1;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional uint32 search_time_avg = 2;

    pub fn search_time_avg(&self) -> u32 {
        self.search_time_avg.unwrap_or(0)
    }

    pub fn clear_search_time_avg(&mut self) {
        self.search_time_avg = ::std::option::Option::None;
    }

    pub fn has_search_time_avg(&self) -> bool {
        self.search_time_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_time_avg(&mut self, v: u32) {
        self.search_time_avg = ::std::option::Option::Some(v);
    }

    // optional uint32 players_searching = 4;

    pub fn players_searching(&self) -> u32 {
        self.players_searching.unwrap_or(0)
    }

    pub fn clear_players_searching(&mut self) {
        self.players_searching = ::std::option::Option::None;
    }

    pub fn has_players_searching(&self) -> bool {
        self.players_searching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_searching(&mut self, v: u32) {
        self.players_searching = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &DetailedSearchStatistic| { &m.game_type },
            |m: &mut DetailedSearchStatistic| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_time_avg",
            |m: &DetailedSearchStatistic| { &m.search_time_avg },
            |m: &mut DetailedSearchStatistic| { &mut m.search_time_avg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "players_searching",
            |m: &DetailedSearchStatistic| { &m.players_searching },
            |m: &mut DetailedSearchStatistic| { &mut m.players_searching },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DetailedSearchStatistic>(
            "DetailedSearchStatistic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DetailedSearchStatistic {
    const NAME: &'static str = "DetailedSearchStatistic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.search_time_avg = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.players_searching = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.search_time_avg {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.players_searching {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.search_time_avg {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.players_searching {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DetailedSearchStatistic {
        DetailedSearchStatistic::new()
    }

    fn clear(&mut self) {
        self.game_type = ::std::option::Option::None;
        self.search_time_avg = ::std::option::Option::None;
        self.players_searching = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DetailedSearchStatistic {
        static instance: DetailedSearchStatistic = DetailedSearchStatistic {
            game_type: ::std::option::Option::None,
            search_time_avg: ::std::option::Option::None,
            players_searching: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DetailedSearchStatistic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DetailedSearchStatistic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DetailedSearchStatistic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetailedSearchStatistic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TournamentPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TournamentPlayer {
    // message fields
    // @@protoc_insertion_point(field:TournamentPlayer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_nick)
    pub player_nick: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_name)
    pub player_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_dob)
    pub player_dob: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_flag)
    pub player_flag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_location)
    pub player_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_desc)
    pub player_desc: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:TournamentPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TournamentPlayer {
    fn default() -> &'a TournamentPlayer {
        <TournamentPlayer as ::protobuf::Message>::default_instance()
    }
}

impl TournamentPlayer {
    pub fn new() -> TournamentPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string player_nick = 2;

    pub fn player_nick(&self) -> &str {
        match self.player_nick.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_nick(&mut self) {
        self.player_nick = ::std::option::Option::None;
    }

    pub fn has_player_nick(&self) -> bool {
        self.player_nick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_nick(&mut self, v: ::std::string::String) {
        self.player_nick = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_nick(&mut self) -> &mut ::std::string::String {
        if self.player_nick.is_none() {
            self.player_nick = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_nick.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_nick(&mut self) -> ::std::string::String {
        self.player_nick.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string player_name = 3;

    pub fn player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name = ::std::option::Option::None;
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 player_dob = 4;

    pub fn player_dob(&self) -> u32 {
        self.player_dob.unwrap_or(0)
    }

    pub fn clear_player_dob(&mut self) {
        self.player_dob = ::std::option::Option::None;
    }

    pub fn has_player_dob(&self) -> bool {
        self.player_dob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_dob(&mut self, v: u32) {
        self.player_dob = ::std::option::Option::Some(v);
    }

    // optional string player_flag = 5;

    pub fn player_flag(&self) -> &str {
        match self.player_flag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_flag(&mut self) {
        self.player_flag = ::std::option::Option::None;
    }

    pub fn has_player_flag(&self) -> bool {
        self.player_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_flag(&mut self, v: ::std::string::String) {
        self.player_flag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_flag(&mut self) -> &mut ::std::string::String {
        if self.player_flag.is_none() {
            self.player_flag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_flag.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_flag(&mut self) -> ::std::string::String {
        self.player_flag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string player_location = 6;

    pub fn player_location(&self) -> &str {
        match self.player_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_location(&mut self) {
        self.player_location = ::std::option::Option::None;
    }

    pub fn has_player_location(&self) -> bool {
        self.player_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_location(&mut self, v: ::std::string::String) {
        self.player_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_location(&mut self) -> &mut ::std::string::String {
        if self.player_location.is_none() {
            self.player_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_location(&mut self) -> ::std::string::String {
        self.player_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string player_desc = 7;

    pub fn player_desc(&self) -> &str {
        match self.player_desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_desc(&mut self) {
        self.player_desc = ::std::option::Option::None;
    }

    pub fn has_player_desc(&self) -> bool {
        self.player_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_desc(&mut self, v: ::std::string::String) {
        self.player_desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_desc(&mut self) -> &mut ::std::string::String {
        if self.player_desc.is_none() {
            self.player_desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_desc(&mut self) -> ::std::string::String {
        self.player_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &TournamentPlayer| { &m.account_id },
            |m: &mut TournamentPlayer| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_nick",
            |m: &TournamentPlayer| { &m.player_nick },
            |m: &mut TournamentPlayer| { &mut m.player_nick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_name",
            |m: &TournamentPlayer| { &m.player_name },
            |m: &mut TournamentPlayer| { &mut m.player_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_dob",
            |m: &TournamentPlayer| { &m.player_dob },
            |m: &mut TournamentPlayer| { &mut m.player_dob },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_flag",
            |m: &TournamentPlayer| { &m.player_flag },
            |m: &mut TournamentPlayer| { &mut m.player_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_location",
            |m: &TournamentPlayer| { &m.player_location },
            |m: &mut TournamentPlayer| { &mut m.player_location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_desc",
            |m: &TournamentPlayer| { &m.player_desc },
            |m: &mut TournamentPlayer| { &mut m.player_desc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TournamentPlayer>(
            "TournamentPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TournamentPlayer {
    const NAME: &'static str = "TournamentPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.player_nick = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.player_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.player_dob = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.player_flag = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.player_location = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.player_desc = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_nick.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.player_dob {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.player_flag.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.player_location.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.player_desc.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_nick.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.player_dob {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.player_flag.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.player_location.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.player_desc.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TournamentPlayer {
        TournamentPlayer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.player_nick = ::std::option::Option::None;
        self.player_name = ::std::option::Option::None;
        self.player_dob = ::std::option::Option::None;
        self.player_flag = ::std::option::Option::None;
        self.player_location = ::std::option::Option::None;
        self.player_desc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TournamentPlayer {
        static instance: TournamentPlayer = TournamentPlayer {
            account_id: ::std::option::Option::None,
            player_nick: ::std::option::Option::None,
            player_name: ::std::option::Option::None,
            player_dob: ::std::option::Option::None,
            player_flag: ::std::option::Option::None,
            player_location: ::std::option::Option::None,
            player_desc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TournamentPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TournamentPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TournamentPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TournamentTeam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TournamentTeam {
    // message fields
    // @@protoc_insertion_point(field:TournamentTeam.team_id)
    pub team_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentTeam.team_tag)
    pub team_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentTeam.team_flag)
    pub team_flag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentTeam.team_name)
    pub team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentTeam.players)
    pub players: ::std::vec::Vec<TournamentPlayer>,
    // special fields
    // @@protoc_insertion_point(special_field:TournamentTeam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TournamentTeam {
    fn default() -> &'a TournamentTeam {
        <TournamentTeam as ::protobuf::Message>::default_instance()
    }
}

impl TournamentTeam {
    pub fn new() -> TournamentTeam {
        ::std::default::Default::default()
    }

    // optional int32 team_id = 1;

    pub fn team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional string team_tag = 2;

    pub fn team_tag(&self) -> &str {
        match self.team_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_tag(&mut self) {
        self.team_tag = ::std::option::Option::None;
    }

    pub fn has_team_tag(&self) -> bool {
        self.team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_tag(&mut self, v: ::std::string::String) {
        self.team_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
        if self.team_tag.is_none() {
            self.team_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_tag(&mut self) -> ::std::string::String {
        self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string team_flag = 3;

    pub fn team_flag(&self) -> &str {
        match self.team_flag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_flag(&mut self) {
        self.team_flag = ::std::option::Option::None;
    }

    pub fn has_team_flag(&self) -> bool {
        self.team_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_flag(&mut self, v: ::std::string::String) {
        self.team_flag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_flag(&mut self) -> &mut ::std::string::String {
        if self.team_flag.is_none() {
            self.team_flag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_flag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_flag(&mut self) -> ::std::string::String {
        self.team_flag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string team_name = 4;

    pub fn team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_name(&mut self) {
        self.team_name = ::std::option::Option::None;
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &TournamentTeam| { &m.team_id },
            |m: &mut TournamentTeam| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_tag",
            |m: &TournamentTeam| { &m.team_tag },
            |m: &mut TournamentTeam| { &mut m.team_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_flag",
            |m: &TournamentTeam| { &m.team_flag },
            |m: &mut TournamentTeam| { &mut m.team_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_name",
            |m: &TournamentTeam| { &m.team_name },
            |m: &mut TournamentTeam| { &mut m.team_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &TournamentTeam| { &m.players },
            |m: &mut TournamentTeam| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TournamentTeam>(
            "TournamentTeam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TournamentTeam {
    const NAME: &'static str = "TournamentTeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.team_tag = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.team_flag = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.team_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.team_flag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_tag.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.team_flag.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.team_name.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TournamentTeam {
        TournamentTeam::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.team_tag = ::std::option::Option::None;
        self.team_flag = ::std::option::Option::None;
        self.team_name = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TournamentTeam {
        static instance: TournamentTeam = TournamentTeam {
            team_id: ::std::option::Option::None,
            team_tag: ::std::option::Option::None,
            team_flag: ::std::option::Option::None,
            team_name: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TournamentTeam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TournamentTeam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TournamentTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentTeam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TournamentEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TournamentEvent {
    // message fields
    // @@protoc_insertion_point(field:TournamentEvent.event_id)
    pub event_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentEvent.event_tag)
    pub event_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentEvent.event_time_start)
    pub event_time_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:TournamentEvent.event_time_end)
    pub event_time_end: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:TournamentEvent.event_public)
    pub event_public: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentEvent.event_stage_id)
    pub event_stage_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentEvent.event_stage_name)
    pub event_stage_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentEvent.active_section_id)
    pub active_section_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:TournamentEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TournamentEvent {
    fn default() -> &'a TournamentEvent {
        <TournamentEvent as ::protobuf::Message>::default_instance()
    }
}

impl TournamentEvent {
    pub fn new() -> TournamentEvent {
        ::std::default::Default::default()
    }

    // optional int32 event_id = 1;

    pub fn event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional string event_tag = 2;

    pub fn event_tag(&self) -> &str {
        match self.event_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_tag(&mut self) {
        self.event_tag = ::std::option::Option::None;
    }

    pub fn has_event_tag(&self) -> bool {
        self.event_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_tag(&mut self, v: ::std::string::String) {
        self.event_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_tag(&mut self) -> &mut ::std::string::String {
        if self.event_tag.is_none() {
            self.event_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_tag(&mut self) -> ::std::string::String {
        self.event_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string event_name = 3;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 event_time_start = 4;

    pub fn event_time_start(&self) -> u32 {
        self.event_time_start.unwrap_or(0)
    }

    pub fn clear_event_time_start(&mut self) {
        self.event_time_start = ::std::option::Option::None;
    }

    pub fn has_event_time_start(&self) -> bool {
        self.event_time_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time_start(&mut self, v: u32) {
        self.event_time_start = ::std::option::Option::Some(v);
    }

    // optional uint32 event_time_end = 5;

    pub fn event_time_end(&self) -> u32 {
        self.event_time_end.unwrap_or(0)
    }

    pub fn clear_event_time_end(&mut self) {
        self.event_time_end = ::std::option::Option::None;
    }

    pub fn has_event_time_end(&self) -> bool {
        self.event_time_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time_end(&mut self, v: u32) {
        self.event_time_end = ::std::option::Option::Some(v);
    }

    // optional int32 event_public = 6;

    pub fn event_public(&self) -> i32 {
        self.event_public.unwrap_or(0)
    }

    pub fn clear_event_public(&mut self) {
        self.event_public = ::std::option::Option::None;
    }

    pub fn has_event_public(&self) -> bool {
        self.event_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_public(&mut self, v: i32) {
        self.event_public = ::std::option::Option::Some(v);
    }

    // optional int32 event_stage_id = 7;

    pub fn event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }

    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    // optional string event_stage_name = 8;

    pub fn event_stage_name(&self) -> &str {
        match self.event_stage_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_stage_name(&mut self) {
        self.event_stage_name = ::std::option::Option::None;
    }

    pub fn has_event_stage_name(&self) -> bool {
        self.event_stage_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_name(&mut self, v: ::std::string::String) {
        self.event_stage_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stage_name(&mut self) -> &mut ::std::string::String {
        if self.event_stage_name.is_none() {
            self.event_stage_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_stage_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stage_name(&mut self) -> ::std::string::String {
        self.event_stage_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 active_section_id = 9;

    pub fn active_section_id(&self) -> u32 {
        self.active_section_id.unwrap_or(0)
    }

    pub fn clear_active_section_id(&mut self) {
        self.active_section_id = ::std::option::Option::None;
    }

    pub fn has_active_section_id(&self) -> bool {
        self.active_section_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_section_id(&mut self, v: u32) {
        self.active_section_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &TournamentEvent| { &m.event_id },
            |m: &mut TournamentEvent| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_tag",
            |m: &TournamentEvent| { &m.event_tag },
            |m: &mut TournamentEvent| { &mut m.event_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_name",
            |m: &TournamentEvent| { &m.event_name },
            |m: &mut TournamentEvent| { &mut m.event_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_time_start",
            |m: &TournamentEvent| { &m.event_time_start },
            |m: &mut TournamentEvent| { &mut m.event_time_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_time_end",
            |m: &TournamentEvent| { &m.event_time_end },
            |m: &mut TournamentEvent| { &mut m.event_time_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_public",
            |m: &TournamentEvent| { &m.event_public },
            |m: &mut TournamentEvent| { &mut m.event_public },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_stage_id",
            |m: &TournamentEvent| { &m.event_stage_id },
            |m: &mut TournamentEvent| { &mut m.event_stage_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_stage_name",
            |m: &TournamentEvent| { &m.event_stage_name },
            |m: &mut TournamentEvent| { &mut m.event_stage_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_section_id",
            |m: &TournamentEvent| { &m.active_section_id },
            |m: &mut TournamentEvent| { &mut m.active_section_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TournamentEvent>(
            "TournamentEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TournamentEvent {
    const NAME: &'static str = "TournamentEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.event_tag = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.event_time_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.event_time_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.event_public = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.event_stage_id = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    self.event_stage_name = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.active_section_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.event_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.event_time_start {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.event_time_end {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.event_public {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.event_stage_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.active_section_id {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.event_tag.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.event_time_start {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_time_end {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.event_public {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.event_stage_name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.active_section_id {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TournamentEvent {
        TournamentEvent::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.event_tag = ::std::option::Option::None;
        self.event_name = ::std::option::Option::None;
        self.event_time_start = ::std::option::Option::None;
        self.event_time_end = ::std::option::Option::None;
        self.event_public = ::std::option::Option::None;
        self.event_stage_id = ::std::option::Option::None;
        self.event_stage_name = ::std::option::Option::None;
        self.active_section_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TournamentEvent {
        static instance: TournamentEvent = TournamentEvent {
            event_id: ::std::option::Option::None,
            event_tag: ::std::option::Option::None,
            event_name: ::std::option::Option::None,
            event_time_start: ::std::option::Option::None,
            event_time_end: ::std::option::Option::None,
            event_public: ::std::option::Option::None,
            event_stage_id: ::std::option::Option::None,
            event_stage_name: ::std::option::Option::None,
            active_section_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TournamentEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TournamentEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TournamentEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GlobalStatistics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GlobalStatistics {
    // message fields
    // @@protoc_insertion_point(field:GlobalStatistics.players_online)
    pub players_online: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.servers_online)
    pub servers_online: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.players_searching)
    pub players_searching: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.servers_available)
    pub servers_available: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.ongoing_matches)
    pub ongoing_matches: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.search_time_avg)
    pub search_time_avg: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.search_statistics)
    pub search_statistics: ::std::vec::Vec<DetailedSearchStatistic>,
    // @@protoc_insertion_point(field:GlobalStatistics.main_post_url)
    pub main_post_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GlobalStatistics.required_appid_version)
    pub required_appid_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.pricesheet_version)
    pub pricesheet_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.twitch_streams_version)
    pub twitch_streams_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.active_tournament_eventid)
    pub active_tournament_eventid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.active_survey_id)
    pub active_survey_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.rtime32_cur)
    pub rtime32_cur: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.rtime32_event_start)
    pub rtime32_event_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.required_appid_version2)
    pub required_appid_version2: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:GlobalStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GlobalStatistics {
    fn default() -> &'a GlobalStatistics {
        <GlobalStatistics as ::protobuf::Message>::default_instance()
    }
}

impl GlobalStatistics {
    pub fn new() -> GlobalStatistics {
        ::std::default::Default::default()
    }

    // optional uint32 players_online = 1;

    pub fn players_online(&self) -> u32 {
        self.players_online.unwrap_or(0)
    }

    pub fn clear_players_online(&mut self) {
        self.players_online = ::std::option::Option::None;
    }

    pub fn has_players_online(&self) -> bool {
        self.players_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_online(&mut self, v: u32) {
        self.players_online = ::std::option::Option::Some(v);
    }

    // optional uint32 servers_online = 2;

    pub fn servers_online(&self) -> u32 {
        self.servers_online.unwrap_or(0)
    }

    pub fn clear_servers_online(&mut self) {
        self.servers_online = ::std::option::Option::None;
    }

    pub fn has_servers_online(&self) -> bool {
        self.servers_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servers_online(&mut self, v: u32) {
        self.servers_online = ::std::option::Option::Some(v);
    }

    // optional uint32 players_searching = 3;

    pub fn players_searching(&self) -> u32 {
        self.players_searching.unwrap_or(0)
    }

    pub fn clear_players_searching(&mut self) {
        self.players_searching = ::std::option::Option::None;
    }

    pub fn has_players_searching(&self) -> bool {
        self.players_searching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_searching(&mut self, v: u32) {
        self.players_searching = ::std::option::Option::Some(v);
    }

    // optional uint32 servers_available = 4;

    pub fn servers_available(&self) -> u32 {
        self.servers_available.unwrap_or(0)
    }

    pub fn clear_servers_available(&mut self) {
        self.servers_available = ::std::option::Option::None;
    }

    pub fn has_servers_available(&self) -> bool {
        self.servers_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servers_available(&mut self, v: u32) {
        self.servers_available = ::std::option::Option::Some(v);
    }

    // optional uint32 ongoing_matches = 5;

    pub fn ongoing_matches(&self) -> u32 {
        self.ongoing_matches.unwrap_or(0)
    }

    pub fn clear_ongoing_matches(&mut self) {
        self.ongoing_matches = ::std::option::Option::None;
    }

    pub fn has_ongoing_matches(&self) -> bool {
        self.ongoing_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ongoing_matches(&mut self, v: u32) {
        self.ongoing_matches = ::std::option::Option::Some(v);
    }

    // optional uint32 search_time_avg = 6;

    pub fn search_time_avg(&self) -> u32 {
        self.search_time_avg.unwrap_or(0)
    }

    pub fn clear_search_time_avg(&mut self) {
        self.search_time_avg = ::std::option::Option::None;
    }

    pub fn has_search_time_avg(&self) -> bool {
        self.search_time_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_time_avg(&mut self, v: u32) {
        self.search_time_avg = ::std::option::Option::Some(v);
    }

    // optional string main_post_url = 8;

    pub fn main_post_url(&self) -> &str {
        match self.main_post_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_main_post_url(&mut self) {
        self.main_post_url = ::std::option::Option::None;
    }

    pub fn has_main_post_url(&self) -> bool {
        self.main_post_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_post_url(&mut self, v: ::std::string::String) {
        self.main_post_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_post_url(&mut self) -> &mut ::std::string::String {
        if self.main_post_url.is_none() {
            self.main_post_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.main_post_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_post_url(&mut self) -> ::std::string::String {
        self.main_post_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 required_appid_version = 9;

    pub fn required_appid_version(&self) -> u32 {
        self.required_appid_version.unwrap_or(0)
    }

    pub fn clear_required_appid_version(&mut self) {
        self.required_appid_version = ::std::option::Option::None;
    }

    pub fn has_required_appid_version(&self) -> bool {
        self.required_appid_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_appid_version(&mut self, v: u32) {
        self.required_appid_version = ::std::option::Option::Some(v);
    }

    // optional uint32 pricesheet_version = 10;

    pub fn pricesheet_version(&self) -> u32 {
        self.pricesheet_version.unwrap_or(0)
    }

    pub fn clear_pricesheet_version(&mut self) {
        self.pricesheet_version = ::std::option::Option::None;
    }

    pub fn has_pricesheet_version(&self) -> bool {
        self.pricesheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pricesheet_version(&mut self, v: u32) {
        self.pricesheet_version = ::std::option::Option::Some(v);
    }

    // optional uint32 twitch_streams_version = 11;

    pub fn twitch_streams_version(&self) -> u32 {
        self.twitch_streams_version.unwrap_or(0)
    }

    pub fn clear_twitch_streams_version(&mut self) {
        self.twitch_streams_version = ::std::option::Option::None;
    }

    pub fn has_twitch_streams_version(&self) -> bool {
        self.twitch_streams_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twitch_streams_version(&mut self, v: u32) {
        self.twitch_streams_version = ::std::option::Option::Some(v);
    }

    // optional uint32 active_tournament_eventid = 12;

    pub fn active_tournament_eventid(&self) -> u32 {
        self.active_tournament_eventid.unwrap_or(0)
    }

    pub fn clear_active_tournament_eventid(&mut self) {
        self.active_tournament_eventid = ::std::option::Option::None;
    }

    pub fn has_active_tournament_eventid(&self) -> bool {
        self.active_tournament_eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_tournament_eventid(&mut self, v: u32) {
        self.active_tournament_eventid = ::std::option::Option::Some(v);
    }

    // optional uint32 active_survey_id = 13;

    pub fn active_survey_id(&self) -> u32 {
        self.active_survey_id.unwrap_or(0)
    }

    pub fn clear_active_survey_id(&mut self) {
        self.active_survey_id = ::std::option::Option::None;
    }

    pub fn has_active_survey_id(&self) -> bool {
        self.active_survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_survey_id(&mut self, v: u32) {
        self.active_survey_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_cur = 14;

    pub fn rtime32_cur(&self) -> u32 {
        self.rtime32_cur.unwrap_or(0)
    }

    pub fn clear_rtime32_cur(&mut self) {
        self.rtime32_cur = ::std::option::Option::None;
    }

    pub fn has_rtime32_cur(&self) -> bool {
        self.rtime32_cur.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_cur(&mut self, v: u32) {
        self.rtime32_cur = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_event_start = 15;

    pub fn rtime32_event_start(&self) -> u32 {
        self.rtime32_event_start.unwrap_or(0)
    }

    pub fn clear_rtime32_event_start(&mut self) {
        self.rtime32_event_start = ::std::option::Option::None;
    }

    pub fn has_rtime32_event_start(&self) -> bool {
        self.rtime32_event_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_event_start(&mut self, v: u32) {
        self.rtime32_event_start = ::std::option::Option::Some(v);
    }

    // optional uint32 required_appid_version2 = 16;

    pub fn required_appid_version2(&self) -> u32 {
        self.required_appid_version2.unwrap_or(0)
    }

    pub fn clear_required_appid_version2(&mut self) {
        self.required_appid_version2 = ::std::option::Option::None;
    }

    pub fn has_required_appid_version2(&self) -> bool {
        self.required_appid_version2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_appid_version2(&mut self, v: u32) {
        self.required_appid_version2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "players_online",
            |m: &GlobalStatistics| { &m.players_online },
            |m: &mut GlobalStatistics| { &mut m.players_online },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "servers_online",
            |m: &GlobalStatistics| { &m.servers_online },
            |m: &mut GlobalStatistics| { &mut m.servers_online },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "players_searching",
            |m: &GlobalStatistics| { &m.players_searching },
            |m: &mut GlobalStatistics| { &mut m.players_searching },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "servers_available",
            |m: &GlobalStatistics| { &m.servers_available },
            |m: &mut GlobalStatistics| { &mut m.servers_available },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ongoing_matches",
            |m: &GlobalStatistics| { &m.ongoing_matches },
            |m: &mut GlobalStatistics| { &mut m.ongoing_matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_time_avg",
            |m: &GlobalStatistics| { &m.search_time_avg },
            |m: &mut GlobalStatistics| { &mut m.search_time_avg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "search_statistics",
            |m: &GlobalStatistics| { &m.search_statistics },
            |m: &mut GlobalStatistics| { &mut m.search_statistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "main_post_url",
            |m: &GlobalStatistics| { &m.main_post_url },
            |m: &mut GlobalStatistics| { &mut m.main_post_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "required_appid_version",
            |m: &GlobalStatistics| { &m.required_appid_version },
            |m: &mut GlobalStatistics| { &mut m.required_appid_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pricesheet_version",
            |m: &GlobalStatistics| { &m.pricesheet_version },
            |m: &mut GlobalStatistics| { &mut m.pricesheet_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "twitch_streams_version",
            |m: &GlobalStatistics| { &m.twitch_streams_version },
            |m: &mut GlobalStatistics| { &mut m.twitch_streams_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_tournament_eventid",
            |m: &GlobalStatistics| { &m.active_tournament_eventid },
            |m: &mut GlobalStatistics| { &mut m.active_tournament_eventid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_survey_id",
            |m: &GlobalStatistics| { &m.active_survey_id },
            |m: &mut GlobalStatistics| { &mut m.active_survey_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_cur",
            |m: &GlobalStatistics| { &m.rtime32_cur },
            |m: &mut GlobalStatistics| { &mut m.rtime32_cur },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_event_start",
            |m: &GlobalStatistics| { &m.rtime32_event_start },
            |m: &mut GlobalStatistics| { &mut m.rtime32_event_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "required_appid_version2",
            |m: &GlobalStatistics| { &m.required_appid_version2 },
            |m: &mut GlobalStatistics| { &mut m.required_appid_version2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GlobalStatistics>(
            "GlobalStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GlobalStatistics {
    const NAME: &'static str = "GlobalStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.players_online = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.servers_online = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.players_searching = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.servers_available = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.ongoing_matches = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.search_time_avg = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.search_statistics.push(is.read_message()?);
                },
                66 => {
                    self.main_post_url = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.required_appid_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.pricesheet_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.twitch_streams_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.active_tournament_eventid = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.active_survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.rtime32_cur = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.rtime32_event_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.required_appid_version2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.players_online {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.servers_online {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.players_searching {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.servers_available {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ongoing_matches {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.search_time_avg {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.search_statistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.main_post_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.required_appid_version {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.pricesheet_version {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.twitch_streams_version {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.active_tournament_eventid {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.active_survey_id {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.rtime32_cur {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.rtime32_event_start {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.required_appid_version2 {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.players_online {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.servers_online {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.players_searching {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.servers_available {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ongoing_matches {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.search_time_avg {
            os.write_uint32(6, v)?;
        }
        for v in &self.search_statistics {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.main_post_url.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.required_appid_version {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.pricesheet_version {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.twitch_streams_version {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.active_tournament_eventid {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.active_survey_id {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.rtime32_cur {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.rtime32_event_start {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.required_appid_version2 {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GlobalStatistics {
        GlobalStatistics::new()
    }

    fn clear(&mut self) {
        self.players_online = ::std::option::Option::None;
        self.servers_online = ::std::option::Option::None;
        self.players_searching = ::std::option::Option::None;
        self.servers_available = ::std::option::Option::None;
        self.ongoing_matches = ::std::option::Option::None;
        self.search_time_avg = ::std::option::Option::None;
        self.search_statistics.clear();
        self.main_post_url = ::std::option::Option::None;
        self.required_appid_version = ::std::option::Option::None;
        self.pricesheet_version = ::std::option::Option::None;
        self.twitch_streams_version = ::std::option::Option::None;
        self.active_tournament_eventid = ::std::option::Option::None;
        self.active_survey_id = ::std::option::Option::None;
        self.rtime32_cur = ::std::option::Option::None;
        self.rtime32_event_start = ::std::option::Option::None;
        self.required_appid_version2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GlobalStatistics {
        static instance: GlobalStatistics = GlobalStatistics {
            players_online: ::std::option::Option::None,
            servers_online: ::std::option::Option::None,
            players_searching: ::std::option::Option::None,
            servers_available: ::std::option::Option::None,
            ongoing_matches: ::std::option::Option::None,
            search_time_avg: ::std::option::Option::None,
            search_statistics: ::std::vec::Vec::new(),
            main_post_url: ::std::option::Option::None,
            required_appid_version: ::std::option::Option::None,
            pricesheet_version: ::std::option::Option::None,
            twitch_streams_version: ::std::option::Option::None,
            active_tournament_eventid: ::std::option::Option::None,
            active_survey_id: ::std::option::Option::None,
            rtime32_cur: ::std::option::Option::None,
            rtime32_event_start: ::std::option::Option::None,
            required_appid_version2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GlobalStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GlobalStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GlobalStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OperationalStatisticDescription)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OperationalStatisticDescription {
    // message fields
    // @@protoc_insertion_point(field:OperationalStatisticDescription.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OperationalStatisticDescription.idkey)
    pub idkey: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:OperationalStatisticDescription.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperationalStatisticDescription {
    fn default() -> &'a OperationalStatisticDescription {
        <OperationalStatisticDescription as ::protobuf::Message>::default_instance()
    }
}

impl OperationalStatisticDescription {
    pub fn new() -> OperationalStatisticDescription {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 idkey = 2;

    pub fn idkey(&self) -> u32 {
        self.idkey.unwrap_or(0)
    }

    pub fn clear_idkey(&mut self) {
        self.idkey = ::std::option::Option::None;
    }

    pub fn has_idkey(&self) -> bool {
        self.idkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idkey(&mut self, v: u32) {
        self.idkey = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &OperationalStatisticDescription| { &m.name },
            |m: &mut OperationalStatisticDescription| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "idkey",
            |m: &OperationalStatisticDescription| { &m.idkey },
            |m: &mut OperationalStatisticDescription| { &mut m.idkey },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OperationalStatisticDescription>(
            "OperationalStatisticDescription",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OperationalStatisticDescription {
    const NAME: &'static str = "OperationalStatisticDescription";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.idkey = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.idkey {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.idkey {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperationalStatisticDescription {
        OperationalStatisticDescription::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.idkey = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperationalStatisticDescription {
        static instance: OperationalStatisticDescription = OperationalStatisticDescription {
            name: ::std::option::Option::None,
            idkey: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OperationalStatisticDescription {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OperationalStatisticDescription").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OperationalStatisticDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticDescription {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OperationalStatisticElement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OperationalStatisticElement {
    // message fields
    // @@protoc_insertion_point(field:OperationalStatisticElement.idkey)
    pub idkey: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:OperationalStatisticElement.values)
    pub values: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:OperationalStatisticElement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperationalStatisticElement {
    fn default() -> &'a OperationalStatisticElement {
        <OperationalStatisticElement as ::protobuf::Message>::default_instance()
    }
}

impl OperationalStatisticElement {
    pub fn new() -> OperationalStatisticElement {
        ::std::default::Default::default()
    }

    // optional uint32 idkey = 1;

    pub fn idkey(&self) -> u32 {
        self.idkey.unwrap_or(0)
    }

    pub fn clear_idkey(&mut self) {
        self.idkey = ::std::option::Option::None;
    }

    pub fn has_idkey(&self) -> bool {
        self.idkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idkey(&mut self, v: u32) {
        self.idkey = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "idkey",
            |m: &OperationalStatisticElement| { &m.idkey },
            |m: &mut OperationalStatisticElement| { &mut m.idkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &OperationalStatisticElement| { &m.values },
            |m: &mut OperationalStatisticElement| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OperationalStatisticElement>(
            "OperationalStatisticElement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OperationalStatisticElement {
    const NAME: &'static str = "OperationalStatisticElement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.idkey = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.values)?;
                },
                16 => {
                    self.values.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.idkey {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.idkey {
            os.write_uint32(1, v)?;
        }
        for v in &self.values {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperationalStatisticElement {
        OperationalStatisticElement::new()
    }

    fn clear(&mut self) {
        self.idkey = ::std::option::Option::None;
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperationalStatisticElement {
        static instance: OperationalStatisticElement = OperationalStatisticElement {
            idkey: ::std::option::Option::None,
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OperationalStatisticElement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OperationalStatisticElement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OperationalStatisticElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticElement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OperationalStatisticsPacket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OperationalStatisticsPacket {
    // message fields
    // @@protoc_insertion_point(field:OperationalStatisticsPacket.packetid)
    pub packetid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OperationalStatisticsPacket.mstimestamp)
    pub mstimestamp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OperationalStatisticsPacket.values)
    pub values: ::std::vec::Vec<OperationalStatisticElement>,
    // special fields
    // @@protoc_insertion_point(special_field:OperationalStatisticsPacket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperationalStatisticsPacket {
    fn default() -> &'a OperationalStatisticsPacket {
        <OperationalStatisticsPacket as ::protobuf::Message>::default_instance()
    }
}

impl OperationalStatisticsPacket {
    pub fn new() -> OperationalStatisticsPacket {
        ::std::default::Default::default()
    }

    // optional int32 packetid = 1;

    pub fn packetid(&self) -> i32 {
        self.packetid.unwrap_or(0)
    }

    pub fn clear_packetid(&mut self) {
        self.packetid = ::std::option::Option::None;
    }

    pub fn has_packetid(&self) -> bool {
        self.packetid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packetid(&mut self, v: i32) {
        self.packetid = ::std::option::Option::Some(v);
    }

    // optional int32 mstimestamp = 2;

    pub fn mstimestamp(&self) -> i32 {
        self.mstimestamp.unwrap_or(0)
    }

    pub fn clear_mstimestamp(&mut self) {
        self.mstimestamp = ::std::option::Option::None;
    }

    pub fn has_mstimestamp(&self) -> bool {
        self.mstimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mstimestamp(&mut self, v: i32) {
        self.mstimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packetid",
            |m: &OperationalStatisticsPacket| { &m.packetid },
            |m: &mut OperationalStatisticsPacket| { &mut m.packetid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mstimestamp",
            |m: &OperationalStatisticsPacket| { &m.mstimestamp },
            |m: &mut OperationalStatisticsPacket| { &mut m.mstimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &OperationalStatisticsPacket| { &m.values },
            |m: &mut OperationalStatisticsPacket| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OperationalStatisticsPacket>(
            "OperationalStatisticsPacket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OperationalStatisticsPacket {
    const NAME: &'static str = "OperationalStatisticsPacket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.packetid = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.mstimestamp = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packetid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mstimestamp {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packetid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mstimestamp {
            os.write_int32(2, v)?;
        }
        for v in &self.values {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperationalStatisticsPacket {
        OperationalStatisticsPacket::new()
    }

    fn clear(&mut self) {
        self.packetid = ::std::option::Option::None;
        self.mstimestamp = ::std::option::Option::None;
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperationalStatisticsPacket {
        static instance: OperationalStatisticsPacket = OperationalStatisticsPacket {
            packetid: ::std::option::Option::None,
            mstimestamp: ::std::option::Option::None,
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OperationalStatisticsPacket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OperationalStatisticsPacket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OperationalStatisticsPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticsPacket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:OperationalVarValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OperationalVarValue {
    // message fields
    // @@protoc_insertion_point(field:OperationalVarValue.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OperationalVarValue.ivalue)
    pub ivalue: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OperationalVarValue.fvalue)
    pub fvalue: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:OperationalVarValue.svalue)
    pub svalue: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:OperationalVarValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperationalVarValue {
    fn default() -> &'a OperationalVarValue {
        <OperationalVarValue as ::protobuf::Message>::default_instance()
    }
}

impl OperationalVarValue {
    pub fn new() -> OperationalVarValue {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 ivalue = 2;

    pub fn ivalue(&self) -> i32 {
        self.ivalue.unwrap_or(0)
    }

    pub fn clear_ivalue(&mut self) {
        self.ivalue = ::std::option::Option::None;
    }

    pub fn has_ivalue(&self) -> bool {
        self.ivalue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ivalue(&mut self, v: i32) {
        self.ivalue = ::std::option::Option::Some(v);
    }

    // optional float fvalue = 3;

    pub fn fvalue(&self) -> f32 {
        self.fvalue.unwrap_or(0.)
    }

    pub fn clear_fvalue(&mut self) {
        self.fvalue = ::std::option::Option::None;
    }

    pub fn has_fvalue(&self) -> bool {
        self.fvalue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fvalue(&mut self, v: f32) {
        self.fvalue = ::std::option::Option::Some(v);
    }

    // optional bytes svalue = 4;

    pub fn svalue(&self) -> &[u8] {
        match self.svalue.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_svalue(&mut self) {
        self.svalue = ::std::option::Option::None;
    }

    pub fn has_svalue(&self) -> bool {
        self.svalue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_svalue(&mut self, v: ::std::vec::Vec<u8>) {
        self.svalue = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_svalue(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.svalue.is_none() {
            self.svalue = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.svalue.as_mut().unwrap()
    }

    // Take field
    pub fn take_svalue(&mut self) -> ::std::vec::Vec<u8> {
        self.svalue.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &OperationalVarValue| { &m.name },
            |m: &mut OperationalVarValue| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ivalue",
            |m: &OperationalVarValue| { &m.ivalue },
            |m: &mut OperationalVarValue| { &mut m.ivalue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fvalue",
            |m: &OperationalVarValue| { &m.fvalue },
            |m: &mut OperationalVarValue| { &mut m.fvalue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "svalue",
            |m: &OperationalVarValue| { &m.svalue },
            |m: &mut OperationalVarValue| { &mut m.svalue },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OperationalVarValue>(
            "OperationalVarValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OperationalVarValue {
    const NAME: &'static str = "OperationalVarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.ivalue = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.fvalue = ::std::option::Option::Some(is.read_float()?);
                },
                34 => {
                    self.svalue = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.ivalue {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.fvalue {
            my_size += 1 + 4;
        }
        if let Some(v) = self.svalue.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.ivalue {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.fvalue {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.svalue.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperationalVarValue {
        OperationalVarValue::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.ivalue = ::std::option::Option::None;
        self.fvalue = ::std::option::Option::None;
        self.svalue = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperationalVarValue {
        static instance: OperationalVarValue = OperationalVarValue {
            name: ::std::option::Option::None,
            ivalue: ::std::option::Option::None,
            fvalue: ::std::option::Option::None,
            svalue: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OperationalVarValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OperationalVarValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OperationalVarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalVarValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PlayerRankingInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerRankingInfo {
    // message fields
    // @@protoc_insertion_point(field:PlayerRankingInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.rank_id)
    pub rank_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.wins)
    pub wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.rank_change)
    pub rank_change: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.rank_type_id)
    pub rank_type_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.tv_control)
    pub tv_control: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.rank_window_stats)
    pub rank_window_stats: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.leaderboard_name)
    pub leaderboard_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.rank_if_win)
    pub rank_if_win: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.rank_if_lose)
    pub rank_if_lose: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.rank_if_tie)
    pub rank_if_tie: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.per_map_rank)
    pub per_map_rank: ::std::vec::Vec<player_ranking_info::PerMapRank>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.leaderboard_name_status)
    pub leaderboard_name_status: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:PlayerRankingInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerRankingInfo {
    fn default() -> &'a PlayerRankingInfo {
        <PlayerRankingInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerRankingInfo {
    pub fn new() -> PlayerRankingInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_id = 2;

    pub fn rank_id(&self) -> u32 {
        self.rank_id.unwrap_or(0)
    }

    pub fn clear_rank_id(&mut self) {
        self.rank_id = ::std::option::Option::None;
    }

    pub fn has_rank_id(&self) -> bool {
        self.rank_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_id(&mut self, v: u32) {
        self.rank_id = ::std::option::Option::Some(v);
    }

    // optional uint32 wins = 3;

    pub fn wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    // optional float rank_change = 4;

    pub fn rank_change(&self) -> f32 {
        self.rank_change.unwrap_or(0.)
    }

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: f32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_type_id = 6;

    pub fn rank_type_id(&self) -> u32 {
        self.rank_type_id.unwrap_or(0)
    }

    pub fn clear_rank_type_id(&mut self) {
        self.rank_type_id = ::std::option::Option::None;
    }

    pub fn has_rank_type_id(&self) -> bool {
        self.rank_type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_type_id(&mut self, v: u32) {
        self.rank_type_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_control = 7;

    pub fn tv_control(&self) -> u32 {
        self.tv_control.unwrap_or(0)
    }

    pub fn clear_tv_control(&mut self) {
        self.tv_control = ::std::option::Option::None;
    }

    pub fn has_tv_control(&self) -> bool {
        self.tv_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_control(&mut self, v: u32) {
        self.tv_control = ::std::option::Option::Some(v);
    }

    // optional uint64 rank_window_stats = 8;

    pub fn rank_window_stats(&self) -> u64 {
        self.rank_window_stats.unwrap_or(0)
    }

    pub fn clear_rank_window_stats(&mut self) {
        self.rank_window_stats = ::std::option::Option::None;
    }

    pub fn has_rank_window_stats(&self) -> bool {
        self.rank_window_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_window_stats(&mut self, v: u64) {
        self.rank_window_stats = ::std::option::Option::Some(v);
    }

    // optional string leaderboard_name = 9;

    pub fn leaderboard_name(&self) -> &str {
        match self.leaderboard_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_leaderboard_name(&mut self) {
        self.leaderboard_name = ::std::option::Option::None;
    }

    pub fn has_leaderboard_name(&self) -> bool {
        self.leaderboard_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name(&mut self, v: ::std::string::String) {
        self.leaderboard_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_name(&mut self) -> &mut ::std::string::String {
        if self.leaderboard_name.is_none() {
            self.leaderboard_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.leaderboard_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_name(&mut self) -> ::std::string::String {
        self.leaderboard_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 rank_if_win = 10;

    pub fn rank_if_win(&self) -> u32 {
        self.rank_if_win.unwrap_or(0)
    }

    pub fn clear_rank_if_win(&mut self) {
        self.rank_if_win = ::std::option::Option::None;
    }

    pub fn has_rank_if_win(&self) -> bool {
        self.rank_if_win.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_if_win(&mut self, v: u32) {
        self.rank_if_win = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_if_lose = 11;

    pub fn rank_if_lose(&self) -> u32 {
        self.rank_if_lose.unwrap_or(0)
    }

    pub fn clear_rank_if_lose(&mut self) {
        self.rank_if_lose = ::std::option::Option::None;
    }

    pub fn has_rank_if_lose(&self) -> bool {
        self.rank_if_lose.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_if_lose(&mut self, v: u32) {
        self.rank_if_lose = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_if_tie = 12;

    pub fn rank_if_tie(&self) -> u32 {
        self.rank_if_tie.unwrap_or(0)
    }

    pub fn clear_rank_if_tie(&mut self) {
        self.rank_if_tie = ::std::option::Option::None;
    }

    pub fn has_rank_if_tie(&self) -> bool {
        self.rank_if_tie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_if_tie(&mut self, v: u32) {
        self.rank_if_tie = ::std::option::Option::Some(v);
    }

    // optional uint32 leaderboard_name_status = 14;

    pub fn leaderboard_name_status(&self) -> u32 {
        self.leaderboard_name_status.unwrap_or(0)
    }

    pub fn clear_leaderboard_name_status(&mut self) {
        self.leaderboard_name_status = ::std::option::Option::None;
    }

    pub fn has_leaderboard_name_status(&self) -> bool {
        self.leaderboard_name_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name_status(&mut self, v: u32) {
        self.leaderboard_name_status = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &PlayerRankingInfo| { &m.account_id },
            |m: &mut PlayerRankingInfo| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_id",
            |m: &PlayerRankingInfo| { &m.rank_id },
            |m: &mut PlayerRankingInfo| { &mut m.rank_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wins",
            |m: &PlayerRankingInfo| { &m.wins },
            |m: &mut PlayerRankingInfo| { &mut m.wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_change",
            |m: &PlayerRankingInfo| { &m.rank_change },
            |m: &mut PlayerRankingInfo| { &mut m.rank_change },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_type_id",
            |m: &PlayerRankingInfo| { &m.rank_type_id },
            |m: &mut PlayerRankingInfo| { &mut m.rank_type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_control",
            |m: &PlayerRankingInfo| { &m.tv_control },
            |m: &mut PlayerRankingInfo| { &mut m.tv_control },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_window_stats",
            |m: &PlayerRankingInfo| { &m.rank_window_stats },
            |m: &mut PlayerRankingInfo| { &mut m.rank_window_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_name",
            |m: &PlayerRankingInfo| { &m.leaderboard_name },
            |m: &mut PlayerRankingInfo| { &mut m.leaderboard_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_if_win",
            |m: &PlayerRankingInfo| { &m.rank_if_win },
            |m: &mut PlayerRankingInfo| { &mut m.rank_if_win },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_if_lose",
            |m: &PlayerRankingInfo| { &m.rank_if_lose },
            |m: &mut PlayerRankingInfo| { &mut m.rank_if_lose },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_if_tie",
            |m: &PlayerRankingInfo| { &m.rank_if_tie },
            |m: &mut PlayerRankingInfo| { &mut m.rank_if_tie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "per_map_rank",
            |m: &PlayerRankingInfo| { &m.per_map_rank },
            |m: &mut PlayerRankingInfo| { &mut m.per_map_rank },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_name_status",
            |m: &PlayerRankingInfo| { &m.leaderboard_name_status },
            |m: &mut PlayerRankingInfo| { &mut m.leaderboard_name_status },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerRankingInfo>(
            "PlayerRankingInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerRankingInfo {
    const NAME: &'static str = "PlayerRankingInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rank_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.rank_change = ::std::option::Option::Some(is.read_float()?);
                },
                48 => {
                    self.rank_type_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.tv_control = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.rank_window_stats = ::std::option::Option::Some(is.read_uint64()?);
                },
                74 => {
                    self.leaderboard_name = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.rank_if_win = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.rank_if_lose = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.rank_if_tie = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.per_map_rank.push(is.read_message()?);
                },
                112 => {
                    self.leaderboard_name_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rank_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rank_change {
            my_size += 1 + 4;
        }
        if let Some(v) = self.rank_type_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.tv_control {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.rank_window_stats {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.leaderboard_name.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.rank_if_win {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.rank_if_lose {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.rank_if_tie {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        for value in &self.per_map_rank {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.leaderboard_name_status {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rank_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.rank_type_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.tv_control {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.rank_window_stats {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.leaderboard_name.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.rank_if_win {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.rank_if_lose {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.rank_if_tie {
            os.write_uint32(12, v)?;
        }
        for v in &self.per_map_rank {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.leaderboard_name_status {
            os.write_uint32(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerRankingInfo {
        PlayerRankingInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rank_id = ::std::option::Option::None;
        self.wins = ::std::option::Option::None;
        self.rank_change = ::std::option::Option::None;
        self.rank_type_id = ::std::option::Option::None;
        self.tv_control = ::std::option::Option::None;
        self.rank_window_stats = ::std::option::Option::None;
        self.leaderboard_name = ::std::option::Option::None;
        self.rank_if_win = ::std::option::Option::None;
        self.rank_if_lose = ::std::option::Option::None;
        self.rank_if_tie = ::std::option::Option::None;
        self.per_map_rank.clear();
        self.leaderboard_name_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerRankingInfo {
        static instance: PlayerRankingInfo = PlayerRankingInfo {
            account_id: ::std::option::Option::None,
            rank_id: ::std::option::Option::None,
            wins: ::std::option::Option::None,
            rank_change: ::std::option::Option::None,
            rank_type_id: ::std::option::Option::None,
            tv_control: ::std::option::Option::None,
            rank_window_stats: ::std::option::Option::None,
            leaderboard_name: ::std::option::Option::None,
            rank_if_win: ::std::option::Option::None,
            rank_if_lose: ::std::option::Option::None,
            rank_if_tie: ::std::option::Option::None,
            per_map_rank: ::std::vec::Vec::new(),
            leaderboard_name_status: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerRankingInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerRankingInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerRankingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerRankingInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PlayerRankingInfo`
pub mod player_ranking_info {
    // @@protoc_insertion_point(message:PlayerRankingInfo.PerMapRank)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PerMapRank {
        // message fields
        // @@protoc_insertion_point(field:PlayerRankingInfo.PerMapRank.map_id)
        pub map_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:PlayerRankingInfo.PerMapRank.rank_id)
        pub rank_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:PlayerRankingInfo.PerMapRank.wins)
        pub wins: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:PlayerRankingInfo.PerMapRank.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PerMapRank {
        fn default() -> &'a PerMapRank {
            <PerMapRank as ::protobuf::Message>::default_instance()
        }
    }

    impl PerMapRank {
        pub fn new() -> PerMapRank {
            ::std::default::Default::default()
        }

        // optional uint32 map_id = 1;

        pub fn map_id(&self) -> u32 {
            self.map_id.unwrap_or(0)
        }

        pub fn clear_map_id(&mut self) {
            self.map_id = ::std::option::Option::None;
        }

        pub fn has_map_id(&self) -> bool {
            self.map_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_id(&mut self, v: u32) {
            self.map_id = ::std::option::Option::Some(v);
        }

        // optional uint32 rank_id = 2;

        pub fn rank_id(&self) -> u32 {
            self.rank_id.unwrap_or(0)
        }

        pub fn clear_rank_id(&mut self) {
            self.rank_id = ::std::option::Option::None;
        }

        pub fn has_rank_id(&self) -> bool {
            self.rank_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_id(&mut self, v: u32) {
            self.rank_id = ::std::option::Option::Some(v);
        }

        // optional uint32 wins = 3;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "map_id",
                |m: &PerMapRank| { &m.map_id },
                |m: &mut PerMapRank| { &mut m.map_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_id",
                |m: &PerMapRank| { &m.rank_id },
                |m: &mut PerMapRank| { &mut m.rank_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wins",
                |m: &PerMapRank| { &m.wins },
                |m: &mut PerMapRank| { &mut m.wins },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PerMapRank>(
                "PlayerRankingInfo.PerMapRank",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PerMapRank {
        const NAME: &'static str = "PerMapRank";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.map_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.rank_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.map_id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.rank_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.wins {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.map_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.rank_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.wins {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PerMapRank {
            PerMapRank::new()
        }

        fn clear(&mut self) {
            self.map_id = ::std::option::Option::None;
            self.rank_id = ::std::option::Option::None;
            self.wins = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PerMapRank {
            static instance: PerMapRank = PerMapRank {
                map_id: ::std::option::Option::None,
                rank_id: ::std::option::Option::None,
                wins: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PerMapRank {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PlayerRankingInfo.PerMapRank").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PerMapRank {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PerMapRank {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:PlayerCommendationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerCommendationInfo {
    // message fields
    // @@protoc_insertion_point(field:PlayerCommendationInfo.cmd_friendly)
    pub cmd_friendly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerCommendationInfo.cmd_teaching)
    pub cmd_teaching: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerCommendationInfo.cmd_leader)
    pub cmd_leader: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:PlayerCommendationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerCommendationInfo {
    fn default() -> &'a PlayerCommendationInfo {
        <PlayerCommendationInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerCommendationInfo {
    pub fn new() -> PlayerCommendationInfo {
        ::std::default::Default::default()
    }

    // optional uint32 cmd_friendly = 1;

    pub fn cmd_friendly(&self) -> u32 {
        self.cmd_friendly.unwrap_or(0)
    }

    pub fn clear_cmd_friendly(&mut self) {
        self.cmd_friendly = ::std::option::Option::None;
    }

    pub fn has_cmd_friendly(&self) -> bool {
        self.cmd_friendly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_friendly(&mut self, v: u32) {
        self.cmd_friendly = ::std::option::Option::Some(v);
    }

    // optional uint32 cmd_teaching = 2;

    pub fn cmd_teaching(&self) -> u32 {
        self.cmd_teaching.unwrap_or(0)
    }

    pub fn clear_cmd_teaching(&mut self) {
        self.cmd_teaching = ::std::option::Option::None;
    }

    pub fn has_cmd_teaching(&self) -> bool {
        self.cmd_teaching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_teaching(&mut self, v: u32) {
        self.cmd_teaching = ::std::option::Option::Some(v);
    }

    // optional uint32 cmd_leader = 4;

    pub fn cmd_leader(&self) -> u32 {
        self.cmd_leader.unwrap_or(0)
    }

    pub fn clear_cmd_leader(&mut self) {
        self.cmd_leader = ::std::option::Option::None;
    }

    pub fn has_cmd_leader(&self) -> bool {
        self.cmd_leader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_leader(&mut self, v: u32) {
        self.cmd_leader = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd_friendly",
            |m: &PlayerCommendationInfo| { &m.cmd_friendly },
            |m: &mut PlayerCommendationInfo| { &mut m.cmd_friendly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd_teaching",
            |m: &PlayerCommendationInfo| { &m.cmd_teaching },
            |m: &mut PlayerCommendationInfo| { &mut m.cmd_teaching },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd_leader",
            |m: &PlayerCommendationInfo| { &m.cmd_leader },
            |m: &mut PlayerCommendationInfo| { &mut m.cmd_leader },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerCommendationInfo>(
            "PlayerCommendationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerCommendationInfo {
    const NAME: &'static str = "PlayerCommendationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cmd_friendly = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.cmd_teaching = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.cmd_leader = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cmd_friendly {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cmd_teaching {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cmd_leader {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cmd_friendly {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cmd_teaching {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cmd_leader {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerCommendationInfo {
        PlayerCommendationInfo::new()
    }

    fn clear(&mut self) {
        self.cmd_friendly = ::std::option::Option::None;
        self.cmd_teaching = ::std::option::Option::None;
        self.cmd_leader = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerCommendationInfo {
        static instance: PlayerCommendationInfo = PlayerCommendationInfo {
            cmd_friendly: ::std::option::Option::None,
            cmd_teaching: ::std::option::Option::None,
            cmd_leader: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerCommendationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerCommendationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerCommendationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerCommendationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PlayerMedalsInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerMedalsInfo {
    // message fields
    // @@protoc_insertion_point(field:PlayerMedalsInfo.display_items_defidx)
    pub display_items_defidx: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:PlayerMedalsInfo.featured_display_item_defidx)
    pub featured_display_item_defidx: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:PlayerMedalsInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerMedalsInfo {
    fn default() -> &'a PlayerMedalsInfo {
        <PlayerMedalsInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerMedalsInfo {
    pub fn new() -> PlayerMedalsInfo {
        ::std::default::Default::default()
    }

    // optional uint32 featured_display_item_defidx = 8;

    pub fn featured_display_item_defidx(&self) -> u32 {
        self.featured_display_item_defidx.unwrap_or(0)
    }

    pub fn clear_featured_display_item_defidx(&mut self) {
        self.featured_display_item_defidx = ::std::option::Option::None;
    }

    pub fn has_featured_display_item_defidx(&self) -> bool {
        self.featured_display_item_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_display_item_defidx(&mut self, v: u32) {
        self.featured_display_item_defidx = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "display_items_defidx",
            |m: &PlayerMedalsInfo| { &m.display_items_defidx },
            |m: &mut PlayerMedalsInfo| { &mut m.display_items_defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "featured_display_item_defidx",
            |m: &PlayerMedalsInfo| { &m.featured_display_item_defidx },
            |m: &mut PlayerMedalsInfo| { &mut m.featured_display_item_defidx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerMedalsInfo>(
            "PlayerMedalsInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerMedalsInfo {
    const NAME: &'static str = "PlayerMedalsInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.display_items_defidx)?;
                },
                56 => {
                    self.display_items_defidx.push(is.read_uint32()?);
                },
                64 => {
                    self.featured_display_item_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.display_items_defidx {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        if let Some(v) = self.featured_display_item_defidx {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.display_items_defidx {
            os.write_uint32(7, *v)?;
        };
        if let Some(v) = self.featured_display_item_defidx {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerMedalsInfo {
        PlayerMedalsInfo::new()
    }

    fn clear(&mut self) {
        self.display_items_defidx.clear();
        self.featured_display_item_defidx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerMedalsInfo {
        static instance: PlayerMedalsInfo = PlayerMedalsInfo {
            display_items_defidx: ::std::vec::Vec::new(),
            featured_display_item_defidx: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerMedalsInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerMedalsInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerMedalsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerMedalsInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AccountActivity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AccountActivity {
    // message fields
    // @@protoc_insertion_point(field:AccountActivity.activity)
    pub activity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AccountActivity.mode)
    pub mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AccountActivity.map)
    pub map: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AccountActivity.matchid)
    pub matchid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:AccountActivity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountActivity {
    fn default() -> &'a AccountActivity {
        <AccountActivity as ::protobuf::Message>::default_instance()
    }
}

impl AccountActivity {
    pub fn new() -> AccountActivity {
        ::std::default::Default::default()
    }

    // optional uint32 activity = 1;

    pub fn activity(&self) -> u32 {
        self.activity.unwrap_or(0)
    }

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: u32) {
        self.activity = ::std::option::Option::Some(v);
    }

    // optional uint32 mode = 2;

    pub fn mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional uint32 map = 3;

    pub fn map(&self) -> u32 {
        self.map.unwrap_or(0)
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: u32) {
        self.map = ::std::option::Option::Some(v);
    }

    // optional uint64 matchid = 4;

    pub fn matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "activity",
            |m: &AccountActivity| { &m.activity },
            |m: &mut AccountActivity| { &mut m.activity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &AccountActivity| { &m.mode },
            |m: &mut AccountActivity| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &AccountActivity| { &m.map },
            |m: &mut AccountActivity| { &mut m.map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchid",
            |m: &AccountActivity| { &m.matchid },
            |m: &mut AccountActivity| { &mut m.matchid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountActivity>(
            "AccountActivity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountActivity {
    const NAME: &'static str = "AccountActivity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.activity = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.map = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.matchid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.map {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.activity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.map {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.matchid {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountActivity {
        AccountActivity::new()
    }

    fn clear(&mut self) {
        self.activity = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.map = ::std::option::Option::None;
        self.matchid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountActivity {
        static instance: AccountActivity = AccountActivity {
            activity: ::std::option::Option::None,
            mode: ::std::option::Option::None,
            map: ::std::option::Option::None,
            matchid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountActivity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountActivity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountActivity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TournamentMatchSetup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TournamentMatchSetup {
    // message fields
    // @@protoc_insertion_point(field:TournamentMatchSetup.event_id)
    pub event_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentMatchSetup.team_id_ct)
    pub team_id_ct: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentMatchSetup.team_id_t)
    pub team_id_t: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentMatchSetup.event_stage_id)
    pub event_stage_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:TournamentMatchSetup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TournamentMatchSetup {
    fn default() -> &'a TournamentMatchSetup {
        <TournamentMatchSetup as ::protobuf::Message>::default_instance()
    }
}

impl TournamentMatchSetup {
    pub fn new() -> TournamentMatchSetup {
        ::std::default::Default::default()
    }

    // optional int32 event_id = 1;

    pub fn event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_ct = 2;

    pub fn team_id_ct(&self) -> i32 {
        self.team_id_ct.unwrap_or(0)
    }

    pub fn clear_team_id_ct(&mut self) {
        self.team_id_ct = ::std::option::Option::None;
    }

    pub fn has_team_id_ct(&self) -> bool {
        self.team_id_ct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_ct(&mut self, v: i32) {
        self.team_id_ct = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_t = 3;

    pub fn team_id_t(&self) -> i32 {
        self.team_id_t.unwrap_or(0)
    }

    pub fn clear_team_id_t(&mut self) {
        self.team_id_t = ::std::option::Option::None;
    }

    pub fn has_team_id_t(&self) -> bool {
        self.team_id_t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_t(&mut self, v: i32) {
        self.team_id_t = ::std::option::Option::Some(v);
    }

    // optional int32 event_stage_id = 4;

    pub fn event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }

    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &TournamentMatchSetup| { &m.event_id },
            |m: &mut TournamentMatchSetup| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_ct",
            |m: &TournamentMatchSetup| { &m.team_id_ct },
            |m: &mut TournamentMatchSetup| { &mut m.team_id_ct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_t",
            |m: &TournamentMatchSetup| { &m.team_id_t },
            |m: &mut TournamentMatchSetup| { &mut m.team_id_t },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_stage_id",
            |m: &TournamentMatchSetup| { &m.event_stage_id },
            |m: &mut TournamentMatchSetup| { &mut m.event_stage_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TournamentMatchSetup>(
            "TournamentMatchSetup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TournamentMatchSetup {
    const NAME: &'static str = "TournamentMatchSetup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.team_id_ct = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.team_id_t = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.event_stage_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.team_id_ct {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.team_id_t {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id_ct {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team_id_t {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TournamentMatchSetup {
        TournamentMatchSetup::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.team_id_ct = ::std::option::Option::None;
        self.team_id_t = ::std::option::Option::None;
        self.event_stage_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TournamentMatchSetup {
        static instance: TournamentMatchSetup = TournamentMatchSetup {
            event_id: ::std::option::Option::None,
            team_id_ct: ::std::option::Option::None,
            team_id_t: ::std::option::Option::None,
            event_stage_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TournamentMatchSetup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TournamentMatchSetup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TournamentMatchSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentMatchSetup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ServerHltvInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerHltvInfo {
    // message fields
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_udp_port)
    pub tv_udp_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_watch_key)
    pub tv_watch_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_slots)
    pub tv_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_clients)
    pub tv_clients: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_proxies)
    pub tv_proxies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_time)
    pub tv_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.game_mapgroup)
    pub game_mapgroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServerHltvInfo.game_map)
    pub game_map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_master_steamid)
    pub tv_master_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_local_slots)
    pub tv_local_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_local_clients)
    pub tv_local_clients: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_local_proxies)
    pub tv_local_proxies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_slots)
    pub tv_relay_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_clients)
    pub tv_relay_clients: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_proxies)
    pub tv_relay_proxies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_address)
    pub tv_relay_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_port)
    pub tv_relay_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_steamid)
    pub tv_relay_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ServerHltvInfo.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ServerHltvInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerHltvInfo {
    fn default() -> &'a ServerHltvInfo {
        <ServerHltvInfo as ::protobuf::Message>::default_instance()
    }
}

impl ServerHltvInfo {
    pub fn new() -> ServerHltvInfo {
        ::std::default::Default::default()
    }

    // optional uint32 tv_udp_port = 1;

    pub fn tv_udp_port(&self) -> u32 {
        self.tv_udp_port.unwrap_or(0)
    }

    pub fn clear_tv_udp_port(&mut self) {
        self.tv_udp_port = ::std::option::Option::None;
    }

    pub fn has_tv_udp_port(&self) -> bool {
        self.tv_udp_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_udp_port(&mut self, v: u32) {
        self.tv_udp_port = ::std::option::Option::Some(v);
    }

    // optional uint64 tv_watch_key = 2;

    pub fn tv_watch_key(&self) -> u64 {
        self.tv_watch_key.unwrap_or(0)
    }

    pub fn clear_tv_watch_key(&mut self) {
        self.tv_watch_key = ::std::option::Option::None;
    }

    pub fn has_tv_watch_key(&self) -> bool {
        self.tv_watch_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_watch_key(&mut self, v: u64) {
        self.tv_watch_key = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_slots = 3;

    pub fn tv_slots(&self) -> u32 {
        self.tv_slots.unwrap_or(0)
    }

    pub fn clear_tv_slots(&mut self) {
        self.tv_slots = ::std::option::Option::None;
    }

    pub fn has_tv_slots(&self) -> bool {
        self.tv_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_slots(&mut self, v: u32) {
        self.tv_slots = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_clients = 4;

    pub fn tv_clients(&self) -> u32 {
        self.tv_clients.unwrap_or(0)
    }

    pub fn clear_tv_clients(&mut self) {
        self.tv_clients = ::std::option::Option::None;
    }

    pub fn has_tv_clients(&self) -> bool {
        self.tv_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_clients(&mut self, v: u32) {
        self.tv_clients = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_proxies = 5;

    pub fn tv_proxies(&self) -> u32 {
        self.tv_proxies.unwrap_or(0)
    }

    pub fn clear_tv_proxies(&mut self) {
        self.tv_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_proxies(&self) -> bool {
        self.tv_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_proxies(&mut self, v: u32) {
        self.tv_proxies = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_time = 6;

    pub fn tv_time(&self) -> u32 {
        self.tv_time.unwrap_or(0)
    }

    pub fn clear_tv_time(&mut self) {
        self.tv_time = ::std::option::Option::None;
    }

    pub fn has_tv_time(&self) -> bool {
        self.tv_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_time(&mut self, v: u32) {
        self.tv_time = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 8;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional string game_mapgroup = 9;

    pub fn game_mapgroup(&self) -> &str {
        match self.game_mapgroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_mapgroup(&mut self) {
        self.game_mapgroup = ::std::option::Option::None;
    }

    pub fn has_game_mapgroup(&self) -> bool {
        self.game_mapgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mapgroup(&mut self, v: ::std::string::String) {
        self.game_mapgroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mapgroup(&mut self) -> &mut ::std::string::String {
        if self.game_mapgroup.is_none() {
            self.game_mapgroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_mapgroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mapgroup(&mut self) -> ::std::string::String {
        self.game_mapgroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_map = 10;

    pub fn game_map(&self) -> &str {
        match self.game_map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_map(&mut self) {
        self.game_map = ::std::option::Option::None;
    }

    pub fn has_game_map(&self) -> bool {
        self.game_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_map(&mut self, v: ::std::string::String) {
        self.game_map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_map(&mut self) -> &mut ::std::string::String {
        if self.game_map.is_none() {
            self.game_map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_map(&mut self) -> ::std::string::String {
        self.game_map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 tv_master_steamid = 11;

    pub fn tv_master_steamid(&self) -> u64 {
        self.tv_master_steamid.unwrap_or(0)
    }

    pub fn clear_tv_master_steamid(&mut self) {
        self.tv_master_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_master_steamid(&self) -> bool {
        self.tv_master_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_master_steamid(&mut self, v: u64) {
        self.tv_master_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_local_slots = 12;

    pub fn tv_local_slots(&self) -> u32 {
        self.tv_local_slots.unwrap_or(0)
    }

    pub fn clear_tv_local_slots(&mut self) {
        self.tv_local_slots = ::std::option::Option::None;
    }

    pub fn has_tv_local_slots(&self) -> bool {
        self.tv_local_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_slots(&mut self, v: u32) {
        self.tv_local_slots = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_local_clients = 13;

    pub fn tv_local_clients(&self) -> u32 {
        self.tv_local_clients.unwrap_or(0)
    }

    pub fn clear_tv_local_clients(&mut self) {
        self.tv_local_clients = ::std::option::Option::None;
    }

    pub fn has_tv_local_clients(&self) -> bool {
        self.tv_local_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_clients(&mut self, v: u32) {
        self.tv_local_clients = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_local_proxies = 14;

    pub fn tv_local_proxies(&self) -> u32 {
        self.tv_local_proxies.unwrap_or(0)
    }

    pub fn clear_tv_local_proxies(&mut self) {
        self.tv_local_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_local_proxies(&self) -> bool {
        self.tv_local_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_proxies(&mut self, v: u32) {
        self.tv_local_proxies = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_slots = 15;

    pub fn tv_relay_slots(&self) -> u32 {
        self.tv_relay_slots.unwrap_or(0)
    }

    pub fn clear_tv_relay_slots(&mut self) {
        self.tv_relay_slots = ::std::option::Option::None;
    }

    pub fn has_tv_relay_slots(&self) -> bool {
        self.tv_relay_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_slots(&mut self, v: u32) {
        self.tv_relay_slots = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_clients = 16;

    pub fn tv_relay_clients(&self) -> u32 {
        self.tv_relay_clients.unwrap_or(0)
    }

    pub fn clear_tv_relay_clients(&mut self) {
        self.tv_relay_clients = ::std::option::Option::None;
    }

    pub fn has_tv_relay_clients(&self) -> bool {
        self.tv_relay_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_clients(&mut self, v: u32) {
        self.tv_relay_clients = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_proxies = 17;

    pub fn tv_relay_proxies(&self) -> u32 {
        self.tv_relay_proxies.unwrap_or(0)
    }

    pub fn clear_tv_relay_proxies(&mut self) {
        self.tv_relay_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_relay_proxies(&self) -> bool {
        self.tv_relay_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_proxies(&mut self, v: u32) {
        self.tv_relay_proxies = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_address = 18;

    pub fn tv_relay_address(&self) -> u32 {
        self.tv_relay_address.unwrap_or(0)
    }

    pub fn clear_tv_relay_address(&mut self) {
        self.tv_relay_address = ::std::option::Option::None;
    }

    pub fn has_tv_relay_address(&self) -> bool {
        self.tv_relay_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_address(&mut self, v: u32) {
        self.tv_relay_address = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_port = 19;

    pub fn tv_relay_port(&self) -> u32 {
        self.tv_relay_port.unwrap_or(0)
    }

    pub fn clear_tv_relay_port(&mut self) {
        self.tv_relay_port = ::std::option::Option::None;
    }

    pub fn has_tv_relay_port(&self) -> bool {
        self.tv_relay_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_port(&mut self, v: u32) {
        self.tv_relay_port = ::std::option::Option::Some(v);
    }

    // optional uint64 tv_relay_steamid = 20;

    pub fn tv_relay_steamid(&self) -> u64 {
        self.tv_relay_steamid.unwrap_or(0)
    }

    pub fn clear_tv_relay_steamid(&mut self) {
        self.tv_relay_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_relay_steamid(&self) -> bool {
        self.tv_relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_steamid(&mut self, v: u64) {
        self.tv_relay_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 21;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_udp_port",
            |m: &ServerHltvInfo| { &m.tv_udp_port },
            |m: &mut ServerHltvInfo| { &mut m.tv_udp_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_watch_key",
            |m: &ServerHltvInfo| { &m.tv_watch_key },
            |m: &mut ServerHltvInfo| { &mut m.tv_watch_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_slots",
            |m: &ServerHltvInfo| { &m.tv_slots },
            |m: &mut ServerHltvInfo| { &mut m.tv_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_clients",
            |m: &ServerHltvInfo| { &m.tv_clients },
            |m: &mut ServerHltvInfo| { &mut m.tv_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_proxies",
            |m: &ServerHltvInfo| { &m.tv_proxies },
            |m: &mut ServerHltvInfo| { &mut m.tv_proxies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_time",
            |m: &ServerHltvInfo| { &m.tv_time },
            |m: &mut ServerHltvInfo| { &mut m.tv_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &ServerHltvInfo| { &m.game_type },
            |m: &mut ServerHltvInfo| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mapgroup",
            |m: &ServerHltvInfo| { &m.game_mapgroup },
            |m: &mut ServerHltvInfo| { &mut m.game_mapgroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_map",
            |m: &ServerHltvInfo| { &m.game_map },
            |m: &mut ServerHltvInfo| { &mut m.game_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_master_steamid",
            |m: &ServerHltvInfo| { &m.tv_master_steamid },
            |m: &mut ServerHltvInfo| { &mut m.tv_master_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_local_slots",
            |m: &ServerHltvInfo| { &m.tv_local_slots },
            |m: &mut ServerHltvInfo| { &mut m.tv_local_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_local_clients",
            |m: &ServerHltvInfo| { &m.tv_local_clients },
            |m: &mut ServerHltvInfo| { &mut m.tv_local_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_local_proxies",
            |m: &ServerHltvInfo| { &m.tv_local_proxies },
            |m: &mut ServerHltvInfo| { &mut m.tv_local_proxies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_slots",
            |m: &ServerHltvInfo| { &m.tv_relay_slots },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_clients",
            |m: &ServerHltvInfo| { &m.tv_relay_clients },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_proxies",
            |m: &ServerHltvInfo| { &m.tv_relay_proxies },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_proxies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_address",
            |m: &ServerHltvInfo| { &m.tv_relay_address },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_port",
            |m: &ServerHltvInfo| { &m.tv_relay_port },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_steamid",
            |m: &ServerHltvInfo| { &m.tv_relay_steamid },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &ServerHltvInfo| { &m.flags },
            |m: &mut ServerHltvInfo| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerHltvInfo>(
            "ServerHltvInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerHltvInfo {
    const NAME: &'static str = "ServerHltvInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tv_udp_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.tv_watch_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.tv_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tv_clients = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tv_proxies = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.tv_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.game_mapgroup = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.game_map = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.tv_master_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.tv_local_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.tv_local_clients = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.tv_local_proxies = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.tv_relay_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.tv_relay_clients = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.tv_relay_proxies = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.tv_relay_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.tv_relay_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.tv_relay_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                168 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tv_udp_port {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tv_watch_key {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.tv_slots {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tv_clients {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tv_proxies {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tv_time {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.game_mapgroup.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.game_map.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.tv_master_steamid {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.tv_local_slots {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.tv_local_clients {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.tv_local_proxies {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.tv_relay_slots {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.tv_relay_clients {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.tv_relay_proxies {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.tv_relay_address {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.tv_relay_port {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.tv_relay_steamid {
            my_size += ::protobuf::rt::uint64_size(20, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(21, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tv_udp_port {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tv_watch_key {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.tv_slots {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tv_clients {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tv_proxies {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tv_time {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_mapgroup.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.game_map.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.tv_master_steamid {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.tv_local_slots {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.tv_local_clients {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.tv_local_proxies {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.tv_relay_slots {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.tv_relay_clients {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.tv_relay_proxies {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.tv_relay_address {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.tv_relay_port {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.tv_relay_steamid {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerHltvInfo {
        ServerHltvInfo::new()
    }

    fn clear(&mut self) {
        self.tv_udp_port = ::std::option::Option::None;
        self.tv_watch_key = ::std::option::Option::None;
        self.tv_slots = ::std::option::Option::None;
        self.tv_clients = ::std::option::Option::None;
        self.tv_proxies = ::std::option::Option::None;
        self.tv_time = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.game_mapgroup = ::std::option::Option::None;
        self.game_map = ::std::option::Option::None;
        self.tv_master_steamid = ::std::option::Option::None;
        self.tv_local_slots = ::std::option::Option::None;
        self.tv_local_clients = ::std::option::Option::None;
        self.tv_local_proxies = ::std::option::Option::None;
        self.tv_relay_slots = ::std::option::Option::None;
        self.tv_relay_clients = ::std::option::Option::None;
        self.tv_relay_proxies = ::std::option::Option::None;
        self.tv_relay_address = ::std::option::Option::None;
        self.tv_relay_port = ::std::option::Option::None;
        self.tv_relay_steamid = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerHltvInfo {
        static instance: ServerHltvInfo = ServerHltvInfo {
            tv_udp_port: ::std::option::Option::None,
            tv_watch_key: ::std::option::Option::None,
            tv_slots: ::std::option::Option::None,
            tv_clients: ::std::option::Option::None,
            tv_proxies: ::std::option::Option::None,
            tv_time: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            game_mapgroup: ::std::option::Option::None,
            game_map: ::std::option::Option::None,
            tv_master_steamid: ::std::option::Option::None,
            tv_local_slots: ::std::option::Option::None,
            tv_local_clients: ::std::option::Option::None,
            tv_local_proxies: ::std::option::Option::None,
            tv_relay_slots: ::std::option::Option::None,
            tv_relay_clients: ::std::option::Option::None,
            tv_relay_proxies: ::std::option::Option::None,
            tv_relay_address: ::std::option::Option::None,
            tv_relay_port: ::std::option::Option::None,
            tv_relay_steamid: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerHltvInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerHltvInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerHltvInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerHltvInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:IpAddressMask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct IpAddressMask {
    // message fields
    // @@protoc_insertion_point(field:IpAddressMask.a)
    pub a: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:IpAddressMask.b)
    pub b: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:IpAddressMask.c)
    pub c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:IpAddressMask.d)
    pub d: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:IpAddressMask.bits)
    pub bits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:IpAddressMask.token)
    pub token: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:IpAddressMask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IpAddressMask {
    fn default() -> &'a IpAddressMask {
        <IpAddressMask as ::protobuf::Message>::default_instance()
    }
}

impl IpAddressMask {
    pub fn new() -> IpAddressMask {
        ::std::default::Default::default()
    }

    // optional uint32 a = 1;

    pub fn a(&self) -> u32 {
        self.a.unwrap_or(0)
    }

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: u32) {
        self.a = ::std::option::Option::Some(v);
    }

    // optional uint32 b = 2;

    pub fn b(&self) -> u32 {
        self.b.unwrap_or(0)
    }

    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: u32) {
        self.b = ::std::option::Option::Some(v);
    }

    // optional uint32 c = 3;

    pub fn c(&self) -> u32 {
        self.c.unwrap_or(0)
    }

    pub fn clear_c(&mut self) {
        self.c = ::std::option::Option::None;
    }

    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c(&mut self, v: u32) {
        self.c = ::std::option::Option::Some(v);
    }

    // optional uint32 d = 4;

    pub fn d(&self) -> u32 {
        self.d.unwrap_or(0)
    }

    pub fn clear_d(&mut self) {
        self.d = ::std::option::Option::None;
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: u32) {
        self.d = ::std::option::Option::Some(v);
    }

    // optional uint32 bits = 5;

    pub fn bits(&self) -> u32 {
        self.bits.unwrap_or(0)
    }

    pub fn clear_bits(&mut self) {
        self.bits = ::std::option::Option::None;
    }

    pub fn has_bits(&self) -> bool {
        self.bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bits(&mut self, v: u32) {
        self.bits = ::std::option::Option::Some(v);
    }

    // optional uint32 token = 6;

    pub fn token(&self) -> u32 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "a",
            |m: &IpAddressMask| { &m.a },
            |m: &mut IpAddressMask| { &mut m.a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "b",
            |m: &IpAddressMask| { &m.b },
            |m: &mut IpAddressMask| { &mut m.b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "c",
            |m: &IpAddressMask| { &m.c },
            |m: &mut IpAddressMask| { &mut m.c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "d",
            |m: &IpAddressMask| { &m.d },
            |m: &mut IpAddressMask| { &mut m.d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bits",
            |m: &IpAddressMask| { &m.bits },
            |m: &mut IpAddressMask| { &mut m.bits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &IpAddressMask| { &m.token },
            |m: &mut IpAddressMask| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IpAddressMask>(
            "IpAddressMask",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IpAddressMask {
    const NAME: &'static str = "IpAddressMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.a = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.b = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.c = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.d = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.bits = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.token = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.a {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.b {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.c {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.d {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.bits {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.a {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.b {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.c {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.d {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bits {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.token {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IpAddressMask {
        IpAddressMask::new()
    }

    fn clear(&mut self) {
        self.a = ::std::option::Option::None;
        self.b = ::std::option::Option::None;
        self.c = ::std::option::Option::None;
        self.d = ::std::option::Option::None;
        self.bits = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IpAddressMask {
        static instance: IpAddressMask = IpAddressMask {
            a: ::std::option::Option::None,
            b: ::std::option::Option::None,
            c: ::std::option::Option::None,
            d: ::std::option::Option::None,
            bits: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IpAddressMask {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IpAddressMask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IpAddressMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IpAddressMask {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgCsgoSteamUserStatChange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCsgoSteamUserStatChange {
    // message fields
    // @@protoc_insertion_point(field:CMsgCsgoSteamUserStatChange.ecsgosteamuserstat)
    pub ecsgosteamuserstat: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgCsgoSteamUserStatChange.delta)
    pub delta: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgCsgoSteamUserStatChange.absolute)
    pub absolute: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCsgoSteamUserStatChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCsgoSteamUserStatChange {
    fn default() -> &'a CMsgCsgoSteamUserStatChange {
        <CMsgCsgoSteamUserStatChange as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCsgoSteamUserStatChange {
    pub fn new() -> CMsgCsgoSteamUserStatChange {
        ::std::default::Default::default()
    }

    // optional int32 ecsgosteamuserstat = 1;

    pub fn ecsgosteamuserstat(&self) -> i32 {
        self.ecsgosteamuserstat.unwrap_or(0)
    }

    pub fn clear_ecsgosteamuserstat(&mut self) {
        self.ecsgosteamuserstat = ::std::option::Option::None;
    }

    pub fn has_ecsgosteamuserstat(&self) -> bool {
        self.ecsgosteamuserstat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ecsgosteamuserstat(&mut self, v: i32) {
        self.ecsgosteamuserstat = ::std::option::Option::Some(v);
    }

    // optional int32 delta = 2;

    pub fn delta(&self) -> i32 {
        self.delta.unwrap_or(0)
    }

    pub fn clear_delta(&mut self) {
        self.delta = ::std::option::Option::None;
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: i32) {
        self.delta = ::std::option::Option::Some(v);
    }

    // optional bool absolute = 3;

    pub fn absolute(&self) -> bool {
        self.absolute.unwrap_or(false)
    }

    pub fn clear_absolute(&mut self) {
        self.absolute = ::std::option::Option::None;
    }

    pub fn has_absolute(&self) -> bool {
        self.absolute.is_some()
    }

    // Param is passed by value, moved
    pub fn set_absolute(&mut self, v: bool) {
        self.absolute = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ecsgosteamuserstat",
            |m: &CMsgCsgoSteamUserStatChange| { &m.ecsgosteamuserstat },
            |m: &mut CMsgCsgoSteamUserStatChange| { &mut m.ecsgosteamuserstat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta",
            |m: &CMsgCsgoSteamUserStatChange| { &m.delta },
            |m: &mut CMsgCsgoSteamUserStatChange| { &mut m.delta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "absolute",
            |m: &CMsgCsgoSteamUserStatChange| { &m.absolute },
            |m: &mut CMsgCsgoSteamUserStatChange| { &mut m.absolute },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCsgoSteamUserStatChange>(
            "CMsgCsgoSteamUserStatChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCsgoSteamUserStatChange {
    const NAME: &'static str = "CMsgCsgoSteamUserStatChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ecsgosteamuserstat = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.delta = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.absolute = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ecsgosteamuserstat {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.delta {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.absolute {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ecsgosteamuserstat {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.delta {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.absolute {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCsgoSteamUserStatChange {
        CMsgCsgoSteamUserStatChange::new()
    }

    fn clear(&mut self) {
        self.ecsgosteamuserstat = ::std::option::Option::None;
        self.delta = ::std::option::Option::None;
        self.absolute = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCsgoSteamUserStatChange {
        static instance: CMsgCsgoSteamUserStatChange = CMsgCsgoSteamUserStatChange {
            ecsgosteamuserstat: ::std::option::Option::None,
            delta: ::std::option::Option::None,
            absolute: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCsgoSteamUserStatChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCsgoSteamUserStatChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCsgoSteamUserStatChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCsgoSteamUserStatChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:XpProgressData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct XpProgressData {
    // message fields
    // @@protoc_insertion_point(field:XpProgressData.xp_points)
    pub xp_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:XpProgressData.xp_category)
    pub xp_category: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:XpProgressData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a XpProgressData {
    fn default() -> &'a XpProgressData {
        <XpProgressData as ::protobuf::Message>::default_instance()
    }
}

impl XpProgressData {
    pub fn new() -> XpProgressData {
        ::std::default::Default::default()
    }

    // optional uint32 xp_points = 1;

    pub fn xp_points(&self) -> u32 {
        self.xp_points.unwrap_or(0)
    }

    pub fn clear_xp_points(&mut self) {
        self.xp_points = ::std::option::Option::None;
    }

    pub fn has_xp_points(&self) -> bool {
        self.xp_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_points(&mut self, v: u32) {
        self.xp_points = ::std::option::Option::Some(v);
    }

    // optional int32 xp_category = 2;

    pub fn xp_category(&self) -> i32 {
        self.xp_category.unwrap_or(0)
    }

    pub fn clear_xp_category(&mut self) {
        self.xp_category = ::std::option::Option::None;
    }

    pub fn has_xp_category(&self) -> bool {
        self.xp_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_category(&mut self, v: i32) {
        self.xp_category = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xp_points",
            |m: &XpProgressData| { &m.xp_points },
            |m: &mut XpProgressData| { &mut m.xp_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xp_category",
            |m: &XpProgressData| { &m.xp_category },
            |m: &mut XpProgressData| { &mut m.xp_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<XpProgressData>(
            "XpProgressData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for XpProgressData {
    const NAME: &'static str = "XpProgressData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.xp_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.xp_category = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.xp_points {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.xp_category {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.xp_points {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.xp_category {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> XpProgressData {
        XpProgressData::new()
    }

    fn clear(&mut self) {
        self.xp_points = ::std::option::Option::None;
        self.xp_category = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static XpProgressData {
        static instance: XpProgressData = XpProgressData {
            xp_points: ::std::option::Option::None,
            xp_category: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for XpProgressData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("XpProgressData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for XpProgressData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for XpProgressData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MatchEndItemUpdates)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MatchEndItemUpdates {
    // message fields
    // @@protoc_insertion_point(field:MatchEndItemUpdates.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:MatchEndItemUpdates.item_attr_defidx)
    pub item_attr_defidx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MatchEndItemUpdates.item_attr_delta_value)
    pub item_attr_delta_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:MatchEndItemUpdates.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatchEndItemUpdates {
    fn default() -> &'a MatchEndItemUpdates {
        <MatchEndItemUpdates as ::protobuf::Message>::default_instance()
    }
}

impl MatchEndItemUpdates {
    pub fn new() -> MatchEndItemUpdates {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_attr_defidx = 2;

    pub fn item_attr_defidx(&self) -> u32 {
        self.item_attr_defidx.unwrap_or(0)
    }

    pub fn clear_item_attr_defidx(&mut self) {
        self.item_attr_defidx = ::std::option::Option::None;
    }

    pub fn has_item_attr_defidx(&self) -> bool {
        self.item_attr_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_attr_defidx(&mut self, v: u32) {
        self.item_attr_defidx = ::std::option::Option::Some(v);
    }

    // optional uint32 item_attr_delta_value = 3;

    pub fn item_attr_delta_value(&self) -> u32 {
        self.item_attr_delta_value.unwrap_or(0)
    }

    pub fn clear_item_attr_delta_value(&mut self) {
        self.item_attr_delta_value = ::std::option::Option::None;
    }

    pub fn has_item_attr_delta_value(&self) -> bool {
        self.item_attr_delta_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_attr_delta_value(&mut self, v: u32) {
        self.item_attr_delta_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &MatchEndItemUpdates| { &m.item_id },
            |m: &mut MatchEndItemUpdates| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_attr_defidx",
            |m: &MatchEndItemUpdates| { &m.item_attr_defidx },
            |m: &mut MatchEndItemUpdates| { &mut m.item_attr_defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_attr_delta_value",
            |m: &MatchEndItemUpdates| { &m.item_attr_delta_value },
            |m: &mut MatchEndItemUpdates| { &mut m.item_attr_delta_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchEndItemUpdates>(
            "MatchEndItemUpdates",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatchEndItemUpdates {
    const NAME: &'static str = "MatchEndItemUpdates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_attr_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_attr_delta_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_attr_defidx {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_attr_delta_value {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_attr_defidx {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_attr_delta_value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatchEndItemUpdates {
        MatchEndItemUpdates::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.item_attr_defidx = ::std::option::Option::None;
        self.item_attr_delta_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatchEndItemUpdates {
        static instance: MatchEndItemUpdates = MatchEndItemUpdates {
            item_id: ::std::option::Option::None,
            item_attr_defidx: ::std::option::Option::None,
            item_attr_delta_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatchEndItemUpdates {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatchEndItemUpdates").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatchEndItemUpdates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchEndItemUpdates {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ScoreLeaderboardData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ScoreLeaderboardData {
    // message fields
    // @@protoc_insertion_point(field:ScoreLeaderboardData.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ScoreLeaderboardData.score)
    pub score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ScoreLeaderboardData.accountentries)
    pub accountentries: ::std::vec::Vec<score_leaderboard_data::AccountEntries>,
    // @@protoc_insertion_point(field:ScoreLeaderboardData.matchentries)
    pub matchentries: ::std::vec::Vec<score_leaderboard_data::Entry>,
    // @@protoc_insertion_point(field:ScoreLeaderboardData.leaderboard_name)
    pub leaderboard_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ScoreLeaderboardData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScoreLeaderboardData {
    fn default() -> &'a ScoreLeaderboardData {
        <ScoreLeaderboardData as ::protobuf::Message>::default_instance()
    }
}

impl ScoreLeaderboardData {
    pub fn new() -> ScoreLeaderboardData {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 2;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional string leaderboard_name = 6;

    pub fn leaderboard_name(&self) -> &str {
        match self.leaderboard_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_leaderboard_name(&mut self) {
        self.leaderboard_name = ::std::option::Option::None;
    }

    pub fn has_leaderboard_name(&self) -> bool {
        self.leaderboard_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name(&mut self, v: ::std::string::String) {
        self.leaderboard_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_name(&mut self) -> &mut ::std::string::String {
        if self.leaderboard_name.is_none() {
            self.leaderboard_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.leaderboard_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_name(&mut self) -> ::std::string::String {
        self.leaderboard_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &ScoreLeaderboardData| { &m.quest_id },
            |m: &mut ScoreLeaderboardData| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &ScoreLeaderboardData| { &m.score },
            |m: &mut ScoreLeaderboardData| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accountentries",
            |m: &ScoreLeaderboardData| { &m.accountentries },
            |m: &mut ScoreLeaderboardData| { &mut m.accountentries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchentries",
            |m: &ScoreLeaderboardData| { &m.matchentries },
            |m: &mut ScoreLeaderboardData| { &mut m.matchentries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_name",
            |m: &ScoreLeaderboardData| { &m.leaderboard_name },
            |m: &mut ScoreLeaderboardData| { &mut m.leaderboard_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScoreLeaderboardData>(
            "ScoreLeaderboardData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScoreLeaderboardData {
    const NAME: &'static str = "ScoreLeaderboardData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.accountentries.push(is.read_message()?);
                },
                42 => {
                    self.matchentries.push(is.read_message()?);
                },
                50 => {
                    self.leaderboard_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.accountentries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.matchentries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.leaderboard_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        for v in &self.accountentries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.matchentries {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.leaderboard_name.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScoreLeaderboardData {
        ScoreLeaderboardData::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.accountentries.clear();
        self.matchentries.clear();
        self.leaderboard_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScoreLeaderboardData {
        static instance: ScoreLeaderboardData = ScoreLeaderboardData {
            quest_id: ::std::option::Option::None,
            score: ::std::option::Option::None,
            accountentries: ::std::vec::Vec::new(),
            matchentries: ::std::vec::Vec::new(),
            leaderboard_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScoreLeaderboardData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScoreLeaderboardData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScoreLeaderboardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreLeaderboardData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ScoreLeaderboardData`
pub mod score_leaderboard_data {
    // @@protoc_insertion_point(message:ScoreLeaderboardData.Entry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:ScoreLeaderboardData.Entry.tag)
        pub tag: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:ScoreLeaderboardData.Entry.val)
        pub val: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:ScoreLeaderboardData.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        // optional uint32 tag = 1;

        pub fn tag(&self) -> u32 {
            self.tag.unwrap_or(0)
        }

        pub fn clear_tag(&mut self) {
            self.tag = ::std::option::Option::None;
        }

        pub fn has_tag(&self) -> bool {
            self.tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag(&mut self, v: u32) {
            self.tag = ::std::option::Option::Some(v);
        }

        // optional uint32 val = 2;

        pub fn val(&self) -> u32 {
            self.val.unwrap_or(0)
        }

        pub fn clear_val(&mut self) {
            self.val = ::std::option::Option::None;
        }

        pub fn has_val(&self) -> bool {
            self.val.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val(&mut self, v: u32) {
            self.val = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tag",
                |m: &Entry| { &m.tag },
                |m: &mut Entry| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val",
                |m: &Entry| { &m.val },
                |m: &mut Entry| { &mut m.val },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "ScoreLeaderboardData.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tag = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.val = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tag {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.val {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tag {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.val {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.tag = ::std::option::Option::None;
            self.val = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                tag: ::std::option::Option::None,
                val: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ScoreLeaderboardData.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:ScoreLeaderboardData.AccountEntries)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AccountEntries {
        // message fields
        // @@protoc_insertion_point(field:ScoreLeaderboardData.AccountEntries.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:ScoreLeaderboardData.AccountEntries.entries)
        pub entries: ::std::vec::Vec<Entry>,
        // special fields
        // @@protoc_insertion_point(special_field:ScoreLeaderboardData.AccountEntries.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AccountEntries {
        fn default() -> &'a AccountEntries {
            <AccountEntries as ::protobuf::Message>::default_instance()
        }
    }

    impl AccountEntries {
        pub fn new() -> AccountEntries {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &AccountEntries| { &m.accountid },
                |m: &mut AccountEntries| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "entries",
                |m: &AccountEntries| { &m.entries },
                |m: &mut AccountEntries| { &mut m.entries },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountEntries>(
                "ScoreLeaderboardData.AccountEntries",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AccountEntries {
        const NAME: &'static str = "AccountEntries";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.entries.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.entries {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            for v in &self.entries {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AccountEntries {
            AccountEntries::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.entries.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AccountEntries {
            static instance: AccountEntries = AccountEntries {
                accountid: ::std::option::Option::None,
                entries: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AccountEntries {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ScoreLeaderboardData.AccountEntries").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AccountEntries {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AccountEntries {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:PlayerQuestData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerQuestData {
    // message fields
    // @@protoc_insertion_point(field:PlayerQuestData.quester_account_id)
    pub quester_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerQuestData.quest_item_data)
    pub quest_item_data: ::std::vec::Vec<player_quest_data::QuestItemData>,
    // @@protoc_insertion_point(field:PlayerQuestData.xp_progress_data)
    pub xp_progress_data: ::std::vec::Vec<XpProgressData>,
    // @@protoc_insertion_point(field:PlayerQuestData.time_played)
    pub time_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerQuestData.mm_game_mode)
    pub mm_game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerQuestData.item_updates)
    pub item_updates: ::std::vec::Vec<MatchEndItemUpdates>,
    // @@protoc_insertion_point(field:PlayerQuestData.operation_points_eligible)
    pub operation_points_eligible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:PlayerQuestData.userstatchanges)
    pub userstatchanges: ::std::vec::Vec<CMsgCsgoSteamUserStatChange>,
    // special fields
    // @@protoc_insertion_point(special_field:PlayerQuestData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerQuestData {
    fn default() -> &'a PlayerQuestData {
        <PlayerQuestData as ::protobuf::Message>::default_instance()
    }
}

impl PlayerQuestData {
    pub fn new() -> PlayerQuestData {
        ::std::default::Default::default()
    }

    // optional uint32 quester_account_id = 1;

    pub fn quester_account_id(&self) -> u32 {
        self.quester_account_id.unwrap_or(0)
    }

    pub fn clear_quester_account_id(&mut self) {
        self.quester_account_id = ::std::option::Option::None;
    }

    pub fn has_quester_account_id(&self) -> bool {
        self.quester_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quester_account_id(&mut self, v: u32) {
        self.quester_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_played = 4;

    pub fn time_played(&self) -> u32 {
        self.time_played.unwrap_or(0)
    }

    pub fn clear_time_played(&mut self) {
        self.time_played = ::std::option::Option::None;
    }

    pub fn has_time_played(&self) -> bool {
        self.time_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_played(&mut self, v: u32) {
        self.time_played = ::std::option::Option::Some(v);
    }

    // optional uint32 mm_game_mode = 5;

    pub fn mm_game_mode(&self) -> u32 {
        self.mm_game_mode.unwrap_or(0)
    }

    pub fn clear_mm_game_mode(&mut self) {
        self.mm_game_mode = ::std::option::Option::None;
    }

    pub fn has_mm_game_mode(&self) -> bool {
        self.mm_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mm_game_mode(&mut self, v: u32) {
        self.mm_game_mode = ::std::option::Option::Some(v);
    }

    // optional bool operation_points_eligible = 7;

    pub fn operation_points_eligible(&self) -> bool {
        self.operation_points_eligible.unwrap_or(false)
    }

    pub fn clear_operation_points_eligible(&mut self) {
        self.operation_points_eligible = ::std::option::Option::None;
    }

    pub fn has_operation_points_eligible(&self) -> bool {
        self.operation_points_eligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation_points_eligible(&mut self, v: bool) {
        self.operation_points_eligible = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quester_account_id",
            |m: &PlayerQuestData| { &m.quester_account_id },
            |m: &mut PlayerQuestData| { &mut m.quester_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "quest_item_data",
            |m: &PlayerQuestData| { &m.quest_item_data },
            |m: &mut PlayerQuestData| { &mut m.quest_item_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "xp_progress_data",
            |m: &PlayerQuestData| { &m.xp_progress_data },
            |m: &mut PlayerQuestData| { &mut m.xp_progress_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_played",
            |m: &PlayerQuestData| { &m.time_played },
            |m: &mut PlayerQuestData| { &mut m.time_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mm_game_mode",
            |m: &PlayerQuestData| { &m.mm_game_mode },
            |m: &mut PlayerQuestData| { &mut m.mm_game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_updates",
            |m: &PlayerQuestData| { &m.item_updates },
            |m: &mut PlayerQuestData| { &mut m.item_updates },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation_points_eligible",
            |m: &PlayerQuestData| { &m.operation_points_eligible },
            |m: &mut PlayerQuestData| { &mut m.operation_points_eligible },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "userstatchanges",
            |m: &PlayerQuestData| { &m.userstatchanges },
            |m: &mut PlayerQuestData| { &mut m.userstatchanges },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerQuestData>(
            "PlayerQuestData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerQuestData {
    const NAME: &'static str = "PlayerQuestData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quester_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.quest_item_data.push(is.read_message()?);
                },
                26 => {
                    self.xp_progress_data.push(is.read_message()?);
                },
                32 => {
                    self.time_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.mm_game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.item_updates.push(is.read_message()?);
                },
                56 => {
                    self.operation_points_eligible = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    self.userstatchanges.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quester_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.quest_item_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.xp_progress_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.time_played {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.mm_game_mode {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.item_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.operation_points_eligible {
            my_size += 1 + 1;
        }
        for value in &self.userstatchanges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quester_account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.quest_item_data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.xp_progress_data {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.time_played {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.mm_game_mode {
            os.write_uint32(5, v)?;
        }
        for v in &self.item_updates {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.operation_points_eligible {
            os.write_bool(7, v)?;
        }
        for v in &self.userstatchanges {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerQuestData {
        PlayerQuestData::new()
    }

    fn clear(&mut self) {
        self.quester_account_id = ::std::option::Option::None;
        self.quest_item_data.clear();
        self.xp_progress_data.clear();
        self.time_played = ::std::option::Option::None;
        self.mm_game_mode = ::std::option::Option::None;
        self.item_updates.clear();
        self.operation_points_eligible = ::std::option::Option::None;
        self.userstatchanges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerQuestData {
        static instance: PlayerQuestData = PlayerQuestData {
            quester_account_id: ::std::option::Option::None,
            quest_item_data: ::std::vec::Vec::new(),
            xp_progress_data: ::std::vec::Vec::new(),
            time_played: ::std::option::Option::None,
            mm_game_mode: ::std::option::Option::None,
            item_updates: ::std::vec::Vec::new(),
            operation_points_eligible: ::std::option::Option::None,
            userstatchanges: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerQuestData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerQuestData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerQuestData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerQuestData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PlayerQuestData`
pub mod player_quest_data {
    // @@protoc_insertion_point(message:PlayerQuestData.QuestItemData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct QuestItemData {
        // message fields
        // @@protoc_insertion_point(field:PlayerQuestData.QuestItemData.quest_id)
        pub quest_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:PlayerQuestData.QuestItemData.quest_normal_points_earned)
        pub quest_normal_points_earned: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:PlayerQuestData.QuestItemData.quest_bonus_points_earned)
        pub quest_bonus_points_earned: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:PlayerQuestData.QuestItemData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QuestItemData {
        fn default() -> &'a QuestItemData {
            <QuestItemData as ::protobuf::Message>::default_instance()
        }
    }

    impl QuestItemData {
        pub fn new() -> QuestItemData {
            ::std::default::Default::default()
        }

        // optional uint64 quest_id = 1;

        pub fn quest_id(&self) -> u64 {
            self.quest_id.unwrap_or(0)
        }

        pub fn clear_quest_id(&mut self) {
            self.quest_id = ::std::option::Option::None;
        }

        pub fn has_quest_id(&self) -> bool {
            self.quest_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quest_id(&mut self, v: u64) {
            self.quest_id = ::std::option::Option::Some(v);
        }

        // optional int32 quest_normal_points_earned = 2;

        pub fn quest_normal_points_earned(&self) -> i32 {
            self.quest_normal_points_earned.unwrap_or(0)
        }

        pub fn clear_quest_normal_points_earned(&mut self) {
            self.quest_normal_points_earned = ::std::option::Option::None;
        }

        pub fn has_quest_normal_points_earned(&self) -> bool {
            self.quest_normal_points_earned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quest_normal_points_earned(&mut self, v: i32) {
            self.quest_normal_points_earned = ::std::option::Option::Some(v);
        }

        // optional int32 quest_bonus_points_earned = 3;

        pub fn quest_bonus_points_earned(&self) -> i32 {
            self.quest_bonus_points_earned.unwrap_or(0)
        }

        pub fn clear_quest_bonus_points_earned(&mut self) {
            self.quest_bonus_points_earned = ::std::option::Option::None;
        }

        pub fn has_quest_bonus_points_earned(&self) -> bool {
            self.quest_bonus_points_earned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quest_bonus_points_earned(&mut self, v: i32) {
            self.quest_bonus_points_earned = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quest_id",
                |m: &QuestItemData| { &m.quest_id },
                |m: &mut QuestItemData| { &mut m.quest_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quest_normal_points_earned",
                |m: &QuestItemData| { &m.quest_normal_points_earned },
                |m: &mut QuestItemData| { &mut m.quest_normal_points_earned },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quest_bonus_points_earned",
                |m: &QuestItemData| { &m.quest_bonus_points_earned },
                |m: &mut QuestItemData| { &mut m.quest_bonus_points_earned },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuestItemData>(
                "PlayerQuestData.QuestItemData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for QuestItemData {
        const NAME: &'static str = "QuestItemData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.quest_normal_points_earned = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.quest_bonus_points_earned = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.quest_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.quest_normal_points_earned {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.quest_bonus_points_earned {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.quest_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.quest_normal_points_earned {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.quest_bonus_points_earned {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QuestItemData {
            QuestItemData::new()
        }

        fn clear(&mut self) {
            self.quest_id = ::std::option::Option::None;
            self.quest_normal_points_earned = ::std::option::Option::None;
            self.quest_bonus_points_earned = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QuestItemData {
            static instance: QuestItemData = QuestItemData {
                quest_id: ::std::option::Option::None,
                quest_normal_points_earned: ::std::option::Option::None,
                quest_bonus_points_earned: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for QuestItemData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PlayerQuestData.QuestItemData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for QuestItemData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for QuestItemData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:DeepPlayerStatsEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeepPlayerStatsEntry {
    // message fields
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.mm_game_mode)
    pub mm_game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.mapid)
    pub mapid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.b_starting_ct)
    pub b_starting_ct: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.match_outcome)
    pub match_outcome: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.rounds_won)
    pub rounds_won: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.rounds_lost)
    pub rounds_lost: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.stat_score)
    pub stat_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.stat_deaths)
    pub stat_deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.stat_mvps)
    pub stat_mvps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.enemy_kills)
    pub enemy_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.enemy_headshots)
    pub enemy_headshots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.enemy_2ks)
    pub enemy_2ks: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.enemy_3ks)
    pub enemy_3ks: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.enemy_4ks)
    pub enemy_4ks: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.total_damage)
    pub total_damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.engagements_entry_count)
    pub engagements_entry_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.engagements_entry_wins)
    pub engagements_entry_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.engagements_1v1_count)
    pub engagements_1v1_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.engagements_1v1_wins)
    pub engagements_1v1_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.engagements_1v2_count)
    pub engagements_1v2_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.engagements_1v2_wins)
    pub engagements_1v2_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.utility_count)
    pub utility_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.utility_success)
    pub utility_success: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.flash_count)
    pub flash_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.flash_success)
    pub flash_success: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerStatsEntry.mates)
    pub mates: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:DeepPlayerStatsEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeepPlayerStatsEntry {
    fn default() -> &'a DeepPlayerStatsEntry {
        <DeepPlayerStatsEntry as ::protobuf::Message>::default_instance()
    }
}

impl DeepPlayerStatsEntry {
    pub fn new() -> DeepPlayerStatsEntry {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 mm_game_mode = 3;

    pub fn mm_game_mode(&self) -> u32 {
        self.mm_game_mode.unwrap_or(0)
    }

    pub fn clear_mm_game_mode(&mut self) {
        self.mm_game_mode = ::std::option::Option::None;
    }

    pub fn has_mm_game_mode(&self) -> bool {
        self.mm_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mm_game_mode(&mut self, v: u32) {
        self.mm_game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 mapid = 4;

    pub fn mapid(&self) -> u32 {
        self.mapid.unwrap_or(0)
    }

    pub fn clear_mapid(&mut self) {
        self.mapid = ::std::option::Option::None;
    }

    pub fn has_mapid(&self) -> bool {
        self.mapid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mapid(&mut self, v: u32) {
        self.mapid = ::std::option::Option::Some(v);
    }

    // optional bool b_starting_ct = 5;

    pub fn b_starting_ct(&self) -> bool {
        self.b_starting_ct.unwrap_or(false)
    }

    pub fn clear_b_starting_ct(&mut self) {
        self.b_starting_ct = ::std::option::Option::None;
    }

    pub fn has_b_starting_ct(&self) -> bool {
        self.b_starting_ct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b_starting_ct(&mut self, v: bool) {
        self.b_starting_ct = ::std::option::Option::Some(v);
    }

    // optional uint32 match_outcome = 6;

    pub fn match_outcome(&self) -> u32 {
        self.match_outcome.unwrap_or(0)
    }

    pub fn clear_match_outcome(&mut self) {
        self.match_outcome = ::std::option::Option::None;
    }

    pub fn has_match_outcome(&self) -> bool {
        self.match_outcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_outcome(&mut self, v: u32) {
        self.match_outcome = ::std::option::Option::Some(v);
    }

    // optional uint32 rounds_won = 7;

    pub fn rounds_won(&self) -> u32 {
        self.rounds_won.unwrap_or(0)
    }

    pub fn clear_rounds_won(&mut self) {
        self.rounds_won = ::std::option::Option::None;
    }

    pub fn has_rounds_won(&self) -> bool {
        self.rounds_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rounds_won(&mut self, v: u32) {
        self.rounds_won = ::std::option::Option::Some(v);
    }

    // optional uint32 rounds_lost = 8;

    pub fn rounds_lost(&self) -> u32 {
        self.rounds_lost.unwrap_or(0)
    }

    pub fn clear_rounds_lost(&mut self) {
        self.rounds_lost = ::std::option::Option::None;
    }

    pub fn has_rounds_lost(&self) -> bool {
        self.rounds_lost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rounds_lost(&mut self, v: u32) {
        self.rounds_lost = ::std::option::Option::Some(v);
    }

    // optional uint32 stat_score = 9;

    pub fn stat_score(&self) -> u32 {
        self.stat_score.unwrap_or(0)
    }

    pub fn clear_stat_score(&mut self) {
        self.stat_score = ::std::option::Option::None;
    }

    pub fn has_stat_score(&self) -> bool {
        self.stat_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_score(&mut self, v: u32) {
        self.stat_score = ::std::option::Option::Some(v);
    }

    // optional uint32 stat_deaths = 12;

    pub fn stat_deaths(&self) -> u32 {
        self.stat_deaths.unwrap_or(0)
    }

    pub fn clear_stat_deaths(&mut self) {
        self.stat_deaths = ::std::option::Option::None;
    }

    pub fn has_stat_deaths(&self) -> bool {
        self.stat_deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_deaths(&mut self, v: u32) {
        self.stat_deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 stat_mvps = 13;

    pub fn stat_mvps(&self) -> u32 {
        self.stat_mvps.unwrap_or(0)
    }

    pub fn clear_stat_mvps(&mut self) {
        self.stat_mvps = ::std::option::Option::None;
    }

    pub fn has_stat_mvps(&self) -> bool {
        self.stat_mvps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_mvps(&mut self, v: u32) {
        self.stat_mvps = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_kills = 14;

    pub fn enemy_kills(&self) -> u32 {
        self.enemy_kills.unwrap_or(0)
    }

    pub fn clear_enemy_kills(&mut self) {
        self.enemy_kills = ::std::option::Option::None;
    }

    pub fn has_enemy_kills(&self) -> bool {
        self.enemy_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_kills(&mut self, v: u32) {
        self.enemy_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_headshots = 15;

    pub fn enemy_headshots(&self) -> u32 {
        self.enemy_headshots.unwrap_or(0)
    }

    pub fn clear_enemy_headshots(&mut self) {
        self.enemy_headshots = ::std::option::Option::None;
    }

    pub fn has_enemy_headshots(&self) -> bool {
        self.enemy_headshots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_headshots(&mut self, v: u32) {
        self.enemy_headshots = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_2ks = 16;

    pub fn enemy_2ks(&self) -> u32 {
        self.enemy_2ks.unwrap_or(0)
    }

    pub fn clear_enemy_2ks(&mut self) {
        self.enemy_2ks = ::std::option::Option::None;
    }

    pub fn has_enemy_2ks(&self) -> bool {
        self.enemy_2ks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_2ks(&mut self, v: u32) {
        self.enemy_2ks = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_3ks = 17;

    pub fn enemy_3ks(&self) -> u32 {
        self.enemy_3ks.unwrap_or(0)
    }

    pub fn clear_enemy_3ks(&mut self) {
        self.enemy_3ks = ::std::option::Option::None;
    }

    pub fn has_enemy_3ks(&self) -> bool {
        self.enemy_3ks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_3ks(&mut self, v: u32) {
        self.enemy_3ks = ::std::option::Option::Some(v);
    }

    // optional uint32 enemy_4ks = 18;

    pub fn enemy_4ks(&self) -> u32 {
        self.enemy_4ks.unwrap_or(0)
    }

    pub fn clear_enemy_4ks(&mut self) {
        self.enemy_4ks = ::std::option::Option::None;
    }

    pub fn has_enemy_4ks(&self) -> bool {
        self.enemy_4ks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enemy_4ks(&mut self, v: u32) {
        self.enemy_4ks = ::std::option::Option::Some(v);
    }

    // optional uint32 total_damage = 19;

    pub fn total_damage(&self) -> u32 {
        self.total_damage.unwrap_or(0)
    }

    pub fn clear_total_damage(&mut self) {
        self.total_damage = ::std::option::Option::None;
    }

    pub fn has_total_damage(&self) -> bool {
        self.total_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_damage(&mut self, v: u32) {
        self.total_damage = ::std::option::Option::Some(v);
    }

    // optional uint32 engagements_entry_count = 23;

    pub fn engagements_entry_count(&self) -> u32 {
        self.engagements_entry_count.unwrap_or(0)
    }

    pub fn clear_engagements_entry_count(&mut self) {
        self.engagements_entry_count = ::std::option::Option::None;
    }

    pub fn has_engagements_entry_count(&self) -> bool {
        self.engagements_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engagements_entry_count(&mut self, v: u32) {
        self.engagements_entry_count = ::std::option::Option::Some(v);
    }

    // optional uint32 engagements_entry_wins = 24;

    pub fn engagements_entry_wins(&self) -> u32 {
        self.engagements_entry_wins.unwrap_or(0)
    }

    pub fn clear_engagements_entry_wins(&mut self) {
        self.engagements_entry_wins = ::std::option::Option::None;
    }

    pub fn has_engagements_entry_wins(&self) -> bool {
        self.engagements_entry_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engagements_entry_wins(&mut self, v: u32) {
        self.engagements_entry_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 engagements_1v1_count = 25;

    pub fn engagements_1v1_count(&self) -> u32 {
        self.engagements_1v1_count.unwrap_or(0)
    }

    pub fn clear_engagements_1v1_count(&mut self) {
        self.engagements_1v1_count = ::std::option::Option::None;
    }

    pub fn has_engagements_1v1_count(&self) -> bool {
        self.engagements_1v1_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engagements_1v1_count(&mut self, v: u32) {
        self.engagements_1v1_count = ::std::option::Option::Some(v);
    }

    // optional uint32 engagements_1v1_wins = 26;

    pub fn engagements_1v1_wins(&self) -> u32 {
        self.engagements_1v1_wins.unwrap_or(0)
    }

    pub fn clear_engagements_1v1_wins(&mut self) {
        self.engagements_1v1_wins = ::std::option::Option::None;
    }

    pub fn has_engagements_1v1_wins(&self) -> bool {
        self.engagements_1v1_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engagements_1v1_wins(&mut self, v: u32) {
        self.engagements_1v1_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 engagements_1v2_count = 27;

    pub fn engagements_1v2_count(&self) -> u32 {
        self.engagements_1v2_count.unwrap_or(0)
    }

    pub fn clear_engagements_1v2_count(&mut self) {
        self.engagements_1v2_count = ::std::option::Option::None;
    }

    pub fn has_engagements_1v2_count(&self) -> bool {
        self.engagements_1v2_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engagements_1v2_count(&mut self, v: u32) {
        self.engagements_1v2_count = ::std::option::Option::Some(v);
    }

    // optional uint32 engagements_1v2_wins = 28;

    pub fn engagements_1v2_wins(&self) -> u32 {
        self.engagements_1v2_wins.unwrap_or(0)
    }

    pub fn clear_engagements_1v2_wins(&mut self) {
        self.engagements_1v2_wins = ::std::option::Option::None;
    }

    pub fn has_engagements_1v2_wins(&self) -> bool {
        self.engagements_1v2_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engagements_1v2_wins(&mut self, v: u32) {
        self.engagements_1v2_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 utility_count = 29;

    pub fn utility_count(&self) -> u32 {
        self.utility_count.unwrap_or(0)
    }

    pub fn clear_utility_count(&mut self) {
        self.utility_count = ::std::option::Option::None;
    }

    pub fn has_utility_count(&self) -> bool {
        self.utility_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utility_count(&mut self, v: u32) {
        self.utility_count = ::std::option::Option::Some(v);
    }

    // optional uint32 utility_success = 30;

    pub fn utility_success(&self) -> u32 {
        self.utility_success.unwrap_or(0)
    }

    pub fn clear_utility_success(&mut self) {
        self.utility_success = ::std::option::Option::None;
    }

    pub fn has_utility_success(&self) -> bool {
        self.utility_success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utility_success(&mut self, v: u32) {
        self.utility_success = ::std::option::Option::Some(v);
    }

    // optional uint32 flash_count = 32;

    pub fn flash_count(&self) -> u32 {
        self.flash_count.unwrap_or(0)
    }

    pub fn clear_flash_count(&mut self) {
        self.flash_count = ::std::option::Option::None;
    }

    pub fn has_flash_count(&self) -> bool {
        self.flash_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flash_count(&mut self, v: u32) {
        self.flash_count = ::std::option::Option::Some(v);
    }

    // optional uint32 flash_success = 33;

    pub fn flash_success(&self) -> u32 {
        self.flash_success.unwrap_or(0)
    }

    pub fn clear_flash_success(&mut self) {
        self.flash_success = ::std::option::Option::None;
    }

    pub fn has_flash_success(&self) -> bool {
        self.flash_success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flash_success(&mut self, v: u32) {
        self.flash_success = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(28);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &DeepPlayerStatsEntry| { &m.accountid },
            |m: &mut DeepPlayerStatsEntry| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &DeepPlayerStatsEntry| { &m.match_id },
            |m: &mut DeepPlayerStatsEntry| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mm_game_mode",
            |m: &DeepPlayerStatsEntry| { &m.mm_game_mode },
            |m: &mut DeepPlayerStatsEntry| { &mut m.mm_game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mapid",
            |m: &DeepPlayerStatsEntry| { &m.mapid },
            |m: &mut DeepPlayerStatsEntry| { &mut m.mapid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "b_starting_ct",
            |m: &DeepPlayerStatsEntry| { &m.b_starting_ct },
            |m: &mut DeepPlayerStatsEntry| { &mut m.b_starting_ct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_outcome",
            |m: &DeepPlayerStatsEntry| { &m.match_outcome },
            |m: &mut DeepPlayerStatsEntry| { &mut m.match_outcome },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rounds_won",
            |m: &DeepPlayerStatsEntry| { &m.rounds_won },
            |m: &mut DeepPlayerStatsEntry| { &mut m.rounds_won },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rounds_lost",
            |m: &DeepPlayerStatsEntry| { &m.rounds_lost },
            |m: &mut DeepPlayerStatsEntry| { &mut m.rounds_lost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stat_score",
            |m: &DeepPlayerStatsEntry| { &m.stat_score },
            |m: &mut DeepPlayerStatsEntry| { &mut m.stat_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stat_deaths",
            |m: &DeepPlayerStatsEntry| { &m.stat_deaths },
            |m: &mut DeepPlayerStatsEntry| { &mut m.stat_deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stat_mvps",
            |m: &DeepPlayerStatsEntry| { &m.stat_mvps },
            |m: &mut DeepPlayerStatsEntry| { &mut m.stat_mvps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_kills",
            |m: &DeepPlayerStatsEntry| { &m.enemy_kills },
            |m: &mut DeepPlayerStatsEntry| { &mut m.enemy_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_headshots",
            |m: &DeepPlayerStatsEntry| { &m.enemy_headshots },
            |m: &mut DeepPlayerStatsEntry| { &mut m.enemy_headshots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_2ks",
            |m: &DeepPlayerStatsEntry| { &m.enemy_2ks },
            |m: &mut DeepPlayerStatsEntry| { &mut m.enemy_2ks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_3ks",
            |m: &DeepPlayerStatsEntry| { &m.enemy_3ks },
            |m: &mut DeepPlayerStatsEntry| { &mut m.enemy_3ks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enemy_4ks",
            |m: &DeepPlayerStatsEntry| { &m.enemy_4ks },
            |m: &mut DeepPlayerStatsEntry| { &mut m.enemy_4ks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_damage",
            |m: &DeepPlayerStatsEntry| { &m.total_damage },
            |m: &mut DeepPlayerStatsEntry| { &mut m.total_damage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engagements_entry_count",
            |m: &DeepPlayerStatsEntry| { &m.engagements_entry_count },
            |m: &mut DeepPlayerStatsEntry| { &mut m.engagements_entry_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engagements_entry_wins",
            |m: &DeepPlayerStatsEntry| { &m.engagements_entry_wins },
            |m: &mut DeepPlayerStatsEntry| { &mut m.engagements_entry_wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engagements_1v1_count",
            |m: &DeepPlayerStatsEntry| { &m.engagements_1v1_count },
            |m: &mut DeepPlayerStatsEntry| { &mut m.engagements_1v1_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engagements_1v1_wins",
            |m: &DeepPlayerStatsEntry| { &m.engagements_1v1_wins },
            |m: &mut DeepPlayerStatsEntry| { &mut m.engagements_1v1_wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engagements_1v2_count",
            |m: &DeepPlayerStatsEntry| { &m.engagements_1v2_count },
            |m: &mut DeepPlayerStatsEntry| { &mut m.engagements_1v2_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "engagements_1v2_wins",
            |m: &DeepPlayerStatsEntry| { &m.engagements_1v2_wins },
            |m: &mut DeepPlayerStatsEntry| { &mut m.engagements_1v2_wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utility_count",
            |m: &DeepPlayerStatsEntry| { &m.utility_count },
            |m: &mut DeepPlayerStatsEntry| { &mut m.utility_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utility_success",
            |m: &DeepPlayerStatsEntry| { &m.utility_success },
            |m: &mut DeepPlayerStatsEntry| { &mut m.utility_success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flash_count",
            |m: &DeepPlayerStatsEntry| { &m.flash_count },
            |m: &mut DeepPlayerStatsEntry| { &mut m.flash_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flash_success",
            |m: &DeepPlayerStatsEntry| { &m.flash_success },
            |m: &mut DeepPlayerStatsEntry| { &mut m.flash_success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mates",
            |m: &DeepPlayerStatsEntry| { &m.mates },
            |m: &mut DeepPlayerStatsEntry| { &mut m.mates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeepPlayerStatsEntry>(
            "DeepPlayerStatsEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeepPlayerStatsEntry {
    const NAME: &'static str = "DeepPlayerStatsEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.mm_game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.mapid = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.b_starting_ct = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.match_outcome = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.rounds_won = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.rounds_lost = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.stat_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.stat_deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.stat_mvps = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.enemy_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.enemy_headshots = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.enemy_2ks = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.enemy_3ks = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.enemy_4ks = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.total_damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.engagements_entry_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.engagements_entry_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.engagements_1v1_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.engagements_1v1_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.engagements_1v2_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.engagements_1v2_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.utility_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.utility_success = ::std::option::Option::Some(is.read_uint32()?);
                },
                256 => {
                    self.flash_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.flash_success = ::std::option::Option::Some(is.read_uint32()?);
                },
                274 => {
                    is.read_repeated_packed_uint32_into(&mut self.mates)?;
                },
                272 => {
                    self.mates.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.mm_game_mode {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.mapid {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.b_starting_ct {
            my_size += 1 + 1;
        }
        if let Some(v) = self.match_outcome {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.rounds_won {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.rounds_lost {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.stat_score {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.stat_deaths {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.stat_mvps {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.enemy_kills {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.enemy_headshots {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.enemy_2ks {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.enemy_3ks {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.enemy_4ks {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.total_damage {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.engagements_entry_count {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.engagements_entry_wins {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.engagements_1v1_count {
            my_size += ::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.engagements_1v1_wins {
            my_size += ::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.engagements_1v2_count {
            my_size += ::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.engagements_1v2_wins {
            my_size += ::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.utility_count {
            my_size += ::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.utility_success {
            my_size += ::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.flash_count {
            my_size += ::protobuf::rt::uint32_size(32, v);
        }
        if let Some(v) = self.flash_success {
            my_size += ::protobuf::rt::uint32_size(33, v);
        }
        for value in &self.mates {
            my_size += ::protobuf::rt::uint32_size(34, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.mm_game_mode {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.mapid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.b_starting_ct {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.match_outcome {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rounds_won {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.rounds_lost {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.stat_score {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.stat_deaths {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.stat_mvps {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.enemy_kills {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.enemy_headshots {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.enemy_2ks {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.enemy_3ks {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.enemy_4ks {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.total_damage {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.engagements_entry_count {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.engagements_entry_wins {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.engagements_1v1_count {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.engagements_1v1_wins {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.engagements_1v2_count {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.engagements_1v2_wins {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.utility_count {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.utility_success {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.flash_count {
            os.write_uint32(32, v)?;
        }
        if let Some(v) = self.flash_success {
            os.write_uint32(33, v)?;
        }
        for v in &self.mates {
            os.write_uint32(34, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeepPlayerStatsEntry {
        DeepPlayerStatsEntry::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.mm_game_mode = ::std::option::Option::None;
        self.mapid = ::std::option::Option::None;
        self.b_starting_ct = ::std::option::Option::None;
        self.match_outcome = ::std::option::Option::None;
        self.rounds_won = ::std::option::Option::None;
        self.rounds_lost = ::std::option::Option::None;
        self.stat_score = ::std::option::Option::None;
        self.stat_deaths = ::std::option::Option::None;
        self.stat_mvps = ::std::option::Option::None;
        self.enemy_kills = ::std::option::Option::None;
        self.enemy_headshots = ::std::option::Option::None;
        self.enemy_2ks = ::std::option::Option::None;
        self.enemy_3ks = ::std::option::Option::None;
        self.enemy_4ks = ::std::option::Option::None;
        self.total_damage = ::std::option::Option::None;
        self.engagements_entry_count = ::std::option::Option::None;
        self.engagements_entry_wins = ::std::option::Option::None;
        self.engagements_1v1_count = ::std::option::Option::None;
        self.engagements_1v1_wins = ::std::option::Option::None;
        self.engagements_1v2_count = ::std::option::Option::None;
        self.engagements_1v2_wins = ::std::option::Option::None;
        self.utility_count = ::std::option::Option::None;
        self.utility_success = ::std::option::Option::None;
        self.flash_count = ::std::option::Option::None;
        self.flash_success = ::std::option::Option::None;
        self.mates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeepPlayerStatsEntry {
        static instance: DeepPlayerStatsEntry = DeepPlayerStatsEntry {
            accountid: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            mm_game_mode: ::std::option::Option::None,
            mapid: ::std::option::Option::None,
            b_starting_ct: ::std::option::Option::None,
            match_outcome: ::std::option::Option::None,
            rounds_won: ::std::option::Option::None,
            rounds_lost: ::std::option::Option::None,
            stat_score: ::std::option::Option::None,
            stat_deaths: ::std::option::Option::None,
            stat_mvps: ::std::option::Option::None,
            enemy_kills: ::std::option::Option::None,
            enemy_headshots: ::std::option::Option::None,
            enemy_2ks: ::std::option::Option::None,
            enemy_3ks: ::std::option::Option::None,
            enemy_4ks: ::std::option::Option::None,
            total_damage: ::std::option::Option::None,
            engagements_entry_count: ::std::option::Option::None,
            engagements_entry_wins: ::std::option::Option::None,
            engagements_1v1_count: ::std::option::Option::None,
            engagements_1v1_wins: ::std::option::Option::None,
            engagements_1v2_count: ::std::option::Option::None,
            engagements_1v2_wins: ::std::option::Option::None,
            utility_count: ::std::option::Option::None,
            utility_success: ::std::option::Option::None,
            flash_count: ::std::option::Option::None,
            flash_success: ::std::option::Option::None,
            mates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeepPlayerStatsEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeepPlayerStatsEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeepPlayerStatsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeepPlayerStatsEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DeepPlayerMatchEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeepPlayerMatchEvent {
    // message fields
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.event_type)
    pub event_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.b_playing_ct)
    pub b_playing_ct: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.user_pos_x)
    pub user_pos_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.user_pos_y)
    pub user_pos_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.user_pos_z)
    pub user_pos_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.user_defidx)
    pub user_defidx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.other_pos_x)
    pub other_pos_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.other_pos_y)
    pub other_pos_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.other_pos_z)
    pub other_pos_z: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.other_defidx)
    pub other_defidx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DeepPlayerMatchEvent.event_data)
    pub event_data: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:DeepPlayerMatchEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeepPlayerMatchEvent {
    fn default() -> &'a DeepPlayerMatchEvent {
        <DeepPlayerMatchEvent as ::protobuf::Message>::default_instance()
    }
}

impl DeepPlayerMatchEvent {
    pub fn new() -> DeepPlayerMatchEvent {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 3;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 4;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional bool b_playing_ct = 5;

    pub fn b_playing_ct(&self) -> bool {
        self.b_playing_ct.unwrap_or(false)
    }

    pub fn clear_b_playing_ct(&mut self) {
        self.b_playing_ct = ::std::option::Option::None;
    }

    pub fn has_b_playing_ct(&self) -> bool {
        self.b_playing_ct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b_playing_ct(&mut self, v: bool) {
        self.b_playing_ct = ::std::option::Option::Some(v);
    }

    // optional int32 user_pos_x = 6;

    pub fn user_pos_x(&self) -> i32 {
        self.user_pos_x.unwrap_or(0)
    }

    pub fn clear_user_pos_x(&mut self) {
        self.user_pos_x = ::std::option::Option::None;
    }

    pub fn has_user_pos_x(&self) -> bool {
        self.user_pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_pos_x(&mut self, v: i32) {
        self.user_pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 user_pos_y = 7;

    pub fn user_pos_y(&self) -> i32 {
        self.user_pos_y.unwrap_or(0)
    }

    pub fn clear_user_pos_y(&mut self) {
        self.user_pos_y = ::std::option::Option::None;
    }

    pub fn has_user_pos_y(&self) -> bool {
        self.user_pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_pos_y(&mut self, v: i32) {
        self.user_pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 user_pos_z = 12;

    pub fn user_pos_z(&self) -> i32 {
        self.user_pos_z.unwrap_or(0)
    }

    pub fn clear_user_pos_z(&mut self) {
        self.user_pos_z = ::std::option::Option::None;
    }

    pub fn has_user_pos_z(&self) -> bool {
        self.user_pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_pos_z(&mut self, v: i32) {
        self.user_pos_z = ::std::option::Option::Some(v);
    }

    // optional uint32 user_defidx = 8;

    pub fn user_defidx(&self) -> u32 {
        self.user_defidx.unwrap_or(0)
    }

    pub fn clear_user_defidx(&mut self) {
        self.user_defidx = ::std::option::Option::None;
    }

    pub fn has_user_defidx(&self) -> bool {
        self.user_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_defidx(&mut self, v: u32) {
        self.user_defidx = ::std::option::Option::Some(v);
    }

    // optional int32 other_pos_x = 9;

    pub fn other_pos_x(&self) -> i32 {
        self.other_pos_x.unwrap_or(0)
    }

    pub fn clear_other_pos_x(&mut self) {
        self.other_pos_x = ::std::option::Option::None;
    }

    pub fn has_other_pos_x(&self) -> bool {
        self.other_pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_pos_x(&mut self, v: i32) {
        self.other_pos_x = ::std::option::Option::Some(v);
    }

    // optional int32 other_pos_y = 10;

    pub fn other_pos_y(&self) -> i32 {
        self.other_pos_y.unwrap_or(0)
    }

    pub fn clear_other_pos_y(&mut self) {
        self.other_pos_y = ::std::option::Option::None;
    }

    pub fn has_other_pos_y(&self) -> bool {
        self.other_pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_pos_y(&mut self, v: i32) {
        self.other_pos_y = ::std::option::Option::Some(v);
    }

    // optional int32 other_pos_z = 13;

    pub fn other_pos_z(&self) -> i32 {
        self.other_pos_z.unwrap_or(0)
    }

    pub fn clear_other_pos_z(&mut self) {
        self.other_pos_z = ::std::option::Option::None;
    }

    pub fn has_other_pos_z(&self) -> bool {
        self.other_pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_pos_z(&mut self, v: i32) {
        self.other_pos_z = ::std::option::Option::Some(v);
    }

    // optional uint32 other_defidx = 11;

    pub fn other_defidx(&self) -> u32 {
        self.other_defidx.unwrap_or(0)
    }

    pub fn clear_other_defidx(&mut self) {
        self.other_defidx = ::std::option::Option::None;
    }

    pub fn has_other_defidx(&self) -> bool {
        self.other_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_defidx(&mut self, v: u32) {
        self.other_defidx = ::std::option::Option::Some(v);
    }

    // optional int32 event_data = 14;

    pub fn event_data(&self) -> i32 {
        self.event_data.unwrap_or(0)
    }

    pub fn clear_event_data(&mut self) {
        self.event_data = ::std::option::Option::None;
    }

    pub fn has_event_data(&self) -> bool {
        self.event_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_data(&mut self, v: i32) {
        self.event_data = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &DeepPlayerMatchEvent| { &m.accountid },
            |m: &mut DeepPlayerMatchEvent| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &DeepPlayerMatchEvent| { &m.match_id },
            |m: &mut DeepPlayerMatchEvent| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &DeepPlayerMatchEvent| { &m.event_id },
            |m: &mut DeepPlayerMatchEvent| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_type",
            |m: &DeepPlayerMatchEvent| { &m.event_type },
            |m: &mut DeepPlayerMatchEvent| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "b_playing_ct",
            |m: &DeepPlayerMatchEvent| { &m.b_playing_ct },
            |m: &mut DeepPlayerMatchEvent| { &mut m.b_playing_ct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_pos_x",
            |m: &DeepPlayerMatchEvent| { &m.user_pos_x },
            |m: &mut DeepPlayerMatchEvent| { &mut m.user_pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_pos_y",
            |m: &DeepPlayerMatchEvent| { &m.user_pos_y },
            |m: &mut DeepPlayerMatchEvent| { &mut m.user_pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_pos_z",
            |m: &DeepPlayerMatchEvent| { &m.user_pos_z },
            |m: &mut DeepPlayerMatchEvent| { &mut m.user_pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_defidx",
            |m: &DeepPlayerMatchEvent| { &m.user_defidx },
            |m: &mut DeepPlayerMatchEvent| { &mut m.user_defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_pos_x",
            |m: &DeepPlayerMatchEvent| { &m.other_pos_x },
            |m: &mut DeepPlayerMatchEvent| { &mut m.other_pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_pos_y",
            |m: &DeepPlayerMatchEvent| { &m.other_pos_y },
            |m: &mut DeepPlayerMatchEvent| { &mut m.other_pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_pos_z",
            |m: &DeepPlayerMatchEvent| { &m.other_pos_z },
            |m: &mut DeepPlayerMatchEvent| { &mut m.other_pos_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_defidx",
            |m: &DeepPlayerMatchEvent| { &m.other_defidx },
            |m: &mut DeepPlayerMatchEvent| { &mut m.other_defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_data",
            |m: &DeepPlayerMatchEvent| { &m.event_data },
            |m: &mut DeepPlayerMatchEvent| { &mut m.event_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeepPlayerMatchEvent>(
            "DeepPlayerMatchEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeepPlayerMatchEvent {
    const NAME: &'static str = "DeepPlayerMatchEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.b_playing_ct = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.user_pos_x = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.user_pos_y = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.user_pos_z = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.user_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.other_pos_x = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.other_pos_y = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.other_pos_z = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.other_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.event_data = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.b_playing_ct {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_pos_x {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.user_pos_y {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.user_pos_z {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.user_defidx {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.other_pos_x {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.other_pos_y {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.other_pos_z {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.other_defidx {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.event_data {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.b_playing_ct {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.user_pos_x {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.user_pos_y {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.user_pos_z {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.user_defidx {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.other_pos_x {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.other_pos_y {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.other_pos_z {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.other_defidx {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.event_data {
            os.write_int32(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeepPlayerMatchEvent {
        DeepPlayerMatchEvent::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.b_playing_ct = ::std::option::Option::None;
        self.user_pos_x = ::std::option::Option::None;
        self.user_pos_y = ::std::option::Option::None;
        self.user_pos_z = ::std::option::Option::None;
        self.user_defidx = ::std::option::Option::None;
        self.other_pos_x = ::std::option::Option::None;
        self.other_pos_y = ::std::option::Option::None;
        self.other_pos_z = ::std::option::Option::None;
        self.other_defidx = ::std::option::Option::None;
        self.event_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeepPlayerMatchEvent {
        static instance: DeepPlayerMatchEvent = DeepPlayerMatchEvent {
            accountid: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            b_playing_ct: ::std::option::Option::None,
            user_pos_x: ::std::option::Option::None,
            user_pos_y: ::std::option::Option::None,
            user_pos_z: ::std::option::Option::None,
            user_defidx: ::std::option::Option::None,
            other_pos_x: ::std::option::Option::None,
            other_pos_y: ::std::option::Option::None,
            other_pos_z: ::std::option::Option::None,
            other_defidx: ::std::option::Option::None,
            event_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeepPlayerMatchEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeepPlayerMatchEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeepPlayerMatchEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeepPlayerMatchEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_ServerQuestUpdateData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_ServerQuestUpdateData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_ServerQuestUpdateData.player_quest_data)
    pub player_quest_data: ::std::vec::Vec<PlayerQuestData>,
    // @@protoc_insertion_point(field:CMsgGC_ServerQuestUpdateData.binary_data)
    pub binary_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGC_ServerQuestUpdateData.mm_game_mode)
    pub mm_game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_ServerQuestUpdateData.missionlbsdata)
    pub missionlbsdata: ::protobuf::MessageField<ScoreLeaderboardData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_ServerQuestUpdateData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_ServerQuestUpdateData {
    fn default() -> &'a CMsgGC_ServerQuestUpdateData {
        <CMsgGC_ServerQuestUpdateData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_ServerQuestUpdateData {
    pub fn new() -> CMsgGC_ServerQuestUpdateData {
        ::std::default::Default::default()
    }

    // optional bytes binary_data = 2;

    pub fn binary_data(&self) -> &[u8] {
        match self.binary_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_binary_data(&mut self) {
        self.binary_data = ::std::option::Option::None;
    }

    pub fn has_binary_data(&self) -> bool {
        self.binary_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binary_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.binary_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binary_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.binary_data.is_none() {
            self.binary_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.binary_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_binary_data(&mut self) -> ::std::vec::Vec<u8> {
        self.binary_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 mm_game_mode = 3;

    pub fn mm_game_mode(&self) -> u32 {
        self.mm_game_mode.unwrap_or(0)
    }

    pub fn clear_mm_game_mode(&mut self) {
        self.mm_game_mode = ::std::option::Option::None;
    }

    pub fn has_mm_game_mode(&self) -> bool {
        self.mm_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mm_game_mode(&mut self, v: u32) {
        self.mm_game_mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_quest_data",
            |m: &CMsgGC_ServerQuestUpdateData| { &m.player_quest_data },
            |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.player_quest_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "binary_data",
            |m: &CMsgGC_ServerQuestUpdateData| { &m.binary_data },
            |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.binary_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mm_game_mode",
            |m: &CMsgGC_ServerQuestUpdateData| { &m.mm_game_mode },
            |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.mm_game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScoreLeaderboardData>(
            "missionlbsdata",
            |m: &CMsgGC_ServerQuestUpdateData| { &m.missionlbsdata },
            |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.missionlbsdata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_ServerQuestUpdateData>(
            "CMsgGC_ServerQuestUpdateData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_ServerQuestUpdateData {
    const NAME: &'static str = "CMsgGC_ServerQuestUpdateData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_quest_data.push(is.read_message()?);
                },
                18 => {
                    self.binary_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.mm_game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.missionlbsdata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_quest_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.binary_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.mm_game_mode {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.missionlbsdata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_quest_data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.binary_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.mm_game_mode {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.missionlbsdata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_ServerQuestUpdateData {
        CMsgGC_ServerQuestUpdateData::new()
    }

    fn clear(&mut self) {
        self.player_quest_data.clear();
        self.binary_data = ::std::option::Option::None;
        self.mm_game_mode = ::std::option::Option::None;
        self.missionlbsdata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_ServerQuestUpdateData {
        static instance: CMsgGC_ServerQuestUpdateData = CMsgGC_ServerQuestUpdateData {
            player_quest_data: ::std::vec::Vec::new(),
            binary_data: ::std::option::Option::None,
            mm_game_mode: ::std::option::Option::None,
            missionlbsdata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_ServerQuestUpdateData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_ServerQuestUpdateData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_ServerQuestUpdateData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_ServerQuestUpdateData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.token)
    pub token: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.stamp)
    pub stamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.exchange)
    pub exchange: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.retry)
    pub retry: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        <CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        ::std::default::Default::default()
    }

    // optional uint32 token = 1;

    pub fn token(&self) -> u32 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }

    // optional uint32 stamp = 2;

    pub fn stamp(&self) -> u32 {
        self.stamp.unwrap_or(0)
    }

    pub fn clear_stamp(&mut self) {
        self.stamp = ::std::option::Option::None;
    }

    pub fn has_stamp(&self) -> bool {
        self.stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stamp(&mut self, v: u32) {
        self.stamp = ::std::option::Option::Some(v);
    }

    // optional uint64 exchange = 3;

    pub fn exchange(&self) -> u64 {
        self.exchange.unwrap_or(0)
    }

    pub fn clear_exchange(&mut self) {
        self.exchange = ::std::option::Option::None;
    }

    pub fn has_exchange(&self) -> bool {
        self.exchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exchange(&mut self, v: u64) {
        self.exchange = ::std::option::Option::Some(v);
    }

    // optional uint32 retry = 4;

    pub fn retry(&self) -> u32 {
        self.retry.unwrap_or(0)
    }

    pub fn clear_retry(&mut self) {
        self.retry = ::std::option::Option::None;
    }

    pub fn has_retry(&self) -> bool {
        self.retry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry(&mut self, v: u32) {
        self.retry = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &m.token },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stamp",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &m.stamp },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &mut m.stamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "exchange",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &m.exchange },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &mut m.exchange },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "retry",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &m.retry },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &mut m.retry },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.token = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.stamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.exchange = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.retry = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.stamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.exchange {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.retry {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.exchange {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.retry {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.stamp = ::std::option::Option::None;
        self.exchange = ::std::option::Option::None;
        self.retry = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
            token: ::std::option::Option::None,
            stamp: ::std::option::Option::None,
            exchange: ::std::option::Option::None,
            retry: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GC2ServerReservationUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ServerReservationUpdate.viewers_external_total)
    pub viewers_external_total: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ServerReservationUpdate.viewers_external_steam)
    pub viewers_external_steam: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GC2ServerReservationUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        <CMsgGCCStrike15_v2_GC2ServerReservationUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 viewers_external_total = 1;

    pub fn viewers_external_total(&self) -> u32 {
        self.viewers_external_total.unwrap_or(0)
    }

    pub fn clear_viewers_external_total(&mut self) {
        self.viewers_external_total = ::std::option::Option::None;
    }

    pub fn has_viewers_external_total(&self) -> bool {
        self.viewers_external_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_external_total(&mut self, v: u32) {
        self.viewers_external_total = ::std::option::Option::Some(v);
    }

    // optional uint32 viewers_external_steam = 2;

    pub fn viewers_external_steam(&self) -> u32 {
        self.viewers_external_steam.unwrap_or(0)
    }

    pub fn clear_viewers_external_steam(&mut self) {
        self.viewers_external_steam = ::std::option::Option::None;
    }

    pub fn has_viewers_external_steam(&self) -> bool {
        self.viewers_external_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_external_steam(&mut self, v: u32) {
        self.viewers_external_steam = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewers_external_total",
            |m: &CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &m.viewers_external_total },
            |m: &mut CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &mut m.viewers_external_total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewers_external_steam",
            |m: &CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &m.viewers_external_steam },
            |m: &mut CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &mut m.viewers_external_steam },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GC2ServerReservationUpdate>(
            "CMsgGCCStrike15_v2_GC2ServerReservationUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GC2ServerReservationUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.viewers_external_total = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.viewers_external_steam = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.viewers_external_total {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.viewers_external_steam {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.viewers_external_total {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.viewers_external_steam {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        CMsgGCCStrike15_v2_GC2ServerReservationUpdate::new()
    }

    fn clear(&mut self) {
        self.viewers_external_total = ::std::option::Option::None;
        self.viewers_external_steam = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        static instance: CMsgGCCStrike15_v2_GC2ServerReservationUpdate = CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
            viewers_external_total: ::std::option::Option::None,
            viewers_external_steam: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GC2ServerReservationUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingStart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingStart {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.ticket_data)
    pub ticket_data: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.tournament_match)
    pub tournament_match: ::protobuf::MessageField<TournamentMatchSetup>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.prime_only)
    pub prime_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.tv_control)
    pub tv_control: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingStart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingStart {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingStart {
        <CMsgGCCStrike15_v2_MatchmakingStart as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingStart {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingStart {
        ::std::default::Default::default()
    }

    // optional uint32 game_type = 2;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional string ticket_data = 3;

    pub fn ticket_data(&self) -> &str {
        match self.ticket_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ticket_data(&mut self) {
        self.ticket_data = ::std::option::Option::None;
    }

    pub fn has_ticket_data(&self) -> bool {
        self.ticket_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_data(&mut self, v: ::std::string::String) {
        self.ticket_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket_data(&mut self) -> &mut ::std::string::String {
        if self.ticket_data.is_none() {
            self.ticket_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ticket_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket_data(&mut self) -> ::std::string::String {
        self.ticket_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_version = 4;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional bool prime_only = 6;

    pub fn prime_only(&self) -> bool {
        self.prime_only.unwrap_or(false)
    }

    pub fn clear_prime_only(&mut self) {
        self.prime_only = ::std::option::Option::None;
    }

    pub fn has_prime_only(&self) -> bool {
        self.prime_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prime_only(&mut self, v: bool) {
        self.prime_only = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_control = 7;

    pub fn tv_control(&self) -> u32 {
        self.tv_control.unwrap_or(0)
    }

    pub fn clear_tv_control(&mut self) {
        self.tv_control = ::std::option::Option::None;
    }

    pub fn has_tv_control(&self) -> bool {
        self.tv_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_control(&mut self, v: u32) {
        self.tv_control = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 8;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.account_ids },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.game_type },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket_data",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.ticket_data },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.ticket_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.client_version },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TournamentMatchSetup>(
            "tournament_match",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.tournament_match },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.tournament_match },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prime_only",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.prime_only },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.prime_only },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_control",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.tv_control },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.tv_control },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobby_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.lobby_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.lobby_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingStart>(
            "CMsgGCCStrike15_v2_MatchmakingStart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingStart {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                16 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.ticket_data = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tournament_match)?;
                },
                48 => {
                    self.prime_only = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.tv_control = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ticket_data.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tournament_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.prime_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.tv_control {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.game_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ticket_data.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tournament_match.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.prime_only {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.tv_control {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingStart {
        CMsgGCCStrike15_v2_MatchmakingStart::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.game_type = ::std::option::Option::None;
        self.ticket_data = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.tournament_match.clear();
        self.prime_only = ::std::option::Option::None;
        self.tv_control = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingStart {
        static instance: CMsgGCCStrike15_v2_MatchmakingStart = CMsgGCCStrike15_v2_MatchmakingStart {
            account_ids: ::std::vec::Vec::new(),
            game_type: ::std::option::Option::None,
            ticket_data: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            tournament_match: ::protobuf::MessageField::none(),
            prime_only: ::std::option::Option::None,
            tv_control: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingStart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingStart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingStart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingStop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingStop {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStop.abandon)
    pub abandon: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingStop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingStop {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingStop {
        <CMsgGCCStrike15_v2_MatchmakingStop as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingStop {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingStop {
        ::std::default::Default::default()
    }

    // optional int32 abandon = 1;

    pub fn abandon(&self) -> i32 {
        self.abandon.unwrap_or(0)
    }

    pub fn clear_abandon(&mut self) {
        self.abandon = ::std::option::Option::None;
    }

    pub fn has_abandon(&self) -> bool {
        self.abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandon(&mut self, v: i32) {
        self.abandon = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "abandon",
            |m: &CMsgGCCStrike15_v2_MatchmakingStop| { &m.abandon },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStop| { &mut m.abandon },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingStop>(
            "CMsgGCCStrike15_v2_MatchmakingStop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingStop {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingStop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.abandon = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.abandon {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.abandon {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingStop {
        CMsgGCCStrike15_v2_MatchmakingStop::new()
    }

    fn clear(&mut self) {
        self.abandon = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingStop {
        static instance: CMsgGCCStrike15_v2_MatchmakingStop = CMsgGCCStrike15_v2_MatchmakingStop {
            abandon: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingStop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingStop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingStop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note.type)
    pub type_: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note.region_id)
    pub region_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note.region_r)
    pub region_r: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note.distance)
    pub distance: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn type_(&self) -> i32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: i32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional int32 region_id = 2;

    pub fn region_id(&self) -> i32 {
        self.region_id.unwrap_or(0)
    }

    pub fn clear_region_id(&mut self) {
        self.region_id = ::std::option::Option::None;
    }

    pub fn has_region_id(&self) -> bool {
        self.region_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: i32) {
        self.region_id = ::std::option::Option::Some(v);
    }

    // optional float region_r = 3;

    pub fn region_r(&self) -> f32 {
        self.region_r.unwrap_or(0.)
    }

    pub fn clear_region_r(&mut self) {
        self.region_r = ::std::option::Option::None;
    }

    pub fn has_region_r(&self) -> bool {
        self.region_r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_r(&mut self, v: f32) {
        self.region_r = ::std::option::Option::Some(v);
    }

    // optional float distance = 4;

    pub fn distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &m.type_ },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &m.region_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &mut m.region_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "region_r",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &m.region_r },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &mut m.region_r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "distance",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &m.distance },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note| { &mut m.distance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.region_id = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.region_r = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.distance = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.region_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.region_r {
            my_size += 1 + 4;
        }
        if let Some(v) = self.distance {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.region_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.region_r {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.distance {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.region_id = ::std::option::Option::None;
        self.region_r = ::std::option::Option::None;
        self.distance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note = CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
            type_: ::std::option::Option::None,
            region_id: ::std::option::Option::None,
            region_r: ::std::option::Option::None,
            distance: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.gameserverpings)
    pub gameserverpings: ::std::vec::Vec<GameServerPing>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.offset_index)
    pub offset_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.final_batch)
    pub final_batch: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.data_center_pings)
    pub data_center_pings: ::std::vec::Vec<DataCenterPing>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.max_ping)
    pub max_ping: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.test_token)
    pub test_token: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.search_key)
    pub search_key: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.notes)
    pub notes: ::std::vec::Vec<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.debug_message)
    pub debug_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        <CMsgGCCStrike15_v2_MatchmakingClient2ServerPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        ::std::default::Default::default()
    }

    // optional int32 offset_index = 2;

    pub fn offset_index(&self) -> i32 {
        self.offset_index.unwrap_or(0)
    }

    pub fn clear_offset_index(&mut self) {
        self.offset_index = ::std::option::Option::None;
    }

    pub fn has_offset_index(&self) -> bool {
        self.offset_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset_index(&mut self, v: i32) {
        self.offset_index = ::std::option::Option::Some(v);
    }

    // optional int32 final_batch = 3;

    pub fn final_batch(&self) -> i32 {
        self.final_batch.unwrap_or(0)
    }

    pub fn clear_final_batch(&mut self) {
        self.final_batch = ::std::option::Option::None;
    }

    pub fn has_final_batch(&self) -> bool {
        self.final_batch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_final_batch(&mut self, v: i32) {
        self.final_batch = ::std::option::Option::Some(v);
    }

    // optional uint32 max_ping = 5;

    pub fn max_ping(&self) -> u32 {
        self.max_ping.unwrap_or(0)
    }

    pub fn clear_max_ping(&mut self) {
        self.max_ping = ::std::option::Option::None;
    }

    pub fn has_max_ping(&self) -> bool {
        self.max_ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_ping(&mut self, v: u32) {
        self.max_ping = ::std::option::Option::Some(v);
    }

    // optional fixed32 test_token = 6;

    pub fn test_token(&self) -> u32 {
        self.test_token.unwrap_or(0)
    }

    pub fn clear_test_token(&mut self) {
        self.test_token = ::std::option::Option::None;
    }

    pub fn has_test_token(&self) -> bool {
        self.test_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_token(&mut self, v: u32) {
        self.test_token = ::std::option::Option::Some(v);
    }

    // optional bytes search_key = 7;

    pub fn search_key(&self) -> &[u8] {
        match self.search_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_search_key(&mut self) {
        self.search_key = ::std::option::Option::None;
    }

    pub fn has_search_key(&self) -> bool {
        self.search_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.search_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.search_key.is_none() {
            self.search_key = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.search_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_key(&mut self) -> ::std::vec::Vec<u8> {
        self.search_key.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string debug_message = 9;

    pub fn debug_message(&self) -> &str {
        match self.debug_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_message(&mut self) {
        self.debug_message = ::std::option::Option::None;
    }

    pub fn has_debug_message(&self) -> bool {
        self.debug_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_message(&mut self, v: ::std::string::String) {
        self.debug_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_message(&mut self) -> &mut ::std::string::String {
        if self.debug_message.is_none() {
            self.debug_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_message(&mut self) -> ::std::string::String {
        self.debug_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gameserverpings",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.gameserverpings },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.gameserverpings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset_index",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.offset_index },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.offset_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "final_batch",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.final_batch },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.final_batch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_center_pings",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.data_center_pings },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.data_center_pings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_ping",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.max_ping },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.max_ping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "test_token",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.test_token },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.test_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_key",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.search_key },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.search_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notes",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.notes },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "debug_message",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.debug_message },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.debug_message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingClient2ServerPing>(
            "CMsgGCCStrike15_v2_MatchmakingClient2ServerPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingClient2ServerPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gameserverpings.push(is.read_message()?);
                },
                16 => {
                    self.offset_index = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.final_batch = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.data_center_pings.push(is.read_message()?);
                },
                40 => {
                    self.max_ping = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.test_token = ::std::option::Option::Some(is.read_fixed32()?);
                },
                58 => {
                    self.search_key = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.notes.push(is.read_message()?);
                },
                74 => {
                    self.debug_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.gameserverpings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.offset_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.final_batch {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        for value in &self.data_center_pings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.max_ping {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.test_token {
            my_size += 1 + 4;
        }
        if let Some(v) = self.search_key.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        for value in &self.notes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.debug_message.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.gameserverpings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.offset_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.final_batch {
            os.write_int32(3, v)?;
        }
        for v in &self.data_center_pings {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.max_ping {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.test_token {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.search_key.as_ref() {
            os.write_bytes(7, v)?;
        }
        for v in &self.notes {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.debug_message.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::new()
    }

    fn clear(&mut self) {
        self.gameserverpings.clear();
        self.offset_index = ::std::option::Option::None;
        self.final_batch = ::std::option::Option::None;
        self.data_center_pings.clear();
        self.max_ping = ::std::option::Option::None;
        self.test_token = ::std::option::Option::None;
        self.search_key = ::std::option::Option::None;
        self.notes.clear();
        self.debug_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        static instance: CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
            gameserverpings: ::std::vec::Vec::new(),
            offset_index: ::std::option::Option::None,
            final_batch: ::std::option::Option::None,
            data_center_pings: ::std::vec::Vec::new(),
            max_ping: ::std::option::Option::None,
            test_token: ::std::option::Option::None,
            search_key: ::std::option::Option::None,
            notes: ::std::vec::Vec::new(),
            debug_message: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingClient2ServerPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.matchmaking)
    pub matchmaking: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.waiting_account_id_sessions)
    pub waiting_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.error)
    pub error: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.ongoingmatch_account_id_sessions)
    pub ongoingmatch_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.global_stats)
    pub global_stats: ::protobuf::MessageField<GlobalStatistics>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.failping_account_id_sessions)
    pub failping_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.penalty_account_id_sessions)
    pub penalty_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.failready_account_id_sessions)
    pub failready_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.vacbanned_account_id_sessions)
    pub vacbanned_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.server_ipaddress_mask)
    pub server_ipaddress_mask: ::protobuf::MessageField<IpAddressMask>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.notes)
    pub notes: ::std::vec::Vec<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.penalty_account_id_sessions_green)
    pub penalty_account_id_sessions_green: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.insufficientlevel_sessions)
    pub insufficientlevel_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.vsncheck_account_id_sessions)
    pub vsncheck_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.launcher_mismatch_sessions)
    pub launcher_mismatch_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.insecure_account_id_sessions)
    pub insecure_account_id_sessions: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        ::std::default::Default::default()
    }

    // optional int32 matchmaking = 1;

    pub fn matchmaking(&self) -> i32 {
        self.matchmaking.unwrap_or(0)
    }

    pub fn clear_matchmaking(&mut self) {
        self.matchmaking = ::std::option::Option::None;
    }

    pub fn has_matchmaking(&self) -> bool {
        self.matchmaking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking(&mut self, v: i32) {
        self.matchmaking = ::std::option::Option::Some(v);
    }

    // optional string error = 3;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.matchmaking },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.matchmaking },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "waiting_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.waiting_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.waiting_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.error },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ongoingmatch_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.ongoingmatch_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.ongoingmatch_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GlobalStatistics>(
            "global_stats",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.global_stats },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.global_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failping_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.failping_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.failping_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "penalty_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.penalty_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.penalty_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failready_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.failready_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.failready_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vacbanned_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.vacbanned_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.vacbanned_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IpAddressMask>(
            "server_ipaddress_mask",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.server_ipaddress_mask },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.server_ipaddress_mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notes",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.notes },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "penalty_account_id_sessions_green",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.penalty_account_id_sessions_green },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.penalty_account_id_sessions_green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "insufficientlevel_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.insufficientlevel_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.insufficientlevel_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vsncheck_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.vsncheck_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.vsncheck_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "launcher_mismatch_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.launcher_mismatch_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.launcher_mismatch_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "insecure_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.insecure_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.insecure_account_id_sessions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.matchmaking = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.waiting_account_id_sessions)?;
                },
                16 => {
                    self.waiting_account_id_sessions.push(is.read_uint32()?);
                },
                26 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.ongoingmatch_account_id_sessions)?;
                },
                48 => {
                    self.ongoingmatch_account_id_sessions.push(is.read_uint32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.global_stats)?;
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.failping_account_id_sessions)?;
                },
                64 => {
                    self.failping_account_id_sessions.push(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.penalty_account_id_sessions)?;
                },
                72 => {
                    self.penalty_account_id_sessions.push(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.failready_account_id_sessions)?;
                },
                80 => {
                    self.failready_account_id_sessions.push(is.read_uint32()?);
                },
                90 => {
                    is.read_repeated_packed_uint32_into(&mut self.vacbanned_account_id_sessions)?;
                },
                88 => {
                    self.vacbanned_account_id_sessions.push(is.read_uint32()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_ipaddress_mask)?;
                },
                106 => {
                    self.notes.push(is.read_message()?);
                },
                114 => {
                    is.read_repeated_packed_uint32_into(&mut self.penalty_account_id_sessions_green)?;
                },
                112 => {
                    self.penalty_account_id_sessions_green.push(is.read_uint32()?);
                },
                122 => {
                    is.read_repeated_packed_uint32_into(&mut self.insufficientlevel_sessions)?;
                },
                120 => {
                    self.insufficientlevel_sessions.push(is.read_uint32()?);
                },
                130 => {
                    is.read_repeated_packed_uint32_into(&mut self.vsncheck_account_id_sessions)?;
                },
                128 => {
                    self.vsncheck_account_id_sessions.push(is.read_uint32()?);
                },
                138 => {
                    is.read_repeated_packed_uint32_into(&mut self.launcher_mismatch_sessions)?;
                },
                136 => {
                    self.launcher_mismatch_sessions.push(is.read_uint32()?);
                },
                146 => {
                    is.read_repeated_packed_uint32_into(&mut self.insecure_account_id_sessions)?;
                },
                144 => {
                    self.insecure_account_id_sessions.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matchmaking {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.waiting_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.ongoingmatch_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        if let Some(v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.failping_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        for value in &self.penalty_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        for value in &self.failready_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        for value in &self.vacbanned_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(11, *value);
        };
        if let Some(v) = self.server_ipaddress_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.notes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.penalty_account_id_sessions_green {
            my_size += ::protobuf::rt::uint32_size(14, *value);
        };
        for value in &self.insufficientlevel_sessions {
            my_size += ::protobuf::rt::uint32_size(15, *value);
        };
        for value in &self.vsncheck_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(16, *value);
        };
        for value in &self.launcher_mismatch_sessions {
            my_size += ::protobuf::rt::uint32_size(17, *value);
        };
        for value in &self.insecure_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(18, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matchmaking {
            os.write_int32(1, v)?;
        }
        for v in &self.waiting_account_id_sessions {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.error.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.ongoingmatch_account_id_sessions {
            os.write_uint32(6, *v)?;
        };
        if let Some(v) = self.global_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.failping_account_id_sessions {
            os.write_uint32(8, *v)?;
        };
        for v in &self.penalty_account_id_sessions {
            os.write_uint32(9, *v)?;
        };
        for v in &self.failready_account_id_sessions {
            os.write_uint32(10, *v)?;
        };
        for v in &self.vacbanned_account_id_sessions {
            os.write_uint32(11, *v)?;
        };
        if let Some(v) = self.server_ipaddress_mask.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.notes {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.penalty_account_id_sessions_green {
            os.write_uint32(14, *v)?;
        };
        for v in &self.insufficientlevel_sessions {
            os.write_uint32(15, *v)?;
        };
        for v in &self.vsncheck_account_id_sessions {
            os.write_uint32(16, *v)?;
        };
        for v in &self.launcher_mismatch_sessions {
            os.write_uint32(17, *v)?;
        };
        for v in &self.insecure_account_id_sessions {
            os.write_uint32(18, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::new()
    }

    fn clear(&mut self) {
        self.matchmaking = ::std::option::Option::None;
        self.waiting_account_id_sessions.clear();
        self.error = ::std::option::Option::None;
        self.ongoingmatch_account_id_sessions.clear();
        self.global_stats.clear();
        self.failping_account_id_sessions.clear();
        self.penalty_account_id_sessions.clear();
        self.failready_account_id_sessions.clear();
        self.vacbanned_account_id_sessions.clear();
        self.server_ipaddress_mask.clear();
        self.notes.clear();
        self.penalty_account_id_sessions_green.clear();
        self.insufficientlevel_sessions.clear();
        self.vsncheck_account_id_sessions.clear();
        self.launcher_mismatch_sessions.clear();
        self.insecure_account_id_sessions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
            matchmaking: ::std::option::Option::None,
            waiting_account_id_sessions: ::std::vec::Vec::new(),
            error: ::std::option::Option::None,
            ongoingmatch_account_id_sessions: ::std::vec::Vec::new(),
            global_stats: ::protobuf::MessageField::none(),
            failping_account_id_sessions: ::std::vec::Vec::new(),
            penalty_account_id_sessions: ::std::vec::Vec::new(),
            failready_account_id_sessions: ::std::vec::Vec::new(),
            vacbanned_account_id_sessions: ::std::vec::Vec::new(),
            server_ipaddress_mask: ::protobuf::MessageField::none(),
            notes: ::std::vec::Vec::new(),
            penalty_account_id_sessions_green: ::std::vec::Vec::new(),
            insufficientlevel_sessions: ::std::vec::Vec::new(),
            vsncheck_account_id_sessions: ::std::vec::Vec::new(),
            launcher_mismatch_sessions: ::std::vec::Vec::new(),
            insecure_account_id_sessions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentMatchDraft)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDataGCCStrike15_v2_TournamentMatchDraft {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.event_id)
    pub event_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.event_stage_id)
    pub event_stage_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.team_id_0)
    pub team_id_0: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.team_id_1)
    pub team_id_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.maps_count)
    pub maps_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.maps_current)
    pub maps_current: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.team_id_start)
    pub team_id_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.team_id_veto1)
    pub team_id_veto1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.team_id_pickn)
    pub team_id_pickn: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.drafts)
    pub drafts: ::std::vec::Vec<cdata_gccstrike15_v2_tournament_match_draft::Entry>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.vote_mapid_0)
    pub vote_mapid_0: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.vote_mapid_1)
    pub vote_mapid_1: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.vote_mapid_2)
    pub vote_mapid_2: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.vote_mapid_3)
    pub vote_mapid_3: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.vote_mapid_4)
    pub vote_mapid_4: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.vote_mapid_5)
    pub vote_mapid_5: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.vote_starting_side)
    pub vote_starting_side: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.vote_phase)
    pub vote_phase: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.vote_phase_start)
    pub vote_phase_start: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.vote_phase_length)
    pub vote_phase_length: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentMatchDraft.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentMatchDraft {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentMatchDraft {
        <CDataGCCStrike15_v2_TournamentMatchDraft as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentMatchDraft {
    pub fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft {
        ::std::default::Default::default()
    }

    // optional int32 event_id = 1;

    pub fn event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional int32 event_stage_id = 2;

    pub fn event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }

    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_0 = 3;

    pub fn team_id_0(&self) -> i32 {
        self.team_id_0.unwrap_or(0)
    }

    pub fn clear_team_id_0(&mut self) {
        self.team_id_0 = ::std::option::Option::None;
    }

    pub fn has_team_id_0(&self) -> bool {
        self.team_id_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_0(&mut self, v: i32) {
        self.team_id_0 = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_1 = 4;

    pub fn team_id_1(&self) -> i32 {
        self.team_id_1.unwrap_or(0)
    }

    pub fn clear_team_id_1(&mut self) {
        self.team_id_1 = ::std::option::Option::None;
    }

    pub fn has_team_id_1(&self) -> bool {
        self.team_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_1(&mut self, v: i32) {
        self.team_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 maps_count = 5;

    pub fn maps_count(&self) -> i32 {
        self.maps_count.unwrap_or(0)
    }

    pub fn clear_maps_count(&mut self) {
        self.maps_count = ::std::option::Option::None;
    }

    pub fn has_maps_count(&self) -> bool {
        self.maps_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maps_count(&mut self, v: i32) {
        self.maps_count = ::std::option::Option::Some(v);
    }

    // optional int32 maps_current = 6;

    pub fn maps_current(&self) -> i32 {
        self.maps_current.unwrap_or(0)
    }

    pub fn clear_maps_current(&mut self) {
        self.maps_current = ::std::option::Option::None;
    }

    pub fn has_maps_current(&self) -> bool {
        self.maps_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maps_current(&mut self, v: i32) {
        self.maps_current = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_start = 7;

    pub fn team_id_start(&self) -> i32 {
        self.team_id_start.unwrap_or(0)
    }

    pub fn clear_team_id_start(&mut self) {
        self.team_id_start = ::std::option::Option::None;
    }

    pub fn has_team_id_start(&self) -> bool {
        self.team_id_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_start(&mut self, v: i32) {
        self.team_id_start = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_veto1 = 8;

    pub fn team_id_veto1(&self) -> i32 {
        self.team_id_veto1.unwrap_or(0)
    }

    pub fn clear_team_id_veto1(&mut self) {
        self.team_id_veto1 = ::std::option::Option::None;
    }

    pub fn has_team_id_veto1(&self) -> bool {
        self.team_id_veto1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_veto1(&mut self, v: i32) {
        self.team_id_veto1 = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_pickn = 9;

    pub fn team_id_pickn(&self) -> i32 {
        self.team_id_pickn.unwrap_or(0)
    }

    pub fn clear_team_id_pickn(&mut self) {
        self.team_id_pickn = ::std::option::Option::None;
    }

    pub fn has_team_id_pickn(&self) -> bool {
        self.team_id_pickn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_pickn(&mut self, v: i32) {
        self.team_id_pickn = ::std::option::Option::Some(v);
    }

    // optional int32 vote_phase = 18;

    pub fn vote_phase(&self) -> i32 {
        self.vote_phase.unwrap_or(0)
    }

    pub fn clear_vote_phase(&mut self) {
        self.vote_phase = ::std::option::Option::None;
    }

    pub fn has_vote_phase(&self) -> bool {
        self.vote_phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_phase(&mut self, v: i32) {
        self.vote_phase = ::std::option::Option::Some(v);
    }

    // optional float vote_phase_start = 19;

    pub fn vote_phase_start(&self) -> f32 {
        self.vote_phase_start.unwrap_or(0.)
    }

    pub fn clear_vote_phase_start(&mut self) {
        self.vote_phase_start = ::std::option::Option::None;
    }

    pub fn has_vote_phase_start(&self) -> bool {
        self.vote_phase_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_phase_start(&mut self, v: f32) {
        self.vote_phase_start = ::std::option::Option::Some(v);
    }

    // optional float vote_phase_length = 20;

    pub fn vote_phase_length(&self) -> f32 {
        self.vote_phase_length.unwrap_or(0.)
    }

    pub fn clear_vote_phase_length(&mut self) {
        self.vote_phase_length = ::std::option::Option::None;
    }

    pub fn has_vote_phase_length(&self) -> bool {
        self.vote_phase_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_phase_length(&mut self, v: f32) {
        self.vote_phase_length = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.event_id },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_stage_id",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.event_stage_id },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.event_stage_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_0",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_0 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_1",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_1 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maps_count",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.maps_count },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.maps_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maps_current",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.maps_current },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.maps_current },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_start",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_start },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_veto1",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_veto1 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_veto1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_pickn",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_pickn },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_pickn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "drafts",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.drafts },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.drafts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vote_mapid_0",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.vote_mapid_0 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.vote_mapid_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vote_mapid_1",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.vote_mapid_1 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.vote_mapid_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vote_mapid_2",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.vote_mapid_2 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.vote_mapid_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vote_mapid_3",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.vote_mapid_3 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.vote_mapid_3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vote_mapid_4",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.vote_mapid_4 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.vote_mapid_4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vote_mapid_5",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.vote_mapid_5 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.vote_mapid_5 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vote_starting_side",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.vote_starting_side },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.vote_starting_side },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote_phase",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.vote_phase },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.vote_phase },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote_phase_start",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.vote_phase_start },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.vote_phase_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote_phase_length",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.vote_phase_length },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.vote_phase_length },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_TournamentMatchDraft>(
            "CDataGCCStrike15_v2_TournamentMatchDraft",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentMatchDraft {
    const NAME: &'static str = "CDataGCCStrike15_v2_TournamentMatchDraft";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.event_stage_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.team_id_0 = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.team_id_1 = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.maps_count = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.maps_current = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.team_id_start = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.team_id_veto1 = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.team_id_pickn = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.drafts.push(is.read_message()?);
                },
                90 => {
                    is.read_repeated_packed_int32_into(&mut self.vote_mapid_0)?;
                },
                88 => {
                    self.vote_mapid_0.push(is.read_int32()?);
                },
                98 => {
                    is.read_repeated_packed_int32_into(&mut self.vote_mapid_1)?;
                },
                96 => {
                    self.vote_mapid_1.push(is.read_int32()?);
                },
                106 => {
                    is.read_repeated_packed_int32_into(&mut self.vote_mapid_2)?;
                },
                104 => {
                    self.vote_mapid_2.push(is.read_int32()?);
                },
                114 => {
                    is.read_repeated_packed_int32_into(&mut self.vote_mapid_3)?;
                },
                112 => {
                    self.vote_mapid_3.push(is.read_int32()?);
                },
                122 => {
                    is.read_repeated_packed_int32_into(&mut self.vote_mapid_4)?;
                },
                120 => {
                    self.vote_mapid_4.push(is.read_int32()?);
                },
                130 => {
                    is.read_repeated_packed_int32_into(&mut self.vote_mapid_5)?;
                },
                128 => {
                    self.vote_mapid_5.push(is.read_int32()?);
                },
                138 => {
                    is.read_repeated_packed_int32_into(&mut self.vote_starting_side)?;
                },
                136 => {
                    self.vote_starting_side.push(is.read_int32()?);
                },
                144 => {
                    self.vote_phase = ::std::option::Option::Some(is.read_int32()?);
                },
                157 => {
                    self.vote_phase_start = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.vote_phase_length = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.team_id_0 {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.team_id_1 {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.maps_count {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.maps_current {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.team_id_start {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.team_id_veto1 {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.team_id_pickn {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.drafts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.vote_mapid_0 {
            my_size += ::protobuf::rt::int32_size(11, *value);
        };
        for value in &self.vote_mapid_1 {
            my_size += ::protobuf::rt::int32_size(12, *value);
        };
        for value in &self.vote_mapid_2 {
            my_size += ::protobuf::rt::int32_size(13, *value);
        };
        for value in &self.vote_mapid_3 {
            my_size += ::protobuf::rt::int32_size(14, *value);
        };
        for value in &self.vote_mapid_4 {
            my_size += ::protobuf::rt::int32_size(15, *value);
        };
        for value in &self.vote_mapid_5 {
            my_size += ::protobuf::rt::int32_size(16, *value);
        };
        for value in &self.vote_starting_side {
            my_size += ::protobuf::rt::int32_size(17, *value);
        };
        if let Some(v) = self.vote_phase {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        if let Some(v) = self.vote_phase_start {
            my_size += 2 + 4;
        }
        if let Some(v) = self.vote_phase_length {
            my_size += 2 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team_id_0 {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.team_id_1 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.maps_count {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.maps_current {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.team_id_start {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.team_id_veto1 {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.team_id_pickn {
            os.write_int32(9, v)?;
        }
        for v in &self.drafts {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.vote_mapid_0 {
            os.write_int32(11, *v)?;
        };
        for v in &self.vote_mapid_1 {
            os.write_int32(12, *v)?;
        };
        for v in &self.vote_mapid_2 {
            os.write_int32(13, *v)?;
        };
        for v in &self.vote_mapid_3 {
            os.write_int32(14, *v)?;
        };
        for v in &self.vote_mapid_4 {
            os.write_int32(15, *v)?;
        };
        for v in &self.vote_mapid_5 {
            os.write_int32(16, *v)?;
        };
        for v in &self.vote_starting_side {
            os.write_int32(17, *v)?;
        };
        if let Some(v) = self.vote_phase {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.vote_phase_start {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.vote_phase_length {
            os.write_float(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft {
        CDataGCCStrike15_v2_TournamentMatchDraft::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.event_stage_id = ::std::option::Option::None;
        self.team_id_0 = ::std::option::Option::None;
        self.team_id_1 = ::std::option::Option::None;
        self.maps_count = ::std::option::Option::None;
        self.maps_current = ::std::option::Option::None;
        self.team_id_start = ::std::option::Option::None;
        self.team_id_veto1 = ::std::option::Option::None;
        self.team_id_pickn = ::std::option::Option::None;
        self.drafts.clear();
        self.vote_mapid_0.clear();
        self.vote_mapid_1.clear();
        self.vote_mapid_2.clear();
        self.vote_mapid_3.clear();
        self.vote_mapid_4.clear();
        self.vote_mapid_5.clear();
        self.vote_starting_side.clear();
        self.vote_phase = ::std::option::Option::None;
        self.vote_phase_start = ::std::option::Option::None;
        self.vote_phase_length = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentMatchDraft {
        static instance: CDataGCCStrike15_v2_TournamentMatchDraft = CDataGCCStrike15_v2_TournamentMatchDraft {
            event_id: ::std::option::Option::None,
            event_stage_id: ::std::option::Option::None,
            team_id_0: ::std::option::Option::None,
            team_id_1: ::std::option::Option::None,
            maps_count: ::std::option::Option::None,
            maps_current: ::std::option::Option::None,
            team_id_start: ::std::option::Option::None,
            team_id_veto1: ::std::option::Option::None,
            team_id_pickn: ::std::option::Option::None,
            drafts: ::std::vec::Vec::new(),
            vote_mapid_0: ::std::vec::Vec::new(),
            vote_mapid_1: ::std::vec::Vec::new(),
            vote_mapid_2: ::std::vec::Vec::new(),
            vote_mapid_3: ::std::vec::Vec::new(),
            vote_mapid_4: ::std::vec::Vec::new(),
            vote_mapid_5: ::std::vec::Vec::new(),
            vote_starting_side: ::std::vec::Vec::new(),
            vote_phase: ::std::option::Option::None,
            vote_phase_start: ::std::option::Option::None,
            vote_phase_length: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentMatchDraft").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentMatchDraft {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDataGCCStrike15_v2_TournamentMatchDraft`
pub mod cdata_gccstrike15_v2_tournament_match_draft {
    // @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentMatchDraft.Entry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.Entry.mapid)
        pub mapid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.Entry.team_id_ct)
        pub team_id_ct: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentMatchDraft.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        // optional int32 mapid = 1;

        pub fn mapid(&self) -> i32 {
            self.mapid.unwrap_or(0)
        }

        pub fn clear_mapid(&mut self) {
            self.mapid = ::std::option::Option::None;
        }

        pub fn has_mapid(&self) -> bool {
            self.mapid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mapid(&mut self, v: i32) {
            self.mapid = ::std::option::Option::Some(v);
        }

        // optional int32 team_id_ct = 2;

        pub fn team_id_ct(&self) -> i32 {
            self.team_id_ct.unwrap_or(0)
        }

        pub fn clear_team_id_ct(&mut self) {
            self.team_id_ct = ::std::option::Option::None;
        }

        pub fn has_team_id_ct(&self) -> bool {
            self.team_id_ct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_ct(&mut self, v: i32) {
            self.team_id_ct = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mapid",
                |m: &Entry| { &m.mapid },
                |m: &mut Entry| { &mut m.mapid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id_ct",
                |m: &Entry| { &m.team_id_ct },
                |m: &mut Entry| { &mut m.team_id_ct },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "CDataGCCStrike15_v2_TournamentMatchDraft.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.mapid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.team_id_ct = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.mapid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.team_id_ct {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.mapid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.team_id_ct {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.mapid = ::std::option::Option::None;
            self.team_id_ct = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                mapid: ::std::option::Option::None,
                team_id_ct: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentMatchDraft.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CPreMatchInfoData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CPreMatchInfoData {
    // message fields
    // @@protoc_insertion_point(field:CPreMatchInfoData.predictions_pct)
    pub predictions_pct: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPreMatchInfoData.draft)
    pub draft: ::protobuf::MessageField<CDataGCCStrike15_v2_TournamentMatchDraft>,
    // @@protoc_insertion_point(field:CPreMatchInfoData.stats)
    pub stats: ::std::vec::Vec<cpre_match_info_data::TeamStats>,
    // @@protoc_insertion_point(field:CPreMatchInfoData.wins)
    pub wins: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CPreMatchInfoData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPreMatchInfoData {
    fn default() -> &'a CPreMatchInfoData {
        <CPreMatchInfoData as ::protobuf::Message>::default_instance()
    }
}

impl CPreMatchInfoData {
    pub fn new() -> CPreMatchInfoData {
        ::std::default::Default::default()
    }

    // optional int32 predictions_pct = 1;

    pub fn predictions_pct(&self) -> i32 {
        self.predictions_pct.unwrap_or(0)
    }

    pub fn clear_predictions_pct(&mut self) {
        self.predictions_pct = ::std::option::Option::None;
    }

    pub fn has_predictions_pct(&self) -> bool {
        self.predictions_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predictions_pct(&mut self, v: i32) {
        self.predictions_pct = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "predictions_pct",
            |m: &CPreMatchInfoData| { &m.predictions_pct },
            |m: &mut CPreMatchInfoData| { &mut m.predictions_pct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDataGCCStrike15_v2_TournamentMatchDraft>(
            "draft",
            |m: &CPreMatchInfoData| { &m.draft },
            |m: &mut CPreMatchInfoData| { &mut m.draft },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CPreMatchInfoData| { &m.stats },
            |m: &mut CPreMatchInfoData| { &mut m.stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "wins",
            |m: &CPreMatchInfoData| { &m.wins },
            |m: &mut CPreMatchInfoData| { &mut m.wins },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CPreMatchInfoData>(
            "CPreMatchInfoData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CPreMatchInfoData {
    const NAME: &'static str = "CPreMatchInfoData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.predictions_pct = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.draft)?;
                },
                42 => {
                    self.stats.push(is.read_message()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.wins)?;
                },
                48 => {
                    self.wins.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.predictions_pct {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.draft.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.wins {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.predictions_pct {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.draft.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.wins {
            os.write_int32(6, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPreMatchInfoData {
        CPreMatchInfoData::new()
    }

    fn clear(&mut self) {
        self.predictions_pct = ::std::option::Option::None;
        self.draft.clear();
        self.stats.clear();
        self.wins.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPreMatchInfoData {
        static instance: CPreMatchInfoData = CPreMatchInfoData {
            predictions_pct: ::std::option::Option::None,
            draft: ::protobuf::MessageField::none(),
            stats: ::std::vec::Vec::new(),
            wins: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CPreMatchInfoData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CPreMatchInfoData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CPreMatchInfoData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPreMatchInfoData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CPreMatchInfoData`
pub mod cpre_match_info_data {
    // @@protoc_insertion_point(message:CPreMatchInfoData.TeamStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamStats {
        // message fields
        // @@protoc_insertion_point(field:CPreMatchInfoData.TeamStats.match_info_idxtxt)
        pub match_info_idxtxt: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CPreMatchInfoData.TeamStats.match_info_txt)
        pub match_info_txt: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CPreMatchInfoData.TeamStats.match_info_teams)
        pub match_info_teams: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CPreMatchInfoData.TeamStats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamStats {
        fn default() -> &'a TeamStats {
            <TeamStats as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamStats {
        pub fn new() -> TeamStats {
            ::std::default::Default::default()
        }

        // optional int32 match_info_idxtxt = 1;

        pub fn match_info_idxtxt(&self) -> i32 {
            self.match_info_idxtxt.unwrap_or(0)
        }

        pub fn clear_match_info_idxtxt(&mut self) {
            self.match_info_idxtxt = ::std::option::Option::None;
        }

        pub fn has_match_info_idxtxt(&self) -> bool {
            self.match_info_idxtxt.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_info_idxtxt(&mut self, v: i32) {
            self.match_info_idxtxt = ::std::option::Option::Some(v);
        }

        // optional string match_info_txt = 2;

        pub fn match_info_txt(&self) -> &str {
            match self.match_info_txt.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_match_info_txt(&mut self) {
            self.match_info_txt = ::std::option::Option::None;
        }

        pub fn has_match_info_txt(&self) -> bool {
            self.match_info_txt.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_info_txt(&mut self, v: ::std::string::String) {
            self.match_info_txt = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_match_info_txt(&mut self) -> &mut ::std::string::String {
            if self.match_info_txt.is_none() {
                self.match_info_txt = ::std::option::Option::Some(::std::string::String::new());
            }
            self.match_info_txt.as_mut().unwrap()
        }

        // Take field
        pub fn take_match_info_txt(&mut self) -> ::std::string::String {
            self.match_info_txt.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_info_idxtxt",
                |m: &TeamStats| { &m.match_info_idxtxt },
                |m: &mut TeamStats| { &mut m.match_info_idxtxt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_info_txt",
                |m: &TeamStats| { &m.match_info_txt },
                |m: &mut TeamStats| { &mut m.match_info_txt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "match_info_teams",
                |m: &TeamStats| { &m.match_info_teams },
                |m: &mut TeamStats| { &mut m.match_info_teams },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamStats>(
                "CPreMatchInfoData.TeamStats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamStats {
        const NAME: &'static str = "TeamStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_info_idxtxt = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.match_info_txt = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.match_info_teams.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_info_idxtxt {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.match_info_txt.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            for value in &self.match_info_teams {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.match_info_idxtxt {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.match_info_txt.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.match_info_teams {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamStats {
            TeamStats::new()
        }

        fn clear(&mut self) {
            self.match_info_idxtxt = ::std::option::Option::None;
            self.match_info_txt = ::std::option::Option::None;
            self.match_info_teams.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamStats {
            static instance: TeamStats = TeamStats {
                match_info_idxtxt: ::std::option::Option::None,
                match_info_txt: ::std::option::Option::None,
                match_info_teams: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamStats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CPreMatchInfoData.TeamStats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamStats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamStats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.rankings)
    pub rankings: ::std::vec::Vec<PlayerRankingInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.encryption_key)
    pub encryption_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.encryption_key_pub)
    pub encryption_key_pub: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.party_ids)
    pub party_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.whitelist)
    pub whitelist: ::std::vec::Vec<IpAddressMask>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tv_master_steamid)
    pub tv_master_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tournament_event)
    pub tournament_event: ::protobuf::MessageField<TournamentEvent>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tournament_teams)
    pub tournament_teams: ::std::vec::Vec<TournamentTeam>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tournament_casters_account_ids)
    pub tournament_casters_account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tv_relay_steamid)
    pub tv_relay_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.pre_match_data)
    pub pre_match_data: ::protobuf::MessageField<CPreMatchInfoData>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.rtime32_event_start)
    pub rtime32_event_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tv_control)
    pub tv_control: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.op_var_values)
    pub op_var_values: ::std::vec::Vec<OperationalVarValue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        <CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        ::std::default::Default::default()
    }

    // optional uint32 game_type = 2;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 3;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 4;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 18;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint64 encryption_key = 6;

    pub fn encryption_key(&self) -> u64 {
        self.encryption_key.unwrap_or(0)
    }

    pub fn clear_encryption_key(&mut self) {
        self.encryption_key = ::std::option::Option::None;
    }

    pub fn has_encryption_key(&self) -> bool {
        self.encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key(&mut self, v: u64) {
        self.encryption_key = ::std::option::Option::Some(v);
    }

    // optional uint64 encryption_key_pub = 7;

    pub fn encryption_key_pub(&self) -> u64 {
        self.encryption_key_pub.unwrap_or(0)
    }

    pub fn clear_encryption_key_pub(&mut self) {
        self.encryption_key_pub = ::std::option::Option::None;
    }

    pub fn has_encryption_key_pub(&self) -> bool {
        self.encryption_key_pub.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key_pub(&mut self, v: u64) {
        self.encryption_key_pub = ::std::option::Option::Some(v);
    }

    // optional uint64 tv_master_steamid = 10;

    pub fn tv_master_steamid(&self) -> u64 {
        self.tv_master_steamid.unwrap_or(0)
    }

    pub fn clear_tv_master_steamid(&mut self) {
        self.tv_master_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_master_steamid(&self) -> bool {
        self.tv_master_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_master_steamid(&mut self, v: u64) {
        self.tv_master_steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 tv_relay_steamid = 14;

    pub fn tv_relay_steamid(&self) -> u64 {
        self.tv_relay_steamid.unwrap_or(0)
    }

    pub fn clear_tv_relay_steamid(&mut self) {
        self.tv_relay_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_relay_steamid(&self) -> bool {
        self.tv_relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_steamid(&mut self, v: u64) {
        self.tv_relay_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_event_start = 16;

    pub fn rtime32_event_start(&self) -> u32 {
        self.rtime32_event_start.unwrap_or(0)
    }

    pub fn clear_rtime32_event_start(&mut self) {
        self.rtime32_event_start = ::std::option::Option::None;
    }

    pub fn has_rtime32_event_start(&self) -> bool {
        self.rtime32_event_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_event_start(&mut self, v: u32) {
        self.rtime32_event_start = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_control = 17;

    pub fn tv_control(&self) -> u32 {
        self.tv_control.unwrap_or(0)
    }

    pub fn clear_tv_control(&mut self) {
        self.tv_control = ::std::option::Option::None;
    }

    pub fn has_tv_control(&self) -> bool {
        self.tv_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_control(&mut self, v: u32) {
        self.tv_control = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.account_ids },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.game_type },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.server_version },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.server_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.flags },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rankings",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.rankings },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.rankings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encryption_key",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.encryption_key },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.encryption_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encryption_key_pub",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.encryption_key_pub },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.encryption_key_pub },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "party_ids",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.party_ids },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.party_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "whitelist",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.whitelist },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.whitelist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_master_steamid",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tv_master_steamid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tv_master_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TournamentEvent>(
            "tournament_event",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tournament_event },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tournament_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tournament_teams",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tournament_teams },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tournament_teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tournament_casters_account_ids",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tournament_casters_account_ids },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tournament_casters_account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_steamid",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tv_relay_steamid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tv_relay_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CPreMatchInfoData>(
            "pre_match_data",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.pre_match_data },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.pre_match_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_event_start",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.rtime32_event_start },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.rtime32_event_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_control",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tv_control },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tv_control },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "op_var_values",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.op_var_values },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.op_var_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                16 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.rankings.push(is.read_message()?);
                },
                48 => {
                    self.encryption_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.encryption_key_pub = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.party_ids)?;
                },
                64 => {
                    self.party_ids.push(is.read_uint32()?);
                },
                74 => {
                    self.whitelist.push(is.read_message()?);
                },
                80 => {
                    self.tv_master_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tournament_event)?;
                },
                98 => {
                    self.tournament_teams.push(is.read_message()?);
                },
                106 => {
                    is.read_repeated_packed_uint32_into(&mut self.tournament_casters_account_ids)?;
                },
                104 => {
                    self.tournament_casters_account_ids.push(is.read_uint32()?);
                },
                112 => {
                    self.tv_relay_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pre_match_data)?;
                },
                128 => {
                    self.rtime32_event_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.tv_control = ::std::option::Option::Some(is.read_uint32()?);
                },
                154 => {
                    self.op_var_values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.encryption_key {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.encryption_key_pub {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        for value in &self.party_ids {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        for value in &self.whitelist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tv_master_steamid {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.tournament_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tournament_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tournament_casters_account_ids {
            my_size += ::protobuf::rt::uint32_size(13, *value);
        };
        if let Some(v) = self.tv_relay_steamid {
            my_size += ::protobuf::rt::uint64_size(14, v);
        }
        if let Some(v) = self.pre_match_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rtime32_event_start {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.tv_control {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        for value in &self.op_var_values {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.game_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(18, v)?;
        }
        for v in &self.rankings {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.encryption_key {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.encryption_key_pub {
            os.write_uint64(7, v)?;
        }
        for v in &self.party_ids {
            os.write_uint32(8, *v)?;
        };
        for v in &self.whitelist {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.tv_master_steamid {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.tournament_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        for v in &self.tournament_teams {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.tournament_casters_account_ids {
            os.write_uint32(13, *v)?;
        };
        if let Some(v) = self.tv_relay_steamid {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.pre_match_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.rtime32_event_start {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.tv_control {
            os.write_uint32(17, v)?;
        }
        for v in &self.op_var_values {
            ::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.game_type = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.server_version = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.rankings.clear();
        self.encryption_key = ::std::option::Option::None;
        self.encryption_key_pub = ::std::option::Option::None;
        self.party_ids.clear();
        self.whitelist.clear();
        self.tv_master_steamid = ::std::option::Option::None;
        self.tournament_event.clear();
        self.tournament_teams.clear();
        self.tournament_casters_account_ids.clear();
        self.tv_relay_steamid = ::std::option::Option::None;
        self.pre_match_data.clear();
        self.rtime32_event_start = ::std::option::Option::None;
        self.tv_control = ::std::option::Option::None;
        self.op_var_values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
            account_ids: ::std::vec::Vec::new(),
            game_type: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            server_version: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            rankings: ::std::vec::Vec::new(),
            encryption_key: ::std::option::Option::None,
            encryption_key_pub: ::std::option::Option::None,
            party_ids: ::std::vec::Vec::new(),
            whitelist: ::std::vec::Vec::new(),
            tv_master_steamid: ::std::option::Option::None,
            tournament_event: ::protobuf::MessageField::none(),
            tournament_teams: ::std::vec::Vec::new(),
            tournament_casters_account_ids: ::std::vec::Vec::new(),
            tv_relay_steamid: ::std::option::Option::None,
            pre_match_data: ::protobuf::MessageField::none(),
            rtime32_event_start: ::std::option::Option::None,
            tv_control: ::std::option::Option::None,
            op_var_values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reservationid)
    pub reservationid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reservation)
    pub reservation: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.map)
    pub map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.gc_reservation_sent)
    pub gc_reservation_sent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.tv_info)
    pub tv_info: ::protobuf::MessageField<ServerHltvInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reward_player_accounts)
    pub reward_player_accounts: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.idle_player_accounts)
    pub idle_player_accounts: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reward_item_attr_def_idx)
    pub reward_item_attr_def_idx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reward_item_attr_value)
    pub reward_item_attr_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reward_item_attr_reward_idx)
    pub reward_item_attr_reward_idx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reward_drop_list)
    pub reward_drop_list: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.tournament_tag)
    pub tournament_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.legacy_steamdatagram_port)
    pub legacy_steamdatagram_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.steamdatagram_routing)
    pub steamdatagram_routing: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.test_token)
    pub test_token: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        <CMsgGCCStrike15_v2_MatchmakingServerReservationResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        ::std::default::Default::default()
    }

    // optional uint64 reservationid = 1;

    pub fn reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }

    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    // optional string map = 3;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 gc_reservation_sent = 4;

    pub fn gc_reservation_sent(&self) -> u64 {
        self.gc_reservation_sent.unwrap_or(0)
    }

    pub fn clear_gc_reservation_sent(&mut self) {
        self.gc_reservation_sent = ::std::option::Option::None;
    }

    pub fn has_gc_reservation_sent(&self) -> bool {
        self.gc_reservation_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_reservation_sent(&mut self, v: u64) {
        self.gc_reservation_sent = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 5;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_item_attr_def_idx = 9;

    pub fn reward_item_attr_def_idx(&self) -> u32 {
        self.reward_item_attr_def_idx.unwrap_or(0)
    }

    pub fn clear_reward_item_attr_def_idx(&mut self) {
        self.reward_item_attr_def_idx = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_def_idx(&self) -> bool {
        self.reward_item_attr_def_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_def_idx(&mut self, v: u32) {
        self.reward_item_attr_def_idx = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_item_attr_value = 10;

    pub fn reward_item_attr_value(&self) -> u32 {
        self.reward_item_attr_value.unwrap_or(0)
    }

    pub fn clear_reward_item_attr_value(&mut self) {
        self.reward_item_attr_value = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_value(&self) -> bool {
        self.reward_item_attr_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_value(&mut self, v: u32) {
        self.reward_item_attr_value = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_item_attr_reward_idx = 11;

    pub fn reward_item_attr_reward_idx(&self) -> u32 {
        self.reward_item_attr_reward_idx.unwrap_or(0)
    }

    pub fn clear_reward_item_attr_reward_idx(&mut self) {
        self.reward_item_attr_reward_idx = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_reward_idx(&self) -> bool {
        self.reward_item_attr_reward_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_reward_idx(&mut self, v: u32) {
        self.reward_item_attr_reward_idx = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_drop_list = 12;

    pub fn reward_drop_list(&self) -> u32 {
        self.reward_drop_list.unwrap_or(0)
    }

    pub fn clear_reward_drop_list(&mut self) {
        self.reward_drop_list = ::std::option::Option::None;
    }

    pub fn has_reward_drop_list(&self) -> bool {
        self.reward_drop_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_drop_list(&mut self, v: u32) {
        self.reward_drop_list = ::std::option::Option::Some(v);
    }

    // optional string tournament_tag = 13;

    pub fn tournament_tag(&self) -> &str {
        match self.tournament_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tournament_tag(&mut self) {
        self.tournament_tag = ::std::option::Option::None;
    }

    pub fn has_tournament_tag(&self) -> bool {
        self.tournament_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_tag(&mut self, v: ::std::string::String) {
        self.tournament_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_tag(&mut self) -> &mut ::std::string::String {
        if self.tournament_tag.is_none() {
            self.tournament_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tournament_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournament_tag(&mut self) -> ::std::string::String {
        self.tournament_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 legacy_steamdatagram_port = 14;

    pub fn legacy_steamdatagram_port(&self) -> u32 {
        self.legacy_steamdatagram_port.unwrap_or(0)
    }

    pub fn clear_legacy_steamdatagram_port(&mut self) {
        self.legacy_steamdatagram_port = ::std::option::Option::None;
    }

    pub fn has_legacy_steamdatagram_port(&self) -> bool {
        self.legacy_steamdatagram_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_steamdatagram_port(&mut self, v: u32) {
        self.legacy_steamdatagram_port = ::std::option::Option::Some(v);
    }

    // optional uint32 steamdatagram_routing = 17;

    pub fn steamdatagram_routing(&self) -> u32 {
        self.steamdatagram_routing.unwrap_or(0)
    }

    pub fn clear_steamdatagram_routing(&mut self) {
        self.steamdatagram_routing = ::std::option::Option::None;
    }

    pub fn has_steamdatagram_routing(&self) -> bool {
        self.steamdatagram_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamdatagram_routing(&mut self, v: u32) {
        self.steamdatagram_routing = ::std::option::Option::Some(v);
    }

    // optional fixed32 test_token = 15;

    pub fn test_token(&self) -> u32 {
        self.test_token.unwrap_or(0)
    }

    pub fn clear_test_token(&mut self) {
        self.test_token = ::std::option::Option::None;
    }

    pub fn has_test_token(&self) -> bool {
        self.test_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_token(&mut self, v: u32) {
        self.test_token = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 16;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservationid",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reservationid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reservationid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "reservation",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reservation },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reservation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.map },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gc_reservation_sent",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.gc_reservation_sent },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.gc_reservation_sent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.server_version },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.server_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServerHltvInfo>(
            "tv_info",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.tv_info },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.tv_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reward_player_accounts",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_player_accounts },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_player_accounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "idle_player_accounts",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.idle_player_accounts },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.idle_player_accounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_item_attr_def_idx",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_item_attr_def_idx },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_item_attr_def_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_item_attr_value",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_item_attr_value },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_item_attr_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_item_attr_reward_idx",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_item_attr_reward_idx },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_item_attr_reward_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_drop_list",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_drop_list },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_drop_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_tag",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.tournament_tag },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.tournament_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "legacy_steamdatagram_port",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.legacy_steamdatagram_port },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.legacy_steamdatagram_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamdatagram_routing",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.steamdatagram_routing },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.steamdatagram_routing },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "test_token",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.test_token },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.test_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.flags },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>(
            "CMsgGCCStrike15_v2_MatchmakingServerReservationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingServerReservationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reservationid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reservation)?;
                },
                26 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.gc_reservation_sent = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tv_info)?;
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.reward_player_accounts)?;
                },
                56 => {
                    self.reward_player_accounts.push(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.idle_player_accounts)?;
                },
                64 => {
                    self.idle_player_accounts.push(is.read_uint32()?);
                },
                72 => {
                    self.reward_item_attr_def_idx = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.reward_item_attr_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.reward_item_attr_reward_idx = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.reward_drop_list = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.tournament_tag = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.legacy_steamdatagram_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.steamdatagram_routing = ::std::option::Option::Some(is.read_uint32()?);
                },
                125 => {
                    self.test_token = ::std::option::Option::Some(is.read_fixed32()?);
                },
                128 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.gc_reservation_sent {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tv_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reward_player_accounts {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        for value in &self.idle_player_accounts {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        if let Some(v) = self.reward_item_attr_def_idx {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.reward_item_attr_value {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.reward_item_attr_reward_idx {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.reward_drop_list {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.tournament_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.legacy_steamdatagram_port {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.steamdatagram_routing {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.test_token {
            my_size += 1 + 4;
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reservationid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.reservation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.gc_reservation_sent {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tv_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.reward_player_accounts {
            os.write_uint32(7, *v)?;
        };
        for v in &self.idle_player_accounts {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.reward_item_attr_def_idx {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.reward_item_attr_value {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.reward_item_attr_reward_idx {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.reward_drop_list {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.tournament_tag.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.legacy_steamdatagram_port {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.steamdatagram_routing {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.test_token {
            os.write_fixed32(15, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::new()
    }

    fn clear(&mut self) {
        self.reservationid = ::std::option::Option::None;
        self.reservation.clear();
        self.map = ::std::option::Option::None;
        self.gc_reservation_sent = ::std::option::Option::None;
        self.server_version = ::std::option::Option::None;
        self.tv_info.clear();
        self.reward_player_accounts.clear();
        self.idle_player_accounts.clear();
        self.reward_item_attr_def_idx = ::std::option::Option::None;
        self.reward_item_attr_value = ::std::option::Option::None;
        self.reward_item_attr_reward_idx = ::std::option::Option::None;
        self.reward_drop_list = ::std::option::Option::None;
        self.tournament_tag = ::std::option::Option::None;
        self.legacy_steamdatagram_port = ::std::option::Option::None;
        self.steamdatagram_routing = ::std::option::Option::None;
        self.test_token = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        static instance: CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
            reservationid: ::std::option::Option::None,
            reservation: ::protobuf::MessageField::none(),
            map: ::std::option::Option::None,
            gc_reservation_sent: ::std::option::Option::None,
            server_version: ::std::option::Option::None,
            tv_info: ::protobuf::MessageField::none(),
            reward_player_accounts: ::std::vec::Vec::new(),
            idle_player_accounts: ::std::vec::Vec::new(),
            reward_item_attr_def_idx: ::std::option::Option::None,
            reward_item_attr_value: ::std::option::Option::None,
            reward_item_attr_reward_idx: ::std::option::Option::None,
            reward_drop_list: ::std::option::Option::None,
            tournament_tag: ::std::option::Option::None,
            legacy_steamdatagram_port: ::std::option::Option::None,
            steamdatagram_routing: ::std::option::Option::None,
            test_token: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingServerReservationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.serverid)
    pub serverid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.direct_udp_ip)
    pub direct_udp_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.direct_udp_port)
    pub direct_udp_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.reservationid)
    pub reservationid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.reservation)
    pub reservation: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.map)
    pub map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.server_address)
    pub server_address: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        ::std::default::Default::default()
    }

    // optional uint64 serverid = 1;

    pub fn serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }

    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    // optional uint32 direct_udp_ip = 2;

    pub fn direct_udp_ip(&self) -> u32 {
        self.direct_udp_ip.unwrap_or(0)
    }

    pub fn clear_direct_udp_ip(&mut self) {
        self.direct_udp_ip = ::std::option::Option::None;
    }

    pub fn has_direct_udp_ip(&self) -> bool {
        self.direct_udp_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direct_udp_ip(&mut self, v: u32) {
        self.direct_udp_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 direct_udp_port = 3;

    pub fn direct_udp_port(&self) -> u32 {
        self.direct_udp_port.unwrap_or(0)
    }

    pub fn clear_direct_udp_port(&mut self) {
        self.direct_udp_port = ::std::option::Option::None;
    }

    pub fn has_direct_udp_port(&self) -> bool {
        self.direct_udp_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direct_udp_port(&mut self, v: u32) {
        self.direct_udp_port = ::std::option::Option::Some(v);
    }

    // optional uint64 reservationid = 4;

    pub fn reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }

    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    // optional string map = 6;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string server_address = 7;

    pub fn server_address(&self) -> &str {
        match self.server_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_address(&mut self) {
        self.server_address = ::std::option::Option::None;
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: ::std::string::String) {
        self.server_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_address(&mut self) -> &mut ::std::string::String {
        if self.server_address.is_none() {
            self.server_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_address(&mut self) -> ::std::string::String {
        self.server_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverid",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.serverid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.serverid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "direct_udp_ip",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.direct_udp_ip },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.direct_udp_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "direct_udp_port",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.direct_udp_port },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.direct_udp_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservationid",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.reservationid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.reservationid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "reservation",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.reservation },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.reservation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.map },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_address",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.server_address },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.server_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.serverid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.direct_udp_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.direct_udp_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.reservationid = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reservation)?;
                },
                50 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.server_address = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.direct_udp_ip {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.direct_udp_port {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.server_address.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serverid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.direct_udp_ip {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.direct_udp_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.reservationid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.reservation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.server_address.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new()
    }

    fn clear(&mut self) {
        self.serverid = ::std::option::Option::None;
        self.direct_udp_ip = ::std::option::Option::None;
        self.direct_udp_port = ::std::option::Option::None;
        self.reservationid = ::std::option::Option::None;
        self.reservation.clear();
        self.map = ::std::option::Option::None;
        self.server_address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
            serverid: ::std::option::Option::None,
            direct_udp_ip: ::std::option::Option::None,
            direct_udp_port: ::std::option::Option::None,
            reservationid: ::std::option::Option::None,
            reservation: ::protobuf::MessageField::none(),
            map: ::std::option::Option::None,
            server_address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingServerRoundStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.reservationid)
    pub reservationid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.reservation)
    pub reservation: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.map)
    pub map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.round)
    pub round: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.kills)
    pub kills: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.assists)
    pub assists: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.deaths)
    pub deaths: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.scores)
    pub scores: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.pings)
    pub pings: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.round_result)
    pub round_result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.match_result)
    pub match_result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.team_scores)
    pub team_scores: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.confirm)
    pub confirm: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.reservation_stage)
    pub reservation_stage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.match_duration)
    pub match_duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_kills)
    pub enemy_kills: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_headshots)
    pub enemy_headshots: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_3ks)
    pub enemy_3ks: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_4ks)
    pub enemy_4ks: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_5ks)
    pub enemy_5ks: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.mvps)
    pub mvps: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.spectators_count)
    pub spectators_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.spectators_count_tv)
    pub spectators_count_tv: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.spectators_count_lnk)
    pub spectators_count_lnk: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_kills_agg)
    pub enemy_kills_agg: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.drop_info)
    pub drop_info: ::protobuf::MessageField<cmsg_gccstrike15_v2_matchmaking_server_round_stats::DropInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.b_switched_teams)
    pub b_switched_teams: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_2ks)
    pub enemy_2ks: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.player_spawned)
    pub player_spawned: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.team_spawn_count)
    pub team_spawn_count: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.max_rounds)
    pub max_rounds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        <CMsgGCCStrike15_v2_MatchmakingServerRoundStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        ::std::default::Default::default()
    }

    // optional uint64 reservationid = 1;

    pub fn reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }

    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    // optional string map = 3;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 round = 4;

    pub fn round(&self) -> i32 {
        self.round.unwrap_or(0)
    }

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i32) {
        self.round = ::std::option::Option::Some(v);
    }

    // optional int32 round_result = 10;

    pub fn round_result(&self) -> i32 {
        self.round_result.unwrap_or(0)
    }

    pub fn clear_round_result(&mut self) {
        self.round_result = ::std::option::Option::None;
    }

    pub fn has_round_result(&self) -> bool {
        self.round_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_result(&mut self, v: i32) {
        self.round_result = ::std::option::Option::Some(v);
    }

    // optional int32 match_result = 11;

    pub fn match_result(&self) -> i32 {
        self.match_result.unwrap_or(0)
    }

    pub fn clear_match_result(&mut self) {
        self.match_result = ::std::option::Option::None;
    }

    pub fn has_match_result(&self) -> bool {
        self.match_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_result(&mut self, v: i32) {
        self.match_result = ::std::option::Option::Some(v);
    }

    // optional int32 reservation_stage = 14;

    pub fn reservation_stage(&self) -> i32 {
        self.reservation_stage.unwrap_or(0)
    }

    pub fn clear_reservation_stage(&mut self) {
        self.reservation_stage = ::std::option::Option::None;
    }

    pub fn has_reservation_stage(&self) -> bool {
        self.reservation_stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_stage(&mut self, v: i32) {
        self.reservation_stage = ::std::option::Option::Some(v);
    }

    // optional int32 match_duration = 15;

    pub fn match_duration(&self) -> i32 {
        self.match_duration.unwrap_or(0)
    }

    pub fn clear_match_duration(&mut self) {
        self.match_duration = ::std::option::Option::None;
    }

    pub fn has_match_duration(&self) -> bool {
        self.match_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_duration(&mut self, v: i32) {
        self.match_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 spectators_count = 22;

    pub fn spectators_count(&self) -> u32 {
        self.spectators_count.unwrap_or(0)
    }

    pub fn clear_spectators_count(&mut self) {
        self.spectators_count = ::std::option::Option::None;
    }

    pub fn has_spectators_count(&self) -> bool {
        self.spectators_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count(&mut self, v: u32) {
        self.spectators_count = ::std::option::Option::Some(v);
    }

    // optional uint32 spectators_count_tv = 23;

    pub fn spectators_count_tv(&self) -> u32 {
        self.spectators_count_tv.unwrap_or(0)
    }

    pub fn clear_spectators_count_tv(&mut self) {
        self.spectators_count_tv = ::std::option::Option::None;
    }

    pub fn has_spectators_count_tv(&self) -> bool {
        self.spectators_count_tv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count_tv(&mut self, v: u32) {
        self.spectators_count_tv = ::std::option::Option::Some(v);
    }

    // optional uint32 spectators_count_lnk = 24;

    pub fn spectators_count_lnk(&self) -> u32 {
        self.spectators_count_lnk.unwrap_or(0)
    }

    pub fn clear_spectators_count_lnk(&mut self) {
        self.spectators_count_lnk = ::std::option::Option::None;
    }

    pub fn has_spectators_count_lnk(&self) -> bool {
        self.spectators_count_lnk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count_lnk(&mut self, v: u32) {
        self.spectators_count_lnk = ::std::option::Option::Some(v);
    }

    // optional bool b_switched_teams = 27;

    pub fn b_switched_teams(&self) -> bool {
        self.b_switched_teams.unwrap_or(false)
    }

    pub fn clear_b_switched_teams(&mut self) {
        self.b_switched_teams = ::std::option::Option::None;
    }

    pub fn has_b_switched_teams(&self) -> bool {
        self.b_switched_teams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b_switched_teams(&mut self, v: bool) {
        self.b_switched_teams = ::std::option::Option::Some(v);
    }

    // optional uint32 max_rounds = 31;

    pub fn max_rounds(&self) -> u32 {
        self.max_rounds.unwrap_or(0)
    }

    pub fn clear_max_rounds(&mut self) {
        self.max_rounds = ::std::option::Option::None;
    }

    pub fn has_max_rounds(&self) -> bool {
        self.max_rounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_rounds(&mut self, v: u32) {
        self.max_rounds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(31);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservationid",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.reservationid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.reservationid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "reservation",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.reservation },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.reservation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.map },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.round },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kills",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.kills },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "assists",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.assists },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.assists },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deaths",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.deaths },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scores",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.scores },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.scores },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pings",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.pings },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.pings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round_result",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.round_result },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.round_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_result",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.match_result },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.match_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_scores",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.team_scores },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.team_scores },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>(
            "confirm",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.confirm },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.confirm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservation_stage",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.reservation_stage },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.reservation_stage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_duration",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.match_duration },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.match_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_kills",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_kills },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_headshots",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_headshots },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_headshots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_3ks",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_3ks },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_3ks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_4ks",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_4ks },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_4ks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_5ks",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_5ks },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_5ks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mvps",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.mvps },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.mvps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectators_count",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.spectators_count },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.spectators_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectators_count_tv",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.spectators_count_tv },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.spectators_count_tv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectators_count_lnk",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.spectators_count_lnk },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.spectators_count_lnk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_kills_agg",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_kills_agg },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_kills_agg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_gccstrike15_v2_matchmaking_server_round_stats::DropInfo>(
            "drop_info",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.drop_info },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.drop_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "b_switched_teams",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.b_switched_teams },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.b_switched_teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_2ks",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_2ks },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_2ks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_spawned",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.player_spawned },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.player_spawned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_spawn_count",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.team_spawn_count },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.team_spawn_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_rounds",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.max_rounds },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.max_rounds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>(
            "CMsgGCCStrike15_v2_MatchmakingServerRoundStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingServerRoundStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reservationid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reservation)?;
                },
                26 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.round = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.kills)?;
                },
                40 => {
                    self.kills.push(is.read_int32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.assists)?;
                },
                48 => {
                    self.assists.push(is.read_int32()?);
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.deaths)?;
                },
                56 => {
                    self.deaths.push(is.read_int32()?);
                },
                66 => {
                    is.read_repeated_packed_int32_into(&mut self.scores)?;
                },
                64 => {
                    self.scores.push(is.read_int32()?);
                },
                74 => {
                    is.read_repeated_packed_int32_into(&mut self.pings)?;
                },
                72 => {
                    self.pings.push(is.read_int32()?);
                },
                80 => {
                    self.round_result = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.match_result = ::std::option::Option::Some(is.read_int32()?);
                },
                98 => {
                    is.read_repeated_packed_int32_into(&mut self.team_scores)?;
                },
                96 => {
                    self.team_scores.push(is.read_int32()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.confirm)?;
                },
                112 => {
                    self.reservation_stage = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.match_duration = ::std::option::Option::Some(is.read_int32()?);
                },
                130 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_kills)?;
                },
                128 => {
                    self.enemy_kills.push(is.read_int32()?);
                },
                138 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_headshots)?;
                },
                136 => {
                    self.enemy_headshots.push(is.read_int32()?);
                },
                146 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_3ks)?;
                },
                144 => {
                    self.enemy_3ks.push(is.read_int32()?);
                },
                154 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_4ks)?;
                },
                152 => {
                    self.enemy_4ks.push(is.read_int32()?);
                },
                162 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_5ks)?;
                },
                160 => {
                    self.enemy_5ks.push(is.read_int32()?);
                },
                170 => {
                    is.read_repeated_packed_int32_into(&mut self.mvps)?;
                },
                168 => {
                    self.mvps.push(is.read_int32()?);
                },
                176 => {
                    self.spectators_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.spectators_count_tv = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.spectators_count_lnk = ::std::option::Option::Some(is.read_uint32()?);
                },
                202 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_kills_agg)?;
                },
                200 => {
                    self.enemy_kills_agg.push(is.read_int32()?);
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.drop_info)?;
                },
                216 => {
                    self.b_switched_teams = ::std::option::Option::Some(is.read_bool()?);
                },
                226 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_2ks)?;
                },
                224 => {
                    self.enemy_2ks.push(is.read_int32()?);
                },
                234 => {
                    is.read_repeated_packed_int32_into(&mut self.player_spawned)?;
                },
                232 => {
                    self.player_spawned.push(is.read_int32()?);
                },
                242 => {
                    is.read_repeated_packed_int32_into(&mut self.team_spawn_count)?;
                },
                240 => {
                    self.team_spawn_count.push(is.read_int32()?);
                },
                248 => {
                    self.max_rounds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.round {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        for value in &self.kills {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        for value in &self.assists {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        for value in &self.deaths {
            my_size += ::protobuf::rt::int32_size(7, *value);
        };
        for value in &self.scores {
            my_size += ::protobuf::rt::int32_size(8, *value);
        };
        for value in &self.pings {
            my_size += ::protobuf::rt::int32_size(9, *value);
        };
        if let Some(v) = self.round_result {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.match_result {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        for value in &self.team_scores {
            my_size += ::protobuf::rt::int32_size(12, *value);
        };
        if let Some(v) = self.confirm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reservation_stage {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.match_duration {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        for value in &self.enemy_kills {
            my_size += ::protobuf::rt::int32_size(16, *value);
        };
        for value in &self.enemy_headshots {
            my_size += ::protobuf::rt::int32_size(17, *value);
        };
        for value in &self.enemy_3ks {
            my_size += ::protobuf::rt::int32_size(18, *value);
        };
        for value in &self.enemy_4ks {
            my_size += ::protobuf::rt::int32_size(19, *value);
        };
        for value in &self.enemy_5ks {
            my_size += ::protobuf::rt::int32_size(20, *value);
        };
        for value in &self.mvps {
            my_size += ::protobuf::rt::int32_size(21, *value);
        };
        if let Some(v) = self.spectators_count {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.spectators_count_tv {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.spectators_count_lnk {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        for value in &self.enemy_kills_agg {
            my_size += ::protobuf::rt::int32_size(25, *value);
        };
        if let Some(v) = self.drop_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.b_switched_teams {
            my_size += 2 + 1;
        }
        for value in &self.enemy_2ks {
            my_size += ::protobuf::rt::int32_size(28, *value);
        };
        for value in &self.player_spawned {
            my_size += ::protobuf::rt::int32_size(29, *value);
        };
        for value in &self.team_spawn_count {
            my_size += ::protobuf::rt::int32_size(30, *value);
        };
        if let Some(v) = self.max_rounds {
            my_size += ::protobuf::rt::uint32_size(31, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reservationid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.reservation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.round {
            os.write_int32(4, v)?;
        }
        for v in &self.kills {
            os.write_int32(5, *v)?;
        };
        for v in &self.assists {
            os.write_int32(6, *v)?;
        };
        for v in &self.deaths {
            os.write_int32(7, *v)?;
        };
        for v in &self.scores {
            os.write_int32(8, *v)?;
        };
        for v in &self.pings {
            os.write_int32(9, *v)?;
        };
        if let Some(v) = self.round_result {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.match_result {
            os.write_int32(11, v)?;
        }
        for v in &self.team_scores {
            os.write_int32(12, *v)?;
        };
        if let Some(v) = self.confirm.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.reservation_stage {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.match_duration {
            os.write_int32(15, v)?;
        }
        for v in &self.enemy_kills {
            os.write_int32(16, *v)?;
        };
        for v in &self.enemy_headshots {
            os.write_int32(17, *v)?;
        };
        for v in &self.enemy_3ks {
            os.write_int32(18, *v)?;
        };
        for v in &self.enemy_4ks {
            os.write_int32(19, *v)?;
        };
        for v in &self.enemy_5ks {
            os.write_int32(20, *v)?;
        };
        for v in &self.mvps {
            os.write_int32(21, *v)?;
        };
        if let Some(v) = self.spectators_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.spectators_count_tv {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.spectators_count_lnk {
            os.write_uint32(24, v)?;
        }
        for v in &self.enemy_kills_agg {
            os.write_int32(25, *v)?;
        };
        if let Some(v) = self.drop_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.b_switched_teams {
            os.write_bool(27, v)?;
        }
        for v in &self.enemy_2ks {
            os.write_int32(28, *v)?;
        };
        for v in &self.player_spawned {
            os.write_int32(29, *v)?;
        };
        for v in &self.team_spawn_count {
            os.write_int32(30, *v)?;
        };
        if let Some(v) = self.max_rounds {
            os.write_uint32(31, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        CMsgGCCStrike15_v2_MatchmakingServerRoundStats::new()
    }

    fn clear(&mut self) {
        self.reservationid = ::std::option::Option::None;
        self.reservation.clear();
        self.map = ::std::option::Option::None;
        self.round = ::std::option::Option::None;
        self.kills.clear();
        self.assists.clear();
        self.deaths.clear();
        self.scores.clear();
        self.pings.clear();
        self.round_result = ::std::option::Option::None;
        self.match_result = ::std::option::Option::None;
        self.team_scores.clear();
        self.confirm.clear();
        self.reservation_stage = ::std::option::Option::None;
        self.match_duration = ::std::option::Option::None;
        self.enemy_kills.clear();
        self.enemy_headshots.clear();
        self.enemy_3ks.clear();
        self.enemy_4ks.clear();
        self.enemy_5ks.clear();
        self.mvps.clear();
        self.spectators_count = ::std::option::Option::None;
        self.spectators_count_tv = ::std::option::Option::None;
        self.spectators_count_lnk = ::std::option::Option::None;
        self.enemy_kills_agg.clear();
        self.drop_info.clear();
        self.b_switched_teams = ::std::option::Option::None;
        self.enemy_2ks.clear();
        self.player_spawned.clear();
        self.team_spawn_count.clear();
        self.max_rounds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        static instance: CMsgGCCStrike15_v2_MatchmakingServerRoundStats = CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
            reservationid: ::std::option::Option::None,
            reservation: ::protobuf::MessageField::none(),
            map: ::std::option::Option::None,
            round: ::std::option::Option::None,
            kills: ::std::vec::Vec::new(),
            assists: ::std::vec::Vec::new(),
            deaths: ::std::vec::Vec::new(),
            scores: ::std::vec::Vec::new(),
            pings: ::std::vec::Vec::new(),
            round_result: ::std::option::Option::None,
            match_result: ::std::option::Option::None,
            team_scores: ::std::vec::Vec::new(),
            confirm: ::protobuf::MessageField::none(),
            reservation_stage: ::std::option::Option::None,
            match_duration: ::std::option::Option::None,
            enemy_kills: ::std::vec::Vec::new(),
            enemy_headshots: ::std::vec::Vec::new(),
            enemy_3ks: ::std::vec::Vec::new(),
            enemy_4ks: ::std::vec::Vec::new(),
            enemy_5ks: ::std::vec::Vec::new(),
            mvps: ::std::vec::Vec::new(),
            spectators_count: ::std::option::Option::None,
            spectators_count_tv: ::std::option::Option::None,
            spectators_count_lnk: ::std::option::Option::None,
            enemy_kills_agg: ::std::vec::Vec::new(),
            drop_info: ::protobuf::MessageField::none(),
            b_switched_teams: ::std::option::Option::None,
            enemy_2ks: ::std::vec::Vec::new(),
            player_spawned: ::std::vec::Vec::new(),
            team_spawn_count: ::std::vec::Vec::new(),
            max_rounds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingServerRoundStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_MatchmakingServerRoundStats`
pub mod cmsg_gccstrike15_v2_matchmaking_server_round_stats {
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DropInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo.account_mvp)
        pub account_mvp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DropInfo {
        fn default() -> &'a DropInfo {
            <DropInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl DropInfo {
        pub fn new() -> DropInfo {
            ::std::default::Default::default()
        }

        // optional uint32 account_mvp = 1;

        pub fn account_mvp(&self) -> u32 {
            self.account_mvp.unwrap_or(0)
        }

        pub fn clear_account_mvp(&mut self) {
            self.account_mvp = ::std::option::Option::None;
        }

        pub fn has_account_mvp(&self) -> bool {
            self.account_mvp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_mvp(&mut self, v: u32) {
            self.account_mvp = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_mvp",
                |m: &DropInfo| { &m.account_mvp },
                |m: &mut DropInfo| { &mut m.account_mvp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropInfo>(
                "CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DropInfo {
        const NAME: &'static str = "DropInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_mvp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_mvp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_mvp {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DropInfo {
            DropInfo::new()
        }

        fn clear(&mut self) {
            self.account_mvp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DropInfo {
            static instance: DropInfo = DropInfo {
                account_mvp: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DropInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DropInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DropInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingClient2GCHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingClient2GCHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        <CMsgGCCStrike15_v2_MatchmakingClient2GCHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingClient2GCHello>(
            "CMsgGCCStrike15_v2_MatchmakingClient2GCHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingClient2GCHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        CMsgGCCStrike15_v2_MatchmakingClient2GCHello::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        static instance: CMsgGCCStrike15_v2_MatchmakingClient2GCHello = CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingClient2GCHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.ongoingmatch)
    pub ongoingmatch: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.global_stats)
    pub global_stats: ::protobuf::MessageField<GlobalStatistics>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.penalty_seconds)
    pub penalty_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.penalty_reason)
    pub penalty_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.vac_banned)
    pub vac_banned: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.ranking)
    pub ranking: ::protobuf::MessageField<PlayerRankingInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.commendation)
    pub commendation: ::protobuf::MessageField<PlayerCommendationInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.medals)
    pub medals: ::protobuf::MessageField<PlayerMedalsInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.my_current_event)
    pub my_current_event: ::protobuf::MessageField<TournamentEvent>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.my_current_event_teams)
    pub my_current_event_teams: ::std::vec::Vec<TournamentTeam>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.my_current_team)
    pub my_current_team: ::protobuf::MessageField<TournamentTeam>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.my_current_event_stages)
    pub my_current_event_stages: ::std::vec::Vec<TournamentEvent>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.survey_vote)
    pub survey_vote: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.activity)
    pub activity: ::protobuf::MessageField<AccountActivity>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.player_level)
    pub player_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.player_cur_xp)
    pub player_cur_xp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.player_xp_bonus_flags)
    pub player_xp_bonus_flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.rankings)
    pub rankings: ::std::vec::Vec<PlayerRankingInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_seconds = 4;

    pub fn penalty_seconds(&self) -> u32 {
        self.penalty_seconds.unwrap_or(0)
    }

    pub fn clear_penalty_seconds(&mut self) {
        self.penalty_seconds = ::std::option::Option::None;
    }

    pub fn has_penalty_seconds(&self) -> bool {
        self.penalty_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_seconds(&mut self, v: u32) {
        self.penalty_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_reason = 5;

    pub fn penalty_reason(&self) -> u32 {
        self.penalty_reason.unwrap_or(0)
    }

    pub fn clear_penalty_reason(&mut self) {
        self.penalty_reason = ::std::option::Option::None;
    }

    pub fn has_penalty_reason(&self) -> bool {
        self.penalty_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_reason(&mut self, v: u32) {
        self.penalty_reason = ::std::option::Option::Some(v);
    }

    // optional int32 vac_banned = 6;

    pub fn vac_banned(&self) -> i32 {
        self.vac_banned.unwrap_or(0)
    }

    pub fn clear_vac_banned(&mut self) {
        self.vac_banned = ::std::option::Option::None;
    }

    pub fn has_vac_banned(&self) -> bool {
        self.vac_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vac_banned(&mut self, v: i32) {
        self.vac_banned = ::std::option::Option::Some(v);
    }

    // optional uint32 survey_vote = 14;

    pub fn survey_vote(&self) -> u32 {
        self.survey_vote.unwrap_or(0)
    }

    pub fn clear_survey_vote(&mut self) {
        self.survey_vote = ::std::option::Option::None;
    }

    pub fn has_survey_vote(&self) -> bool {
        self.survey_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_vote(&mut self, v: u32) {
        self.survey_vote = ::std::option::Option::Some(v);
    }

    // optional int32 player_level = 17;

    pub fn player_level(&self) -> i32 {
        self.player_level.unwrap_or(0)
    }

    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: i32) {
        self.player_level = ::std::option::Option::Some(v);
    }

    // optional int32 player_cur_xp = 18;

    pub fn player_cur_xp(&self) -> i32 {
        self.player_cur_xp.unwrap_or(0)
    }

    pub fn clear_player_cur_xp(&mut self) {
        self.player_cur_xp = ::std::option::Option::None;
    }

    pub fn has_player_cur_xp(&self) -> bool {
        self.player_cur_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_cur_xp(&mut self, v: i32) {
        self.player_cur_xp = ::std::option::Option::Some(v);
    }

    // optional int32 player_xp_bonus_flags = 19;

    pub fn player_xp_bonus_flags(&self) -> i32 {
        self.player_xp_bonus_flags.unwrap_or(0)
    }

    pub fn clear_player_xp_bonus_flags(&mut self) {
        self.player_xp_bonus_flags = ::std::option::Option::None;
    }

    pub fn has_player_xp_bonus_flags(&self) -> bool {
        self.player_xp_bonus_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_xp_bonus_flags(&mut self, v: i32) {
        self.player_xp_bonus_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
            "ongoingmatch",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.ongoingmatch },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.ongoingmatch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GlobalStatistics>(
            "global_stats",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.global_stats },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.global_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_seconds",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.penalty_seconds },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.penalty_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_reason",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.penalty_reason },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.penalty_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vac_banned",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.vac_banned },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.vac_banned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerRankingInfo>(
            "ranking",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.ranking },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.ranking },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerCommendationInfo>(
            "commendation",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.commendation },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.commendation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerMedalsInfo>(
            "medals",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.medals },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.medals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TournamentEvent>(
            "my_current_event",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_event },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "my_current_event_teams",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_event_teams },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_event_teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TournamentTeam>(
            "my_current_team",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_team },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "my_current_event_stages",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_event_stages },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_event_stages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "survey_vote",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.survey_vote },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.survey_vote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AccountActivity>(
            "activity",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.activity },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.activity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_level",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.player_level },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.player_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_cur_xp",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.player_cur_xp },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.player_cur_xp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_xp_bonus_flags",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.player_xp_bonus_flags },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.player_xp_bonus_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rankings",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.rankings },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.rankings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ClientHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ClientHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ongoingmatch)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.global_stats)?;
                },
                32 => {
                    self.penalty_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.penalty_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.vac_banned = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ranking)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commendation)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.medals)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.my_current_event)?;
                },
                90 => {
                    self.my_current_event_teams.push(is.read_message()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.my_current_team)?;
                },
                106 => {
                    self.my_current_event_stages.push(is.read_message()?);
                },
                112 => {
                    self.survey_vote = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.activity)?;
                },
                136 => {
                    self.player_level = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.player_cur_xp = ::std::option::Option::Some(is.read_int32()?);
                },
                152 => {
                    self.player_xp_bonus_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                162 => {
                    self.rankings.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ongoingmatch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.penalty_seconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.penalty_reason {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.vac_banned {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.ranking.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.medals.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.my_current_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.my_current_event_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.my_current_team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.my_current_event_stages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.survey_vote {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.activity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.player_cur_xp {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        if let Some(v) = self.player_xp_bonus_flags {
            my_size += ::protobuf::rt::int32_size(19, v);
        }
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ongoingmatch.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.global_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.penalty_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.penalty_reason {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.vac_banned {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.ranking.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.commendation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.medals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.my_current_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for v in &self.my_current_event_teams {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.my_current_team.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.my_current_event_stages {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.survey_vote {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.activity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.player_level {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.player_cur_xp {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.player_xp_bonus_flags {
            os.write_int32(19, v)?;
        }
        for v in &self.rankings {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.ongoingmatch.clear();
        self.global_stats.clear();
        self.penalty_seconds = ::std::option::Option::None;
        self.penalty_reason = ::std::option::Option::None;
        self.vac_banned = ::std::option::Option::None;
        self.ranking.clear();
        self.commendation.clear();
        self.medals.clear();
        self.my_current_event.clear();
        self.my_current_event_teams.clear();
        self.my_current_team.clear();
        self.my_current_event_stages.clear();
        self.survey_vote = ::std::option::Option::None;
        self.activity.clear();
        self.player_level = ::std::option::Option::None;
        self.player_cur_xp = ::std::option::Option::None;
        self.player_xp_bonus_flags = ::std::option::Option::None;
        self.rankings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
            account_id: ::std::option::Option::None,
            ongoingmatch: ::protobuf::MessageField::none(),
            global_stats: ::protobuf::MessageField::none(),
            penalty_seconds: ::std::option::Option::None,
            penalty_reason: ::std::option::Option::None,
            vac_banned: ::std::option::Option::None,
            ranking: ::protobuf::MessageField::none(),
            commendation: ::protobuf::MessageField::none(),
            medals: ::protobuf::MessageField::none(),
            my_current_event: ::protobuf::MessageField::none(),
            my_current_event_teams: ::std::vec::Vec::new(),
            my_current_team: ::protobuf::MessageField::none(),
            my_current_event_stages: ::std::vec::Vec::new(),
            survey_vote: ::std::option::Option::None,
            activity: ::protobuf::MessageField::none(),
            player_level: ::std::option::Option::None,
            player_cur_xp: ::std::option::Option::None,
            player_xp_bonus_flags: ::std::option::Option::None,
            rankings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ClientHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_AccountPrivacySettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_AccountPrivacySettings {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_AccountPrivacySettings.settings)
    pub settings: ::std::vec::Vec<cmsg_gccstrike15_v2_account_privacy_settings::Setting>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_AccountPrivacySettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn default() -> &'a CMsgGCCStrike15_v2_AccountPrivacySettings {
        <CMsgGCCStrike15_v2_AccountPrivacySettings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_AccountPrivacySettings {
    pub fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "settings",
            |m: &CMsgGCCStrike15_v2_AccountPrivacySettings| { &m.settings },
            |m: &mut CMsgGCCStrike15_v2_AccountPrivacySettings| { &mut m.settings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_AccountPrivacySettings>(
            "CMsgGCCStrike15_v2_AccountPrivacySettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_AccountPrivacySettings {
    const NAME: &'static str = "CMsgGCCStrike15_v2_AccountPrivacySettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.settings.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.settings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.settings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings {
        CMsgGCCStrike15_v2_AccountPrivacySettings::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_AccountPrivacySettings {
        static instance: CMsgGCCStrike15_v2_AccountPrivacySettings = CMsgGCCStrike15_v2_AccountPrivacySettings {
            settings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_AccountPrivacySettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_AccountPrivacySettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_AccountPrivacySettings`
pub mod cmsg_gccstrike15_v2_account_privacy_settings {
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_AccountPrivacySettings.Setting)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Setting {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_AccountPrivacySettings.Setting.setting_type)
        pub setting_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_AccountPrivacySettings.Setting.setting_value)
        pub setting_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_AccountPrivacySettings.Setting.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Setting {
        fn default() -> &'a Setting {
            <Setting as ::protobuf::Message>::default_instance()
        }
    }

    impl Setting {
        pub fn new() -> Setting {
            ::std::default::Default::default()
        }

        // optional uint32 setting_type = 1;

        pub fn setting_type(&self) -> u32 {
            self.setting_type.unwrap_or(0)
        }

        pub fn clear_setting_type(&mut self) {
            self.setting_type = ::std::option::Option::None;
        }

        pub fn has_setting_type(&self) -> bool {
            self.setting_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_setting_type(&mut self, v: u32) {
            self.setting_type = ::std::option::Option::Some(v);
        }

        // optional uint32 setting_value = 2;

        pub fn setting_value(&self) -> u32 {
            self.setting_value.unwrap_or(0)
        }

        pub fn clear_setting_value(&mut self) {
            self.setting_value = ::std::option::Option::None;
        }

        pub fn has_setting_value(&self) -> bool {
            self.setting_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_setting_value(&mut self, v: u32) {
            self.setting_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "setting_type",
                |m: &Setting| { &m.setting_type },
                |m: &mut Setting| { &mut m.setting_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "setting_value",
                |m: &Setting| { &m.setting_value },
                |m: &mut Setting| { &mut m.setting_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Setting>(
                "CMsgGCCStrike15_v2_AccountPrivacySettings.Setting",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Setting {
        const NAME: &'static str = "Setting";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.setting_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.setting_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.setting_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.setting_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.setting_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.setting_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Setting {
            Setting::new()
        }

        fn clear(&mut self) {
            self.setting_type = ::std::option::Option::None;
            self.setting_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Setting {
            static instance: Setting = Setting {
                setting_type: ::std::option::Option::None,
                setting_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Setting {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_AccountPrivacySettings.Setting").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Setting {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Setting {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.abandoned_match)
    pub abandoned_match: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.penalty_seconds)
    pub penalty_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.penalty_reason)
    pub penalty_reason: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_seconds = 3;

    pub fn penalty_seconds(&self) -> u32 {
        self.penalty_seconds.unwrap_or(0)
    }

    pub fn clear_penalty_seconds(&mut self) {
        self.penalty_seconds = ::std::option::Option::None;
    }

    pub fn has_penalty_seconds(&self) -> bool {
        self.penalty_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_seconds(&mut self, v: u32) {
        self.penalty_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_reason = 4;

    pub fn penalty_reason(&self) -> u32 {
        self.penalty_reason.unwrap_or(0)
    }

    pub fn clear_penalty_reason(&mut self) {
        self.penalty_reason = ::std::option::Option::None;
    }

    pub fn has_penalty_reason(&self) -> bool {
        self.penalty_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_reason(&mut self, v: u32) {
        self.penalty_reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
            "abandoned_match",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.abandoned_match },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.abandoned_match },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_seconds",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.penalty_seconds },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.penalty_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_reason",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.penalty_reason },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.penalty_reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.abandoned_match)?;
                },
                24 => {
                    self.penalty_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.penalty_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.abandoned_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.penalty_seconds {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.penalty_reason {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.abandoned_match.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.penalty_seconds {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.penalty_reason {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.abandoned_match.clear();
        self.penalty_seconds = ::std::option::Option::None;
        self.penalty_reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
            account_id: ::std::option::Option::None,
            abandoned_match: ::protobuf::MessageField::none(),
            penalty_seconds: ::std::option::Option::None,
            penalty_reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientGCRankUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientGCRankUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientGCRankUpdate.rankings)
    pub rankings: ::std::vec::Vec<PlayerRankingInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientGCRankUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientGCRankUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientGCRankUpdate {
        <CMsgGCCStrike15_v2_ClientGCRankUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientGCRankUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_ClientGCRankUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rankings",
            |m: &CMsgGCCStrike15_v2_ClientGCRankUpdate| { &m.rankings },
            |m: &mut CMsgGCCStrike15_v2_ClientGCRankUpdate| { &mut m.rankings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientGCRankUpdate>(
            "CMsgGCCStrike15_v2_ClientGCRankUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientGCRankUpdate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientGCRankUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rankings.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rankings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientGCRankUpdate {
        CMsgGCCStrike15_v2_ClientGCRankUpdate::new()
    }

    fn clear(&mut self) {
        self.rankings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientGCRankUpdate {
        static instance: CMsgGCCStrike15_v2_ClientGCRankUpdate = CMsgGCCStrike15_v2_ClientGCRankUpdate {
            rankings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientGCRankUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientGCRankUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientGCRankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientGCRankUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.main_post_url)
    pub main_post_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        <CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        ::std::default::Default::default()
    }

    // optional string main_post_url = 1;

    pub fn main_post_url(&self) -> &str {
        match self.main_post_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_main_post_url(&mut self) {
        self.main_post_url = ::std::option::Option::None;
    }

    pub fn has_main_post_url(&self) -> bool {
        self.main_post_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_post_url(&mut self, v: ::std::string::String) {
        self.main_post_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_post_url(&mut self) -> &mut ::std::string::String {
        if self.main_post_url.is_none() {
            self.main_post_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.main_post_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_post_url(&mut self) -> ::std::string::String {
        self.main_post_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "main_post_url",
            |m: &CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate| { &m.main_post_url },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate| { &mut m.main_post_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate>(
            "CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.main_post_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.main_post_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.main_post_url.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate::new()
    }

    fn clear(&mut self) {
        self.main_post_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        static instance: CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
            main_post_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.reason)
    pub reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.seconds)
    pub seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.communication_cooldown)
    pub communication_cooldown: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn default() -> &'a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        <CMsgGCCStrike15_v2_ServerNotificationForUserPenalty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    pub fn new() -> CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reason = 2;

    pub fn reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds = 3;

    pub fn seconds(&self) -> u32 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional bool communication_cooldown = 4;

    pub fn communication_cooldown(&self) -> bool {
        self.communication_cooldown.unwrap_or(false)
    }

    pub fn clear_communication_cooldown(&mut self) {
        self.communication_cooldown = ::std::option::Option::None;
    }

    pub fn has_communication_cooldown(&self) -> bool {
        self.communication_cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_communication_cooldown(&mut self, v: bool) {
        self.communication_cooldown = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &m.reason },
            |m: &mut CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds",
            |m: &CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &m.seconds },
            |m: &mut CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &mut m.seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "communication_cooldown",
            |m: &CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &m.communication_cooldown },
            |m: &mut CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &mut m.communication_cooldown },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ServerNotificationForUserPenalty>(
            "CMsgGCCStrike15_v2_ServerNotificationForUserPenalty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ServerNotificationForUserPenalty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.communication_cooldown = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.communication_cooldown {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.communication_cooldown {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.communication_cooldown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        static instance: CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
            account_id: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            seconds: ::std::option::Option::None,
            communication_cooldown: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ServerNotificationForUserPenalty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientReportPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientReportPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_aimbot)
    pub rpt_aimbot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_wallhack)
    pub rpt_wallhack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_speedhack)
    pub rpt_speedhack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_teamharm)
    pub rpt_teamharm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_textabuse)
    pub rpt_textabuse: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_voiceabuse)
    pub rpt_voiceabuse: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.report_from_demo)
    pub report_from_demo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientReportPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientReportPlayer {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientReportPlayer {
        <CMsgGCCStrike15_v2_ClientReportPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientReportPlayer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_aimbot = 2;

    pub fn rpt_aimbot(&self) -> u32 {
        self.rpt_aimbot.unwrap_or(0)
    }

    pub fn clear_rpt_aimbot(&mut self) {
        self.rpt_aimbot = ::std::option::Option::None;
    }

    pub fn has_rpt_aimbot(&self) -> bool {
        self.rpt_aimbot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_aimbot(&mut self, v: u32) {
        self.rpt_aimbot = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_wallhack = 3;

    pub fn rpt_wallhack(&self) -> u32 {
        self.rpt_wallhack.unwrap_or(0)
    }

    pub fn clear_rpt_wallhack(&mut self) {
        self.rpt_wallhack = ::std::option::Option::None;
    }

    pub fn has_rpt_wallhack(&self) -> bool {
        self.rpt_wallhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_wallhack(&mut self, v: u32) {
        self.rpt_wallhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_speedhack = 4;

    pub fn rpt_speedhack(&self) -> u32 {
        self.rpt_speedhack.unwrap_or(0)
    }

    pub fn clear_rpt_speedhack(&mut self) {
        self.rpt_speedhack = ::std::option::Option::None;
    }

    pub fn has_rpt_speedhack(&self) -> bool {
        self.rpt_speedhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_speedhack(&mut self, v: u32) {
        self.rpt_speedhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_teamharm = 5;

    pub fn rpt_teamharm(&self) -> u32 {
        self.rpt_teamharm.unwrap_or(0)
    }

    pub fn clear_rpt_teamharm(&mut self) {
        self.rpt_teamharm = ::std::option::Option::None;
    }

    pub fn has_rpt_teamharm(&self) -> bool {
        self.rpt_teamharm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_teamharm(&mut self, v: u32) {
        self.rpt_teamharm = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_textabuse = 6;

    pub fn rpt_textabuse(&self) -> u32 {
        self.rpt_textabuse.unwrap_or(0)
    }

    pub fn clear_rpt_textabuse(&mut self) {
        self.rpt_textabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_textabuse(&self) -> bool {
        self.rpt_textabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_textabuse(&mut self, v: u32) {
        self.rpt_textabuse = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_voiceabuse = 7;

    pub fn rpt_voiceabuse(&self) -> u32 {
        self.rpt_voiceabuse.unwrap_or(0)
    }

    pub fn clear_rpt_voiceabuse(&mut self) {
        self.rpt_voiceabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_voiceabuse(&self) -> bool {
        self.rpt_voiceabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_voiceabuse(&mut self, v: u32) {
        self.rpt_voiceabuse = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 8;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bool report_from_demo = 9;

    pub fn report_from_demo(&self) -> bool {
        self.report_from_demo.unwrap_or(false)
    }

    pub fn clear_report_from_demo(&mut self) {
        self.report_from_demo = ::std::option::Option::None;
    }

    pub fn has_report_from_demo(&self) -> bool {
        self.report_from_demo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_from_demo(&mut self, v: bool) {
        self.report_from_demo = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_aimbot",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_aimbot },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_aimbot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_wallhack",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_wallhack },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_wallhack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_speedhack",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_speedhack },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_speedhack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_teamharm",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_teamharm },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_teamharm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_textabuse",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_textabuse },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_textabuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_voiceabuse",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_voiceabuse },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_voiceabuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "report_from_demo",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.report_from_demo },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.report_from_demo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientReportPlayer>(
            "CMsgGCCStrike15_v2_ClientReportPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportPlayer {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientReportPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rpt_aimbot = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.rpt_wallhack = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rpt_speedhack = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rpt_teamharm = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.rpt_textabuse = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.rpt_voiceabuse = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.report_from_demo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rpt_aimbot {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rpt_wallhack {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rpt_speedhack {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rpt_teamharm {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.rpt_textabuse {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.rpt_voiceabuse {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.report_from_demo {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rpt_aimbot {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rpt_wallhack {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rpt_speedhack {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_teamharm {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rpt_textabuse {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rpt_voiceabuse {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.report_from_demo {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientReportPlayer {
        CMsgGCCStrike15_v2_ClientReportPlayer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rpt_aimbot = ::std::option::Option::None;
        self.rpt_wallhack = ::std::option::Option::None;
        self.rpt_speedhack = ::std::option::Option::None;
        self.rpt_teamharm = ::std::option::Option::None;
        self.rpt_textabuse = ::std::option::Option::None;
        self.rpt_voiceabuse = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.report_from_demo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportPlayer {
        static instance: CMsgGCCStrike15_v2_ClientReportPlayer = CMsgGCCStrike15_v2_ClientReportPlayer {
            account_id: ::std::option::Option::None,
            rpt_aimbot: ::std::option::Option::None,
            rpt_wallhack: ::std::option::Option::None,
            rpt_speedhack: ::std::option::Option::None,
            rpt_teamharm: ::std::option::Option::None,
            rpt_textabuse: ::std::option::Option::None,
            rpt_voiceabuse: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            report_from_demo: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientReportPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientCommendPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientCommendPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientCommendPlayer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientCommendPlayer.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientCommendPlayer.commendation)
    pub commendation: ::protobuf::MessageField<PlayerCommendationInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientCommendPlayer.tokens)
    pub tokens: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientCommendPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientCommendPlayer {
        <CMsgGCCStrike15_v2_ClientCommendPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientCommendPlayer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientCommendPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 8;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tokens = 10;

    pub fn tokens(&self) -> u32 {
        self.tokens.unwrap_or(0)
    }

    pub fn clear_tokens(&mut self) {
        self.tokens = ::std::option::Option::None;
    }

    pub fn has_tokens(&self) -> bool {
        self.tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: u32) {
        self.tokens = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerCommendationInfo>(
            "commendation",
            |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.commendation },
            |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.commendation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tokens",
            |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.tokens },
            |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.tokens },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientCommendPlayer>(
            "CMsgGCCStrike15_v2_ClientCommendPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientCommendPlayer {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientCommendPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commendation)?;
                },
                80 => {
                    self.tokens = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tokens {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.commendation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.tokens {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientCommendPlayer {
        CMsgGCCStrike15_v2_ClientCommendPlayer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.commendation.clear();
        self.tokens = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientCommendPlayer {
        static instance: CMsgGCCStrike15_v2_ClientCommendPlayer = CMsgGCCStrike15_v2_ClientCommendPlayer {
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            commendation: ::protobuf::MessageField::none(),
            tokens: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientCommendPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientCommendPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientReportServer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientReportServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.rpt_poorperf)
    pub rpt_poorperf: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.rpt_abusivemodels)
    pub rpt_abusivemodels: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.rpt_badmotd)
    pub rpt_badmotd: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.rpt_listingabuse)
    pub rpt_listingabuse: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.rpt_inventoryabuse)
    pub rpt_inventoryabuse: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientReportServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientReportServer {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientReportServer {
        <CMsgGCCStrike15_v2_ClientReportServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientReportServer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportServer {
        ::std::default::Default::default()
    }

    // optional uint32 rpt_poorperf = 1;

    pub fn rpt_poorperf(&self) -> u32 {
        self.rpt_poorperf.unwrap_or(0)
    }

    pub fn clear_rpt_poorperf(&mut self) {
        self.rpt_poorperf = ::std::option::Option::None;
    }

    pub fn has_rpt_poorperf(&self) -> bool {
        self.rpt_poorperf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_poorperf(&mut self, v: u32) {
        self.rpt_poorperf = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_abusivemodels = 2;

    pub fn rpt_abusivemodels(&self) -> u32 {
        self.rpt_abusivemodels.unwrap_or(0)
    }

    pub fn clear_rpt_abusivemodels(&mut self) {
        self.rpt_abusivemodels = ::std::option::Option::None;
    }

    pub fn has_rpt_abusivemodels(&self) -> bool {
        self.rpt_abusivemodels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_abusivemodels(&mut self, v: u32) {
        self.rpt_abusivemodels = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_badmotd = 3;

    pub fn rpt_badmotd(&self) -> u32 {
        self.rpt_badmotd.unwrap_or(0)
    }

    pub fn clear_rpt_badmotd(&mut self) {
        self.rpt_badmotd = ::std::option::Option::None;
    }

    pub fn has_rpt_badmotd(&self) -> bool {
        self.rpt_badmotd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_badmotd(&mut self, v: u32) {
        self.rpt_badmotd = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_listingabuse = 4;

    pub fn rpt_listingabuse(&self) -> u32 {
        self.rpt_listingabuse.unwrap_or(0)
    }

    pub fn clear_rpt_listingabuse(&mut self) {
        self.rpt_listingabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_listingabuse(&self) -> bool {
        self.rpt_listingabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_listingabuse(&mut self, v: u32) {
        self.rpt_listingabuse = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_inventoryabuse = 5;

    pub fn rpt_inventoryabuse(&self) -> u32 {
        self.rpt_inventoryabuse.unwrap_or(0)
    }

    pub fn clear_rpt_inventoryabuse(&mut self) {
        self.rpt_inventoryabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_inventoryabuse(&self) -> bool {
        self.rpt_inventoryabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_inventoryabuse(&mut self, v: u32) {
        self.rpt_inventoryabuse = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 8;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_poorperf",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_poorperf },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_poorperf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_abusivemodels",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_abusivemodels },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_abusivemodels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_badmotd",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_badmotd },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_badmotd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_listingabuse",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_listingabuse },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_listingabuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_inventoryabuse",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_inventoryabuse },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_inventoryabuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientReportServer>(
            "CMsgGCCStrike15_v2_ClientReportServer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportServer {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientReportServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rpt_poorperf = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rpt_abusivemodels = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.rpt_badmotd = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rpt_listingabuse = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rpt_inventoryabuse = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rpt_poorperf {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rpt_abusivemodels {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rpt_badmotd {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rpt_listingabuse {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rpt_inventoryabuse {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rpt_poorperf {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rpt_abusivemodels {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rpt_badmotd {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rpt_listingabuse {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_inventoryabuse {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientReportServer {
        CMsgGCCStrike15_v2_ClientReportServer::new()
    }

    fn clear(&mut self) {
        self.rpt_poorperf = ::std::option::Option::None;
        self.rpt_abusivemodels = ::std::option::Option::None;
        self.rpt_badmotd = ::std::option::Option::None;
        self.rpt_listingabuse = ::std::option::Option::None;
        self.rpt_inventoryabuse = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportServer {
        static instance: CMsgGCCStrike15_v2_ClientReportServer = CMsgGCCStrike15_v2_ClientReportServer {
            rpt_poorperf: ::std::option::Option::None,
            rpt_abusivemodels: ::std::option::Option::None,
            rpt_badmotd: ::std::option::Option::None,
            rpt_listingabuse: ::std::option::Option::None,
            rpt_inventoryabuse: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientReportServer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientReportServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientReportServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportServer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientReportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientReportResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.confirmation_id)
    pub confirmation_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.server_ip)
    pub server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.response_type)
    pub response_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.response_result)
    pub response_result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.tokens)
    pub tokens: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientReportResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientReportResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientReportResponse {
        <CMsgGCCStrike15_v2_ClientReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientReportResponse {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportResponse {
        ::std::default::Default::default()
    }

    // optional uint64 confirmation_id = 1;

    pub fn confirmation_id(&self) -> u64 {
        self.confirmation_id.unwrap_or(0)
    }

    pub fn clear_confirmation_id(&mut self) {
        self.confirmation_id = ::std::option::Option::None;
    }

    pub fn has_confirmation_id(&self) -> bool {
        self.confirmation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confirmation_id(&mut self, v: u64) {
        self.confirmation_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_ip = 3;

    pub fn server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 response_type = 4;

    pub fn response_type(&self) -> u32 {
        self.response_type.unwrap_or(0)
    }

    pub fn clear_response_type(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_response_type(&self) -> bool {
        self.response_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_type(&mut self, v: u32) {
        self.response_type = ::std::option::Option::Some(v);
    }

    // optional uint32 response_result = 5;

    pub fn response_result(&self) -> u32 {
        self.response_result.unwrap_or(0)
    }

    pub fn clear_response_result(&mut self) {
        self.response_result = ::std::option::Option::None;
    }

    pub fn has_response_result(&self) -> bool {
        self.response_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_result(&mut self, v: u32) {
        self.response_result = ::std::option::Option::Some(v);
    }

    // optional uint32 tokens = 6;

    pub fn tokens(&self) -> u32 {
        self.tokens.unwrap_or(0)
    }

    pub fn clear_tokens(&mut self) {
        self.tokens = ::std::option::Option::None;
    }

    pub fn has_tokens(&self) -> bool {
        self.tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: u32) {
        self.tokens = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "confirmation_id",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.confirmation_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.confirmation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_ip",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.server_ip },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response_type",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.response_type },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.response_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response_result",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.response_result },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.response_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tokens",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.tokens },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.tokens },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientReportResponse>(
            "CMsgGCCStrike15_v2_ClientReportResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportResponse {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientReportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.confirmation_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.response_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.response_result = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.tokens = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.confirmation_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.response_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.response_result {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tokens {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.confirmation_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.response_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.response_result {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tokens {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientReportResponse {
        CMsgGCCStrike15_v2_ClientReportResponse::new()
    }

    fn clear(&mut self) {
        self.confirmation_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.server_ip = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_result = ::std::option::Option::None;
        self.tokens = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportResponse {
        static instance: CMsgGCCStrike15_v2_ClientReportResponse = CMsgGCCStrike15_v2_ClientReportResponse {
            confirmation_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            server_ip: ::std::option::Option::None,
            response_type: ::std::option::Option::None,
            response_result: ::std::option::Option::None,
            tokens: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientReportResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientReportResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.serverid)
    pub serverid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.matchid)
    pub matchid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.client_launcher)
    pub client_launcher: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.data_center_pings)
    pub data_center_pings: ::std::vec::Vec<DataCenterPing>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        <CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 serverid = 3;

    pub fn serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }

    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    // optional uint64 matchid = 4;

    pub fn matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    // optional uint32 client_launcher = 5;

    pub fn client_launcher(&self) -> u32 {
        self.client_launcher.unwrap_or(0)
    }

    pub fn clear_client_launcher(&mut self) {
        self.client_launcher = ::std::option::Option::None;
    }

    pub fn has_client_launcher(&self) -> bool {
        self.client_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_launcher(&mut self, v: u32) {
        self.client_launcher = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.request_id },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.account_ids },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverid",
            |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.serverid },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.serverid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchid",
            |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.matchid },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.matchid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_launcher",
            |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.client_launcher },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.client_launcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_center_pings",
            |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.data_center_pings },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.data_center_pings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends>(
            "CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                16 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                24 => {
                    self.serverid = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.matchid = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.client_launcher = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.data_center_pings.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.client_launcher {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.data_center_pings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.serverid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.matchid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.client_launcher {
            os.write_uint32(5, v)?;
        }
        for v in &self.data_center_pings {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.serverid = ::std::option::Option::None;
        self.matchid = ::std::option::Option::None;
        self.client_launcher = ::std::option::Option::None;
        self.data_center_pings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        static instance: CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
            request_id: ::std::option::Option::None,
            account_ids: ::std::vec::Vec::new(),
            serverid: ::std::option::Option::None,
            matchid: ::std::option::Option::None,
            client_launcher: ::std::option::Option::None,
            data_center_pings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:WatchableMatchInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct WatchableMatchInfo {
    // message fields
    // @@protoc_insertion_point(field:WatchableMatchInfo.server_ip)
    pub server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.tv_port)
    pub tv_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.tv_spectators)
    pub tv_spectators: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.tv_time)
    pub tv_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.tv_watch_password)
    pub tv_watch_password: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.cl_decryptdata_key)
    pub cl_decryptdata_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.cl_decryptdata_key_pub)
    pub cl_decryptdata_key_pub: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.game_mapgroup)
    pub game_mapgroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.game_map)
    pub game_map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.server_id)
    pub server_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.reservation_id)
    pub reservation_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:WatchableMatchInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WatchableMatchInfo {
    fn default() -> &'a WatchableMatchInfo {
        <WatchableMatchInfo as ::protobuf::Message>::default_instance()
    }
}

impl WatchableMatchInfo {
    pub fn new() -> WatchableMatchInfo {
        ::std::default::Default::default()
    }

    // optional uint32 server_ip = 1;

    pub fn server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_port = 2;

    pub fn tv_port(&self) -> u32 {
        self.tv_port.unwrap_or(0)
    }

    pub fn clear_tv_port(&mut self) {
        self.tv_port = ::std::option::Option::None;
    }

    pub fn has_tv_port(&self) -> bool {
        self.tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_port(&mut self, v: u32) {
        self.tv_port = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_spectators = 3;

    pub fn tv_spectators(&self) -> u32 {
        self.tv_spectators.unwrap_or(0)
    }

    pub fn clear_tv_spectators(&mut self) {
        self.tv_spectators = ::std::option::Option::None;
    }

    pub fn has_tv_spectators(&self) -> bool {
        self.tv_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_spectators(&mut self, v: u32) {
        self.tv_spectators = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_time = 4;

    pub fn tv_time(&self) -> u32 {
        self.tv_time.unwrap_or(0)
    }

    pub fn clear_tv_time(&mut self) {
        self.tv_time = ::std::option::Option::None;
    }

    pub fn has_tv_time(&self) -> bool {
        self.tv_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_time(&mut self, v: u32) {
        self.tv_time = ::std::option::Option::Some(v);
    }

    // optional bytes tv_watch_password = 5;

    pub fn tv_watch_password(&self) -> &[u8] {
        match self.tv_watch_password.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tv_watch_password(&mut self) {
        self.tv_watch_password = ::std::option::Option::None;
    }

    pub fn has_tv_watch_password(&self) -> bool {
        self.tv_watch_password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_watch_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.tv_watch_password = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tv_watch_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tv_watch_password.is_none() {
            self.tv_watch_password = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tv_watch_password.as_mut().unwrap()
    }

    // Take field
    pub fn take_tv_watch_password(&mut self) -> ::std::vec::Vec<u8> {
        self.tv_watch_password.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 cl_decryptdata_key = 6;

    pub fn cl_decryptdata_key(&self) -> u64 {
        self.cl_decryptdata_key.unwrap_or(0)
    }

    pub fn clear_cl_decryptdata_key(&mut self) {
        self.cl_decryptdata_key = ::std::option::Option::None;
    }

    pub fn has_cl_decryptdata_key(&self) -> bool {
        self.cl_decryptdata_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cl_decryptdata_key(&mut self, v: u64) {
        self.cl_decryptdata_key = ::std::option::Option::Some(v);
    }

    // optional uint64 cl_decryptdata_key_pub = 7;

    pub fn cl_decryptdata_key_pub(&self) -> u64 {
        self.cl_decryptdata_key_pub.unwrap_or(0)
    }

    pub fn clear_cl_decryptdata_key_pub(&mut self) {
        self.cl_decryptdata_key_pub = ::std::option::Option::None;
    }

    pub fn has_cl_decryptdata_key_pub(&self) -> bool {
        self.cl_decryptdata_key_pub.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cl_decryptdata_key_pub(&mut self, v: u64) {
        self.cl_decryptdata_key_pub = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 8;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional string game_mapgroup = 9;

    pub fn game_mapgroup(&self) -> &str {
        match self.game_mapgroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_mapgroup(&mut self) {
        self.game_mapgroup = ::std::option::Option::None;
    }

    pub fn has_game_mapgroup(&self) -> bool {
        self.game_mapgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mapgroup(&mut self, v: ::std::string::String) {
        self.game_mapgroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mapgroup(&mut self) -> &mut ::std::string::String {
        if self.game_mapgroup.is_none() {
            self.game_mapgroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_mapgroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mapgroup(&mut self) -> ::std::string::String {
        self.game_mapgroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_map = 10;

    pub fn game_map(&self) -> &str {
        match self.game_map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_map(&mut self) {
        self.game_map = ::std::option::Option::None;
    }

    pub fn has_game_map(&self) -> bool {
        self.game_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_map(&mut self, v: ::std::string::String) {
        self.game_map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_map(&mut self) -> &mut ::std::string::String {
        if self.game_map.is_none() {
            self.game_map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_map(&mut self) -> ::std::string::String {
        self.game_map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 server_id = 11;

    pub fn server_id(&self) -> u64 {
        self.server_id.unwrap_or(0)
    }

    pub fn clear_server_id(&mut self) {
        self.server_id = ::std::option::Option::None;
    }

    pub fn has_server_id(&self) -> bool {
        self.server_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_id(&mut self, v: u64) {
        self.server_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 12;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint64 reservation_id = 13;

    pub fn reservation_id(&self) -> u64 {
        self.reservation_id.unwrap_or(0)
    }

    pub fn clear_reservation_id(&mut self) {
        self.reservation_id = ::std::option::Option::None;
    }

    pub fn has_reservation_id(&self) -> bool {
        self.reservation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_id(&mut self, v: u64) {
        self.reservation_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_ip",
            |m: &WatchableMatchInfo| { &m.server_ip },
            |m: &mut WatchableMatchInfo| { &mut m.server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_port",
            |m: &WatchableMatchInfo| { &m.tv_port },
            |m: &mut WatchableMatchInfo| { &mut m.tv_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_spectators",
            |m: &WatchableMatchInfo| { &m.tv_spectators },
            |m: &mut WatchableMatchInfo| { &mut m.tv_spectators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_time",
            |m: &WatchableMatchInfo| { &m.tv_time },
            |m: &mut WatchableMatchInfo| { &mut m.tv_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_watch_password",
            |m: &WatchableMatchInfo| { &m.tv_watch_password },
            |m: &mut WatchableMatchInfo| { &mut m.tv_watch_password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cl_decryptdata_key",
            |m: &WatchableMatchInfo| { &m.cl_decryptdata_key },
            |m: &mut WatchableMatchInfo| { &mut m.cl_decryptdata_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cl_decryptdata_key_pub",
            |m: &WatchableMatchInfo| { &m.cl_decryptdata_key_pub },
            |m: &mut WatchableMatchInfo| { &mut m.cl_decryptdata_key_pub },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &WatchableMatchInfo| { &m.game_type },
            |m: &mut WatchableMatchInfo| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mapgroup",
            |m: &WatchableMatchInfo| { &m.game_mapgroup },
            |m: &mut WatchableMatchInfo| { &mut m.game_mapgroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_map",
            |m: &WatchableMatchInfo| { &m.game_map },
            |m: &mut WatchableMatchInfo| { &mut m.game_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_id",
            |m: &WatchableMatchInfo| { &m.server_id },
            |m: &mut WatchableMatchInfo| { &mut m.server_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &WatchableMatchInfo| { &m.match_id },
            |m: &mut WatchableMatchInfo| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservation_id",
            |m: &WatchableMatchInfo| { &m.reservation_id },
            |m: &mut WatchableMatchInfo| { &mut m.reservation_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WatchableMatchInfo>(
            "WatchableMatchInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WatchableMatchInfo {
    const NAME: &'static str = "WatchableMatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.tv_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.tv_spectators = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tv_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.tv_watch_password = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.cl_decryptdata_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.cl_decryptdata_key_pub = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.game_mapgroup = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.game_map = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.server_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                104 => {
                    self.reservation_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tv_port {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.tv_spectators {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tv_time {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tv_watch_password.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.cl_decryptdata_key {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.cl_decryptdata_key_pub {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.game_mapgroup.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.game_map.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.server_id {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.reservation_id {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_ip {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tv_port {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tv_spectators {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tv_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tv_watch_password.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.cl_decryptdata_key {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.cl_decryptdata_key_pub {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_mapgroup.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.game_map.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.server_id {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.reservation_id {
            os.write_uint64(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WatchableMatchInfo {
        WatchableMatchInfo::new()
    }

    fn clear(&mut self) {
        self.server_ip = ::std::option::Option::None;
        self.tv_port = ::std::option::Option::None;
        self.tv_spectators = ::std::option::Option::None;
        self.tv_time = ::std::option::Option::None;
        self.tv_watch_password = ::std::option::Option::None;
        self.cl_decryptdata_key = ::std::option::Option::None;
        self.cl_decryptdata_key_pub = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.game_mapgroup = ::std::option::Option::None;
        self.game_map = ::std::option::Option::None;
        self.server_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.reservation_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WatchableMatchInfo {
        static instance: WatchableMatchInfo = WatchableMatchInfo {
            server_ip: ::std::option::Option::None,
            tv_port: ::std::option::Option::None,
            tv_spectators: ::std::option::Option::None,
            tv_time: ::std::option::Option::None,
            tv_watch_password: ::std::option::Option::None,
            cl_decryptdata_key: ::std::option::Option::None,
            cl_decryptdata_key_pub: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            game_mapgroup: ::std::option::Option::None,
            game_map: ::std::option::Option::None,
            server_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            reservation_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WatchableMatchInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WatchableMatchInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WatchableMatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchableMatchInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientRequestJoinFriendData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.join_token)
    pub join_token: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.join_ipp)
    pub join_ipp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.res)
    pub res: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.errormsg)
    pub errormsg: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        <CMsgGCCStrike15_v2_ClientRequestJoinFriendData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 join_token = 3;

    pub fn join_token(&self) -> u32 {
        self.join_token.unwrap_or(0)
    }

    pub fn clear_join_token(&mut self) {
        self.join_token = ::std::option::Option::None;
    }

    pub fn has_join_token(&self) -> bool {
        self.join_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_token(&mut self, v: u32) {
        self.join_token = ::std::option::Option::Some(v);
    }

    // optional uint32 join_ipp = 4;

    pub fn join_ipp(&self) -> u32 {
        self.join_ipp.unwrap_or(0)
    }

    pub fn clear_join_ipp(&mut self) {
        self.join_ipp = ::std::option::Option::None;
    }

    pub fn has_join_ipp(&self) -> bool {
        self.join_ipp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_ipp(&mut self, v: u32) {
        self.join_ipp = ::std::option::Option::Some(v);
    }

    // optional string errormsg = 6;

    pub fn errormsg(&self) -> &str {
        match self.errormsg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_errormsg(&mut self) {
        self.errormsg = ::std::option::Option::None;
    }

    pub fn has_errormsg(&self) -> bool {
        self.errormsg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errormsg(&mut self, v: ::std::string::String) {
        self.errormsg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errormsg(&mut self) -> &mut ::std::string::String {
        if self.errormsg.is_none() {
            self.errormsg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.errormsg.as_mut().unwrap()
    }

    // Take field
    pub fn take_errormsg(&mut self) -> ::std::string::String {
        self.errormsg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.version },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "join_token",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.join_token },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.join_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "join_ipp",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.join_ipp },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.join_ipp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
            "res",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.res },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.res },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "errormsg",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.errormsg },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.errormsg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientRequestJoinFriendData>(
            "CMsgGCCStrike15_v2_ClientRequestJoinFriendData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientRequestJoinFriendData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.join_token = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.join_ipp = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.res)?;
                },
                50 => {
                    self.errormsg = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.join_token {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.join_ipp {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.res.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.errormsg.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.join_token {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.join_ipp {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.res.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.errormsg.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        CMsgGCCStrike15_v2_ClientRequestJoinFriendData::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.join_token = ::std::option::Option::None;
        self.join_ipp = ::std::option::Option::None;
        self.res.clear();
        self.errormsg = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        static instance: CMsgGCCStrike15_v2_ClientRequestJoinFriendData = CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
            version: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            join_token: ::std::option::Option::None,
            join_ipp: ::std::option::Option::None,
            res: ::protobuf::MessageField::none(),
            errormsg: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientRequestJoinFriendData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientRequestJoinServerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.serverid)
    pub serverid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.server_ip)
    pub server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.res)
    pub res: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.errormsg)
    pub errormsg: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        <CMsgGCCStrike15_v2_ClientRequestJoinServerData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 serverid = 3;

    pub fn serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }

    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    // optional uint32 server_ip = 4;

    pub fn server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 5;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional string errormsg = 7;

    pub fn errormsg(&self) -> &str {
        match self.errormsg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_errormsg(&mut self) {
        self.errormsg = ::std::option::Option::None;
    }

    pub fn has_errormsg(&self) -> bool {
        self.errormsg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errormsg(&mut self, v: ::std::string::String) {
        self.errormsg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errormsg(&mut self) -> &mut ::std::string::String {
        if self.errormsg.is_none() {
            self.errormsg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.errormsg.as_mut().unwrap()
    }

    // Take field
    pub fn take_errormsg(&mut self) -> ::std::string::String {
        self.errormsg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.version },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverid",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.serverid },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.serverid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_ip",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.server_ip },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_port",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.server_port },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
            "res",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.res },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.res },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "errormsg",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.errormsg },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.errormsg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientRequestJoinServerData>(
            "CMsgGCCStrike15_v2_ClientRequestJoinServerData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientRequestJoinServerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.serverid = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.res)?;
                },
                58 => {
                    self.errormsg = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.res.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.errormsg.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.serverid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.res.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.errormsg.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        CMsgGCCStrike15_v2_ClientRequestJoinServerData::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.serverid = ::std::option::Option::None;
        self.server_ip = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.res.clear();
        self.errormsg = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        static instance: CMsgGCCStrike15_v2_ClientRequestJoinServerData = CMsgGCCStrike15_v2_ClientRequestJoinServerData {
            version: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            serverid: ::std::option::Option::None,
            server_ip: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            res: ::protobuf::MessageField::none(),
            errormsg: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientRequestJoinServerData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCstrike15_v2_ClientRequestNewMission)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCstrike15_v2_ClientRequestNewMission {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRequestNewMission.mission_id)
    pub mission_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRequestNewMission.campaign_id)
    pub campaign_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCstrike15_v2_ClientRequestNewMission.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn default() -> &'a CMsgGCCstrike15_v2_ClientRequestNewMission {
        <CMsgGCCstrike15_v2_ClientRequestNewMission as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCstrike15_v2_ClientRequestNewMission {
    pub fn new() -> CMsgGCCstrike15_v2_ClientRequestNewMission {
        ::std::default::Default::default()
    }

    // optional uint32 mission_id = 2;

    pub fn mission_id(&self) -> u32 {
        self.mission_id.unwrap_or(0)
    }

    pub fn clear_mission_id(&mut self) {
        self.mission_id = ::std::option::Option::None;
    }

    pub fn has_mission_id(&self) -> bool {
        self.mission_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_id(&mut self, v: u32) {
        self.mission_id = ::std::option::Option::Some(v);
    }

    // optional uint32 campaign_id = 3;

    pub fn campaign_id(&self) -> u32 {
        self.campaign_id.unwrap_or(0)
    }

    pub fn clear_campaign_id(&mut self) {
        self.campaign_id = ::std::option::Option::None;
    }

    pub fn has_campaign_id(&self) -> bool {
        self.campaign_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaign_id(&mut self, v: u32) {
        self.campaign_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mission_id",
            |m: &CMsgGCCstrike15_v2_ClientRequestNewMission| { &m.mission_id },
            |m: &mut CMsgGCCstrike15_v2_ClientRequestNewMission| { &mut m.mission_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "campaign_id",
            |m: &CMsgGCCstrike15_v2_ClientRequestNewMission| { &m.campaign_id },
            |m: &mut CMsgGCCstrike15_v2_ClientRequestNewMission| { &mut m.campaign_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCstrike15_v2_ClientRequestNewMission>(
            "CMsgGCCstrike15_v2_ClientRequestNewMission",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCstrike15_v2_ClientRequestNewMission {
    const NAME: &'static str = "CMsgGCCstrike15_v2_ClientRequestNewMission";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.mission_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.campaign_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mission_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.campaign_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mission_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.campaign_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCstrike15_v2_ClientRequestNewMission {
        CMsgGCCstrike15_v2_ClientRequestNewMission::new()
    }

    fn clear(&mut self) {
        self.mission_id = ::std::option::Option::None;
        self.campaign_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCstrike15_v2_ClientRequestNewMission {
        static instance: CMsgGCCstrike15_v2_ClientRequestNewMission = CMsgGCCstrike15_v2_ClientRequestNewMission {
            mission_id: ::std::option::Option::None,
            campaign_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCstrike15_v2_ClientRequestNewMission").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCstrike15_v2_ClientRequestNewMission {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCstrike15_v2_ClientRedeemMissionReward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCstrike15_v2_ClientRedeemMissionReward {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRedeemMissionReward.campaign_id)
    pub campaign_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRedeemMissionReward.redeem_id)
    pub redeem_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRedeemMissionReward.redeemable_balance)
    pub redeemable_balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRedeemMissionReward.expected_cost)
    pub expected_cost: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCstrike15_v2_ClientRedeemMissionReward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCstrike15_v2_ClientRedeemMissionReward {
    fn default() -> &'a CMsgGCCstrike15_v2_ClientRedeemMissionReward {
        <CMsgGCCstrike15_v2_ClientRedeemMissionReward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCstrike15_v2_ClientRedeemMissionReward {
    pub fn new() -> CMsgGCCstrike15_v2_ClientRedeemMissionReward {
        ::std::default::Default::default()
    }

    // optional uint32 campaign_id = 1;

    pub fn campaign_id(&self) -> u32 {
        self.campaign_id.unwrap_or(0)
    }

    pub fn clear_campaign_id(&mut self) {
        self.campaign_id = ::std::option::Option::None;
    }

    pub fn has_campaign_id(&self) -> bool {
        self.campaign_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaign_id(&mut self, v: u32) {
        self.campaign_id = ::std::option::Option::Some(v);
    }

    // optional uint32 redeem_id = 2;

    pub fn redeem_id(&self) -> u32 {
        self.redeem_id.unwrap_or(0)
    }

    pub fn clear_redeem_id(&mut self) {
        self.redeem_id = ::std::option::Option::None;
    }

    pub fn has_redeem_id(&self) -> bool {
        self.redeem_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redeem_id(&mut self, v: u32) {
        self.redeem_id = ::std::option::Option::Some(v);
    }

    // optional uint32 redeemable_balance = 3;

    pub fn redeemable_balance(&self) -> u32 {
        self.redeemable_balance.unwrap_or(0)
    }

    pub fn clear_redeemable_balance(&mut self) {
        self.redeemable_balance = ::std::option::Option::None;
    }

    pub fn has_redeemable_balance(&self) -> bool {
        self.redeemable_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redeemable_balance(&mut self, v: u32) {
        self.redeemable_balance = ::std::option::Option::Some(v);
    }

    // optional uint32 expected_cost = 4;

    pub fn expected_cost(&self) -> u32 {
        self.expected_cost.unwrap_or(0)
    }

    pub fn clear_expected_cost(&mut self) {
        self.expected_cost = ::std::option::Option::None;
    }

    pub fn has_expected_cost(&self) -> bool {
        self.expected_cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expected_cost(&mut self, v: u32) {
        self.expected_cost = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "campaign_id",
            |m: &CMsgGCCstrike15_v2_ClientRedeemMissionReward| { &m.campaign_id },
            |m: &mut CMsgGCCstrike15_v2_ClientRedeemMissionReward| { &mut m.campaign_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "redeem_id",
            |m: &CMsgGCCstrike15_v2_ClientRedeemMissionReward| { &m.redeem_id },
            |m: &mut CMsgGCCstrike15_v2_ClientRedeemMissionReward| { &mut m.redeem_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "redeemable_balance",
            |m: &CMsgGCCstrike15_v2_ClientRedeemMissionReward| { &m.redeemable_balance },
            |m: &mut CMsgGCCstrike15_v2_ClientRedeemMissionReward| { &mut m.redeemable_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expected_cost",
            |m: &CMsgGCCstrike15_v2_ClientRedeemMissionReward| { &m.expected_cost },
            |m: &mut CMsgGCCstrike15_v2_ClientRedeemMissionReward| { &mut m.expected_cost },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCstrike15_v2_ClientRedeemMissionReward>(
            "CMsgGCCstrike15_v2_ClientRedeemMissionReward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCstrike15_v2_ClientRedeemMissionReward {
    const NAME: &'static str = "CMsgGCCstrike15_v2_ClientRedeemMissionReward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.campaign_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.redeem_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.redeemable_balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.expected_cost = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.campaign_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.redeem_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.redeemable_balance {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.expected_cost {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.campaign_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.redeem_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.redeemable_balance {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.expected_cost {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCstrike15_v2_ClientRedeemMissionReward {
        CMsgGCCstrike15_v2_ClientRedeemMissionReward::new()
    }

    fn clear(&mut self) {
        self.campaign_id = ::std::option::Option::None;
        self.redeem_id = ::std::option::Option::None;
        self.redeemable_balance = ::std::option::Option::None;
        self.expected_cost = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCstrike15_v2_ClientRedeemMissionReward {
        static instance: CMsgGCCstrike15_v2_ClientRedeemMissionReward = CMsgGCCstrike15_v2_ClientRedeemMissionReward {
            campaign_id: ::std::option::Option::None,
            redeem_id: ::std::option::Option::None,
            redeemable_balance: ::std::option::Option::None,
            expected_cost: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCstrike15_v2_ClientRedeemMissionReward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCstrike15_v2_ClientRedeemMissionReward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCstrike15_v2_ClientRedeemMissionReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCstrike15_v2_ClientRedeemMissionReward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCstrike15_v2_ClientRedeemFreeReward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCstrike15_v2_ClientRedeemFreeReward {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRedeemFreeReward.generation_time)
    pub generation_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRedeemFreeReward.redeemable_balance)
    pub redeemable_balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRedeemFreeReward.items)
    pub items: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCstrike15_v2_ClientRedeemFreeReward.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCstrike15_v2_ClientRedeemFreeReward {
    fn default() -> &'a CMsgGCCstrike15_v2_ClientRedeemFreeReward {
        <CMsgGCCstrike15_v2_ClientRedeemFreeReward as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCstrike15_v2_ClientRedeemFreeReward {
    pub fn new() -> CMsgGCCstrike15_v2_ClientRedeemFreeReward {
        ::std::default::Default::default()
    }

    // optional uint32 generation_time = 1;

    pub fn generation_time(&self) -> u32 {
        self.generation_time.unwrap_or(0)
    }

    pub fn clear_generation_time(&mut self) {
        self.generation_time = ::std::option::Option::None;
    }

    pub fn has_generation_time(&self) -> bool {
        self.generation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation_time(&mut self, v: u32) {
        self.generation_time = ::std::option::Option::Some(v);
    }

    // optional uint32 redeemable_balance = 2;

    pub fn redeemable_balance(&self) -> u32 {
        self.redeemable_balance.unwrap_or(0)
    }

    pub fn clear_redeemable_balance(&mut self) {
        self.redeemable_balance = ::std::option::Option::None;
    }

    pub fn has_redeemable_balance(&self) -> bool {
        self.redeemable_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redeemable_balance(&mut self, v: u32) {
        self.redeemable_balance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generation_time",
            |m: &CMsgGCCstrike15_v2_ClientRedeemFreeReward| { &m.generation_time },
            |m: &mut CMsgGCCstrike15_v2_ClientRedeemFreeReward| { &mut m.generation_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "redeemable_balance",
            |m: &CMsgGCCstrike15_v2_ClientRedeemFreeReward| { &m.redeemable_balance },
            |m: &mut CMsgGCCstrike15_v2_ClientRedeemFreeReward| { &mut m.redeemable_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CMsgGCCstrike15_v2_ClientRedeemFreeReward| { &m.items },
            |m: &mut CMsgGCCstrike15_v2_ClientRedeemFreeReward| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCstrike15_v2_ClientRedeemFreeReward>(
            "CMsgGCCstrike15_v2_ClientRedeemFreeReward",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCstrike15_v2_ClientRedeemFreeReward {
    const NAME: &'static str = "CMsgGCCstrike15_v2_ClientRedeemFreeReward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.generation_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.redeemable_balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.items)?;
                },
                24 => {
                    self.items.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.generation_time {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.redeemable_balance {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.items {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.generation_time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.redeemable_balance {
            os.write_uint32(2, v)?;
        }
        for v in &self.items {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCstrike15_v2_ClientRedeemFreeReward {
        CMsgGCCstrike15_v2_ClientRedeemFreeReward::new()
    }

    fn clear(&mut self) {
        self.generation_time = ::std::option::Option::None;
        self.redeemable_balance = ::std::option::Option::None;
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCstrike15_v2_ClientRedeemFreeReward {
        static instance: CMsgGCCstrike15_v2_ClientRedeemFreeReward = CMsgGCCstrike15_v2_ClientRedeemFreeReward {
            generation_time: ::std::option::Option::None,
            redeemable_balance: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCstrike15_v2_ClientRedeemFreeReward {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCstrike15_v2_ClientRedeemFreeReward").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCstrike15_v2_ClientRedeemFreeReward {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCstrike15_v2_ClientRedeemFreeReward {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.xp_progress_data)
    pub xp_progress_data: ::std::vec::Vec<XpProgressData>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.current_xp)
    pub current_xp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.current_level)
    pub current_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.upgraded_defidx)
    pub upgraded_defidx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.operation_points_awarded)
    pub operation_points_awarded: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.free_rewards)
    pub free_rewards: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn default() -> &'a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        <CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    pub fn new() -> CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 current_xp = 3;

    pub fn current_xp(&self) -> u32 {
        self.current_xp.unwrap_or(0)
    }

    pub fn clear_current_xp(&mut self) {
        self.current_xp = ::std::option::Option::None;
    }

    pub fn has_current_xp(&self) -> bool {
        self.current_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_xp(&mut self, v: u32) {
        self.current_xp = ::std::option::Option::Some(v);
    }

    // optional uint32 current_level = 4;

    pub fn current_level(&self) -> u32 {
        self.current_level.unwrap_or(0)
    }

    pub fn clear_current_level(&mut self) {
        self.current_level = ::std::option::Option::None;
    }

    pub fn has_current_level(&self) -> bool {
        self.current_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_level(&mut self, v: u32) {
        self.current_level = ::std::option::Option::Some(v);
    }

    // optional uint32 upgraded_defidx = 5;

    pub fn upgraded_defidx(&self) -> u32 {
        self.upgraded_defidx.unwrap_or(0)
    }

    pub fn clear_upgraded_defidx(&mut self) {
        self.upgraded_defidx = ::std::option::Option::None;
    }

    pub fn has_upgraded_defidx(&self) -> bool {
        self.upgraded_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgraded_defidx(&mut self, v: u32) {
        self.upgraded_defidx = ::std::option::Option::Some(v);
    }

    // optional uint32 operation_points_awarded = 6;

    pub fn operation_points_awarded(&self) -> u32 {
        self.operation_points_awarded.unwrap_or(0)
    }

    pub fn clear_operation_points_awarded(&mut self) {
        self.operation_points_awarded = ::std::option::Option::None;
    }

    pub fn has_operation_points_awarded(&self) -> bool {
        self.operation_points_awarded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation_points_awarded(&mut self, v: u32) {
        self.operation_points_awarded = ::std::option::Option::Some(v);
    }

    // optional uint32 free_rewards = 7;

    pub fn free_rewards(&self) -> u32 {
        self.free_rewards.unwrap_or(0)
    }

    pub fn clear_free_rewards(&mut self) {
        self.free_rewards = ::std::option::Option::None;
    }

    pub fn has_free_rewards(&self) -> bool {
        self.free_rewards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_free_rewards(&mut self, v: u32) {
        self.free_rewards = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "xp_progress_data",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.xp_progress_data },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.xp_progress_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.account_id },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_xp",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.current_xp },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.current_xp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_level",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.current_level },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.current_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upgraded_defidx",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.upgraded_defidx },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.upgraded_defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operation_points_awarded",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.operation_points_awarded },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.operation_points_awarded },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "free_rewards",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.free_rewards },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.free_rewards },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>(
            "CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    const NAME: &'static str = "CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.xp_progress_data.push(is.read_message()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.current_xp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.current_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.upgraded_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.operation_points_awarded = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.free_rewards = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.xp_progress_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.current_xp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.current_level {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.upgraded_defidx {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.operation_points_awarded {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.free_rewards {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.xp_progress_data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.current_xp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.current_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.upgraded_defidx {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.operation_points_awarded {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.free_rewards {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::new()
    }

    fn clear(&mut self) {
        self.xp_progress_data.clear();
        self.account_id = ::std::option::Option::None;
        self.current_xp = ::std::option::Option::None;
        self.current_level = ::std::option::Option::None;
        self.upgraded_defidx = ::std::option::Option::None;
        self.operation_points_awarded = ::std::option::Option::None;
        self.free_rewards = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        static instance: CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
            xp_progress_data: ::std::vec::Vec::new(),
            account_id: ::std::option::Option::None,
            current_xp: ::std::option::Option::None,
            current_level: ::std::option::Option::None,
            upgraded_defidx: ::std::option::Option::None,
            operation_points_awarded: ::std::option::Option::None,
            free_rewards: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_ClientDeepStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_ClientDeepStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_ClientDeepStats.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_ClientDeepStats.range)
    pub range: ::protobuf::MessageField<cmsg_gccstrike15_client_deep_stats::DeepStatsRange>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_ClientDeepStats.matches)
    pub matches: ::std::vec::Vec<cmsg_gccstrike15_client_deep_stats::DeepStatsMatch>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_ClientDeepStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_ClientDeepStats {
    fn default() -> &'a CMsgGCCStrike15_ClientDeepStats {
        <CMsgGCCStrike15_ClientDeepStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_ClientDeepStats {
    pub fn new() -> CMsgGCCStrike15_ClientDeepStats {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_ClientDeepStats| { &m.account_id },
            |m: &mut CMsgGCCStrike15_ClientDeepStats| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_gccstrike15_client_deep_stats::DeepStatsRange>(
            "range",
            |m: &CMsgGCCStrike15_ClientDeepStats| { &m.range },
            |m: &mut CMsgGCCStrike15_ClientDeepStats| { &mut m.range },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matches",
            |m: &CMsgGCCStrike15_ClientDeepStats| { &m.matches },
            |m: &mut CMsgGCCStrike15_ClientDeepStats| { &mut m.matches },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_ClientDeepStats>(
            "CMsgGCCStrike15_ClientDeepStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_ClientDeepStats {
    const NAME: &'static str = "CMsgGCCStrike15_ClientDeepStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.range)?;
                },
                26 => {
                    self.matches.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.range.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.range.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.matches {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_ClientDeepStats {
        CMsgGCCStrike15_ClientDeepStats::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.range.clear();
        self.matches.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_ClientDeepStats {
        static instance: CMsgGCCStrike15_ClientDeepStats = CMsgGCCStrike15_ClientDeepStats {
            account_id: ::std::option::Option::None,
            range: ::protobuf::MessageField::none(),
            matches: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_ClientDeepStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_ClientDeepStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_ClientDeepStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_ClientDeepStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_ClientDeepStats`
pub mod cmsg_gccstrike15_client_deep_stats {
    // @@protoc_insertion_point(message:CMsgGCCStrike15_ClientDeepStats.DeepStatsRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeepStatsRange {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_ClientDeepStats.DeepStatsRange.begin)
        pub begin: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_ClientDeepStats.DeepStatsRange.end)
        pub end: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_ClientDeepStats.DeepStatsRange.frozen)
        pub frozen: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_ClientDeepStats.DeepStatsRange.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeepStatsRange {
        fn default() -> &'a DeepStatsRange {
            <DeepStatsRange as ::protobuf::Message>::default_instance()
        }
    }

    impl DeepStatsRange {
        pub fn new() -> DeepStatsRange {
            ::std::default::Default::default()
        }

        // optional uint32 begin = 1;

        pub fn begin(&self) -> u32 {
            self.begin.unwrap_or(0)
        }

        pub fn clear_begin(&mut self) {
            self.begin = ::std::option::Option::None;
        }

        pub fn has_begin(&self) -> bool {
            self.begin.is_some()
        }

        // Param is passed by value, moved
        pub fn set_begin(&mut self, v: u32) {
            self.begin = ::std::option::Option::Some(v);
        }

        // optional uint32 end = 2;

        pub fn end(&self) -> u32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: u32) {
            self.end = ::std::option::Option::Some(v);
        }

        // optional bool frozen = 3;

        pub fn frozen(&self) -> bool {
            self.frozen.unwrap_or(false)
        }

        pub fn clear_frozen(&mut self) {
            self.frozen = ::std::option::Option::None;
        }

        pub fn has_frozen(&self) -> bool {
            self.frozen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_frozen(&mut self, v: bool) {
            self.frozen = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "begin",
                |m: &DeepStatsRange| { &m.begin },
                |m: &mut DeepStatsRange| { &mut m.begin },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "end",
                |m: &DeepStatsRange| { &m.end },
                |m: &mut DeepStatsRange| { &mut m.end },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "frozen",
                |m: &DeepStatsRange| { &m.frozen },
                |m: &mut DeepStatsRange| { &mut m.frozen },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeepStatsRange>(
                "CMsgGCCStrike15_ClientDeepStats.DeepStatsRange",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DeepStatsRange {
        const NAME: &'static str = "DeepStatsRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.begin = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.frozen = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.begin {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.frozen {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.begin {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.frozen {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeepStatsRange {
            DeepStatsRange::new()
        }

        fn clear(&mut self) {
            self.begin = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.frozen = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeepStatsRange {
            static instance: DeepStatsRange = DeepStatsRange {
                begin: ::std::option::Option::None,
                end: ::std::option::Option::None,
                frozen: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DeepStatsRange {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_ClientDeepStats.DeepStatsRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeepStatsRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DeepStatsRange {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgGCCStrike15_ClientDeepStats.DeepStatsMatch)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeepStatsMatch {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_ClientDeepStats.DeepStatsMatch.player)
        pub player: ::protobuf::MessageField<super::DeepPlayerStatsEntry>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_ClientDeepStats.DeepStatsMatch.events)
        pub events: ::std::vec::Vec<super::DeepPlayerMatchEvent>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_ClientDeepStats.DeepStatsMatch.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeepStatsMatch {
        fn default() -> &'a DeepStatsMatch {
            <DeepStatsMatch as ::protobuf::Message>::default_instance()
        }
    }

    impl DeepStatsMatch {
        pub fn new() -> DeepStatsMatch {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::DeepPlayerStatsEntry>(
                "player",
                |m: &DeepStatsMatch| { &m.player },
                |m: &mut DeepStatsMatch| { &mut m.player },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "events",
                |m: &DeepStatsMatch| { &m.events },
                |m: &mut DeepStatsMatch| { &mut m.events },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeepStatsMatch>(
                "CMsgGCCStrike15_ClientDeepStats.DeepStatsMatch",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DeepStatsMatch {
        const NAME: &'static str = "DeepStatsMatch";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.player)?;
                    },
                    18 => {
                        self.events.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.events {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            for v in &self.events {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeepStatsMatch {
            DeepStatsMatch::new()
        }

        fn clear(&mut self) {
            self.player.clear();
            self.events.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeepStatsMatch {
            static instance: DeepStatsMatch = DeepStatsMatch {
                player: ::protobuf::MessageField::none(),
                events: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DeepStatsMatch {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_ClientDeepStats.DeepStatsMatch").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeepStatsMatch {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DeepStatsMatch {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_WatchInfoUsers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_WatchInfoUsers {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_WatchInfoUsers.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_WatchInfoUsers.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_WatchInfoUsers.watchable_match_infos)
    pub watchable_match_infos: ::std::vec::Vec<WatchableMatchInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_WatchInfoUsers.extended_timeout)
    pub extended_timeout: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_WatchInfoUsers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_WatchInfoUsers {
    fn default() -> &'a CMsgGCCStrike15_v2_WatchInfoUsers {
        <CMsgGCCStrike15_v2_WatchInfoUsers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_WatchInfoUsers {
    pub fn new() -> CMsgGCCStrike15_v2_WatchInfoUsers {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint32 extended_timeout = 5;

    pub fn extended_timeout(&self) -> u32 {
        self.extended_timeout.unwrap_or(0)
    }

    pub fn clear_extended_timeout(&mut self) {
        self.extended_timeout = ::std::option::Option::None;
    }

    pub fn has_extended_timeout(&self) -> bool {
        self.extended_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extended_timeout(&mut self, v: u32) {
        self.extended_timeout = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.request_id },
            |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.account_ids },
            |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "watchable_match_infos",
            |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.watchable_match_infos },
            |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.watchable_match_infos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "extended_timeout",
            |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.extended_timeout },
            |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.extended_timeout },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_WatchInfoUsers>(
            "CMsgGCCStrike15_v2_WatchInfoUsers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_WatchInfoUsers {
    const NAME: &'static str = "CMsgGCCStrike15_v2_WatchInfoUsers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                16 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                26 => {
                    self.watchable_match_infos.push(is.read_message()?);
                },
                40 => {
                    self.extended_timeout = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.watchable_match_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.extended_timeout {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.watchable_match_infos {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.extended_timeout {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_WatchInfoUsers {
        CMsgGCCStrike15_v2_WatchInfoUsers::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.watchable_match_infos.clear();
        self.extended_timeout = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_WatchInfoUsers {
        static instance: CMsgGCCStrike15_v2_WatchInfoUsers = CMsgGCCStrike15_v2_WatchInfoUsers {
            request_id: ::std::option::Option::None,
            account_ids: ::std::vec::Vec::new(),
            watchable_match_infos: ::std::vec::Vec::new(),
            extended_timeout: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_WatchInfoUsers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_WatchInfoUsers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientRequestPlayersProfile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestPlayersProfile.request_id__deprecated)
    pub request_id__deprecated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestPlayersProfile.account_ids__deprecated)
    pub account_ids__deprecated: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestPlayersProfile.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestPlayersProfile.request_level)
    pub request_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientRequestPlayersProfile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        <CMsgGCCStrike15_v2_ClientRequestPlayersProfile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        ::std::default::Default::default()
    }

    // optional uint32 request_id__deprecated = 1;

    pub fn request_id__deprecated(&self) -> u32 {
        self.request_id__deprecated.unwrap_or(0)
    }

    pub fn clear_request_id__deprecated(&mut self) {
        self.request_id__deprecated = ::std::option::Option::None;
    }

    pub fn has_request_id__deprecated(&self) -> bool {
        self.request_id__deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id__deprecated(&mut self, v: u32) {
        self.request_id__deprecated = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 3;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 request_level = 4;

    pub fn request_level(&self) -> u32 {
        self.request_level.unwrap_or(0)
    }

    pub fn clear_request_level(&mut self) {
        self.request_level = ::std::option::Option::None;
    }

    pub fn has_request_level(&self) -> bool {
        self.request_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_level(&mut self, v: u32) {
        self.request_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id__deprecated",
            |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.request_id__deprecated },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.request_id__deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids__deprecated",
            |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.account_ids__deprecated },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.account_ids__deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_level",
            |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.request_level },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.request_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientRequestPlayersProfile>(
            "CMsgGCCStrike15_v2_ClientRequestPlayersProfile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientRequestPlayersProfile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id__deprecated = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids__deprecated)?;
                },
                16 => {
                    self.account_ids__deprecated.push(is.read_uint32()?);
                },
                24 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.request_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id__deprecated {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.account_ids__deprecated {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.request_level {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id__deprecated {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids__deprecated {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.request_level {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        CMsgGCCStrike15_v2_ClientRequestPlayersProfile::new()
    }

    fn clear(&mut self) {
        self.request_id__deprecated = ::std::option::Option::None;
        self.account_ids__deprecated.clear();
        self.account_id = ::std::option::Option::None;
        self.request_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        static instance: CMsgGCCStrike15_v2_ClientRequestPlayersProfile = CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
            request_id__deprecated: ::std::option::Option::None,
            account_ids__deprecated: ::std::vec::Vec::new(),
            account_id: ::std::option::Option::None,
            request_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientRequestPlayersProfile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_PlayersProfile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_PlayersProfile {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayersProfile.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayersProfile.account_profiles)
    pub account_profiles: ::std::vec::Vec<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_PlayersProfile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayersProfile {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayersProfile {
        <CMsgGCCStrike15_v2_PlayersProfile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayersProfile {
    pub fn new() -> CMsgGCCStrike15_v2_PlayersProfile {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgGCCStrike15_v2_PlayersProfile| { &m.request_id },
            |m: &mut CMsgGCCStrike15_v2_PlayersProfile| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_profiles",
            |m: &CMsgGCCStrike15_v2_PlayersProfile| { &m.account_profiles },
            |m: &mut CMsgGCCStrike15_v2_PlayersProfile| { &mut m.account_profiles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_PlayersProfile>(
            "CMsgGCCStrike15_v2_PlayersProfile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayersProfile {
    const NAME: &'static str = "CMsgGCCStrike15_v2_PlayersProfile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.account_profiles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.account_profiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_profiles {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_PlayersProfile {
        CMsgGCCStrike15_v2_PlayersProfile::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.account_profiles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayersProfile {
        static instance: CMsgGCCStrike15_v2_PlayersProfile = CMsgGCCStrike15_v2_PlayersProfile {
            request_id: ::std::option::Option::None,
            account_profiles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_PlayersProfile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_PlayersProfile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_PlayersProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayersProfile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.caseid)
    pub caseid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.suspectid)
    pub suspectid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.fractionid)
    pub fractionid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.rpt_aimbot)
    pub rpt_aimbot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.rpt_wallhack)
    pub rpt_wallhack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.rpt_speedhack)
    pub rpt_speedhack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.rpt_teamharm)
    pub rpt_teamharm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.reason)
    pub reason: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        <CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        ::std::default::Default::default()
    }

    // optional uint64 caseid = 1;

    pub fn caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    // optional uint32 suspectid = 3;

    pub fn suspectid(&self) -> u32 {
        self.suspectid.unwrap_or(0)
    }

    pub fn clear_suspectid(&mut self) {
        self.suspectid = ::std::option::Option::None;
    }

    pub fn has_suspectid(&self) -> bool {
        self.suspectid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suspectid(&mut self, v: u32) {
        self.suspectid = ::std::option::Option::Some(v);
    }

    // optional uint32 fractionid = 4;

    pub fn fractionid(&self) -> u32 {
        self.fractionid.unwrap_or(0)
    }

    pub fn clear_fractionid(&mut self) {
        self.fractionid = ::std::option::Option::None;
    }

    pub fn has_fractionid(&self) -> bool {
        self.fractionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionid(&mut self, v: u32) {
        self.fractionid = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_aimbot = 5;

    pub fn rpt_aimbot(&self) -> u32 {
        self.rpt_aimbot.unwrap_or(0)
    }

    pub fn clear_rpt_aimbot(&mut self) {
        self.rpt_aimbot = ::std::option::Option::None;
    }

    pub fn has_rpt_aimbot(&self) -> bool {
        self.rpt_aimbot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_aimbot(&mut self, v: u32) {
        self.rpt_aimbot = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_wallhack = 6;

    pub fn rpt_wallhack(&self) -> u32 {
        self.rpt_wallhack.unwrap_or(0)
    }

    pub fn clear_rpt_wallhack(&mut self) {
        self.rpt_wallhack = ::std::option::Option::None;
    }

    pub fn has_rpt_wallhack(&self) -> bool {
        self.rpt_wallhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_wallhack(&mut self, v: u32) {
        self.rpt_wallhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_speedhack = 7;

    pub fn rpt_speedhack(&self) -> u32 {
        self.rpt_speedhack.unwrap_or(0)
    }

    pub fn clear_rpt_speedhack(&mut self) {
        self.rpt_speedhack = ::std::option::Option::None;
    }

    pub fn has_rpt_speedhack(&self) -> bool {
        self.rpt_speedhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_speedhack(&mut self, v: u32) {
        self.rpt_speedhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_teamharm = 8;

    pub fn rpt_teamharm(&self) -> u32 {
        self.rpt_teamharm.unwrap_or(0)
    }

    pub fn clear_rpt_teamharm(&mut self) {
        self.rpt_teamharm = ::std::option::Option::None;
    }

    pub fn has_rpt_teamharm(&self) -> bool {
        self.rpt_teamharm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_teamharm(&mut self, v: u32) {
        self.rpt_teamharm = ::std::option::Option::Some(v);
    }

    // optional uint32 reason = 9;

    pub fn reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caseid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.caseid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.caseid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suspectid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.suspectid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.suspectid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fractionid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.fractionid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.fractionid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_aimbot",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_aimbot },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_aimbot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_wallhack",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_wallhack },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_wallhack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_speedhack",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_speedhack },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_speedhack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_teamharm",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_teamharm },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_teamharm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.reason },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate>(
            "CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.caseid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.suspectid = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.fractionid = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rpt_aimbot = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.rpt_wallhack = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.rpt_speedhack = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.rpt_teamharm = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.suspectid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.fractionid {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rpt_aimbot {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.rpt_wallhack {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.rpt_speedhack {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.rpt_teamharm {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.suspectid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.fractionid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_aimbot {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rpt_wallhack {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rpt_speedhack {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.rpt_teamharm {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::new()
    }

    fn clear(&mut self) {
        self.caseid = ::std::option::Option::None;
        self.suspectid = ::std::option::Option::None;
        self.fractionid = ::std::option::Option::None;
        self.rpt_aimbot = ::std::option::Option::None;
        self.rpt_wallhack = ::std::option::Option::None;
        self.rpt_speedhack = ::std::option::Option::None;
        self.rpt_teamharm = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        static instance: CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
            caseid: ::std::option::Option::None,
            suspectid: ::std::option::Option::None,
            fractionid: ::std::option::Option::None,
            rpt_aimbot: ::std::option::Option::None,
            rpt_wallhack: ::std::option::Option::None,
            rpt_speedhack: ::std::option::Option::None,
            rpt_teamharm: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.caseid)
    pub caseid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.caseurl)
    pub caseurl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.verdict)
    pub verdict: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.throttleseconds)
    pub throttleseconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.suspectid)
    pub suspectid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.fractionid)
    pub fractionid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.numrounds)
    pub numrounds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.fractionrounds)
    pub fractionrounds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.streakconvictions)
    pub streakconvictions: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.reason)
    pub reason: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        <CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        ::std::default::Default::default()
    }

    // optional uint64 caseid = 1;

    pub fn caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    // optional string caseurl = 2;

    pub fn caseurl(&self) -> &str {
        match self.caseurl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caseurl(&mut self) {
        self.caseurl = ::std::option::Option::None;
    }

    pub fn has_caseurl(&self) -> bool {
        self.caseurl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseurl(&mut self, v: ::std::string::String) {
        self.caseurl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caseurl(&mut self) -> &mut ::std::string::String {
        if self.caseurl.is_none() {
            self.caseurl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caseurl.as_mut().unwrap()
    }

    // Take field
    pub fn take_caseurl(&mut self) -> ::std::string::String {
        self.caseurl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 verdict = 3;

    pub fn verdict(&self) -> u32 {
        self.verdict.unwrap_or(0)
    }

    pub fn clear_verdict(&mut self) {
        self.verdict = ::std::option::Option::None;
    }

    pub fn has_verdict(&self) -> bool {
        self.verdict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verdict(&mut self, v: u32) {
        self.verdict = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 4;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 throttleseconds = 5;

    pub fn throttleseconds(&self) -> u32 {
        self.throttleseconds.unwrap_or(0)
    }

    pub fn clear_throttleseconds(&mut self) {
        self.throttleseconds = ::std::option::Option::None;
    }

    pub fn has_throttleseconds(&self) -> bool {
        self.throttleseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttleseconds(&mut self, v: u32) {
        self.throttleseconds = ::std::option::Option::Some(v);
    }

    // optional uint32 suspectid = 6;

    pub fn suspectid(&self) -> u32 {
        self.suspectid.unwrap_or(0)
    }

    pub fn clear_suspectid(&mut self) {
        self.suspectid = ::std::option::Option::None;
    }

    pub fn has_suspectid(&self) -> bool {
        self.suspectid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suspectid(&mut self, v: u32) {
        self.suspectid = ::std::option::Option::Some(v);
    }

    // optional uint32 fractionid = 7;

    pub fn fractionid(&self) -> u32 {
        self.fractionid.unwrap_or(0)
    }

    pub fn clear_fractionid(&mut self) {
        self.fractionid = ::std::option::Option::None;
    }

    pub fn has_fractionid(&self) -> bool {
        self.fractionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionid(&mut self, v: u32) {
        self.fractionid = ::std::option::Option::Some(v);
    }

    // optional uint32 numrounds = 8;

    pub fn numrounds(&self) -> u32 {
        self.numrounds.unwrap_or(0)
    }

    pub fn clear_numrounds(&mut self) {
        self.numrounds = ::std::option::Option::None;
    }

    pub fn has_numrounds(&self) -> bool {
        self.numrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numrounds(&mut self, v: u32) {
        self.numrounds = ::std::option::Option::Some(v);
    }

    // optional uint32 fractionrounds = 9;

    pub fn fractionrounds(&self) -> u32 {
        self.fractionrounds.unwrap_or(0)
    }

    pub fn clear_fractionrounds(&mut self) {
        self.fractionrounds = ::std::option::Option::None;
    }

    pub fn has_fractionrounds(&self) -> bool {
        self.fractionrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionrounds(&mut self, v: u32) {
        self.fractionrounds = ::std::option::Option::Some(v);
    }

    // optional int32 streakconvictions = 10;

    pub fn streakconvictions(&self) -> i32 {
        self.streakconvictions.unwrap_or(0)
    }

    pub fn clear_streakconvictions(&mut self) {
        self.streakconvictions = ::std::option::Option::None;
    }

    pub fn has_streakconvictions(&self) -> bool {
        self.streakconvictions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streakconvictions(&mut self, v: i32) {
        self.streakconvictions = ::std::option::Option::Some(v);
    }

    // optional uint32 reason = 11;

    pub fn reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caseid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.caseid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.caseid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caseurl",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.caseurl },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.caseurl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verdict",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.verdict },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.verdict },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.timestamp },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "throttleseconds",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.throttleseconds },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.throttleseconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suspectid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.suspectid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.suspectid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fractionid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.fractionid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.fractionid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numrounds",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.numrounds },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.numrounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fractionrounds",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.fractionrounds },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.fractionrounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "streakconvictions",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.streakconvictions },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.streakconvictions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.reason },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment>(
            "CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    const NAME: &'static str = "CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.caseid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.caseurl = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.verdict = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.throttleseconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.suspectid = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.fractionid = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.numrounds = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.fractionrounds = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.streakconvictions = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.caseurl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.verdict {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.throttleseconds {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.suspectid {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.fractionid {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.numrounds {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.fractionrounds {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.streakconvictions {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.caseurl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.verdict {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.throttleseconds {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.suspectid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.fractionid {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.numrounds {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.fractionrounds {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.streakconvictions {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::new()
    }

    fn clear(&mut self) {
        self.caseid = ::std::option::Option::None;
        self.caseurl = ::std::option::Option::None;
        self.verdict = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.throttleseconds = ::std::option::Option::None;
        self.suspectid = ::std::option::Option::None;
        self.fractionid = ::std::option::Option::None;
        self.numrounds = ::std::option::Option::None;
        self.fractionrounds = ::std::option::Option::None;
        self.streakconvictions = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        static instance: CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
            caseid: ::std::option::Option::None,
            caseurl: ::std::option::Option::None,
            verdict: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            throttleseconds: ::std::option::Option::None,
            suspectid: ::std::option::Option::None,
            fractionid: ::std::option::Option::None,
            numrounds: ::std::option::Option::None,
            fractionrounds: ::std::option::Option::None,
            streakconvictions: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.caseid)
    pub caseid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.statusid)
    pub statusid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        <CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        ::std::default::Default::default()
    }

    // optional uint64 caseid = 1;

    pub fn caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    // optional uint32 statusid = 2;

    pub fn statusid(&self) -> u32 {
        self.statusid.unwrap_or(0)
    }

    pub fn clear_statusid(&mut self) {
        self.statusid = ::std::option::Option::None;
    }

    pub fn has_statusid(&self) -> bool {
        self.statusid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusid(&mut self, v: u32) {
        self.statusid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caseid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &m.caseid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &mut m.caseid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "statusid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &m.statusid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &mut m.statusid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus>(
            "CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    const NAME: &'static str = "CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.caseid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.statusid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.statusid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.statusid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::new()
    }

    fn clear(&mut self) {
        self.caseid = ::std::option::Option::None;
        self.statusid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        static instance: CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
            caseid: ::std::option::Option::None,
            statusid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientHeaderOverwatchEvidence)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientHeaderOverwatchEvidence {
    // message fields
    // @@protoc_insertion_point(field:CClientHeaderOverwatchEvidence.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientHeaderOverwatchEvidence.caseid)
    pub caseid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientHeaderOverwatchEvidence.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientHeaderOverwatchEvidence {
    fn default() -> &'a CClientHeaderOverwatchEvidence {
        <CClientHeaderOverwatchEvidence as ::protobuf::Message>::default_instance()
    }
}

impl CClientHeaderOverwatchEvidence {
    pub fn new() -> CClientHeaderOverwatchEvidence {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 caseid = 2;

    pub fn caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CClientHeaderOverwatchEvidence| { &m.accountid },
            |m: &mut CClientHeaderOverwatchEvidence| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caseid",
            |m: &CClientHeaderOverwatchEvidence| { &m.caseid },
            |m: &mut CClientHeaderOverwatchEvidence| { &mut m.caseid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientHeaderOverwatchEvidence>(
            "CClientHeaderOverwatchEvidence",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientHeaderOverwatchEvidence {
    const NAME: &'static str = "CClientHeaderOverwatchEvidence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.caseid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.caseid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientHeaderOverwatchEvidence {
        CClientHeaderOverwatchEvidence::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.caseid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientHeaderOverwatchEvidence {
        static instance: CClientHeaderOverwatchEvidence = CClientHeaderOverwatchEvidence {
            accountid: ::std::option::Option::None,
            caseid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientHeaderOverwatchEvidence {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientHeaderOverwatchEvidence").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientHeaderOverwatchEvidence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientHeaderOverwatchEvidence {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GC2ClientTextMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GC2ClientTextMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTextMsg.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTextMsg.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTextMsg.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GC2ClientTextMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ClientTextMsg {
        <CMsgGCCStrike15_v2_GC2ClientTextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ClientTextMsg {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 2;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 3;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgGCCStrike15_v2_GC2ClientTextMsg| { &m.id },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTextMsg| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgGCCStrike15_v2_GC2ClientTextMsg| { &m.type_ },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTextMsg| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &CMsgGCCStrike15_v2_GC2ClientTextMsg| { &m.payload },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTextMsg| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GC2ClientTextMsg>(
            "CMsgGCCStrike15_v2_GC2ClientTextMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GC2ClientTextMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ClientTextMsg {
        CMsgGCCStrike15_v2_GC2ClientTextMsg::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientTextMsg {
        static instance: CMsgGCCStrike15_v2_GC2ClientTextMsg = CMsgGCCStrike15_v2_GC2ClientTextMsg {
            id: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GC2ClientTextMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Client2GCTextMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Client2GCTextMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCTextMsg.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCTextMsg.args)
    pub args: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Client2GCTextMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCTextMsg {
        <CMsgGCCStrike15_v2_Client2GCTextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCTextMsg {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgGCCStrike15_v2_Client2GCTextMsg| { &m.id },
            |m: &mut CMsgGCCStrike15_v2_Client2GCTextMsg| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &CMsgGCCStrike15_v2_Client2GCTextMsg| { &m.args },
            |m: &mut CMsgGCCStrike15_v2_Client2GCTextMsg| { &mut m.args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Client2GCTextMsg>(
            "CMsgGCCStrike15_v2_Client2GCTextMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCTextMsg {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Client2GCTextMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.args.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.args {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        for v in &self.args {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCTextMsg {
        CMsgGCCStrike15_v2_Client2GCTextMsg::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCTextMsg {
        static instance: CMsgGCCStrike15_v2_Client2GCTextMsg = CMsgGCCStrike15_v2_Client2GCTextMsg {
            id: ::std::option::Option::None,
            args: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Client2GCTextMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCTextMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchEndRunRewardDrops)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchEndRunRewardDrops.serverinfo)
    pub serverinfo: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchEndRunRewardDrops.match_end_quest_data)
    pub match_end_quest_data: ::protobuf::MessageField<CMsgGC_ServerQuestUpdateData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchEndRunRewardDrops.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        <CMsgGCCStrike15_v2_MatchEndRunRewardDrops as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    pub fn new() -> CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>(
            "serverinfo",
            |m: &CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &m.serverinfo },
            |m: &mut CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &mut m.serverinfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGC_ServerQuestUpdateData>(
            "match_end_quest_data",
            |m: &CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &m.match_end_quest_data },
            |m: &mut CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &mut m.match_end_quest_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchEndRunRewardDrops>(
            "CMsgGCCStrike15_v2_MatchEndRunRewardDrops",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchEndRunRewardDrops";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.serverinfo)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_end_quest_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serverinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_end_quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serverinfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.match_end_quest_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        CMsgGCCStrike15_v2_MatchEndRunRewardDrops::new()
    }

    fn clear(&mut self) {
        self.serverinfo.clear();
        self.match_end_quest_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        static instance: CMsgGCCStrike15_v2_MatchEndRunRewardDrops = CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
            serverinfo: ::protobuf::MessageField::none(),
            match_end_quest_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchEndRunRewardDrops").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEconItemPreviewDataBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEconItemPreviewDataBlock {
    // message fields
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.itemid)
    pub itemid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.paintindex)
    pub paintindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.rarity)
    pub rarity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.paintwear)
    pub paintwear: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.paintseed)
    pub paintseed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.killeaterscoretype)
    pub killeaterscoretype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.killeatervalue)
    pub killeatervalue: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.customname)
    pub customname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.stickers)
    pub stickers: ::std::vec::Vec<cecon_item_preview_data_block::Sticker>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.origin)
    pub origin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.questid)
    pub questid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.dropreason)
    pub dropreason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.musicindex)
    pub musicindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.entindex)
    pub entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CEconItemPreviewDataBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEconItemPreviewDataBlock {
    fn default() -> &'a CEconItemPreviewDataBlock {
        <CEconItemPreviewDataBlock as ::protobuf::Message>::default_instance()
    }
}

impl CEconItemPreviewDataBlock {
    pub fn new() -> CEconItemPreviewDataBlock {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 itemid = 2;

    pub fn itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 3;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 paintindex = 4;

    pub fn paintindex(&self) -> u32 {
        self.paintindex.unwrap_or(0)
    }

    pub fn clear_paintindex(&mut self) {
        self.paintindex = ::std::option::Option::None;
    }

    pub fn has_paintindex(&self) -> bool {
        self.paintindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintindex(&mut self, v: u32) {
        self.paintindex = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 5;

    pub fn rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 6;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 paintwear = 7;

    pub fn paintwear(&self) -> u32 {
        self.paintwear.unwrap_or(0)
    }

    pub fn clear_paintwear(&mut self) {
        self.paintwear = ::std::option::Option::None;
    }

    pub fn has_paintwear(&self) -> bool {
        self.paintwear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintwear(&mut self, v: u32) {
        self.paintwear = ::std::option::Option::Some(v);
    }

    // optional uint32 paintseed = 8;

    pub fn paintseed(&self) -> u32 {
        self.paintseed.unwrap_or(0)
    }

    pub fn clear_paintseed(&mut self) {
        self.paintseed = ::std::option::Option::None;
    }

    pub fn has_paintseed(&self) -> bool {
        self.paintseed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintseed(&mut self, v: u32) {
        self.paintseed = ::std::option::Option::Some(v);
    }

    // optional uint32 killeaterscoretype = 9;

    pub fn killeaterscoretype(&self) -> u32 {
        self.killeaterscoretype.unwrap_or(0)
    }

    pub fn clear_killeaterscoretype(&mut self) {
        self.killeaterscoretype = ::std::option::Option::None;
    }

    pub fn has_killeaterscoretype(&self) -> bool {
        self.killeaterscoretype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killeaterscoretype(&mut self, v: u32) {
        self.killeaterscoretype = ::std::option::Option::Some(v);
    }

    // optional uint32 killeatervalue = 10;

    pub fn killeatervalue(&self) -> u32 {
        self.killeatervalue.unwrap_or(0)
    }

    pub fn clear_killeatervalue(&mut self) {
        self.killeatervalue = ::std::option::Option::None;
    }

    pub fn has_killeatervalue(&self) -> bool {
        self.killeatervalue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killeatervalue(&mut self, v: u32) {
        self.killeatervalue = ::std::option::Option::Some(v);
    }

    // optional string customname = 11;

    pub fn customname(&self) -> &str {
        match self.customname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_customname(&mut self) {
        self.customname = ::std::option::Option::None;
    }

    pub fn has_customname(&self) -> bool {
        self.customname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_customname(&mut self, v: ::std::string::String) {
        self.customname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_customname(&mut self) -> &mut ::std::string::String {
        if self.customname.is_none() {
            self.customname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.customname.as_mut().unwrap()
    }

    // Take field
    pub fn take_customname(&mut self) -> ::std::string::String {
        self.customname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 inventory = 13;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 14;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional uint32 questid = 15;

    pub fn questid(&self) -> u32 {
        self.questid.unwrap_or(0)
    }

    pub fn clear_questid(&mut self) {
        self.questid = ::std::option::Option::None;
    }

    pub fn has_questid(&self) -> bool {
        self.questid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_questid(&mut self, v: u32) {
        self.questid = ::std::option::Option::Some(v);
    }

    // optional uint32 dropreason = 16;

    pub fn dropreason(&self) -> u32 {
        self.dropreason.unwrap_or(0)
    }

    pub fn clear_dropreason(&mut self) {
        self.dropreason = ::std::option::Option::None;
    }

    pub fn has_dropreason(&self) -> bool {
        self.dropreason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dropreason(&mut self, v: u32) {
        self.dropreason = ::std::option::Option::Some(v);
    }

    // optional uint32 musicindex = 17;

    pub fn musicindex(&self) -> u32 {
        self.musicindex.unwrap_or(0)
    }

    pub fn clear_musicindex(&mut self) {
        self.musicindex = ::std::option::Option::None;
    }

    pub fn has_musicindex(&self) -> bool {
        self.musicindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_musicindex(&mut self, v: u32) {
        self.musicindex = ::std::option::Option::Some(v);
    }

    // optional int32 entindex = 18;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CEconItemPreviewDataBlock| { &m.accountid },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemid",
            |m: &CEconItemPreviewDataBlock| { &m.itemid },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.itemid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defindex",
            |m: &CEconItemPreviewDataBlock| { &m.defindex },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paintindex",
            |m: &CEconItemPreviewDataBlock| { &m.paintindex },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.paintindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rarity",
            |m: &CEconItemPreviewDataBlock| { &m.rarity },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.rarity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CEconItemPreviewDataBlock| { &m.quality },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paintwear",
            |m: &CEconItemPreviewDataBlock| { &m.paintwear },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.paintwear },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paintseed",
            |m: &CEconItemPreviewDataBlock| { &m.paintseed },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.paintseed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killeaterscoretype",
            |m: &CEconItemPreviewDataBlock| { &m.killeaterscoretype },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.killeaterscoretype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killeatervalue",
            |m: &CEconItemPreviewDataBlock| { &m.killeatervalue },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.killeatervalue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "customname",
            |m: &CEconItemPreviewDataBlock| { &m.customname },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.customname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stickers",
            |m: &CEconItemPreviewDataBlock| { &m.stickers },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.stickers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory",
            |m: &CEconItemPreviewDataBlock| { &m.inventory },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin",
            |m: &CEconItemPreviewDataBlock| { &m.origin },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "questid",
            |m: &CEconItemPreviewDataBlock| { &m.questid },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.questid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dropreason",
            |m: &CEconItemPreviewDataBlock| { &m.dropreason },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.dropreason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "musicindex",
            |m: &CEconItemPreviewDataBlock| { &m.musicindex },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.musicindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entindex",
            |m: &CEconItemPreviewDataBlock| { &m.entindex },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CEconItemPreviewDataBlock>(
            "CEconItemPreviewDataBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CEconItemPreviewDataBlock {
    const NAME: &'static str = "CEconItemPreviewDataBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.itemid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.paintindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rarity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.paintwear = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.paintseed = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.killeaterscoretype = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.killeatervalue = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.customname = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.stickers.push(is.read_message()?);
                },
                104 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.questid = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.dropreason = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.musicindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.paintindex {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.paintwear {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.paintseed {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.killeaterscoretype {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.killeatervalue {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.customname.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.stickers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.questid {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.dropreason {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.musicindex {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.itemid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.paintindex {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.paintwear {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.paintseed {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.killeaterscoretype {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.killeatervalue {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.customname.as_ref() {
            os.write_string(11, v)?;
        }
        for v in &self.stickers {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.inventory {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.questid {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.dropreason {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.musicindex {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEconItemPreviewDataBlock {
        CEconItemPreviewDataBlock::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.itemid = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.paintindex = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.paintwear = ::std::option::Option::None;
        self.paintseed = ::std::option::Option::None;
        self.killeaterscoretype = ::std::option::Option::None;
        self.killeatervalue = ::std::option::Option::None;
        self.customname = ::std::option::Option::None;
        self.stickers.clear();
        self.inventory = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.questid = ::std::option::Option::None;
        self.dropreason = ::std::option::Option::None;
        self.musicindex = ::std::option::Option::None;
        self.entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEconItemPreviewDataBlock {
        static instance: CEconItemPreviewDataBlock = CEconItemPreviewDataBlock {
            accountid: ::std::option::Option::None,
            itemid: ::std::option::Option::None,
            defindex: ::std::option::Option::None,
            paintindex: ::std::option::Option::None,
            rarity: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            paintwear: ::std::option::Option::None,
            paintseed: ::std::option::Option::None,
            killeaterscoretype: ::std::option::Option::None,
            killeatervalue: ::std::option::Option::None,
            customname: ::std::option::Option::None,
            stickers: ::std::vec::Vec::new(),
            inventory: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            questid: ::std::option::Option::None,
            dropreason: ::std::option::Option::None,
            musicindex: ::std::option::Option::None,
            entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CEconItemPreviewDataBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEconItemPreviewDataBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEconItemPreviewDataBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEconItemPreviewDataBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CEconItemPreviewDataBlock`
pub mod cecon_item_preview_data_block {
    // @@protoc_insertion_point(message:CEconItemPreviewDataBlock.Sticker)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Sticker {
        // message fields
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.slot)
        pub slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.sticker_id)
        pub sticker_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.wear)
        pub wear: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.scale)
        pub scale: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.rotation)
        pub rotation: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.tint_id)
        pub tint_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CEconItemPreviewDataBlock.Sticker.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sticker {
        fn default() -> &'a Sticker {
            <Sticker as ::protobuf::Message>::default_instance()
        }
    }

    impl Sticker {
        pub fn new() -> Sticker {
            ::std::default::Default::default()
        }

        // optional uint32 slot = 1;

        pub fn slot(&self) -> u32 {
            self.slot.unwrap_or(0)
        }

        pub fn clear_slot(&mut self) {
            self.slot = ::std::option::Option::None;
        }

        pub fn has_slot(&self) -> bool {
            self.slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot(&mut self, v: u32) {
            self.slot = ::std::option::Option::Some(v);
        }

        // optional uint32 sticker_id = 2;

        pub fn sticker_id(&self) -> u32 {
            self.sticker_id.unwrap_or(0)
        }

        pub fn clear_sticker_id(&mut self) {
            self.sticker_id = ::std::option::Option::None;
        }

        pub fn has_sticker_id(&self) -> bool {
            self.sticker_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sticker_id(&mut self, v: u32) {
            self.sticker_id = ::std::option::Option::Some(v);
        }

        // optional float wear = 3;

        pub fn wear(&self) -> f32 {
            self.wear.unwrap_or(0.)
        }

        pub fn clear_wear(&mut self) {
            self.wear = ::std::option::Option::None;
        }

        pub fn has_wear(&self) -> bool {
            self.wear.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wear(&mut self, v: f32) {
            self.wear = ::std::option::Option::Some(v);
        }

        // optional float scale = 4;

        pub fn scale(&self) -> f32 {
            self.scale.unwrap_or(0.)
        }

        pub fn clear_scale(&mut self) {
            self.scale = ::std::option::Option::None;
        }

        pub fn has_scale(&self) -> bool {
            self.scale.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scale(&mut self, v: f32) {
            self.scale = ::std::option::Option::Some(v);
        }

        // optional float rotation = 5;

        pub fn rotation(&self) -> f32 {
            self.rotation.unwrap_or(0.)
        }

        pub fn clear_rotation(&mut self) {
            self.rotation = ::std::option::Option::None;
        }

        pub fn has_rotation(&self) -> bool {
            self.rotation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rotation(&mut self, v: f32) {
            self.rotation = ::std::option::Option::Some(v);
        }

        // optional uint32 tint_id = 6;

        pub fn tint_id(&self) -> u32 {
            self.tint_id.unwrap_or(0)
        }

        pub fn clear_tint_id(&mut self) {
            self.tint_id = ::std::option::Option::None;
        }

        pub fn has_tint_id(&self) -> bool {
            self.tint_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tint_id(&mut self, v: u32) {
            self.tint_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot",
                |m: &Sticker| { &m.slot },
                |m: &mut Sticker| { &mut m.slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sticker_id",
                |m: &Sticker| { &m.sticker_id },
                |m: &mut Sticker| { &mut m.sticker_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wear",
                |m: &Sticker| { &m.wear },
                |m: &mut Sticker| { &mut m.wear },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scale",
                |m: &Sticker| { &m.scale },
                |m: &mut Sticker| { &mut m.scale },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rotation",
                |m: &Sticker| { &m.rotation },
                |m: &mut Sticker| { &mut m.rotation },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tint_id",
                |m: &Sticker| { &m.tint_id },
                |m: &mut Sticker| { &mut m.tint_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sticker>(
                "CEconItemPreviewDataBlock.Sticker",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sticker {
        const NAME: &'static str = "Sticker";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.sticker_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    29 => {
                        self.wear = ::std::option::Option::Some(is.read_float()?);
                    },
                    37 => {
                        self.scale = ::std::option::Option::Some(is.read_float()?);
                    },
                    45 => {
                        self.rotation = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.tint_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.sticker_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.wear {
                my_size += 1 + 4;
            }
            if let Some(v) = self.scale {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rotation {
                my_size += 1 + 4;
            }
            if let Some(v) = self.tint_id {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.slot {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.sticker_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.wear {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.scale {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.rotation {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.tint_id {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sticker {
            Sticker::new()
        }

        fn clear(&mut self) {
            self.slot = ::std::option::Option::None;
            self.sticker_id = ::std::option::Option::None;
            self.wear = ::std::option::Option::None;
            self.scale = ::std::option::Option::None;
            self.rotation = ::std::option::Option::None;
            self.tint_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sticker {
            static instance: Sticker = Sticker {
                slot: ::std::option::Option::None,
                sticker_id: ::std::option::Option::None,
                wear: ::std::option::Option::None,
                scale: ::std::option::Option::None,
                rotation: ::std::option::Option::None,
                tint_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sticker {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CEconItemPreviewDataBlock.Sticker").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sticker {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sticker {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchEndRewardDropsNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.iteminfo)
    pub iteminfo: ::protobuf::MessageField<CEconItemPreviewDataBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        <CMsgGCCStrike15_v2_MatchEndRewardDropsNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    pub fn new() -> CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CEconItemPreviewDataBlock>(
            "iteminfo",
            |m: &CMsgGCCStrike15_v2_MatchEndRewardDropsNotification| { &m.iteminfo },
            |m: &mut CMsgGCCStrike15_v2_MatchEndRewardDropsNotification| { &mut m.iteminfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchEndRewardDropsNotification>(
            "CMsgGCCStrike15_v2_MatchEndRewardDropsNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchEndRewardDropsNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.iteminfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.iteminfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        CMsgGCCStrike15_v2_MatchEndRewardDropsNotification::new()
    }

    fn clear(&mut self) {
        self.iteminfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        static instance: CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
            iteminfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchEndRewardDropsNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.param_s)
    pub param_s: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.param_a)
    pub param_a: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.param_d)
    pub param_d: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.param_m)
    pub param_m: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        <CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        ::std::default::Default::default()
    }

    // optional uint64 param_s = 1;

    pub fn param_s(&self) -> u64 {
        self.param_s.unwrap_or(0)
    }

    pub fn clear_param_s(&mut self) {
        self.param_s = ::std::option::Option::None;
    }

    pub fn has_param_s(&self) -> bool {
        self.param_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_s(&mut self, v: u64) {
        self.param_s = ::std::option::Option::Some(v);
    }

    // optional uint64 param_a = 2;

    pub fn param_a(&self) -> u64 {
        self.param_a.unwrap_or(0)
    }

    pub fn clear_param_a(&mut self) {
        self.param_a = ::std::option::Option::None;
    }

    pub fn has_param_a(&self) -> bool {
        self.param_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_a(&mut self, v: u64) {
        self.param_a = ::std::option::Option::Some(v);
    }

    // optional uint64 param_d = 3;

    pub fn param_d(&self) -> u64 {
        self.param_d.unwrap_or(0)
    }

    pub fn clear_param_d(&mut self) {
        self.param_d = ::std::option::Option::None;
    }

    pub fn has_param_d(&self) -> bool {
        self.param_d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_d(&mut self, v: u64) {
        self.param_d = ::std::option::Option::Some(v);
    }

    // optional uint64 param_m = 4;

    pub fn param_m(&self) -> u64 {
        self.param_m.unwrap_or(0)
    }

    pub fn clear_param_m(&mut self) {
        self.param_m = ::std::option::Option::None;
    }

    pub fn has_param_m(&self) -> bool {
        self.param_m.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_m(&mut self, v: u64) {
        self.param_m = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_s",
            |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_s },
            |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_a",
            |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_a },
            |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_d",
            |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_d },
            |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_m",
            |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_m },
            |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_m },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest>(
            "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.param_s = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.param_a = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.param_d = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.param_m = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.param_s {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.param_a {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.param_d {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.param_m {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.param_s {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.param_a {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.param_d {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.param_m {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::new()
    }

    fn clear(&mut self) {
        self.param_s = ::std::option::Option::None;
        self.param_a = ::std::option::Option::None;
        self.param_d = ::std::option::Option::None;
        self.param_m = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        static instance: CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
            param_s: ::std::option::Option::None,
            param_a: ::std::option::Option::None,
            param_d: ::std::option::Option::None,
            param_m: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.iteminfo)
    pub iteminfo: ::protobuf::MessageField<CEconItemPreviewDataBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        <CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CEconItemPreviewDataBlock>(
            "iteminfo",
            |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse| { &m.iteminfo },
            |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse| { &mut m.iteminfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse>(
            "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.iteminfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.iteminfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse::new()
    }

    fn clear(&mut self) {
        self.iteminfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        static instance: CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
            iteminfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        <CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames>(
            "CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        static instance: CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        <CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser| { &mut m.accountid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser>(
            "CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        static instance: CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
            accountid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListRequestRecentUserGames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        <CMsgGCCStrike15_v2_MatchListRequestRecentUserGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_MatchListRequestRecentUserGames| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestRecentUserGames| { &mut m.accountid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListRequestRecentUserGames>(
            "CMsgGCCStrike15_v2_MatchListRequestRecentUserGames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListRequestRecentUserGames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        CMsgGCCStrike15_v2_MatchListRequestRecentUserGames::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        static instance: CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
            accountid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListRequestRecentUserGames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListRequestTournamentGames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestTournamentGames.eventid)
    pub eventid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListRequestTournamentGames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        <CMsgGCCStrike15_v2_MatchListRequestTournamentGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        ::std::default::Default::default()
    }

    // optional int32 eventid = 1;

    pub fn eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CMsgGCCStrike15_v2_MatchListRequestTournamentGames| { &m.eventid },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestTournamentGames| { &mut m.eventid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListRequestTournamentGames>(
            "CMsgGCCStrike15_v2_MatchListRequestTournamentGames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListRequestTournamentGames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eventid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eventid {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        CMsgGCCStrike15_v2_MatchListRequestTournamentGames::new()
    }

    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        static instance: CMsgGCCStrike15_v2_MatchListRequestTournamentGames = CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
            eventid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListRequestTournamentGames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListRequestFullGameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.matchid)
    pub matchid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.outcomeid)
    pub outcomeid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.token)
    pub token: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        <CMsgGCCStrike15_v2_MatchListRequestFullGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        ::std::default::Default::default()
    }

    // optional uint64 matchid = 1;

    pub fn matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    // optional uint64 outcomeid = 2;

    pub fn outcomeid(&self) -> u64 {
        self.outcomeid.unwrap_or(0)
    }

    pub fn clear_outcomeid(&mut self) {
        self.outcomeid = ::std::option::Option::None;
    }

    pub fn has_outcomeid(&self) -> bool {
        self.outcomeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outcomeid(&mut self, v: u64) {
        self.outcomeid = ::std::option::Option::Some(v);
    }

    // optional uint32 token = 3;

    pub fn token(&self) -> u32 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchid",
            |m: &CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &m.matchid },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &mut m.matchid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "outcomeid",
            |m: &CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &m.outcomeid },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &mut m.outcomeid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &m.token },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListRequestFullGameInfo>(
            "CMsgGCCStrike15_v2_MatchListRequestFullGameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListRequestFullGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.matchid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.outcomeid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.token = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.outcomeid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matchid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.outcomeid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.token {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::new()
    }

    fn clear(&mut self) {
        self.matchid = ::std::option::Option::None;
        self.outcomeid = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        static instance: CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
            matchid: ::std::option::Option::None,
            outcomeid: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListRequestFullGameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDataGCCStrike15_v2_MatchInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDataGCCStrike15_v2_MatchInfo {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_MatchInfo.matchid)
    pub matchid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_MatchInfo.matchtime)
    pub matchtime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_MatchInfo.watchablematchinfo)
    pub watchablematchinfo: ::protobuf::MessageField<WatchableMatchInfo>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_MatchInfo.roundstats_legacy)
    pub roundstats_legacy: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_MatchInfo.roundstatsall)
    pub roundstatsall: ::std::vec::Vec<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_MatchInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_MatchInfo {
    fn default() -> &'a CDataGCCStrike15_v2_MatchInfo {
        <CDataGCCStrike15_v2_MatchInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_MatchInfo {
    pub fn new() -> CDataGCCStrike15_v2_MatchInfo {
        ::std::default::Default::default()
    }

    // optional uint64 matchid = 1;

    pub fn matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    // optional uint32 matchtime = 2;

    pub fn matchtime(&self) -> u32 {
        self.matchtime.unwrap_or(0)
    }

    pub fn clear_matchtime(&mut self) {
        self.matchtime = ::std::option::Option::None;
    }

    pub fn has_matchtime(&self) -> bool {
        self.matchtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchtime(&mut self, v: u32) {
        self.matchtime = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchid",
            |m: &CDataGCCStrike15_v2_MatchInfo| { &m.matchid },
            |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.matchid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchtime",
            |m: &CDataGCCStrike15_v2_MatchInfo| { &m.matchtime },
            |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.matchtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WatchableMatchInfo>(
            "watchablematchinfo",
            |m: &CDataGCCStrike15_v2_MatchInfo| { &m.watchablematchinfo },
            |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.watchablematchinfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingServerRoundStats>(
            "roundstats_legacy",
            |m: &CDataGCCStrike15_v2_MatchInfo| { &m.roundstats_legacy },
            |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.roundstats_legacy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "roundstatsall",
            |m: &CDataGCCStrike15_v2_MatchInfo| { &m.roundstatsall },
            |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.roundstatsall },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_MatchInfo>(
            "CDataGCCStrike15_v2_MatchInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_MatchInfo {
    const NAME: &'static str = "CDataGCCStrike15_v2_MatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.matchid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.matchtime = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.watchablematchinfo)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.roundstats_legacy)?;
                },
                42 => {
                    self.roundstatsall.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.matchtime {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.watchablematchinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.roundstats_legacy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.roundstatsall {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matchid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.matchtime {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.watchablematchinfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.roundstats_legacy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.roundstatsall {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_MatchInfo {
        CDataGCCStrike15_v2_MatchInfo::new()
    }

    fn clear(&mut self) {
        self.matchid = ::std::option::Option::None;
        self.matchtime = ::std::option::Option::None;
        self.watchablematchinfo.clear();
        self.roundstats_legacy.clear();
        self.roundstatsall.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_MatchInfo {
        static instance: CDataGCCStrike15_v2_MatchInfo = CDataGCCStrike15_v2_MatchInfo {
            matchid: ::std::option::Option::None,
            matchtime: ::std::option::Option::None,
            watchablematchinfo: ::protobuf::MessageField::none(),
            roundstats_legacy: ::protobuf::MessageField::none(),
            roundstatsall: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_MatchInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_MatchInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_MatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_MatchInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentGroupTeam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDataGCCStrike15_v2_TournamentGroupTeam {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroupTeam.team_id)
    pub team_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroupTeam.score)
    pub score: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroupTeam.correctpick)
    pub correctpick: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentGroupTeam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentGroupTeam {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentGroupTeam {
        <CDataGCCStrike15_v2_TournamentGroupTeam as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentGroupTeam {
    pub fn new() -> CDataGCCStrike15_v2_TournamentGroupTeam {
        ::std::default::Default::default()
    }

    // optional int32 team_id = 1;

    pub fn team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional int32 score = 2;

    pub fn score(&self) -> i32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional bool correctpick = 3;

    pub fn correctpick(&self) -> bool {
        self.correctpick.unwrap_or(false)
    }

    pub fn clear_correctpick(&mut self) {
        self.correctpick = ::std::option::Option::None;
    }

    pub fn has_correctpick(&self) -> bool {
        self.correctpick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correctpick(&mut self, v: bool) {
        self.correctpick = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CDataGCCStrike15_v2_TournamentGroupTeam| { &m.team_id },
            |m: &mut CDataGCCStrike15_v2_TournamentGroupTeam| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &CDataGCCStrike15_v2_TournamentGroupTeam| { &m.score },
            |m: &mut CDataGCCStrike15_v2_TournamentGroupTeam| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "correctpick",
            |m: &CDataGCCStrike15_v2_TournamentGroupTeam| { &m.correctpick },
            |m: &mut CDataGCCStrike15_v2_TournamentGroupTeam| { &mut m.correctpick },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_TournamentGroupTeam>(
            "CDataGCCStrike15_v2_TournamentGroupTeam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentGroupTeam {
    const NAME: &'static str = "CDataGCCStrike15_v2_TournamentGroupTeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.score = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.correctpick = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.correctpick {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.correctpick {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_TournamentGroupTeam {
        CDataGCCStrike15_v2_TournamentGroupTeam::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.correctpick = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentGroupTeam {
        static instance: CDataGCCStrike15_v2_TournamentGroupTeam = CDataGCCStrike15_v2_TournamentGroupTeam {
            team_id: ::std::option::Option::None,
            score: ::std::option::Option::None,
            correctpick: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentGroupTeam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentGroupTeam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentGroup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDataGCCStrike15_v2_TournamentGroup {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.groupid)
    pub groupid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.desc)
    pub desc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.picks__deprecated)
    pub picks__deprecated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.teams)
    pub teams: ::std::vec::Vec<CDataGCCStrike15_v2_TournamentGroupTeam>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.stage_ids)
    pub stage_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.picklockuntiltime)
    pub picklockuntiltime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.pickableteams)
    pub pickableteams: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.points_per_pick)
    pub points_per_pick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.picks)
    pub picks: ::std::vec::Vec<cdata_gccstrike15_v2_tournament_group::Picks>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentGroup {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentGroup {
        <CDataGCCStrike15_v2_TournamentGroup as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentGroup {
    pub fn new() -> CDataGCCStrike15_v2_TournamentGroup {
        ::std::default::Default::default()
    }

    // optional uint32 groupid = 1;

    pub fn groupid(&self) -> u32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: u32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc = 3;

    pub fn desc(&self) -> &str {
        match self.desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc(&mut self) {
        self.desc = ::std::option::Option::None;
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        if self.desc.is_none() {
            self.desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        self.desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 picks__deprecated = 4;

    pub fn picks__deprecated(&self) -> u32 {
        self.picks__deprecated.unwrap_or(0)
    }

    pub fn clear_picks__deprecated(&mut self) {
        self.picks__deprecated = ::std::option::Option::None;
    }

    pub fn has_picks__deprecated(&self) -> bool {
        self.picks__deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picks__deprecated(&mut self, v: u32) {
        self.picks__deprecated = ::std::option::Option::Some(v);
    }

    // optional uint32 picklockuntiltime = 7;

    pub fn picklockuntiltime(&self) -> u32 {
        self.picklockuntiltime.unwrap_or(0)
    }

    pub fn clear_picklockuntiltime(&mut self) {
        self.picklockuntiltime = ::std::option::Option::None;
    }

    pub fn has_picklockuntiltime(&self) -> bool {
        self.picklockuntiltime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picklockuntiltime(&mut self, v: u32) {
        self.picklockuntiltime = ::std::option::Option::Some(v);
    }

    // optional uint32 pickableteams = 8;

    pub fn pickableteams(&self) -> u32 {
        self.pickableteams.unwrap_or(0)
    }

    pub fn clear_pickableteams(&mut self) {
        self.pickableteams = ::std::option::Option::None;
    }

    pub fn has_pickableteams(&self) -> bool {
        self.pickableteams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pickableteams(&mut self, v: u32) {
        self.pickableteams = ::std::option::Option::Some(v);
    }

    // optional uint32 points_per_pick = 9;

    pub fn points_per_pick(&self) -> u32 {
        self.points_per_pick.unwrap_or(0)
    }

    pub fn clear_points_per_pick(&mut self) {
        self.points_per_pick = ::std::option::Option::None;
    }

    pub fn has_points_per_pick(&self) -> bool {
        self.points_per_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_per_pick(&mut self, v: u32) {
        self.points_per_pick = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupid",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.groupid },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.groupid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.name },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desc",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.desc },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.desc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "picks__deprecated",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.picks__deprecated },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.picks__deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.teams },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stage_ids",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.stage_ids },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.stage_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "picklockuntiltime",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.picklockuntiltime },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.picklockuntiltime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pickableteams",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.pickableteams },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.pickableteams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_per_pick",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.points_per_pick },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.points_per_pick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "picks",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.picks },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.picks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_TournamentGroup>(
            "CDataGCCStrike15_v2_TournamentGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentGroup {
    const NAME: &'static str = "CDataGCCStrike15_v2_TournamentGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groupid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.desc = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.picks__deprecated = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.teams.push(is.read_message()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.stage_ids)?;
                },
                48 => {
                    self.stage_ids.push(is.read_int32()?);
                },
                56 => {
                    self.picklockuntiltime = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.pickableteams = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.points_per_pick = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.picks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.desc.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.picks__deprecated {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.stage_ids {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        if let Some(v) = self.picklockuntiltime {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.pickableteams {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.points_per_pick {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.picks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.desc.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.picks__deprecated {
            os.write_uint32(4, v)?;
        }
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.stage_ids {
            os.write_int32(6, *v)?;
        };
        if let Some(v) = self.picklockuntiltime {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.pickableteams {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.points_per_pick {
            os.write_uint32(9, v)?;
        }
        for v in &self.picks {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_TournamentGroup {
        CDataGCCStrike15_v2_TournamentGroup::new()
    }

    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.desc = ::std::option::Option::None;
        self.picks__deprecated = ::std::option::Option::None;
        self.teams.clear();
        self.stage_ids.clear();
        self.picklockuntiltime = ::std::option::Option::None;
        self.pickableteams = ::std::option::Option::None;
        self.points_per_pick = ::std::option::Option::None;
        self.picks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentGroup {
        static instance: CDataGCCStrike15_v2_TournamentGroup = CDataGCCStrike15_v2_TournamentGroup {
            groupid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            desc: ::std::option::Option::None,
            picks__deprecated: ::std::option::Option::None,
            teams: ::std::vec::Vec::new(),
            stage_ids: ::std::vec::Vec::new(),
            picklockuntiltime: ::std::option::Option::None,
            pickableteams: ::std::option::Option::None,
            points_per_pick: ::std::option::Option::None,
            picks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_TournamentGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_TournamentGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDataGCCStrike15_v2_TournamentGroup`
pub mod cdata_gccstrike15_v2_tournament_group {
    // @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentGroup.Picks)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Picks {
        // message fields
        // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.Picks.pickids)
        pub pickids: ::std::vec::Vec<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentGroup.Picks.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Picks {
        fn default() -> &'a Picks {
            <Picks as ::protobuf::Message>::default_instance()
        }
    }

    impl Picks {
        pub fn new() -> Picks {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "pickids",
                |m: &Picks| { &m.pickids },
                |m: &mut Picks| { &mut m.pickids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Picks>(
                "CDataGCCStrike15_v2_TournamentGroup.Picks",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Picks {
        const NAME: &'static str = "Picks";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.pickids)?;
                    },
                    8 => {
                        self.pickids.push(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.pickids {
                my_size += ::protobuf::rt::int32_size(1, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.pickids {
                os.write_int32(1, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Picks {
            Picks::new()
        }

        fn clear(&mut self) {
            self.pickids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Picks {
            static instance: Picks = Picks {
                pickids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Picks {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentGroup.Picks").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Picks {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Picks {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentSection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDataGCCStrike15_v2_TournamentSection {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentSection.sectionid)
    pub sectionid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentSection.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentSection.desc)
    pub desc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentSection.groups)
    pub groups: ::std::vec::Vec<CDataGCCStrike15_v2_TournamentGroup>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentSection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentSection {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentSection {
        <CDataGCCStrike15_v2_TournamentSection as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentSection {
    pub fn new() -> CDataGCCStrike15_v2_TournamentSection {
        ::std::default::Default::default()
    }

    // optional uint32 sectionid = 1;

    pub fn sectionid(&self) -> u32 {
        self.sectionid.unwrap_or(0)
    }

    pub fn clear_sectionid(&mut self) {
        self.sectionid = ::std::option::Option::None;
    }

    pub fn has_sectionid(&self) -> bool {
        self.sectionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sectionid(&mut self, v: u32) {
        self.sectionid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc = 3;

    pub fn desc(&self) -> &str {
        match self.desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc(&mut self) {
        self.desc = ::std::option::Option::None;
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        if self.desc.is_none() {
            self.desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        self.desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sectionid",
            |m: &CDataGCCStrike15_v2_TournamentSection| { &m.sectionid },
            |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.sectionid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CDataGCCStrike15_v2_TournamentSection| { &m.name },
            |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desc",
            |m: &CDataGCCStrike15_v2_TournamentSection| { &m.desc },
            |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.desc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groups",
            |m: &CDataGCCStrike15_v2_TournamentSection| { &m.groups },
            |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_TournamentSection>(
            "CDataGCCStrike15_v2_TournamentSection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentSection {
    const NAME: &'static str = "CDataGCCStrike15_v2_TournamentSection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sectionid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.desc = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sectionid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.desc.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sectionid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.desc.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.groups {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_TournamentSection {
        CDataGCCStrike15_v2_TournamentSection::new()
    }

    fn clear(&mut self) {
        self.sectionid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.desc = ::std::option::Option::None;
        self.groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentSection {
        static instance: CDataGCCStrike15_v2_TournamentSection = CDataGCCStrike15_v2_TournamentSection {
            sectionid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            desc: ::std::option::Option::None,
            groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_TournamentSection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentSection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_TournamentSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentSection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDataGCCStrike15_v2_TournamentInfo {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentInfo.sections)
    pub sections: ::std::vec::Vec<CDataGCCStrike15_v2_TournamentSection>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentInfo.tournament_event)
    pub tournament_event: ::protobuf::MessageField<TournamentEvent>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentInfo.tournament_teams)
    pub tournament_teams: ::std::vec::Vec<TournamentTeam>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentInfo {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentInfo {
        <CDataGCCStrike15_v2_TournamentInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentInfo {
    pub fn new() -> CDataGCCStrike15_v2_TournamentInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sections",
            |m: &CDataGCCStrike15_v2_TournamentInfo| { &m.sections },
            |m: &mut CDataGCCStrike15_v2_TournamentInfo| { &mut m.sections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TournamentEvent>(
            "tournament_event",
            |m: &CDataGCCStrike15_v2_TournamentInfo| { &m.tournament_event },
            |m: &mut CDataGCCStrike15_v2_TournamentInfo| { &mut m.tournament_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tournament_teams",
            |m: &CDataGCCStrike15_v2_TournamentInfo| { &m.tournament_teams },
            |m: &mut CDataGCCStrike15_v2_TournamentInfo| { &mut m.tournament_teams },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_TournamentInfo>(
            "CDataGCCStrike15_v2_TournamentInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentInfo {
    const NAME: &'static str = "CDataGCCStrike15_v2_TournamentInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sections.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tournament_event)?;
                },
                26 => {
                    self.tournament_teams.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tournament_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tournament_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sections {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.tournament_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.tournament_teams {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_TournamentInfo {
        CDataGCCStrike15_v2_TournamentInfo::new()
    }

    fn clear(&mut self) {
        self.sections.clear();
        self.tournament_event.clear();
        self.tournament_teams.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentInfo {
        static instance: CDataGCCStrike15_v2_TournamentInfo = CDataGCCStrike15_v2_TournamentInfo {
            sections: ::std::vec::Vec::new(),
            tournament_event: ::protobuf::MessageField::none(),
            tournament_teams: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_TournamentInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_TournamentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchList {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.msgrequestid)
    pub msgrequestid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.servertime)
    pub servertime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.matches)
    pub matches: ::std::vec::Vec<CDataGCCStrike15_v2_MatchInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.streams)
    pub streams: ::std::vec::Vec<TournamentTeam>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.tournamentinfo)
    pub tournamentinfo: ::protobuf::MessageField<CDataGCCStrike15_v2_TournamentInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchList {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchList {
        <CMsgGCCStrike15_v2_MatchList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchList {
    pub fn new() -> CMsgGCCStrike15_v2_MatchList {
        ::std::default::Default::default()
    }

    // optional uint32 msgrequestid = 1;

    pub fn msgrequestid(&self) -> u32 {
        self.msgrequestid.unwrap_or(0)
    }

    pub fn clear_msgrequestid(&mut self) {
        self.msgrequestid = ::std::option::Option::None;
    }

    pub fn has_msgrequestid(&self) -> bool {
        self.msgrequestid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgrequestid(&mut self, v: u32) {
        self.msgrequestid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid = 2;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 servertime = 3;

    pub fn servertime(&self) -> u32 {
        self.servertime.unwrap_or(0)
    }

    pub fn clear_servertime(&mut self) {
        self.servertime = ::std::option::Option::None;
    }

    pub fn has_servertime(&self) -> bool {
        self.servertime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servertime(&mut self, v: u32) {
        self.servertime = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msgrequestid",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.msgrequestid },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.msgrequestid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "servertime",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.servertime },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.servertime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matches",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.matches },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "streams",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.streams },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.streams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDataGCCStrike15_v2_TournamentInfo>(
            "tournamentinfo",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.tournamentinfo },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.tournamentinfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchList>(
            "CMsgGCCStrike15_v2_MatchList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchList {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msgrequestid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.servertime = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.matches.push(is.read_message()?);
                },
                42 => {
                    self.streams.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tournamentinfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msgrequestid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.servertime {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tournamentinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msgrequestid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.servertime {
            os.write_uint32(3, v)?;
        }
        for v in &self.matches {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.streams {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.tournamentinfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchList {
        CMsgGCCStrike15_v2_MatchList::new()
    }

    fn clear(&mut self) {
        self.msgrequestid = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.servertime = ::std::option::Option::None;
        self.matches.clear();
        self.streams.clear();
        self.tournamentinfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchList {
        static instance: CMsgGCCStrike15_v2_MatchList = CMsgGCCStrike15_v2_MatchList {
            msgrequestid: ::std::option::Option::None,
            accountid: ::std::option::Option::None,
            servertime: ::std::option::Option::None,
            matches: ::std::vec::Vec::new(),
            streams: ::std::vec::Vec::new(),
            tournamentinfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt.eventid)
    pub eventid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt.matches)
    pub matches: ::std::vec::Vec<CDataGCCStrike15_v2_MatchInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
        <CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
        ::std::default::Default::default()
    }

    // optional int32 eventid = 1;

    pub fn eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid = 3;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt| { &m.eventid },
            |m: &mut CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt| { &mut m.eventid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matches",
            |m: &CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt| { &m.matches },
            |m: &mut CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt| { &mut m.matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt| { &mut m.accountid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt>(
            "CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eventid = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.matches.push(is.read_message()?);
                },
                24 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eventid {
            os.write_int32(1, v)?;
        }
        for v in &self.matches {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.accountid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
        CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt::new()
    }

    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.matches.clear();
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
        static instance: CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt = CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
            eventid: ::std::option::Option::None,
            matches: ::std::vec::Vec::new(),
            accountid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Predictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Predictions {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.group_match_team_picks)
    pub group_match_team_picks: ::std::vec::Vec<cmsg_gccstrike15_v2_predictions::GroupMatchTeamPick>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Predictions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Predictions {
    fn default() -> &'a CMsgGCCStrike15_v2_Predictions {
        <CMsgGCCStrike15_v2_Predictions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Predictions {
    pub fn new() -> CMsgGCCStrike15_v2_Predictions {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgGCCStrike15_v2_Predictions| { &m.event_id },
            |m: &mut CMsgGCCStrike15_v2_Predictions| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "group_match_team_picks",
            |m: &CMsgGCCStrike15_v2_Predictions| { &m.group_match_team_picks },
            |m: &mut CMsgGCCStrike15_v2_Predictions| { &mut m.group_match_team_picks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Predictions>(
            "CMsgGCCStrike15_v2_Predictions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Predictions {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Predictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.group_match_team_picks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.group_match_team_picks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.group_match_team_picks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Predictions {
        CMsgGCCStrike15_v2_Predictions::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.group_match_team_picks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Predictions {
        static instance: CMsgGCCStrike15_v2_Predictions = CMsgGCCStrike15_v2_Predictions {
            event_id: ::std::option::Option::None,
            group_match_team_picks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Predictions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Predictions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Predictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Predictions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_Predictions`
pub mod cmsg_gccstrike15_v2_predictions {
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GroupMatchTeamPick {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.sectionid)
        pub sectionid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.groupid)
        pub groupid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.teamid)
        pub teamid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.itemid)
        pub itemid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GroupMatchTeamPick {
        fn default() -> &'a GroupMatchTeamPick {
            <GroupMatchTeamPick as ::protobuf::Message>::default_instance()
        }
    }

    impl GroupMatchTeamPick {
        pub fn new() -> GroupMatchTeamPick {
            ::std::default::Default::default()
        }

        // optional int32 sectionid = 1;

        pub fn sectionid(&self) -> i32 {
            self.sectionid.unwrap_or(0)
        }

        pub fn clear_sectionid(&mut self) {
            self.sectionid = ::std::option::Option::None;
        }

        pub fn has_sectionid(&self) -> bool {
            self.sectionid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sectionid(&mut self, v: i32) {
            self.sectionid = ::std::option::Option::Some(v);
        }

        // optional int32 groupid = 2;

        pub fn groupid(&self) -> i32 {
            self.groupid.unwrap_or(0)
        }

        pub fn clear_groupid(&mut self) {
            self.groupid = ::std::option::Option::None;
        }

        pub fn has_groupid(&self) -> bool {
            self.groupid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_groupid(&mut self, v: i32) {
            self.groupid = ::std::option::Option::Some(v);
        }

        // optional int32 index = 3;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int32 teamid = 4;

        pub fn teamid(&self) -> i32 {
            self.teamid.unwrap_or(0)
        }

        pub fn clear_teamid(&mut self) {
            self.teamid = ::std::option::Option::None;
        }

        pub fn has_teamid(&self) -> bool {
            self.teamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamid(&mut self, v: i32) {
            self.teamid = ::std::option::Option::Some(v);
        }

        // optional uint64 itemid = 5;

        pub fn itemid(&self) -> u64 {
            self.itemid.unwrap_or(0)
        }

        pub fn clear_itemid(&mut self) {
            self.itemid = ::std::option::Option::None;
        }

        pub fn has_itemid(&self) -> bool {
            self.itemid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_itemid(&mut self, v: u64) {
            self.itemid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sectionid",
                |m: &GroupMatchTeamPick| { &m.sectionid },
                |m: &mut GroupMatchTeamPick| { &mut m.sectionid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "groupid",
                |m: &GroupMatchTeamPick| { &m.groupid },
                |m: &mut GroupMatchTeamPick| { &mut m.groupid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "index",
                |m: &GroupMatchTeamPick| { &m.index },
                |m: &mut GroupMatchTeamPick| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "teamid",
                |m: &GroupMatchTeamPick| { &m.teamid },
                |m: &mut GroupMatchTeamPick| { &mut m.teamid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "itemid",
                |m: &GroupMatchTeamPick| { &m.itemid },
                |m: &mut GroupMatchTeamPick| { &mut m.itemid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupMatchTeamPick>(
                "CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GroupMatchTeamPick {
        const NAME: &'static str = "GroupMatchTeamPick";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.sectionid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.groupid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.teamid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.itemid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.sectionid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.groupid {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.index {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.teamid {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.itemid {
                my_size += ::protobuf::rt::uint64_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.sectionid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.groupid {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.index {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.teamid {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.itemid {
                os.write_uint64(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GroupMatchTeamPick {
            GroupMatchTeamPick::new()
        }

        fn clear(&mut self) {
            self.sectionid = ::std::option::Option::None;
            self.groupid = ::std::option::Option::None;
            self.index = ::std::option::Option::None;
            self.teamid = ::std::option::Option::None;
            self.itemid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GroupMatchTeamPick {
            static instance: GroupMatchTeamPick = GroupMatchTeamPick {
                sectionid: ::std::option::Option::None,
                groupid: ::std::option::Option::None,
                index: ::std::option::Option::None,
                teamid: ::std::option::Option::None,
                itemid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GroupMatchTeamPick {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GroupMatchTeamPick {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GroupMatchTeamPick {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Fantasy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Fantasy {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.teams)
    pub teams: ::std::vec::Vec<cmsg_gccstrike15_v2_fantasy::FantasyTeam>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Fantasy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Fantasy {
    fn default() -> &'a CMsgGCCStrike15_v2_Fantasy {
        <CMsgGCCStrike15_v2_Fantasy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Fantasy {
    pub fn new() -> CMsgGCCStrike15_v2_Fantasy {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgGCCStrike15_v2_Fantasy| { &m.event_id },
            |m: &mut CMsgGCCStrike15_v2_Fantasy| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CMsgGCCStrike15_v2_Fantasy| { &m.teams },
            |m: &mut CMsgGCCStrike15_v2_Fantasy| { &mut m.teams },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Fantasy>(
            "CMsgGCCStrike15_v2_Fantasy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Fantasy {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Fantasy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.teams.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Fantasy {
        CMsgGCCStrike15_v2_Fantasy::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.teams.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Fantasy {
        static instance: CMsgGCCStrike15_v2_Fantasy = CMsgGCCStrike15_v2_Fantasy {
            event_id: ::std::option::Option::None,
            teams: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Fantasy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Fantasy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Fantasy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Fantasy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_Fantasy`
pub mod cmsg_gccstrike15_v2_fantasy {
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Fantasy.FantasySlot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FantasySlot {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.FantasySlot.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.FantasySlot.pick)
        pub pick: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.FantasySlot.itemid)
        pub itemid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Fantasy.FantasySlot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FantasySlot {
        fn default() -> &'a FantasySlot {
            <FantasySlot as ::protobuf::Message>::default_instance()
        }
    }

    impl FantasySlot {
        pub fn new() -> FantasySlot {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional int32 pick = 2;

        pub fn pick(&self) -> i32 {
            self.pick.unwrap_or(0)
        }

        pub fn clear_pick(&mut self) {
            self.pick = ::std::option::Option::None;
        }

        pub fn has_pick(&self) -> bool {
            self.pick.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pick(&mut self, v: i32) {
            self.pick = ::std::option::Option::Some(v);
        }

        // optional uint64 itemid = 3;

        pub fn itemid(&self) -> u64 {
            self.itemid.unwrap_or(0)
        }

        pub fn clear_itemid(&mut self) {
            self.itemid = ::std::option::Option::None;
        }

        pub fn has_itemid(&self) -> bool {
            self.itemid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_itemid(&mut self, v: u64) {
            self.itemid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &FantasySlot| { &m.type_ },
                |m: &mut FantasySlot| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pick",
                |m: &FantasySlot| { &m.pick },
                |m: &mut FantasySlot| { &mut m.pick },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "itemid",
                |m: &FantasySlot| { &m.itemid },
                |m: &mut FantasySlot| { &mut m.itemid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FantasySlot>(
                "CMsgGCCStrike15_v2_Fantasy.FantasySlot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FantasySlot {
        const NAME: &'static str = "FantasySlot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.pick = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.itemid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.pick {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.itemid {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.pick {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.itemid {
                os.write_uint64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FantasySlot {
            FantasySlot::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.pick = ::std::option::Option::None;
            self.itemid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FantasySlot {
            static instance: FantasySlot = FantasySlot {
                type_: ::std::option::Option::None,
                pick: ::std::option::Option::None,
                itemid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FantasySlot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Fantasy.FantasySlot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FantasySlot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FantasySlot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Fantasy.FantasyTeam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FantasyTeam {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.FantasyTeam.sectionid)
        pub sectionid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.FantasyTeam.slots)
        pub slots: ::std::vec::Vec<FantasySlot>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Fantasy.FantasyTeam.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FantasyTeam {
        fn default() -> &'a FantasyTeam {
            <FantasyTeam as ::protobuf::Message>::default_instance()
        }
    }

    impl FantasyTeam {
        pub fn new() -> FantasyTeam {
            ::std::default::Default::default()
        }

        // optional int32 sectionid = 1;

        pub fn sectionid(&self) -> i32 {
            self.sectionid.unwrap_or(0)
        }

        pub fn clear_sectionid(&mut self) {
            self.sectionid = ::std::option::Option::None;
        }

        pub fn has_sectionid(&self) -> bool {
            self.sectionid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sectionid(&mut self, v: i32) {
            self.sectionid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sectionid",
                |m: &FantasyTeam| { &m.sectionid },
                |m: &mut FantasyTeam| { &mut m.sectionid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "slots",
                |m: &FantasyTeam| { &m.slots },
                |m: &mut FantasyTeam| { &mut m.slots },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FantasyTeam>(
                "CMsgGCCStrike15_v2_Fantasy.FantasyTeam",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FantasyTeam {
        const NAME: &'static str = "FantasyTeam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.sectionid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.slots.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.sectionid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            for value in &self.slots {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.sectionid {
                os.write_int32(1, v)?;
            }
            for v in &self.slots {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FantasyTeam {
            FantasyTeam::new()
        }

        fn clear(&mut self) {
            self.sectionid = ::std::option::Option::None;
            self.slots.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FantasyTeam {
            static instance: FantasyTeam = FantasyTeam {
                sectionid: ::std::option::Option::None,
                slots: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FantasyTeam {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Fantasy.FantasyTeam").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FantasyTeam {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FantasyTeam {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgLegacySource1ClientWelcome)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLegacySource1ClientWelcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.game_data)
    pub game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.outofdate_subscribed_caches)
    pub outofdate_subscribed_caches: ::std::vec::Vec<super::gcsdk_gcmessages::CMsgSOCacheSubscribed>,
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.uptodate_subscribed_caches)
    pub uptodate_subscribed_caches: ::std::vec::Vec<super::gcsdk_gcmessages::CMsgSOCacheSubscriptionCheck>,
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.location)
    pub location: ::protobuf::MessageField<cmsg_legacy_source1client_welcome::Location>,
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.game_data2)
    pub game_data2: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.rtime32_gc_welcome_timestamp)
    pub rtime32_gc_welcome_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.currency)
    pub currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.balance)
    pub balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.balance_url)
    pub balance_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.txn_country_code)
    pub txn_country_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLegacySource1ClientWelcome.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLegacySource1ClientWelcome {
    fn default() -> &'a CMsgLegacySource1ClientWelcome {
        <CMsgLegacySource1ClientWelcome as ::protobuf::Message>::default_instance()
    }
}

impl CMsgLegacySource1ClientWelcome {
    pub fn new() -> CMsgLegacySource1ClientWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes game_data = 2;

    pub fn game_data(&self) -> &[u8] {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data = ::std::option::Option::None;
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data.is_none() {
            self.game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes game_data2 = 6;

    pub fn game_data2(&self) -> &[u8] {
        match self.game_data2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data2(&mut self) {
        self.game_data2 = ::std::option::Option::None;
    }

    pub fn has_game_data2(&self) -> bool {
        self.game_data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data2.is_none() {
            self.game_data2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 rtime32_gc_welcome_timestamp = 7;

    pub fn rtime32_gc_welcome_timestamp(&self) -> u32 {
        self.rtime32_gc_welcome_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_gc_welcome_timestamp(&mut self) {
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_gc_welcome_timestamp(&self) -> bool {
        self.rtime32_gc_welcome_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_gc_welcome_timestamp(&mut self, v: u32) {
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 8;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional uint32 balance = 9;

    pub fn balance(&self) -> u32 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: u32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional string balance_url = 10;

    pub fn balance_url(&self) -> &str {
        match self.balance_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_balance_url(&mut self) {
        self.balance_url = ::std::option::Option::None;
    }

    pub fn has_balance_url(&self) -> bool {
        self.balance_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_url(&mut self, v: ::std::string::String) {
        self.balance_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance_url(&mut self) -> &mut ::std::string::String {
        if self.balance_url.is_none() {
            self.balance_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.balance_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_balance_url(&mut self) -> ::std::string::String {
        self.balance_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string txn_country_code = 11;

    pub fn txn_country_code(&self) -> &str {
        match self.txn_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_txn_country_code(&mut self) {
        self.txn_country_code = ::std::option::Option::None;
    }

    pub fn has_txn_country_code(&self) -> bool {
        self.txn_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_country_code(&mut self, v: ::std::string::String) {
        self.txn_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_country_code(&mut self) -> &mut ::std::string::String {
        if self.txn_country_code.is_none() {
            self.txn_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.txn_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_country_code(&mut self) -> ::std::string::String {
        self.txn_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgLegacySource1ClientWelcome| { &m.version },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_data",
            |m: &CMsgLegacySource1ClientWelcome| { &m.game_data },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.game_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "outofdate_subscribed_caches",
            |m: &CMsgLegacySource1ClientWelcome| { &m.outofdate_subscribed_caches },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.outofdate_subscribed_caches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uptodate_subscribed_caches",
            |m: &CMsgLegacySource1ClientWelcome| { &m.uptodate_subscribed_caches },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.uptodate_subscribed_caches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_legacy_source1client_welcome::Location>(
            "location",
            |m: &CMsgLegacySource1ClientWelcome| { &m.location },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_data2",
            |m: &CMsgLegacySource1ClientWelcome| { &m.game_data2 },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.game_data2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime32_gc_welcome_timestamp",
            |m: &CMsgLegacySource1ClientWelcome| { &m.rtime32_gc_welcome_timestamp },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.rtime32_gc_welcome_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "currency",
            |m: &CMsgLegacySource1ClientWelcome| { &m.currency },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.currency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance",
            |m: &CMsgLegacySource1ClientWelcome| { &m.balance },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance_url",
            |m: &CMsgLegacySource1ClientWelcome| { &m.balance_url },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.balance_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "txn_country_code",
            |m: &CMsgLegacySource1ClientWelcome| { &m.txn_country_code },
            |m: &mut CMsgLegacySource1ClientWelcome| { &mut m.txn_country_code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgLegacySource1ClientWelcome>(
            "CMsgLegacySource1ClientWelcome",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgLegacySource1ClientWelcome {
    const NAME: &'static str = "CMsgLegacySource1ClientWelcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.outofdate_subscribed_caches.push(is.read_message()?);
                },
                34 => {
                    self.uptodate_subscribed_caches.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                50 => {
                    self.game_data2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.rtime32_gc_welcome_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.balance_url = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.txn_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.outofdate_subscribed_caches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.uptodate_subscribed_caches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_data2.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.rtime32_gc_welcome_timestamp {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.currency {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.balance_url.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.outofdate_subscribed_caches {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.uptodate_subscribed_caches {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.location.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.game_data2.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.rtime32_gc_welcome_timestamp {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.balance {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.balance_url.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLegacySource1ClientWelcome {
        CMsgLegacySource1ClientWelcome::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.game_data = ::std::option::Option::None;
        self.outofdate_subscribed_caches.clear();
        self.uptodate_subscribed_caches.clear();
        self.location.clear();
        self.game_data2 = ::std::option::Option::None;
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.balance_url = ::std::option::Option::None;
        self.txn_country_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLegacySource1ClientWelcome {
        static instance: CMsgLegacySource1ClientWelcome = CMsgLegacySource1ClientWelcome {
            version: ::std::option::Option::None,
            game_data: ::std::option::Option::None,
            outofdate_subscribed_caches: ::std::vec::Vec::new(),
            uptodate_subscribed_caches: ::std::vec::Vec::new(),
            location: ::protobuf::MessageField::none(),
            game_data2: ::std::option::Option::None,
            rtime32_gc_welcome_timestamp: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            balance_url: ::std::option::Option::None,
            txn_country_code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgLegacySource1ClientWelcome {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgLegacySource1ClientWelcome").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgLegacySource1ClientWelcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgLegacySource1ClientWelcome {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgLegacySource1ClientWelcome`
pub mod cmsg_legacy_source1client_welcome {
    // @@protoc_insertion_point(message:CMsgLegacySource1ClientWelcome.Location)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.Location.latitude)
        pub latitude: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.Location.longitude)
        pub longitude: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgLegacySource1ClientWelcome.Location.country)
        pub country: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgLegacySource1ClientWelcome.Location.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as ::protobuf::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional float latitude = 1;

        pub fn latitude(&self) -> f32 {
            self.latitude.unwrap_or(0.)
        }

        pub fn clear_latitude(&mut self) {
            self.latitude = ::std::option::Option::None;
        }

        pub fn has_latitude(&self) -> bool {
            self.latitude.is_some()
        }

        // Param is passed by value, moved
        pub fn set_latitude(&mut self, v: f32) {
            self.latitude = ::std::option::Option::Some(v);
        }

        // optional float longitude = 2;

        pub fn longitude(&self) -> f32 {
            self.longitude.unwrap_or(0.)
        }

        pub fn clear_longitude(&mut self) {
            self.longitude = ::std::option::Option::None;
        }

        pub fn has_longitude(&self) -> bool {
            self.longitude.is_some()
        }

        // Param is passed by value, moved
        pub fn set_longitude(&mut self, v: f32) {
            self.longitude = ::std::option::Option::Some(v);
        }

        // optional string country = 3;

        pub fn country(&self) -> &str {
            match self.country.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country(&mut self) {
            self.country = ::std::option::Option::None;
        }

        pub fn has_country(&self) -> bool {
            self.country.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country(&mut self, v: ::std::string::String) {
            self.country = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country(&mut self) -> &mut ::std::string::String {
            if self.country.is_none() {
                self.country = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country.as_mut().unwrap()
        }

        // Take field
        pub fn take_country(&mut self) -> ::std::string::String {
            self.country.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "latitude",
                |m: &Location| { &m.latitude },
                |m: &mut Location| { &mut m.latitude },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "longitude",
                |m: &Location| { &m.longitude },
                |m: &mut Location| { &mut m.longitude },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "country",
                |m: &Location| { &m.country },
                |m: &mut Location| { &mut m.country },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
                "CMsgLegacySource1ClientWelcome.Location",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.latitude = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.longitude = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.country = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.latitude {
                my_size += 1 + 4;
            }
            if let Some(v) = self.longitude {
                my_size += 1 + 4;
            }
            if let Some(v) = self.country.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.latitude {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.longitude {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.country.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.latitude = ::std::option::Option::None;
            self.longitude = ::std::option::Option::None;
            self.country = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                latitude: ::std::option::Option::None,
                longitude: ::std::option::Option::None,
                country: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Location {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgLegacySource1ClientWelcome.Location").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Location {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Location {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgCStrike15Welcome)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCStrike15Welcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.store_item_hash)
    pub store_item_hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.timeplayedconsecutively)
    pub timeplayedconsecutively: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.time_first_played)
    pub time_first_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.last_time_played)
    pub last_time_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.last_ip_address)
    pub last_ip_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.gscookieid)
    pub gscookieid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.uniqueid)
    pub uniqueid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCStrike15Welcome.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCStrike15Welcome {
    fn default() -> &'a CMsgCStrike15Welcome {
        <CMsgCStrike15Welcome as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCStrike15Welcome {
    pub fn new() -> CMsgCStrike15Welcome {
        ::std::default::Default::default()
    }

    // optional uint32 store_item_hash = 5;

    pub fn store_item_hash(&self) -> u32 {
        self.store_item_hash.unwrap_or(0)
    }

    pub fn clear_store_item_hash(&mut self) {
        self.store_item_hash = ::std::option::Option::None;
    }

    pub fn has_store_item_hash(&self) -> bool {
        self.store_item_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_item_hash(&mut self, v: u32) {
        self.store_item_hash = ::std::option::Option::Some(v);
    }

    // optional uint32 timeplayedconsecutively = 6;

    pub fn timeplayedconsecutively(&self) -> u32 {
        self.timeplayedconsecutively.unwrap_or(0)
    }

    pub fn clear_timeplayedconsecutively(&mut self) {
        self.timeplayedconsecutively = ::std::option::Option::None;
    }

    pub fn has_timeplayedconsecutively(&self) -> bool {
        self.timeplayedconsecutively.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeplayedconsecutively(&mut self, v: u32) {
        self.timeplayedconsecutively = ::std::option::Option::Some(v);
    }

    // optional uint32 time_first_played = 10;

    pub fn time_first_played(&self) -> u32 {
        self.time_first_played.unwrap_or(0)
    }

    pub fn clear_time_first_played(&mut self) {
        self.time_first_played = ::std::option::Option::None;
    }

    pub fn has_time_first_played(&self) -> bool {
        self.time_first_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_first_played(&mut self, v: u32) {
        self.time_first_played = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_played = 12;

    pub fn last_time_played(&self) -> u32 {
        self.last_time_played.unwrap_or(0)
    }

    pub fn clear_last_time_played(&mut self) {
        self.last_time_played = ::std::option::Option::None;
    }

    pub fn has_last_time_played(&self) -> bool {
        self.last_time_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_played(&mut self, v: u32) {
        self.last_time_played = ::std::option::Option::Some(v);
    }

    // optional uint32 last_ip_address = 13;

    pub fn last_ip_address(&self) -> u32 {
        self.last_ip_address.unwrap_or(0)
    }

    pub fn clear_last_ip_address(&mut self) {
        self.last_ip_address = ::std::option::Option::None;
    }

    pub fn has_last_ip_address(&self) -> bool {
        self.last_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ip_address(&mut self, v: u32) {
        self.last_ip_address = ::std::option::Option::Some(v);
    }

    // optional uint64 gscookieid = 18;

    pub fn gscookieid(&self) -> u64 {
        self.gscookieid.unwrap_or(0)
    }

    pub fn clear_gscookieid(&mut self) {
        self.gscookieid = ::std::option::Option::None;
    }

    pub fn has_gscookieid(&self) -> bool {
        self.gscookieid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gscookieid(&mut self, v: u64) {
        self.gscookieid = ::std::option::Option::Some(v);
    }

    // optional uint64 uniqueid = 19;

    pub fn uniqueid(&self) -> u64 {
        self.uniqueid.unwrap_or(0)
    }

    pub fn clear_uniqueid(&mut self) {
        self.uniqueid = ::std::option::Option::None;
    }

    pub fn has_uniqueid(&self) -> bool {
        self.uniqueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uniqueid(&mut self, v: u64) {
        self.uniqueid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "store_item_hash",
            |m: &CMsgCStrike15Welcome| { &m.store_item_hash },
            |m: &mut CMsgCStrike15Welcome| { &mut m.store_item_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeplayedconsecutively",
            |m: &CMsgCStrike15Welcome| { &m.timeplayedconsecutively },
            |m: &mut CMsgCStrike15Welcome| { &mut m.timeplayedconsecutively },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_first_played",
            |m: &CMsgCStrike15Welcome| { &m.time_first_played },
            |m: &mut CMsgCStrike15Welcome| { &mut m.time_first_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_time_played",
            |m: &CMsgCStrike15Welcome| { &m.last_time_played },
            |m: &mut CMsgCStrike15Welcome| { &mut m.last_time_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_ip_address",
            |m: &CMsgCStrike15Welcome| { &m.last_ip_address },
            |m: &mut CMsgCStrike15Welcome| { &mut m.last_ip_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gscookieid",
            |m: &CMsgCStrike15Welcome| { &m.gscookieid },
            |m: &mut CMsgCStrike15Welcome| { &mut m.gscookieid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uniqueid",
            |m: &CMsgCStrike15Welcome| { &m.uniqueid },
            |m: &mut CMsgCStrike15Welcome| { &mut m.uniqueid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCStrike15Welcome>(
            "CMsgCStrike15Welcome",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCStrike15Welcome {
    const NAME: &'static str = "CMsgCStrike15Welcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.store_item_hash = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.timeplayedconsecutively = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.time_first_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.last_time_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.last_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.gscookieid = ::std::option::Option::Some(is.read_uint64()?);
                },
                152 => {
                    self.uniqueid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.store_item_hash {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.timeplayedconsecutively {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.time_first_played {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.last_time_played {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.last_ip_address {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.gscookieid {
            my_size += ::protobuf::rt::uint64_size(18, v);
        }
        if let Some(v) = self.uniqueid {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.store_item_hash {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.timeplayedconsecutively {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.time_first_played {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.last_time_played {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.last_ip_address {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.gscookieid {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.uniqueid {
            os.write_uint64(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCStrike15Welcome {
        CMsgCStrike15Welcome::new()
    }

    fn clear(&mut self) {
        self.store_item_hash = ::std::option::Option::None;
        self.timeplayedconsecutively = ::std::option::Option::None;
        self.time_first_played = ::std::option::Option::None;
        self.last_time_played = ::std::option::Option::None;
        self.last_ip_address = ::std::option::Option::None;
        self.gscookieid = ::std::option::Option::None;
        self.uniqueid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCStrike15Welcome {
        static instance: CMsgCStrike15Welcome = CMsgCStrike15Welcome {
            store_item_hash: ::std::option::Option::None,
            timeplayedconsecutively: ::std::option::Option::None,
            time_first_played: ::std::option::Option::None,
            last_time_played: ::std::option::Option::None,
            last_ip_address: ::std::option::Option::None,
            gscookieid: ::std::option::Option::None,
            uniqueid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCStrike15Welcome {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCStrike15Welcome").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCStrike15Welcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCStrike15Welcome {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.value_name)
    pub value_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.value_int)
    pub value_int: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.server_addr)
    pub server_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.choked_blocks)
    pub choked_blocks: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        <CMsgGCCStrike15_v2_ClientVarValueNotificationInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    pub fn new() -> CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        ::std::default::Default::default()
    }

    // optional string value_name = 1;

    pub fn value_name(&self) -> &str {
        match self.value_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value_name(&mut self) {
        self.value_name = ::std::option::Option::None;
    }

    pub fn has_value_name(&self) -> bool {
        self.value_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_name(&mut self, v: ::std::string::String) {
        self.value_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_name(&mut self) -> &mut ::std::string::String {
        if self.value_name.is_none() {
            self.value_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_name(&mut self) -> ::std::string::String {
        self.value_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 value_int = 2;

    pub fn value_int(&self) -> i32 {
        self.value_int.unwrap_or(0)
    }

    pub fn clear_value_int(&mut self) {
        self.value_int = ::std::option::Option::None;
    }

    pub fn has_value_int(&self) -> bool {
        self.value_int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_int(&mut self, v: i32) {
        self.value_int = ::std::option::Option::Some(v);
    }

    // optional uint32 server_addr = 3;

    pub fn server_addr(&self) -> u32 {
        self.server_addr.unwrap_or(0)
    }

    pub fn clear_server_addr(&mut self) {
        self.server_addr = ::std::option::Option::None;
    }

    pub fn has_server_addr(&self) -> bool {
        self.server_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_addr(&mut self, v: u32) {
        self.server_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 4;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value_name",
            |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.value_name },
            |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.value_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value_int",
            |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.value_int },
            |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.value_int },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_addr",
            |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.server_addr },
            |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.server_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_port",
            |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.server_port },
            |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "choked_blocks",
            |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.choked_blocks },
            |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.choked_blocks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientVarValueNotificationInfo>(
            "CMsgGCCStrike15_v2_ClientVarValueNotificationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientVarValueNotificationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.value_int = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.server_addr = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.choked_blocks.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value_int {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.server_addr {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.choked_blocks {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value_int {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.server_addr {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(4, v)?;
        }
        for v in &self.choked_blocks {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::new()
    }

    fn clear(&mut self) {
        self.value_name = ::std::option::Option::None;
        self.value_int = ::std::option::Option::None;
        self.server_addr = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.choked_blocks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        static instance: CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
            value_name: ::std::option::Option::None,
            value_int: ::std::option::Option::None,
            server_addr: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            choked_blocks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientVarValueNotificationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.viewangles)
    pub viewangles: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.userdata)
    pub userdata: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        <CMsgGCCStrike15_v2_ServerVarValueNotificationInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    pub fn new() -> CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 3;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "viewangles",
            |m: &CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &m.viewangles },
            |m: &mut CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &mut m.viewangles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &m.type_ },
            |m: &mut CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "userdata",
            |m: &CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &m.userdata },
            |m: &mut CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &mut m.userdata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ServerVarValueNotificationInfo>(
            "CMsgGCCStrike15_v2_ServerVarValueNotificationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ServerVarValueNotificationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.viewangles)?;
                },
                16 => {
                    self.viewangles.push(is.read_uint32()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.userdata)?;
                },
                32 => {
                    self.userdata.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.viewangles {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.userdata {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        for v in &self.viewangles {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.type_ {
            os.write_uint32(3, v)?;
        }
        for v in &self.userdata {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.viewangles.clear();
        self.type_ = ::std::option::Option::None;
        self.userdata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        static instance: CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
            accountid: ::std::option::Option::None,
            viewangles: ::std::vec::Vec::new(),
            type_: ::std::option::Option::None,
            userdata: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ServerVarValueNotificationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GiftsLeaderboardRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GiftsLeaderboardRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn default() -> &'a CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        <CMsgGCCStrike15_v2_GiftsLeaderboardRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    pub fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GiftsLeaderboardRequest>(
            "CMsgGCCStrike15_v2_GiftsLeaderboardRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GiftsLeaderboardRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        CMsgGCCStrike15_v2_GiftsLeaderboardRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        static instance: CMsgGCCStrike15_v2_GiftsLeaderboardRequest = CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GiftsLeaderboardRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GiftsLeaderboardResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.servertime)
    pub servertime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.time_period_seconds)
    pub time_period_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.total_gifts_given)
    pub total_gifts_given: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.total_givers)
    pub total_givers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.entries)
    pub entries: ::std::vec::Vec<cmsg_gccstrike15_v2_gifts_leaderboard_response::GiftLeaderboardEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        <CMsgGCCStrike15_v2_GiftsLeaderboardResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    pub fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        ::std::default::Default::default()
    }

    // optional uint32 servertime = 1;

    pub fn servertime(&self) -> u32 {
        self.servertime.unwrap_or(0)
    }

    pub fn clear_servertime(&mut self) {
        self.servertime = ::std::option::Option::None;
    }

    pub fn has_servertime(&self) -> bool {
        self.servertime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servertime(&mut self, v: u32) {
        self.servertime = ::std::option::Option::Some(v);
    }

    // optional uint32 time_period_seconds = 2;

    pub fn time_period_seconds(&self) -> u32 {
        self.time_period_seconds.unwrap_or(0)
    }

    pub fn clear_time_period_seconds(&mut self) {
        self.time_period_seconds = ::std::option::Option::None;
    }

    pub fn has_time_period_seconds(&self) -> bool {
        self.time_period_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_period_seconds(&mut self, v: u32) {
        self.time_period_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 total_gifts_given = 3;

    pub fn total_gifts_given(&self) -> u32 {
        self.total_gifts_given.unwrap_or(0)
    }

    pub fn clear_total_gifts_given(&mut self) {
        self.total_gifts_given = ::std::option::Option::None;
    }

    pub fn has_total_gifts_given(&self) -> bool {
        self.total_gifts_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_gifts_given(&mut self, v: u32) {
        self.total_gifts_given = ::std::option::Option::Some(v);
    }

    // optional uint32 total_givers = 4;

    pub fn total_givers(&self) -> u32 {
        self.total_givers.unwrap_or(0)
    }

    pub fn clear_total_givers(&mut self) {
        self.total_givers = ::std::option::Option::None;
    }

    pub fn has_total_givers(&self) -> bool {
        self.total_givers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_givers(&mut self, v: u32) {
        self.total_givers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "servertime",
            |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.servertime },
            |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.servertime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_period_seconds",
            |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.time_period_seconds },
            |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.time_period_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_gifts_given",
            |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.total_gifts_given },
            |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.total_gifts_given },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_givers",
            |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.total_givers },
            |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.total_givers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.entries },
            |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GiftsLeaderboardResponse>(
            "CMsgGCCStrike15_v2_GiftsLeaderboardResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GiftsLeaderboardResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.servertime = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.time_period_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.total_gifts_given = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.total_givers = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.servertime {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.time_period_seconds {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.total_gifts_given {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.total_givers {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.servertime {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_period_seconds {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total_gifts_given {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.total_givers {
            os.write_uint32(4, v)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        CMsgGCCStrike15_v2_GiftsLeaderboardResponse::new()
    }

    fn clear(&mut self) {
        self.servertime = ::std::option::Option::None;
        self.time_period_seconds = ::std::option::Option::None;
        self.total_gifts_given = ::std::option::Option::None;
        self.total_givers = ::std::option::Option::None;
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        static instance: CMsgGCCStrike15_v2_GiftsLeaderboardResponse = CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
            servertime: ::std::option::Option::None,
            time_period_seconds: ::std::option::Option::None,
            total_gifts_given: ::std::option::Option::None,
            total_givers: ::std::option::Option::None,
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GiftsLeaderboardResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_GiftsLeaderboardResponse`
pub mod cmsg_gccstrike15_v2_gifts_leaderboard_response {
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GiftLeaderboardEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry.gifts)
        pub gifts: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GiftLeaderboardEntry {
        fn default() -> &'a GiftLeaderboardEntry {
            <GiftLeaderboardEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl GiftLeaderboardEntry {
        pub fn new() -> GiftLeaderboardEntry {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 gifts = 2;

        pub fn gifts(&self) -> u32 {
            self.gifts.unwrap_or(0)
        }

        pub fn clear_gifts(&mut self) {
            self.gifts = ::std::option::Option::None;
        }

        pub fn has_gifts(&self) -> bool {
            self.gifts.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gifts(&mut self, v: u32) {
            self.gifts = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &GiftLeaderboardEntry| { &m.accountid },
                |m: &mut GiftLeaderboardEntry| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gifts",
                |m: &GiftLeaderboardEntry| { &m.gifts },
                |m: &mut GiftLeaderboardEntry| { &mut m.gifts },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GiftLeaderboardEntry>(
                "CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GiftLeaderboardEntry {
        const NAME: &'static str = "GiftLeaderboardEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.gifts = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.gifts {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.gifts {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GiftLeaderboardEntry {
            GiftLeaderboardEntry::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.gifts = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GiftLeaderboardEntry {
            static instance: GiftLeaderboardEntry = GiftLeaderboardEntry {
                accountid: ::std::option::Option::None,
                gifts: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GiftLeaderboardEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GiftLeaderboardEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GiftLeaderboardEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientSubmitSurveyVote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientSubmitSurveyVote.survey_id)
    pub survey_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientSubmitSurveyVote.vote)
    pub vote: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientSubmitSurveyVote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        <CMsgGCCStrike15_v2_ClientSubmitSurveyVote as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    pub fn new() -> CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;

    pub fn survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    // optional uint32 vote = 2;

    pub fn vote(&self) -> u32 {
        self.vote.unwrap_or(0)
    }

    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: u32) {
        self.vote = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "survey_id",
            |m: &CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &m.survey_id },
            |m: &mut CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &mut m.survey_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote",
            |m: &CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &m.vote },
            |m: &mut CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &mut m.vote },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientSubmitSurveyVote>(
            "CMsgGCCStrike15_v2_ClientSubmitSurveyVote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientSubmitSurveyVote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.vote = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.vote {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.vote {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        CMsgGCCStrike15_v2_ClientSubmitSurveyVote::new()
    }

    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.vote = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        static instance: CMsgGCCStrike15_v2_ClientSubmitSurveyVote = CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
            survey_id: ::std::option::Option::None,
            vote: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientSubmitSurveyVote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Server2GCClientValidate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Server2GCClientValidate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Server2GCClientValidate.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Server2GCClientValidate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn default() -> &'a CMsgGCCStrike15_v2_Server2GCClientValidate {
        <CMsgGCCStrike15_v2_Server2GCClientValidate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Server2GCClientValidate {
    pub fn new() -> CMsgGCCStrike15_v2_Server2GCClientValidate {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_Server2GCClientValidate| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_Server2GCClientValidate| { &mut m.accountid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Server2GCClientValidate>(
            "CMsgGCCStrike15_v2_Server2GCClientValidate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Server2GCClientValidate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Server2GCClientValidate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Server2GCClientValidate {
        CMsgGCCStrike15_v2_Server2GCClientValidate::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Server2GCClientValidate {
        static instance: CMsgGCCStrike15_v2_Server2GCClientValidate = CMsgGCCStrike15_v2_Server2GCClientValidate {
            accountid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Server2GCClientValidate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Server2GCClientValidate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GC2ClientTournamentInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTournamentInfo.eventid)
    pub eventid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTournamentInfo.stageid)
    pub stageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTournamentInfo.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTournamentInfo.teamids)
    pub teamids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GC2ClientTournamentInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        <CMsgGCCStrike15_v2_GC2ClientTournamentInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        ::std::default::Default::default()
    }

    // optional uint32 eventid = 1;

    pub fn eventid(&self) -> u32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: u32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional uint32 stageid = 2;

    pub fn stageid(&self) -> u32 {
        self.stageid.unwrap_or(0)
    }

    pub fn clear_stageid(&mut self) {
        self.stageid = ::std::option::Option::None;
    }

    pub fn has_stageid(&self) -> bool {
        self.stageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stageid(&mut self, v: u32) {
        self.stageid = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 3;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.eventid },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.eventid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stageid",
            |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.stageid },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.stageid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.game_type },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teamids",
            |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.teamids },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.teamids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GC2ClientTournamentInfo>(
            "CMsgGCCStrike15_v2_GC2ClientTournamentInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GC2ClientTournamentInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eventid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.stageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.teamids)?;
                },
                32 => {
                    self.teamids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.stageid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.teamids {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eventid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stageid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(3, v)?;
        }
        for v in &self.teamids {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        CMsgGCCStrike15_v2_GC2ClientTournamentInfo::new()
    }

    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.stageid = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.teamids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        static instance: CMsgGCCStrike15_v2_GC2ClientTournamentInfo = CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
            eventid: ::std::option::Option::None,
            stageid: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            teamids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GC2ClientTournamentInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOEconCoupon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconCoupon {
    // message fields
    // @@protoc_insertion_point(field:CSOEconCoupon.entryid)
    pub entryid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconCoupon.defidx)
    pub defidx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconCoupon.expiration_date)
    pub expiration_date: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconCoupon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconCoupon {
    fn default() -> &'a CSOEconCoupon {
        <CSOEconCoupon as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconCoupon {
    pub fn new() -> CSOEconCoupon {
        ::std::default::Default::default()
    }

    // optional uint32 entryid = 1;

    pub fn entryid(&self) -> u32 {
        self.entryid.unwrap_or(0)
    }

    pub fn clear_entryid(&mut self) {
        self.entryid = ::std::option::Option::None;
    }

    pub fn has_entryid(&self) -> bool {
        self.entryid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryid(&mut self, v: u32) {
        self.entryid = ::std::option::Option::Some(v);
    }

    // optional uint32 defidx = 2;

    pub fn defidx(&self) -> u32 {
        self.defidx.unwrap_or(0)
    }

    pub fn clear_defidx(&mut self) {
        self.defidx = ::std::option::Option::None;
    }

    pub fn has_defidx(&self) -> bool {
        self.defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defidx(&mut self, v: u32) {
        self.defidx = ::std::option::Option::Some(v);
    }

    // optional fixed32 expiration_date = 3;

    pub fn expiration_date(&self) -> u32 {
        self.expiration_date.unwrap_or(0)
    }

    pub fn clear_expiration_date(&mut self) {
        self.expiration_date = ::std::option::Option::None;
    }

    pub fn has_expiration_date(&self) -> bool {
        self.expiration_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_date(&mut self, v: u32) {
        self.expiration_date = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entryid",
            |m: &CSOEconCoupon| { &m.entryid },
            |m: &mut CSOEconCoupon| { &mut m.entryid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defidx",
            |m: &CSOEconCoupon| { &m.defidx },
            |m: &mut CSOEconCoupon| { &mut m.defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_date",
            |m: &CSOEconCoupon| { &m.expiration_date },
            |m: &mut CSOEconCoupon| { &mut m.expiration_date },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconCoupon>(
            "CSOEconCoupon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconCoupon {
    const NAME: &'static str = "CSOEconCoupon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entryid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.expiration_date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entryid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.defidx {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.expiration_date {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entryid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.defidx {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_date {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconCoupon {
        CSOEconCoupon::new()
    }

    fn clear(&mut self) {
        self.entryid = ::std::option::Option::None;
        self.defidx = ::std::option::Option::None;
        self.expiration_date = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconCoupon {
        static instance: CSOEconCoupon = CSOEconCoupon {
            entryid: ::std::option::Option::None,
            defidx: ::std::option::Option::None,
            expiration_date: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconCoupon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconCoupon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconCoupon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconCoupon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOAccountItemPersonalStore)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOAccountItemPersonalStore {
    // message fields
    // @@protoc_insertion_point(field:CSOAccountItemPersonalStore.generation_time)
    pub generation_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOAccountItemPersonalStore.redeemable_balance)
    pub redeemable_balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOAccountItemPersonalStore.items)
    pub items: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOAccountItemPersonalStore.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOAccountItemPersonalStore {
    fn default() -> &'a CSOAccountItemPersonalStore {
        <CSOAccountItemPersonalStore as ::protobuf::Message>::default_instance()
    }
}

impl CSOAccountItemPersonalStore {
    pub fn new() -> CSOAccountItemPersonalStore {
        ::std::default::Default::default()
    }

    // optional uint32 generation_time = 1;

    pub fn generation_time(&self) -> u32 {
        self.generation_time.unwrap_or(0)
    }

    pub fn clear_generation_time(&mut self) {
        self.generation_time = ::std::option::Option::None;
    }

    pub fn has_generation_time(&self) -> bool {
        self.generation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation_time(&mut self, v: u32) {
        self.generation_time = ::std::option::Option::Some(v);
    }

    // optional uint32 redeemable_balance = 2;

    pub fn redeemable_balance(&self) -> u32 {
        self.redeemable_balance.unwrap_or(0)
    }

    pub fn clear_redeemable_balance(&mut self) {
        self.redeemable_balance = ::std::option::Option::None;
    }

    pub fn has_redeemable_balance(&self) -> bool {
        self.redeemable_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redeemable_balance(&mut self, v: u32) {
        self.redeemable_balance = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "generation_time",
            |m: &CSOAccountItemPersonalStore| { &m.generation_time },
            |m: &mut CSOAccountItemPersonalStore| { &mut m.generation_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "redeemable_balance",
            |m: &CSOAccountItemPersonalStore| { &m.redeemable_balance },
            |m: &mut CSOAccountItemPersonalStore| { &mut m.redeemable_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &CSOAccountItemPersonalStore| { &m.items },
            |m: &mut CSOAccountItemPersonalStore| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOAccountItemPersonalStore>(
            "CSOAccountItemPersonalStore",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOAccountItemPersonalStore {
    const NAME: &'static str = "CSOAccountItemPersonalStore";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.generation_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.redeemable_balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.items)?;
                },
                24 => {
                    self.items.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.generation_time {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.redeemable_balance {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.items {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.generation_time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.redeemable_balance {
            os.write_uint32(2, v)?;
        }
        for v in &self.items {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOAccountItemPersonalStore {
        CSOAccountItemPersonalStore::new()
    }

    fn clear(&mut self) {
        self.generation_time = ::std::option::Option::None;
        self.redeemable_balance = ::std::option::Option::None;
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOAccountItemPersonalStore {
        static instance: CSOAccountItemPersonalStore = CSOAccountItemPersonalStore {
            generation_time: ::std::option::Option::None,
            redeemable_balance: ::std::option::Option::None,
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOAccountItemPersonalStore {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOAccountItemPersonalStore").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOAccountItemPersonalStore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOAccountItemPersonalStore {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOQuestProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOQuestProgress {
    // message fields
    // @@protoc_insertion_point(field:CSOQuestProgress.questid)
    pub questid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestProgress.points_remaining)
    pub points_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestProgress.bonus_points)
    pub bonus_points: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOQuestProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOQuestProgress {
    fn default() -> &'a CSOQuestProgress {
        <CSOQuestProgress as ::protobuf::Message>::default_instance()
    }
}

impl CSOQuestProgress {
    pub fn new() -> CSOQuestProgress {
        ::std::default::Default::default()
    }

    // optional uint32 questid = 1;

    pub fn questid(&self) -> u32 {
        self.questid.unwrap_or(0)
    }

    pub fn clear_questid(&mut self) {
        self.questid = ::std::option::Option::None;
    }

    pub fn has_questid(&self) -> bool {
        self.questid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_questid(&mut self, v: u32) {
        self.questid = ::std::option::Option::Some(v);
    }

    // optional uint32 points_remaining = 2;

    pub fn points_remaining(&self) -> u32 {
        self.points_remaining.unwrap_or(0)
    }

    pub fn clear_points_remaining(&mut self) {
        self.points_remaining = ::std::option::Option::None;
    }

    pub fn has_points_remaining(&self) -> bool {
        self.points_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_remaining(&mut self, v: u32) {
        self.points_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_points = 3;

    pub fn bonus_points(&self) -> u32 {
        self.bonus_points.unwrap_or(0)
    }

    pub fn clear_bonus_points(&mut self) {
        self.bonus_points = ::std::option::Option::None;
    }

    pub fn has_bonus_points(&self) -> bool {
        self.bonus_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_points(&mut self, v: u32) {
        self.bonus_points = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "questid",
            |m: &CSOQuestProgress| { &m.questid },
            |m: &mut CSOQuestProgress| { &mut m.questid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_remaining",
            |m: &CSOQuestProgress| { &m.points_remaining },
            |m: &mut CSOQuestProgress| { &mut m.points_remaining },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_points",
            |m: &CSOQuestProgress| { &m.bonus_points },
            |m: &mut CSOQuestProgress| { &mut m.bonus_points },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOQuestProgress>(
            "CSOQuestProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOQuestProgress {
    const NAME: &'static str = "CSOQuestProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.questid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.points_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bonus_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.questid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.points_remaining {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bonus_points {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.questid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.points_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOQuestProgress {
        CSOQuestProgress::new()
    }

    fn clear(&mut self) {
        self.questid = ::std::option::Option::None;
        self.points_remaining = ::std::option::Option::None;
        self.bonus_points = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOQuestProgress {
        static instance: CSOQuestProgress = CSOQuestProgress {
            questid: ::std::option::Option::None,
            points_remaining: ::std::option::Option::None,
            bonus_points: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOQuestProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOQuestProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOQuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOQuestProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOAccountSeasonalOperation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOAccountSeasonalOperation {
    // message fields
    // @@protoc_insertion_point(field:CSOAccountSeasonalOperation.season_value)
    pub season_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOAccountSeasonalOperation.tier_unlocked)
    pub tier_unlocked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOAccountSeasonalOperation.premium_tiers)
    pub premium_tiers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOAccountSeasonalOperation.mission_id)
    pub mission_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOAccountSeasonalOperation.missions_completed)
    pub missions_completed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOAccountSeasonalOperation.redeemable_balance)
    pub redeemable_balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOAccountSeasonalOperation.season_pass_time)
    pub season_pass_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOAccountSeasonalOperation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOAccountSeasonalOperation {
    fn default() -> &'a CSOAccountSeasonalOperation {
        <CSOAccountSeasonalOperation as ::protobuf::Message>::default_instance()
    }
}

impl CSOAccountSeasonalOperation {
    pub fn new() -> CSOAccountSeasonalOperation {
        ::std::default::Default::default()
    }

    // optional uint32 season_value = 1;

    pub fn season_value(&self) -> u32 {
        self.season_value.unwrap_or(0)
    }

    pub fn clear_season_value(&mut self) {
        self.season_value = ::std::option::Option::None;
    }

    pub fn has_season_value(&self) -> bool {
        self.season_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_value(&mut self, v: u32) {
        self.season_value = ::std::option::Option::Some(v);
    }

    // optional uint32 tier_unlocked = 2;

    pub fn tier_unlocked(&self) -> u32 {
        self.tier_unlocked.unwrap_or(0)
    }

    pub fn clear_tier_unlocked(&mut self) {
        self.tier_unlocked = ::std::option::Option::None;
    }

    pub fn has_tier_unlocked(&self) -> bool {
        self.tier_unlocked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier_unlocked(&mut self, v: u32) {
        self.tier_unlocked = ::std::option::Option::Some(v);
    }

    // optional uint32 premium_tiers = 3;

    pub fn premium_tiers(&self) -> u32 {
        self.premium_tiers.unwrap_or(0)
    }

    pub fn clear_premium_tiers(&mut self) {
        self.premium_tiers = ::std::option::Option::None;
    }

    pub fn has_premium_tiers(&self) -> bool {
        self.premium_tiers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_tiers(&mut self, v: u32) {
        self.premium_tiers = ::std::option::Option::Some(v);
    }

    // optional uint32 mission_id = 4;

    pub fn mission_id(&self) -> u32 {
        self.mission_id.unwrap_or(0)
    }

    pub fn clear_mission_id(&mut self) {
        self.mission_id = ::std::option::Option::None;
    }

    pub fn has_mission_id(&self) -> bool {
        self.mission_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_id(&mut self, v: u32) {
        self.mission_id = ::std::option::Option::Some(v);
    }

    // optional uint32 missions_completed = 5;

    pub fn missions_completed(&self) -> u32 {
        self.missions_completed.unwrap_or(0)
    }

    pub fn clear_missions_completed(&mut self) {
        self.missions_completed = ::std::option::Option::None;
    }

    pub fn has_missions_completed(&self) -> bool {
        self.missions_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missions_completed(&mut self, v: u32) {
        self.missions_completed = ::std::option::Option::Some(v);
    }

    // optional uint32 redeemable_balance = 6;

    pub fn redeemable_balance(&self) -> u32 {
        self.redeemable_balance.unwrap_or(0)
    }

    pub fn clear_redeemable_balance(&mut self) {
        self.redeemable_balance = ::std::option::Option::None;
    }

    pub fn has_redeemable_balance(&self) -> bool {
        self.redeemable_balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_redeemable_balance(&mut self, v: u32) {
        self.redeemable_balance = ::std::option::Option::Some(v);
    }

    // optional uint32 season_pass_time = 7;

    pub fn season_pass_time(&self) -> u32 {
        self.season_pass_time.unwrap_or(0)
    }

    pub fn clear_season_pass_time(&mut self) {
        self.season_pass_time = ::std::option::Option::None;
    }

    pub fn has_season_pass_time(&self) -> bool {
        self.season_pass_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_pass_time(&mut self, v: u32) {
        self.season_pass_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "season_value",
            |m: &CSOAccountSeasonalOperation| { &m.season_value },
            |m: &mut CSOAccountSeasonalOperation| { &mut m.season_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tier_unlocked",
            |m: &CSOAccountSeasonalOperation| { &m.tier_unlocked },
            |m: &mut CSOAccountSeasonalOperation| { &mut m.tier_unlocked },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "premium_tiers",
            |m: &CSOAccountSeasonalOperation| { &m.premium_tiers },
            |m: &mut CSOAccountSeasonalOperation| { &mut m.premium_tiers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mission_id",
            |m: &CSOAccountSeasonalOperation| { &m.mission_id },
            |m: &mut CSOAccountSeasonalOperation| { &mut m.mission_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "missions_completed",
            |m: &CSOAccountSeasonalOperation| { &m.missions_completed },
            |m: &mut CSOAccountSeasonalOperation| { &mut m.missions_completed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "redeemable_balance",
            |m: &CSOAccountSeasonalOperation| { &m.redeemable_balance },
            |m: &mut CSOAccountSeasonalOperation| { &mut m.redeemable_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "season_pass_time",
            |m: &CSOAccountSeasonalOperation| { &m.season_pass_time },
            |m: &mut CSOAccountSeasonalOperation| { &mut m.season_pass_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOAccountSeasonalOperation>(
            "CSOAccountSeasonalOperation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOAccountSeasonalOperation {
    const NAME: &'static str = "CSOAccountSeasonalOperation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.season_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.tier_unlocked = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.premium_tiers = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.mission_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.missions_completed = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.redeemable_balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.season_pass_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.season_value {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tier_unlocked {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.premium_tiers {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.mission_id {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.missions_completed {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.redeemable_balance {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.season_pass_time {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.season_value {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tier_unlocked {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.premium_tiers {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.mission_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.missions_completed {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.redeemable_balance {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.season_pass_time {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOAccountSeasonalOperation {
        CSOAccountSeasonalOperation::new()
    }

    fn clear(&mut self) {
        self.season_value = ::std::option::Option::None;
        self.tier_unlocked = ::std::option::Option::None;
        self.premium_tiers = ::std::option::Option::None;
        self.mission_id = ::std::option::Option::None;
        self.missions_completed = ::std::option::Option::None;
        self.redeemable_balance = ::std::option::Option::None;
        self.season_pass_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOAccountSeasonalOperation {
        static instance: CSOAccountSeasonalOperation = CSOAccountSeasonalOperation {
            season_value: ::std::option::Option::None,
            tier_unlocked: ::std::option::Option::None,
            premium_tiers: ::std::option::Option::None,
            mission_id: ::std::option::Option::None,
            missions_completed: ::std::option::Option::None,
            redeemable_balance: ::std::option::Option::None,
            season_pass_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOAccountSeasonalOperation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOAccountSeasonalOperation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOAccountSeasonalOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOAccountSeasonalOperation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOAccountRecurringSubscription)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOAccountRecurringSubscription {
    // message fields
    // @@protoc_insertion_point(field:CSOAccountRecurringSubscription.time_next_cycle)
    pub time_next_cycle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOAccountRecurringSubscription.time_initiated)
    pub time_initiated: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOAccountRecurringSubscription.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOAccountRecurringSubscription {
    fn default() -> &'a CSOAccountRecurringSubscription {
        <CSOAccountRecurringSubscription as ::protobuf::Message>::default_instance()
    }
}

impl CSOAccountRecurringSubscription {
    pub fn new() -> CSOAccountRecurringSubscription {
        ::std::default::Default::default()
    }

    // optional uint32 time_next_cycle = 1;

    pub fn time_next_cycle(&self) -> u32 {
        self.time_next_cycle.unwrap_or(0)
    }

    pub fn clear_time_next_cycle(&mut self) {
        self.time_next_cycle = ::std::option::Option::None;
    }

    pub fn has_time_next_cycle(&self) -> bool {
        self.time_next_cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_next_cycle(&mut self, v: u32) {
        self.time_next_cycle = ::std::option::Option::Some(v);
    }

    // optional uint32 time_initiated = 2;

    pub fn time_initiated(&self) -> u32 {
        self.time_initiated.unwrap_or(0)
    }

    pub fn clear_time_initiated(&mut self) {
        self.time_initiated = ::std::option::Option::None;
    }

    pub fn has_time_initiated(&self) -> bool {
        self.time_initiated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_initiated(&mut self, v: u32) {
        self.time_initiated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_next_cycle",
            |m: &CSOAccountRecurringSubscription| { &m.time_next_cycle },
            |m: &mut CSOAccountRecurringSubscription| { &mut m.time_next_cycle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_initiated",
            |m: &CSOAccountRecurringSubscription| { &m.time_initiated },
            |m: &mut CSOAccountRecurringSubscription| { &mut m.time_initiated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOAccountRecurringSubscription>(
            "CSOAccountRecurringSubscription",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOAccountRecurringSubscription {
    const NAME: &'static str = "CSOAccountRecurringSubscription";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time_next_cycle = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.time_initiated = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time_next_cycle {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.time_initiated {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.time_next_cycle {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_initiated {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOAccountRecurringSubscription {
        CSOAccountRecurringSubscription::new()
    }

    fn clear(&mut self) {
        self.time_next_cycle = ::std::option::Option::None;
        self.time_initiated = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOAccountRecurringSubscription {
        static instance: CSOAccountRecurringSubscription = CSOAccountRecurringSubscription {
            time_next_cycle: ::std::option::Option::None,
            time_initiated: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOAccountRecurringSubscription {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOAccountRecurringSubscription").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOAccountRecurringSubscription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOAccountRecurringSubscription {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSOPersonaDataPublic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOPersonaDataPublic {
    // message fields
    // @@protoc_insertion_point(field:CSOPersonaDataPublic.player_level)
    pub player_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOPersonaDataPublic.commendation)
    pub commendation: ::protobuf::MessageField<PlayerCommendationInfo>,
    // @@protoc_insertion_point(field:CSOPersonaDataPublic.elevated_state)
    pub elevated_state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOPersonaDataPublic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOPersonaDataPublic {
    fn default() -> &'a CSOPersonaDataPublic {
        <CSOPersonaDataPublic as ::protobuf::Message>::default_instance()
    }
}

impl CSOPersonaDataPublic {
    pub fn new() -> CSOPersonaDataPublic {
        ::std::default::Default::default()
    }

    // optional int32 player_level = 1;

    pub fn player_level(&self) -> i32 {
        self.player_level.unwrap_or(0)
    }

    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: i32) {
        self.player_level = ::std::option::Option::Some(v);
    }

    // optional bool elevated_state = 3;

    pub fn elevated_state(&self) -> bool {
        self.elevated_state.unwrap_or(false)
    }

    pub fn clear_elevated_state(&mut self) {
        self.elevated_state = ::std::option::Option::None;
    }

    pub fn has_elevated_state(&self) -> bool {
        self.elevated_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevated_state(&mut self, v: bool) {
        self.elevated_state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_level",
            |m: &CSOPersonaDataPublic| { &m.player_level },
            |m: &mut CSOPersonaDataPublic| { &mut m.player_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerCommendationInfo>(
            "commendation",
            |m: &CSOPersonaDataPublic| { &m.commendation },
            |m: &mut CSOPersonaDataPublic| { &mut m.commendation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elevated_state",
            |m: &CSOPersonaDataPublic| { &m.elevated_state },
            |m: &mut CSOPersonaDataPublic| { &mut m.elevated_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOPersonaDataPublic>(
            "CSOPersonaDataPublic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOPersonaDataPublic {
    const NAME: &'static str = "CSOPersonaDataPublic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_level = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commendation)?;
                },
                24 => {
                    self.elevated_state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.elevated_state {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_level {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.commendation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.elevated_state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOPersonaDataPublic {
        CSOPersonaDataPublic::new()
    }

    fn clear(&mut self) {
        self.player_level = ::std::option::Option::None;
        self.commendation.clear();
        self.elevated_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOPersonaDataPublic {
        static instance: CSOPersonaDataPublic = CSOPersonaDataPublic {
            player_level: ::std::option::Option::None,
            commendation: ::protobuf::MessageField::none(),
            elevated_state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOPersonaDataPublic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOPersonaDataPublic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOPersonaDataPublic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOPersonaDataPublic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GlobalGame_Subscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GlobalGame_Subscribe {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GlobalGame_Subscribe.ticket)
    pub ticket: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GlobalGame_Subscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GlobalGame_Subscribe {
    fn default() -> &'a CMsgGC_GlobalGame_Subscribe {
        <CMsgGC_GlobalGame_Subscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GlobalGame_Subscribe {
    pub fn new() -> CMsgGC_GlobalGame_Subscribe {
        ::std::default::Default::default()
    }

    // optional uint64 ticket = 1;

    pub fn ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgGC_GlobalGame_Subscribe| { &m.ticket },
            |m: &mut CMsgGC_GlobalGame_Subscribe| { &mut m.ticket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GlobalGame_Subscribe>(
            "CMsgGC_GlobalGame_Subscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Subscribe {
    const NAME: &'static str = "CMsgGC_GlobalGame_Subscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ticket = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GlobalGame_Subscribe {
        CMsgGC_GlobalGame_Subscribe::new()
    }

    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GlobalGame_Subscribe {
        static instance: CMsgGC_GlobalGame_Subscribe = CMsgGC_GlobalGame_Subscribe {
            ticket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GlobalGame_Subscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GlobalGame_Subscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GlobalGame_Subscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Subscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GlobalGame_Unsubscribe)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GlobalGame_Unsubscribe {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GlobalGame_Unsubscribe.timeleft)
    pub timeleft: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GlobalGame_Unsubscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GlobalGame_Unsubscribe {
    fn default() -> &'a CMsgGC_GlobalGame_Unsubscribe {
        <CMsgGC_GlobalGame_Unsubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GlobalGame_Unsubscribe {
    pub fn new() -> CMsgGC_GlobalGame_Unsubscribe {
        ::std::default::Default::default()
    }

    // optional int32 timeleft = 1;

    pub fn timeleft(&self) -> i32 {
        self.timeleft.unwrap_or(0)
    }

    pub fn clear_timeleft(&mut self) {
        self.timeleft = ::std::option::Option::None;
    }

    pub fn has_timeleft(&self) -> bool {
        self.timeleft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeleft(&mut self, v: i32) {
        self.timeleft = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeleft",
            |m: &CMsgGC_GlobalGame_Unsubscribe| { &m.timeleft },
            |m: &mut CMsgGC_GlobalGame_Unsubscribe| { &mut m.timeleft },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GlobalGame_Unsubscribe>(
            "CMsgGC_GlobalGame_Unsubscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Unsubscribe {
    const NAME: &'static str = "CMsgGC_GlobalGame_Unsubscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timeleft = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timeleft {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timeleft {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GlobalGame_Unsubscribe {
        CMsgGC_GlobalGame_Unsubscribe::new()
    }

    fn clear(&mut self) {
        self.timeleft = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GlobalGame_Unsubscribe {
        static instance: CMsgGC_GlobalGame_Unsubscribe = CMsgGC_GlobalGame_Unsubscribe {
            timeleft: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GlobalGame_Unsubscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GlobalGame_Unsubscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GlobalGame_Unsubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Unsubscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGC_GlobalGame_Play)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GlobalGame_Play {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GlobalGame_Play.ticket)
    pub ticket: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_GlobalGame_Play.gametimems)
    pub gametimems: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_GlobalGame_Play.msperpoint)
    pub msperpoint: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GlobalGame_Play.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GlobalGame_Play {
    fn default() -> &'a CMsgGC_GlobalGame_Play {
        <CMsgGC_GlobalGame_Play as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GlobalGame_Play {
    pub fn new() -> CMsgGC_GlobalGame_Play {
        ::std::default::Default::default()
    }

    // optional uint64 ticket = 1;

    pub fn ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // optional uint32 gametimems = 2;

    pub fn gametimems(&self) -> u32 {
        self.gametimems.unwrap_or(0)
    }

    pub fn clear_gametimems(&mut self) {
        self.gametimems = ::std::option::Option::None;
    }

    pub fn has_gametimems(&self) -> bool {
        self.gametimems.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gametimems(&mut self, v: u32) {
        self.gametimems = ::std::option::Option::Some(v);
    }

    // optional uint32 msperpoint = 3;

    pub fn msperpoint(&self) -> u32 {
        self.msperpoint.unwrap_or(0)
    }

    pub fn clear_msperpoint(&mut self) {
        self.msperpoint = ::std::option::Option::None;
    }

    pub fn has_msperpoint(&self) -> bool {
        self.msperpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msperpoint(&mut self, v: u32) {
        self.msperpoint = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgGC_GlobalGame_Play| { &m.ticket },
            |m: &mut CMsgGC_GlobalGame_Play| { &mut m.ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gametimems",
            |m: &CMsgGC_GlobalGame_Play| { &m.gametimems },
            |m: &mut CMsgGC_GlobalGame_Play| { &mut m.gametimems },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msperpoint",
            |m: &CMsgGC_GlobalGame_Play| { &m.msperpoint },
            |m: &mut CMsgGC_GlobalGame_Play| { &mut m.msperpoint },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GlobalGame_Play>(
            "CMsgGC_GlobalGame_Play",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Play {
    const NAME: &'static str = "CMsgGC_GlobalGame_Play";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ticket = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.gametimems = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.msperpoint = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.gametimems {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.msperpoint {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.gametimems {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.msperpoint {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GlobalGame_Play {
        CMsgGC_GlobalGame_Play::new()
    }

    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.gametimems = ::std::option::Option::None;
        self.msperpoint = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GlobalGame_Play {
        static instance: CMsgGC_GlobalGame_Play = CMsgGC_GlobalGame_Play {
            ticket: ::std::option::Option::None,
            gametimems: ::std::option::Option::None,
            msperpoint: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GlobalGame_Play {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GlobalGame_Play").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GlobalGame_Play {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Play {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_AcknowledgePenalty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_AcknowledgePenalty {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_AcknowledgePenalty.acknowledged)
    pub acknowledged: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_AcknowledgePenalty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn default() -> &'a CMsgGCCStrike15_v2_AcknowledgePenalty {
        <CMsgGCCStrike15_v2_AcknowledgePenalty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_AcknowledgePenalty {
    pub fn new() -> CMsgGCCStrike15_v2_AcknowledgePenalty {
        ::std::default::Default::default()
    }

    // optional int32 acknowledged = 1;

    pub fn acknowledged(&self) -> i32 {
        self.acknowledged.unwrap_or(0)
    }

    pub fn clear_acknowledged(&mut self) {
        self.acknowledged = ::std::option::Option::None;
    }

    pub fn has_acknowledged(&self) -> bool {
        self.acknowledged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acknowledged(&mut self, v: i32) {
        self.acknowledged = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "acknowledged",
            |m: &CMsgGCCStrike15_v2_AcknowledgePenalty| { &m.acknowledged },
            |m: &mut CMsgGCCStrike15_v2_AcknowledgePenalty| { &mut m.acknowledged },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_AcknowledgePenalty>(
            "CMsgGCCStrike15_v2_AcknowledgePenalty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_AcknowledgePenalty {
    const NAME: &'static str = "CMsgGCCStrike15_v2_AcknowledgePenalty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.acknowledged = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.acknowledged {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.acknowledged {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_AcknowledgePenalty {
        CMsgGCCStrike15_v2_AcknowledgePenalty::new()
    }

    fn clear(&mut self) {
        self.acknowledged = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_AcknowledgePenalty {
        static instance: CMsgGCCStrike15_v2_AcknowledgePenalty = CMsgGCCStrike15_v2_AcknowledgePenalty {
            acknowledged: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_AcknowledgePenalty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_AcknowledgePenalty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.upgradeid)
    pub upgradeid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.hours)
    pub hours: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.prestigetime)
    pub prestigetime: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        <CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        ::std::default::Default::default()
    }

    // optional uint32 defindex = 1;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint64 upgradeid = 2;

    pub fn upgradeid(&self) -> u64 {
        self.upgradeid.unwrap_or(0)
    }

    pub fn clear_upgradeid(&mut self) {
        self.upgradeid = ::std::option::Option::None;
    }

    pub fn has_upgradeid(&self) -> bool {
        self.upgradeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgradeid(&mut self, v: u64) {
        self.upgradeid = ::std::option::Option::Some(v);
    }

    // optional uint32 hours = 3;

    pub fn hours(&self) -> u32 {
        self.hours.unwrap_or(0)
    }

    pub fn clear_hours(&mut self) {
        self.hours = ::std::option::Option::None;
    }

    pub fn has_hours(&self) -> bool {
        self.hours.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hours(&mut self, v: u32) {
        self.hours = ::std::option::Option::Some(v);
    }

    // optional uint32 prestigetime = 4;

    pub fn prestigetime(&self) -> u32 {
        self.prestigetime.unwrap_or(0)
    }

    pub fn clear_prestigetime(&mut self) {
        self.prestigetime = ::std::option::Option::None;
    }

    pub fn has_prestigetime(&self) -> bool {
        self.prestigetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prestigetime(&mut self, v: u32) {
        self.prestigetime = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defindex",
            |m: &CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &m.defindex },
            |m: &mut CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &mut m.defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upgradeid",
            |m: &CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &m.upgradeid },
            |m: &mut CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &mut m.upgradeid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hours",
            |m: &CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &m.hours },
            |m: &mut CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &mut m.hours },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "prestigetime",
            |m: &CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &m.prestigetime },
            |m: &mut CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin| { &mut m.prestigetime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin>(
            "CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.upgradeid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.hours = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.prestigetime = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.upgradeid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.hours {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.prestigetime {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.upgradeid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.hours {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.prestigetime {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin::new()
    }

    fn clear(&mut self) {
        self.defindex = ::std::option::Option::None;
        self.upgradeid = ::std::option::Option::None;
        self.hours = ::std::option::Option::None;
        self.prestigetime = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        static instance: CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
            defindex: ::std::option::Option::None,
            upgradeid: ::std::option::Option::None,
            hours: ::std::option::Option::None,
            prestigetime: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Client2GCStreamUnlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCStreamUnlock.ticket)
    pub ticket: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCStreamUnlock.os)
    pub os: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Client2GCStreamUnlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        <CMsgGCCStrike15_v2_Client2GCStreamUnlock as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        ::std::default::Default::default()
    }

    // optional uint64 ticket = 1;

    pub fn ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // optional int32 os = 2;

    pub fn os(&self) -> i32 {
        self.os.unwrap_or(0)
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: i32) {
        self.os = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &m.ticket },
            |m: &mut CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &mut m.ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os",
            |m: &CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &m.os },
            |m: &mut CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &mut m.os },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Client2GCStreamUnlock>(
            "CMsgGCCStrike15_v2_Client2GCStreamUnlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Client2GCStreamUnlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ticket = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.os = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.os {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.os {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        CMsgGCCStrike15_v2_Client2GCStreamUnlock::new()
    }

    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        static instance: CMsgGCCStrike15_v2_Client2GCStreamUnlock = CMsgGCCStrike15_v2_Client2GCStreamUnlock {
            ticket: ::std::option::Option::None,
            os: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Client2GCStreamUnlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientToGCRequestElevate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientToGCRequestElevate.stage)
    pub stage: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientToGCRequestElevate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        <CMsgGCCStrike15_v2_ClientToGCRequestElevate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    pub fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        ::std::default::Default::default()
    }

    // optional uint32 stage = 1;

    pub fn stage(&self) -> u32 {
        self.stage.unwrap_or(0)
    }

    pub fn clear_stage(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_stage(&self) -> bool {
        self.stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: u32) {
        self.stage = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stage",
            |m: &CMsgGCCStrike15_v2_ClientToGCRequestElevate| { &m.stage },
            |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestElevate| { &mut m.stage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientToGCRequestElevate>(
            "CMsgGCCStrike15_v2_ClientToGCRequestElevate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientToGCRequestElevate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stage = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stage {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stage {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        CMsgGCCStrike15_v2_ClientToGCRequestElevate::new()
    }

    fn clear(&mut self) {
        self.stage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        static instance: CMsgGCCStrike15_v2_ClientToGCRequestElevate = CMsgGCCStrike15_v2_ClientToGCRequestElevate {
            stage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientToGCRequestElevate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientToGCChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientToGCChat {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientToGCChat.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientToGCChat.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientToGCChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientToGCChat {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientToGCChat {
        <CMsgGCCStrike15_v2_ClientToGCChat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientToGCChat {
    pub fn new() -> CMsgGCCStrike15_v2_ClientToGCChat {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_ClientToGCChat| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_ClientToGCChat| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgGCCStrike15_v2_ClientToGCChat| { &m.text },
            |m: &mut CMsgGCCStrike15_v2_ClientToGCChat| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientToGCChat>(
            "CMsgGCCStrike15_v2_ClientToGCChat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientToGCChat {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientToGCChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientToGCChat {
        CMsgGCCStrike15_v2_ClientToGCChat::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientToGCChat {
        static instance: CMsgGCCStrike15_v2_ClientToGCChat = CMsgGCCStrike15_v2_ClientToGCChat {
            match_id: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientToGCChat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientToGCChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientToGCChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientToGCChat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GCToClientChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GCToClientChat {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GCToClientChat.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GCToClientChat.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GCToClientChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GCToClientChat {
    fn default() -> &'a CMsgGCCStrike15_v2_GCToClientChat {
        <CMsgGCCStrike15_v2_GCToClientChat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GCToClientChat {
    pub fn new() -> CMsgGCCStrike15_v2_GCToClientChat {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_GCToClientChat| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_GCToClientChat| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgGCCStrike15_v2_GCToClientChat| { &m.text },
            |m: &mut CMsgGCCStrike15_v2_GCToClientChat| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GCToClientChat>(
            "CMsgGCCStrike15_v2_GCToClientChat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GCToClientChat {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GCToClientChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GCToClientChat {
        CMsgGCCStrike15_v2_GCToClientChat::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GCToClientChat {
        static instance: CMsgGCCStrike15_v2_GCToClientChat = CMsgGCCStrike15_v2_GCToClientChat {
            account_id: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GCToClientChat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GCToClientChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GCToClientChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GCToClientChat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientAuthKeyCode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientAuthKeyCode {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientAuthKeyCode.eventid)
    pub eventid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientAuthKeyCode.code)
    pub code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientAuthKeyCode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientAuthKeyCode {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientAuthKeyCode {
        <CMsgGCCStrike15_v2_ClientAuthKeyCode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientAuthKeyCode {
    pub fn new() -> CMsgGCCStrike15_v2_ClientAuthKeyCode {
        ::std::default::Default::default()
    }

    // optional uint32 eventid = 1;

    pub fn eventid(&self) -> u32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: u32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional string code = 2;

    pub fn code(&self) -> &str {
        match self.code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        if self.code.is_none() {
            self.code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.code.as_mut().unwrap()
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        self.code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CMsgGCCStrike15_v2_ClientAuthKeyCode| { &m.eventid },
            |m: &mut CMsgGCCStrike15_v2_ClientAuthKeyCode| { &mut m.eventid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code",
            |m: &CMsgGCCStrike15_v2_ClientAuthKeyCode| { &m.code },
            |m: &mut CMsgGCCStrike15_v2_ClientAuthKeyCode| { &mut m.code },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientAuthKeyCode>(
            "CMsgGCCStrike15_v2_ClientAuthKeyCode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientAuthKeyCode {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientAuthKeyCode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eventid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.code.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eventid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.code.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientAuthKeyCode {
        CMsgGCCStrike15_v2_ClientAuthKeyCode::new()
    }

    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientAuthKeyCode {
        static instance: CMsgGCCStrike15_v2_ClientAuthKeyCode = CMsgGCCStrike15_v2_ClientAuthKeyCode {
            eventid: ::std::option::Option::None,
            code: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientAuthKeyCode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientAuthKeyCode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientAuthKeyCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientAuthKeyCode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_GotvSyncPacket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_GotvSyncPacket {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_GotvSyncPacket.data)
    pub data: ::protobuf::MessageField<super::engine_gcmessages::CEngineGotvSyncPacket>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_GotvSyncPacket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_GotvSyncPacket {
    fn default() -> &'a CMsgGCCStrike15_GotvSyncPacket {
        <CMsgGCCStrike15_GotvSyncPacket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_GotvSyncPacket {
    pub fn new() -> CMsgGCCStrike15_GotvSyncPacket {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::engine_gcmessages::CEngineGotvSyncPacket>(
            "data",
            |m: &CMsgGCCStrike15_GotvSyncPacket| { &m.data },
            |m: &mut CMsgGCCStrike15_GotvSyncPacket| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_GotvSyncPacket>(
            "CMsgGCCStrike15_GotvSyncPacket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_GotvSyncPacket {
    const NAME: &'static str = "CMsgGCCStrike15_GotvSyncPacket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_GotvSyncPacket {
        CMsgGCCStrike15_GotvSyncPacket::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_GotvSyncPacket {
        static instance: CMsgGCCStrike15_GotvSyncPacket = CMsgGCCStrike15_GotvSyncPacket {
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_GotvSyncPacket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_GotvSyncPacket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_GotvSyncPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_GotvSyncPacket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PlayerDecalDigitalSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlayerDecalDigitalSignature {
    // message fields
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.signature)
    pub signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.rtime)
    pub rtime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.endpos)
    pub endpos: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.startpos)
    pub startpos: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.left)
    pub left: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.tx_defidx)
    pub tx_defidx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.entindex)
    pub entindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.hitbox)
    pub hitbox: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.creationtime)
    pub creationtime: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.equipslot)
    pub equipslot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.trace_id)
    pub trace_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.normal)
    pub normal: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:PlayerDecalDigitalSignature.tint_id)
    pub tint_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:PlayerDecalDigitalSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerDecalDigitalSignature {
    fn default() -> &'a PlayerDecalDigitalSignature {
        <PlayerDecalDigitalSignature as ::protobuf::Message>::default_instance()
    }
}

impl PlayerDecalDigitalSignature {
    pub fn new() -> PlayerDecalDigitalSignature {
        ::std::default::Default::default()
    }

    // optional bytes signature = 1;

    pub fn signature(&self) -> &[u8] {
        match self.signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.signature.is_none() {
            self.signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 accountid = 2;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime = 3;

    pub fn rtime(&self) -> u32 {
        self.rtime.unwrap_or(0)
    }

    pub fn clear_rtime(&mut self) {
        self.rtime = ::std::option::Option::None;
    }

    pub fn has_rtime(&self) -> bool {
        self.rtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime(&mut self, v: u32) {
        self.rtime = ::std::option::Option::Some(v);
    }

    // optional uint32 tx_defidx = 7;

    pub fn tx_defidx(&self) -> u32 {
        self.tx_defidx.unwrap_or(0)
    }

    pub fn clear_tx_defidx(&mut self) {
        self.tx_defidx = ::std::option::Option::None;
    }

    pub fn has_tx_defidx(&self) -> bool {
        self.tx_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx_defidx(&mut self, v: u32) {
        self.tx_defidx = ::std::option::Option::Some(v);
    }

    // optional int32 entindex = 8;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    // optional uint32 hitbox = 9;

    pub fn hitbox(&self) -> u32 {
        self.hitbox.unwrap_or(0)
    }

    pub fn clear_hitbox(&mut self) {
        self.hitbox = ::std::option::Option::None;
    }

    pub fn has_hitbox(&self) -> bool {
        self.hitbox.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hitbox(&mut self, v: u32) {
        self.hitbox = ::std::option::Option::Some(v);
    }

    // optional float creationtime = 10;

    pub fn creationtime(&self) -> f32 {
        self.creationtime.unwrap_or(0.)
    }

    pub fn clear_creationtime(&mut self) {
        self.creationtime = ::std::option::Option::None;
    }

    pub fn has_creationtime(&self) -> bool {
        self.creationtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationtime(&mut self, v: f32) {
        self.creationtime = ::std::option::Option::Some(v);
    }

    // optional uint32 equipslot = 11;

    pub fn equipslot(&self) -> u32 {
        self.equipslot.unwrap_or(0)
    }

    pub fn clear_equipslot(&mut self) {
        self.equipslot = ::std::option::Option::None;
    }

    pub fn has_equipslot(&self) -> bool {
        self.equipslot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_equipslot(&mut self, v: u32) {
        self.equipslot = ::std::option::Option::Some(v);
    }

    // optional uint32 trace_id = 12;

    pub fn trace_id(&self) -> u32 {
        self.trace_id.unwrap_or(0)
    }

    pub fn clear_trace_id(&mut self) {
        self.trace_id = ::std::option::Option::None;
    }

    pub fn has_trace_id(&self) -> bool {
        self.trace_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: u32) {
        self.trace_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tint_id = 14;

    pub fn tint_id(&self) -> u32 {
        self.tint_id.unwrap_or(0)
    }

    pub fn clear_tint_id(&mut self) {
        self.tint_id = ::std::option::Option::None;
    }

    pub fn has_tint_id(&self) -> bool {
        self.tint_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tint_id(&mut self, v: u32) {
        self.tint_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &PlayerDecalDigitalSignature| { &m.signature },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &PlayerDecalDigitalSignature| { &m.accountid },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime",
            |m: &PlayerDecalDigitalSignature| { &m.rtime },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.rtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "endpos",
            |m: &PlayerDecalDigitalSignature| { &m.endpos },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.endpos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "startpos",
            |m: &PlayerDecalDigitalSignature| { &m.startpos },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.startpos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "left",
            |m: &PlayerDecalDigitalSignature| { &m.left },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tx_defidx",
            |m: &PlayerDecalDigitalSignature| { &m.tx_defidx },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.tx_defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entindex",
            |m: &PlayerDecalDigitalSignature| { &m.entindex },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.entindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hitbox",
            |m: &PlayerDecalDigitalSignature| { &m.hitbox },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.hitbox },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "creationtime",
            |m: &PlayerDecalDigitalSignature| { &m.creationtime },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.creationtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "equipslot",
            |m: &PlayerDecalDigitalSignature| { &m.equipslot },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.equipslot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trace_id",
            |m: &PlayerDecalDigitalSignature| { &m.trace_id },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.trace_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "normal",
            |m: &PlayerDecalDigitalSignature| { &m.normal },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.normal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tint_id",
            |m: &PlayerDecalDigitalSignature| { &m.tint_id },
            |m: &mut PlayerDecalDigitalSignature| { &mut m.tint_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerDecalDigitalSignature>(
            "PlayerDecalDigitalSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerDecalDigitalSignature {
    const NAME: &'static str = "PlayerDecalDigitalSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.rtime = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_float_into(&mut self.endpos)?;
                },
                37 => {
                    self.endpos.push(is.read_float()?);
                },
                42 => {
                    is.read_repeated_packed_float_into(&mut self.startpos)?;
                },
                45 => {
                    self.startpos.push(is.read_float()?);
                },
                50 => {
                    is.read_repeated_packed_float_into(&mut self.left)?;
                },
                53 => {
                    self.left.push(is.read_float()?);
                },
                56 => {
                    self.tx_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.hitbox = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.creationtime = ::std::option::Option::Some(is.read_float()?);
                },
                88 => {
                    self.equipslot = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.trace_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    is.read_repeated_packed_float_into(&mut self.normal)?;
                },
                109 => {
                    self.normal.push(is.read_float()?);
                },
                112 => {
                    self.tint_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signature.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rtime {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += 5 * self.endpos.len() as u64;
        my_size += 5 * self.startpos.len() as u64;
        my_size += 5 * self.left.len() as u64;
        if let Some(v) = self.tx_defidx {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.hitbox {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.creationtime {
            my_size += 1 + 4;
        }
        if let Some(v) = self.equipslot {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.trace_id {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        my_size += 5 * self.normal.len() as u64;
        if let Some(v) = self.tint_id {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signature.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rtime {
            os.write_uint32(3, v)?;
        }
        for v in &self.endpos {
            os.write_float(4, *v)?;
        };
        for v in &self.startpos {
            os.write_float(5, *v)?;
        };
        for v in &self.left {
            os.write_float(6, *v)?;
        };
        if let Some(v) = self.tx_defidx {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.hitbox {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.creationtime {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.equipslot {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.trace_id {
            os.write_uint32(12, v)?;
        }
        for v in &self.normal {
            os.write_float(13, *v)?;
        };
        if let Some(v) = self.tint_id {
            os.write_uint32(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerDecalDigitalSignature {
        PlayerDecalDigitalSignature::new()
    }

    fn clear(&mut self) {
        self.signature = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.rtime = ::std::option::Option::None;
        self.endpos.clear();
        self.startpos.clear();
        self.left.clear();
        self.tx_defidx = ::std::option::Option::None;
        self.entindex = ::std::option::Option::None;
        self.hitbox = ::std::option::Option::None;
        self.creationtime = ::std::option::Option::None;
        self.equipslot = ::std::option::Option::None;
        self.trace_id = ::std::option::Option::None;
        self.normal.clear();
        self.tint_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerDecalDigitalSignature {
        static instance: PlayerDecalDigitalSignature = PlayerDecalDigitalSignature {
            signature: ::std::option::Option::None,
            accountid: ::std::option::Option::None,
            rtime: ::std::option::Option::None,
            endpos: ::std::vec::Vec::new(),
            startpos: ::std::vec::Vec::new(),
            left: ::std::vec::Vec::new(),
            tx_defidx: ::std::option::Option::None,
            entindex: ::std::option::Option::None,
            hitbox: ::std::option::Option::None,
            creationtime: ::std::option::Option::None,
            equipslot: ::std::option::Option::None,
            trace_id: ::std::option::Option::None,
            normal: ::std::vec::Vec::new(),
            tint_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerDecalDigitalSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerDecalDigitalSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerDecalDigitalSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerDecalDigitalSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientPlayerDecalSign)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPlayerDecalSign.data)
    pub data: ::protobuf::MessageField<PlayerDecalDigitalSignature>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPlayerDecalSign.itemid)
    pub itemid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientPlayerDecalSign.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientPlayerDecalSign {
        <CMsgGCCStrike15_v2_ClientPlayerDecalSign as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    pub fn new() -> CMsgGCCStrike15_v2_ClientPlayerDecalSign {
        ::std::default::Default::default()
    }

    // optional uint64 itemid = 2;

    pub fn itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerDecalDigitalSignature>(
            "data",
            |m: &CMsgGCCStrike15_v2_ClientPlayerDecalSign| { &m.data },
            |m: &mut CMsgGCCStrike15_v2_ClientPlayerDecalSign| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemid",
            |m: &CMsgGCCStrike15_v2_ClientPlayerDecalSign| { &m.itemid },
            |m: &mut CMsgGCCStrike15_v2_ClientPlayerDecalSign| { &mut m.itemid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientPlayerDecalSign>(
            "CMsgGCCStrike15_v2_ClientPlayerDecalSign",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientPlayerDecalSign";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                16 => {
                    self.itemid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.itemid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientPlayerDecalSign {
        CMsgGCCStrike15_v2_ClientPlayerDecalSign::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.itemid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientPlayerDecalSign {
        static instance: CMsgGCCStrike15_v2_ClientPlayerDecalSign = CMsgGCCStrike15_v2_ClientPlayerDecalSign {
            data: ::protobuf::MessageField::none(),
            itemid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientPlayerDecalSign").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientPlayerDecalSign {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientLogonFatalError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientLogonFatalError {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientLogonFatalError.errorcode)
    pub errorcode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientLogonFatalError.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientLogonFatalError.country)
    pub country: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientLogonFatalError.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientLogonFatalError {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientLogonFatalError {
        <CMsgGCCStrike15_v2_ClientLogonFatalError as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientLogonFatalError {
    pub fn new() -> CMsgGCCStrike15_v2_ClientLogonFatalError {
        ::std::default::Default::default()
    }

    // optional uint32 errorcode = 1;

    pub fn errorcode(&self) -> u32 {
        self.errorcode.unwrap_or(0)
    }

    pub fn clear_errorcode(&mut self) {
        self.errorcode = ::std::option::Option::None;
    }

    pub fn has_errorcode(&self) -> bool {
        self.errorcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorcode(&mut self, v: u32) {
        self.errorcode = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country = 3;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "errorcode",
            |m: &CMsgGCCStrike15_v2_ClientLogonFatalError| { &m.errorcode },
            |m: &mut CMsgGCCStrike15_v2_ClientLogonFatalError| { &mut m.errorcode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CMsgGCCStrike15_v2_ClientLogonFatalError| { &m.message },
            |m: &mut CMsgGCCStrike15_v2_ClientLogonFatalError| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "country",
            |m: &CMsgGCCStrike15_v2_ClientLogonFatalError| { &m.country },
            |m: &mut CMsgGCCStrike15_v2_ClientLogonFatalError| { &mut m.country },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientLogonFatalError>(
            "CMsgGCCStrike15_v2_ClientLogonFatalError",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientLogonFatalError {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientLogonFatalError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.errorcode = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.errorcode {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.country.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.errorcode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.country.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientLogonFatalError {
        CMsgGCCStrike15_v2_ClientLogonFatalError::new()
    }

    fn clear(&mut self) {
        self.errorcode = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.country = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientLogonFatalError {
        static instance: CMsgGCCStrike15_v2_ClientLogonFatalError = CMsgGCCStrike15_v2_ClientLogonFatalError {
            errorcode: ::std::option::Option::None,
            message: ::std::option::Option::None,
            country: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientLogonFatalError {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientLogonFatalError").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientLogonFatalError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientLogonFatalError {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientPollState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientPollState {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPollState.pollid)
    pub pollid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPollState.names)
    pub names: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPollState.values)
    pub values: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientPollState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientPollState {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientPollState {
        <CMsgGCCStrike15_v2_ClientPollState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientPollState {
    pub fn new() -> CMsgGCCStrike15_v2_ClientPollState {
        ::std::default::Default::default()
    }

    // optional uint32 pollid = 1;

    pub fn pollid(&self) -> u32 {
        self.pollid.unwrap_or(0)
    }

    pub fn clear_pollid(&mut self) {
        self.pollid = ::std::option::Option::None;
    }

    pub fn has_pollid(&self) -> bool {
        self.pollid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pollid(&mut self, v: u32) {
        self.pollid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pollid",
            |m: &CMsgGCCStrike15_v2_ClientPollState| { &m.pollid },
            |m: &mut CMsgGCCStrike15_v2_ClientPollState| { &mut m.pollid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "names",
            |m: &CMsgGCCStrike15_v2_ClientPollState| { &m.names },
            |m: &mut CMsgGCCStrike15_v2_ClientPollState| { &mut m.names },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &CMsgGCCStrike15_v2_ClientPollState| { &m.values },
            |m: &mut CMsgGCCStrike15_v2_ClientPollState| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientPollState>(
            "CMsgGCCStrike15_v2_ClientPollState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientPollState {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientPollState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pollid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.names.push(is.read_string()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.values)?;
                },
                24 => {
                    self.values.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pollid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.values {
            my_size += ::protobuf::rt::int32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pollid {
            os.write_uint32(1, v)?;
        }
        for v in &self.names {
            os.write_string(2, &v)?;
        };
        for v in &self.values {
            os.write_int32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientPollState {
        CMsgGCCStrike15_v2_ClientPollState::new()
    }

    fn clear(&mut self) {
        self.pollid = ::std::option::Option::None;
        self.names.clear();
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientPollState {
        static instance: CMsgGCCStrike15_v2_ClientPollState = CMsgGCCStrike15_v2_ClientPollState {
            pollid: ::std::option::Option::None,
            names: ::std::vec::Vec::new(),
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientPollState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientPollState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientPollState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientPollState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Party_Register)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Party_Register {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Register.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Register.ver)
    pub ver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Register.apr)
    pub apr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Register.ark)
    pub ark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Register.nby)
    pub nby: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Register.grp)
    pub grp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Register.slots)
    pub slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Register.launcher)
    pub launcher: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Register.game_type)
    pub game_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Party_Register.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Party_Register {
    fn default() -> &'a CMsgGCCStrike15_v2_Party_Register {
        <CMsgGCCStrike15_v2_Party_Register as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Party_Register {
    pub fn new() -> CMsgGCCStrike15_v2_Party_Register {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 ver = 2;

    pub fn ver(&self) -> u32 {
        self.ver.unwrap_or(0)
    }

    pub fn clear_ver(&mut self) {
        self.ver = ::std::option::Option::None;
    }

    pub fn has_ver(&self) -> bool {
        self.ver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ver(&mut self, v: u32) {
        self.ver = ::std::option::Option::Some(v);
    }

    // optional uint32 apr = 3;

    pub fn apr(&self) -> u32 {
        self.apr.unwrap_or(0)
    }

    pub fn clear_apr(&mut self) {
        self.apr = ::std::option::Option::None;
    }

    pub fn has_apr(&self) -> bool {
        self.apr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apr(&mut self, v: u32) {
        self.apr = ::std::option::Option::Some(v);
    }

    // optional uint32 ark = 4;

    pub fn ark(&self) -> u32 {
        self.ark.unwrap_or(0)
    }

    pub fn clear_ark(&mut self) {
        self.ark = ::std::option::Option::None;
    }

    pub fn has_ark(&self) -> bool {
        self.ark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ark(&mut self, v: u32) {
        self.ark = ::std::option::Option::Some(v);
    }

    // optional uint32 nby = 5;

    pub fn nby(&self) -> u32 {
        self.nby.unwrap_or(0)
    }

    pub fn clear_nby(&mut self) {
        self.nby = ::std::option::Option::None;
    }

    pub fn has_nby(&self) -> bool {
        self.nby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nby(&mut self, v: u32) {
        self.nby = ::std::option::Option::Some(v);
    }

    // optional uint32 grp = 6;

    pub fn grp(&self) -> u32 {
        self.grp.unwrap_or(0)
    }

    pub fn clear_grp(&mut self) {
        self.grp = ::std::option::Option::None;
    }

    pub fn has_grp(&self) -> bool {
        self.grp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grp(&mut self, v: u32) {
        self.grp = ::std::option::Option::Some(v);
    }

    // optional uint32 slots = 7;

    pub fn slots(&self) -> u32 {
        self.slots.unwrap_or(0)
    }

    pub fn clear_slots(&mut self) {
        self.slots = ::std::option::Option::None;
    }

    pub fn has_slots(&self) -> bool {
        self.slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots(&mut self, v: u32) {
        self.slots = ::std::option::Option::Some(v);
    }

    // optional uint32 launcher = 8;

    pub fn launcher(&self) -> u32 {
        self.launcher.unwrap_or(0)
    }

    pub fn clear_launcher(&mut self) {
        self.launcher = ::std::option::Option::None;
    }

    pub fn has_launcher(&self) -> bool {
        self.launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launcher(&mut self, v: u32) {
        self.launcher = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 9;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgGCCStrike15_v2_Party_Register| { &m.id },
            |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ver",
            |m: &CMsgGCCStrike15_v2_Party_Register| { &m.ver },
            |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.ver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apr",
            |m: &CMsgGCCStrike15_v2_Party_Register| { &m.apr },
            |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.apr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ark",
            |m: &CMsgGCCStrike15_v2_Party_Register| { &m.ark },
            |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.ark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nby",
            |m: &CMsgGCCStrike15_v2_Party_Register| { &m.nby },
            |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.nby },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "grp",
            |m: &CMsgGCCStrike15_v2_Party_Register| { &m.grp },
            |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.grp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slots",
            |m: &CMsgGCCStrike15_v2_Party_Register| { &m.slots },
            |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "launcher",
            |m: &CMsgGCCStrike15_v2_Party_Register| { &m.launcher },
            |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.launcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGCCStrike15_v2_Party_Register| { &m.game_type },
            |m: &mut CMsgGCCStrike15_v2_Party_Register| { &mut m.game_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Party_Register>(
            "CMsgGCCStrike15_v2_Party_Register",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Party_Register {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Party_Register";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.ver = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.apr = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ark = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.nby = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.grp = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.launcher = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ver {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.apr {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ark {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.nby {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.grp {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.slots {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.launcher {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ver {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.apr {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ark {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.nby {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.grp {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.slots {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.launcher {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Party_Register {
        CMsgGCCStrike15_v2_Party_Register::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.ver = ::std::option::Option::None;
        self.apr = ::std::option::Option::None;
        self.ark = ::std::option::Option::None;
        self.nby = ::std::option::Option::None;
        self.grp = ::std::option::Option::None;
        self.slots = ::std::option::Option::None;
        self.launcher = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Party_Register {
        static instance: CMsgGCCStrike15_v2_Party_Register = CMsgGCCStrike15_v2_Party_Register {
            id: ::std::option::Option::None,
            ver: ::std::option::Option::None,
            apr: ::std::option::Option::None,
            ark: ::std::option::Option::None,
            nby: ::std::option::Option::None,
            grp: ::std::option::Option::None,
            slots: ::std::option::Option::None,
            launcher: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Party_Register {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Party_Register").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Party_Register {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Party_Register {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Party_Search)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Party_Search {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Search.ver)
    pub ver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Search.apr)
    pub apr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Search.ark)
    pub ark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Search.grps)
    pub grps: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Search.launcher)
    pub launcher: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Search.game_type)
    pub game_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Party_Search.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Party_Search {
    fn default() -> &'a CMsgGCCStrike15_v2_Party_Search {
        <CMsgGCCStrike15_v2_Party_Search as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Party_Search {
    pub fn new() -> CMsgGCCStrike15_v2_Party_Search {
        ::std::default::Default::default()
    }

    // optional uint32 ver = 1;

    pub fn ver(&self) -> u32 {
        self.ver.unwrap_or(0)
    }

    pub fn clear_ver(&mut self) {
        self.ver = ::std::option::Option::None;
    }

    pub fn has_ver(&self) -> bool {
        self.ver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ver(&mut self, v: u32) {
        self.ver = ::std::option::Option::Some(v);
    }

    // optional uint32 apr = 2;

    pub fn apr(&self) -> u32 {
        self.apr.unwrap_or(0)
    }

    pub fn clear_apr(&mut self) {
        self.apr = ::std::option::Option::None;
    }

    pub fn has_apr(&self) -> bool {
        self.apr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apr(&mut self, v: u32) {
        self.apr = ::std::option::Option::Some(v);
    }

    // optional uint32 ark = 3;

    pub fn ark(&self) -> u32 {
        self.ark.unwrap_or(0)
    }

    pub fn clear_ark(&mut self) {
        self.ark = ::std::option::Option::None;
    }

    pub fn has_ark(&self) -> bool {
        self.ark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ark(&mut self, v: u32) {
        self.ark = ::std::option::Option::Some(v);
    }

    // optional uint32 launcher = 5;

    pub fn launcher(&self) -> u32 {
        self.launcher.unwrap_or(0)
    }

    pub fn clear_launcher(&mut self) {
        self.launcher = ::std::option::Option::None;
    }

    pub fn has_launcher(&self) -> bool {
        self.launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launcher(&mut self, v: u32) {
        self.launcher = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 6;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ver",
            |m: &CMsgGCCStrike15_v2_Party_Search| { &m.ver },
            |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.ver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "apr",
            |m: &CMsgGCCStrike15_v2_Party_Search| { &m.apr },
            |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.apr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ark",
            |m: &CMsgGCCStrike15_v2_Party_Search| { &m.ark },
            |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.ark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "grps",
            |m: &CMsgGCCStrike15_v2_Party_Search| { &m.grps },
            |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.grps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "launcher",
            |m: &CMsgGCCStrike15_v2_Party_Search| { &m.launcher },
            |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.launcher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGCCStrike15_v2_Party_Search| { &m.game_type },
            |m: &mut CMsgGCCStrike15_v2_Party_Search| { &mut m.game_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Party_Search>(
            "CMsgGCCStrike15_v2_Party_Search",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Party_Search {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Party_Search";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ver = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.apr = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.ark = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.grps)?;
                },
                32 => {
                    self.grps.push(is.read_uint32()?);
                },
                40 => {
                    self.launcher = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ver {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.apr {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ark {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.grps {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.launcher {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ver {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.apr {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ark {
            os.write_uint32(3, v)?;
        }
        for v in &self.grps {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.launcher {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Party_Search {
        CMsgGCCStrike15_v2_Party_Search::new()
    }

    fn clear(&mut self) {
        self.ver = ::std::option::Option::None;
        self.apr = ::std::option::Option::None;
        self.ark = ::std::option::Option::None;
        self.grps.clear();
        self.launcher = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Party_Search {
        static instance: CMsgGCCStrike15_v2_Party_Search = CMsgGCCStrike15_v2_Party_Search {
            ver: ::std::option::Option::None,
            apr: ::std::option::Option::None,
            ark: ::std::option::Option::None,
            grps: ::std::vec::Vec::new(),
            launcher: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Party_Search {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Party_Search").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Party_Search {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Party_Search {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Party_SearchResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Party_SearchResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_SearchResults.entries)
    pub entries: ::std::vec::Vec<cmsg_gccstrike15_v2_party_search_results::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Party_SearchResults.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Party_SearchResults {
    fn default() -> &'a CMsgGCCStrike15_v2_Party_SearchResults {
        <CMsgGCCStrike15_v2_Party_SearchResults as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Party_SearchResults {
    pub fn new() -> CMsgGCCStrike15_v2_Party_SearchResults {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgGCCStrike15_v2_Party_SearchResults| { &m.entries },
            |m: &mut CMsgGCCStrike15_v2_Party_SearchResults| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Party_SearchResults>(
            "CMsgGCCStrike15_v2_Party_SearchResults",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Party_SearchResults {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Party_SearchResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Party_SearchResults {
        CMsgGCCStrike15_v2_Party_SearchResults::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Party_SearchResults {
        static instance: CMsgGCCStrike15_v2_Party_SearchResults = CMsgGCCStrike15_v2_Party_SearchResults {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Party_SearchResults {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Party_SearchResults").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Party_SearchResults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Party_SearchResults {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_Party_SearchResults`
pub mod cmsg_gccstrike15_v2_party_search_results {
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Party_SearchResults.Entry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_SearchResults.Entry.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_SearchResults.Entry.grp)
        pub grp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_SearchResults.Entry.game_type)
        pub game_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_SearchResults.Entry.apr)
        pub apr: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_SearchResults.Entry.ark)
        pub ark: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_SearchResults.Entry.loc)
        pub loc: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_SearchResults.Entry.accountid)
        pub accountid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Party_SearchResults.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 grp = 2;

        pub fn grp(&self) -> u32 {
            self.grp.unwrap_or(0)
        }

        pub fn clear_grp(&mut self) {
            self.grp = ::std::option::Option::None;
        }

        pub fn has_grp(&self) -> bool {
            self.grp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_grp(&mut self, v: u32) {
            self.grp = ::std::option::Option::Some(v);
        }

        // optional uint32 game_type = 3;

        pub fn game_type(&self) -> u32 {
            self.game_type.unwrap_or(0)
        }

        pub fn clear_game_type(&mut self) {
            self.game_type = ::std::option::Option::None;
        }

        pub fn has_game_type(&self) -> bool {
            self.game_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_type(&mut self, v: u32) {
            self.game_type = ::std::option::Option::Some(v);
        }

        // optional uint32 apr = 4;

        pub fn apr(&self) -> u32 {
            self.apr.unwrap_or(0)
        }

        pub fn clear_apr(&mut self) {
            self.apr = ::std::option::Option::None;
        }

        pub fn has_apr(&self) -> bool {
            self.apr.is_some()
        }

        // Param is passed by value, moved
        pub fn set_apr(&mut self, v: u32) {
            self.apr = ::std::option::Option::Some(v);
        }

        // optional uint32 ark = 5;

        pub fn ark(&self) -> u32 {
            self.ark.unwrap_or(0)
        }

        pub fn clear_ark(&mut self) {
            self.ark = ::std::option::Option::None;
        }

        pub fn has_ark(&self) -> bool {
            self.ark.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ark(&mut self, v: u32) {
            self.ark = ::std::option::Option::Some(v);
        }

        // optional uint32 loc = 6;

        pub fn loc(&self) -> u32 {
            self.loc.unwrap_or(0)
        }

        pub fn clear_loc(&mut self) {
            self.loc = ::std::option::Option::None;
        }

        pub fn has_loc(&self) -> bool {
            self.loc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_loc(&mut self, v: u32) {
            self.loc = ::std::option::Option::Some(v);
        }

        // optional uint32 accountid = 7;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "id",
                |m: &Entry| { &m.id },
                |m: &mut Entry| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "grp",
                |m: &Entry| { &m.grp },
                |m: &mut Entry| { &mut m.grp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_type",
                |m: &Entry| { &m.game_type },
                |m: &mut Entry| { &mut m.game_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "apr",
                |m: &Entry| { &m.apr },
                |m: &mut Entry| { &mut m.apr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ark",
                |m: &Entry| { &m.ark },
                |m: &mut Entry| { &mut m.ark },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "loc",
                |m: &Entry| { &m.loc },
                |m: &mut Entry| { &mut m.loc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &Entry| { &m.accountid },
                |m: &mut Entry| { &mut m.accountid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "CMsgGCCStrike15_v2_Party_SearchResults.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.grp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.apr = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.ark = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.loc = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.grp {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.game_type {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.apr {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.ark {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.loc {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.grp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.game_type {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.apr {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.ark {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.loc {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.accountid {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.grp = ::std::option::Option::None;
            self.game_type = ::std::option::Option::None;
            self.apr = ::std::option::Option::None;
            self.ark = ::std::option::Option::None;
            self.loc = ::std::option::Option::None;
            self.accountid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                id: ::std::option::Option::None,
                grp: ::std::option::Option::None,
                game_type: ::std::option::Option::None,
                apr: ::std::option::Option::None,
                ark: ::std::option::Option::None,
                loc: ::std::option::Option::None,
                accountid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Party_SearchResults.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Party_Invite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Party_Invite {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Invite.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Party_Invite.lobbyid)
    pub lobbyid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Party_Invite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Party_Invite {
    fn default() -> &'a CMsgGCCStrike15_v2_Party_Invite {
        <CMsgGCCStrike15_v2_Party_Invite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Party_Invite {
    pub fn new() -> CMsgGCCStrike15_v2_Party_Invite {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 lobbyid = 2;

    pub fn lobbyid(&self) -> u32 {
        self.lobbyid.unwrap_or(0)
    }

    pub fn clear_lobbyid(&mut self) {
        self.lobbyid = ::std::option::Option::None;
    }

    pub fn has_lobbyid(&self) -> bool {
        self.lobbyid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobbyid(&mut self, v: u32) {
        self.lobbyid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_Party_Invite| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_Party_Invite| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobbyid",
            |m: &CMsgGCCStrike15_v2_Party_Invite| { &m.lobbyid },
            |m: &mut CMsgGCCStrike15_v2_Party_Invite| { &mut m.lobbyid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Party_Invite>(
            "CMsgGCCStrike15_v2_Party_Invite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Party_Invite {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Party_Invite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lobbyid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lobbyid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lobbyid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Party_Invite {
        CMsgGCCStrike15_v2_Party_Invite::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.lobbyid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Party_Invite {
        static instance: CMsgGCCStrike15_v2_Party_Invite = CMsgGCCStrike15_v2_Party_Invite {
            accountid: ::std::option::Option::None,
            lobbyid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Party_Invite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Party_Invite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Party_Invite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Party_Invite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Account_RequestCoPlays)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_Account_RequestCoPlays {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Account_RequestCoPlays.players)
    pub players: ::std::vec::Vec<cmsg_gccstrike15_v2_account_request_co_plays::Player>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Account_RequestCoPlays.servertime)
    pub servertime: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Account_RequestCoPlays.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Account_RequestCoPlays {
    fn default() -> &'a CMsgGCCStrike15_v2_Account_RequestCoPlays {
        <CMsgGCCStrike15_v2_Account_RequestCoPlays as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Account_RequestCoPlays {
    pub fn new() -> CMsgGCCStrike15_v2_Account_RequestCoPlays {
        ::std::default::Default::default()
    }

    // optional uint32 servertime = 2;

    pub fn servertime(&self) -> u32 {
        self.servertime.unwrap_or(0)
    }

    pub fn clear_servertime(&mut self) {
        self.servertime = ::std::option::Option::None;
    }

    pub fn has_servertime(&self) -> bool {
        self.servertime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servertime(&mut self, v: u32) {
        self.servertime = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CMsgGCCStrike15_v2_Account_RequestCoPlays| { &m.players },
            |m: &mut CMsgGCCStrike15_v2_Account_RequestCoPlays| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "servertime",
            |m: &CMsgGCCStrike15_v2_Account_RequestCoPlays| { &m.servertime },
            |m: &mut CMsgGCCStrike15_v2_Account_RequestCoPlays| { &mut m.servertime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Account_RequestCoPlays>(
            "CMsgGCCStrike15_v2_Account_RequestCoPlays",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Account_RequestCoPlays {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Account_RequestCoPlays";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                16 => {
                    self.servertime = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.servertime {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.servertime {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Account_RequestCoPlays {
        CMsgGCCStrike15_v2_Account_RequestCoPlays::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.servertime = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Account_RequestCoPlays {
        static instance: CMsgGCCStrike15_v2_Account_RequestCoPlays = CMsgGCCStrike15_v2_Account_RequestCoPlays {
            players: ::std::vec::Vec::new(),
            servertime: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Account_RequestCoPlays {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Account_RequestCoPlays").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Account_RequestCoPlays {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Account_RequestCoPlays {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_Account_RequestCoPlays`
pub mod cmsg_gccstrike15_v2_account_request_co_plays {
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Account_RequestCoPlays.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Account_RequestCoPlays.Player.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Account_RequestCoPlays.Player.rtcoplay)
        pub rtcoplay: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Account_RequestCoPlays.Player.online)
        pub online: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Account_RequestCoPlays.Player.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 rtcoplay = 2;

        pub fn rtcoplay(&self) -> u32 {
            self.rtcoplay.unwrap_or(0)
        }

        pub fn clear_rtcoplay(&mut self) {
            self.rtcoplay = ::std::option::Option::None;
        }

        pub fn has_rtcoplay(&self) -> bool {
            self.rtcoplay.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtcoplay(&mut self, v: u32) {
            self.rtcoplay = ::std::option::Option::Some(v);
        }

        // optional bool online = 3;

        pub fn online(&self) -> bool {
            self.online.unwrap_or(false)
        }

        pub fn clear_online(&mut self) {
            self.online = ::std::option::Option::None;
        }

        pub fn has_online(&self) -> bool {
            self.online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_online(&mut self, v: bool) {
            self.online = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &Player| { &m.accountid },
                |m: &mut Player| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtcoplay",
                |m: &Player| { &m.rtcoplay },
                |m: &mut Player| { &mut m.rtcoplay },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "online",
                |m: &Player| { &m.online },
                |m: &mut Player| { &mut m.online },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CMsgGCCStrike15_v2_Account_RequestCoPlays.Player",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.rtcoplay = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.online = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.rtcoplay {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.online {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.rtcoplay {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.online {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.rtcoplay = ::std::option::Option::None;
            self.online = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                accountid: ::std::option::Option::None,
                rtcoplay: ::std::option::Option::None,
                online: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Player {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Account_RequestCoPlays.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Player {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientToGCRequestTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientToGCRequestTicket.authorized_steam_id)
    pub authorized_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientToGCRequestTicket.authorized_public_ip)
    pub authorized_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientToGCRequestTicket.gameserver_steam_id)
    pub gameserver_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientToGCRequestTicket.gameserver_sdr_routing)
    pub gameserver_sdr_routing: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientToGCRequestTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientToGCRequestTicket {
        <CMsgGCCStrike15_v2_ClientToGCRequestTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    pub fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestTicket {
        ::std::default::Default::default()
    }

    // optional fixed64 authorized_steam_id = 1;

    pub fn authorized_steam_id(&self) -> u64 {
        self.authorized_steam_id.unwrap_or(0)
    }

    pub fn clear_authorized_steam_id(&mut self) {
        self.authorized_steam_id = ::std::option::Option::None;
    }

    pub fn has_authorized_steam_id(&self) -> bool {
        self.authorized_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorized_steam_id(&mut self, v: u64) {
        self.authorized_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 authorized_public_ip = 2;

    pub fn authorized_public_ip(&self) -> u32 {
        self.authorized_public_ip.unwrap_or(0)
    }

    pub fn clear_authorized_public_ip(&mut self) {
        self.authorized_public_ip = ::std::option::Option::None;
    }

    pub fn has_authorized_public_ip(&self) -> bool {
        self.authorized_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorized_public_ip(&mut self, v: u32) {
        self.authorized_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameserver_steam_id = 3;

    pub fn gameserver_steam_id(&self) -> u64 {
        self.gameserver_steam_id.unwrap_or(0)
    }

    pub fn clear_gameserver_steam_id(&mut self) {
        self.gameserver_steam_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_steam_id(&self) -> bool {
        self.gameserver_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_steam_id(&mut self, v: u64) {
        self.gameserver_steam_id = ::std::option::Option::Some(v);
    }

    // optional string gameserver_sdr_routing = 5;

    pub fn gameserver_sdr_routing(&self) -> &str {
        match self.gameserver_sdr_routing.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gameserver_sdr_routing(&mut self) {
        self.gameserver_sdr_routing = ::std::option::Option::None;
    }

    pub fn has_gameserver_sdr_routing(&self) -> bool {
        self.gameserver_sdr_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_sdr_routing(&mut self, v: ::std::string::String) {
        self.gameserver_sdr_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gameserver_sdr_routing(&mut self) -> &mut ::std::string::String {
        if self.gameserver_sdr_routing.is_none() {
            self.gameserver_sdr_routing = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gameserver_sdr_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_gameserver_sdr_routing(&mut self) -> ::std::string::String {
        self.gameserver_sdr_routing.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "authorized_steam_id",
            |m: &CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &m.authorized_steam_id },
            |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &mut m.authorized_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "authorized_public_ip",
            |m: &CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &m.authorized_public_ip },
            |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &mut m.authorized_public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameserver_steam_id",
            |m: &CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &m.gameserver_steam_id },
            |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &mut m.gameserver_steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameserver_sdr_routing",
            |m: &CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &m.gameserver_sdr_routing },
            |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestTicket| { &mut m.gameserver_sdr_routing },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientToGCRequestTicket>(
            "CMsgGCCStrike15_v2_ClientToGCRequestTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientToGCRequestTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.authorized_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                21 => {
                    self.authorized_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                25 => {
                    self.gameserver_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    self.gameserver_sdr_routing = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.authorized_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.authorized_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.gameserver_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.gameserver_sdr_routing.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.authorized_steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.authorized_public_ip {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.gameserver_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gameserver_sdr_routing.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestTicket {
        CMsgGCCStrike15_v2_ClientToGCRequestTicket::new()
    }

    fn clear(&mut self) {
        self.authorized_steam_id = ::std::option::Option::None;
        self.authorized_public_ip = ::std::option::Option::None;
        self.gameserver_steam_id = ::std::option::Option::None;
        self.gameserver_sdr_routing = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientToGCRequestTicket {
        static instance: CMsgGCCStrike15_v2_ClientToGCRequestTicket = CMsgGCCStrike15_v2_ClientToGCRequestTicket {
            authorized_steam_id: ::std::option::Option::None,
            authorized_public_ip: ::std::option::Option::None,
            gameserver_steam_id: ::std::option::Option::None,
            gameserver_sdr_routing: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientToGCRequestTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientToGCRequestTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCToClientSteamDatagramTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientSteamDatagramTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientSteamDatagramTicket.serialized_ticket)
    pub serialized_ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientSteamDatagramTicket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientSteamDatagramTicket {
    fn default() -> &'a CMsgGCToClientSteamDatagramTicket {
        <CMsgGCToClientSteamDatagramTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientSteamDatagramTicket {
    pub fn new() -> CMsgGCToClientSteamDatagramTicket {
        ::std::default::Default::default()
    }

    // optional bytes serialized_ticket = 16;

    pub fn serialized_ticket(&self) -> &[u8] {
        match self.serialized_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_ticket(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
    }

    pub fn has_serialized_ticket(&self) -> bool {
        self.serialized_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_ticket.is_none() {
            self.serialized_ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serialized_ticket",
            |m: &CMsgGCToClientSteamDatagramTicket| { &m.serialized_ticket },
            |m: &mut CMsgGCToClientSteamDatagramTicket| { &mut m.serialized_ticket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToClientSteamDatagramTicket>(
            "CMsgGCToClientSteamDatagramTicket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToClientSteamDatagramTicket {
    const NAME: &'static str = "CMsgGCToClientSteamDatagramTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                130 => {
                    self.serialized_ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serialized_ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(16, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serialized_ticket.as_ref() {
            os.write_bytes(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientSteamDatagramTicket {
        CMsgGCToClientSteamDatagramTicket::new()
    }

    fn clear(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientSteamDatagramTicket {
        static instance: CMsgGCToClientSteamDatagramTicket = CMsgGCToClientSteamDatagramTicket {
            serialized_ticket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToClientSteamDatagramTicket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToClientSteamDatagramTicket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToClientSteamDatagramTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToClientSteamDatagramTicket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientRequestOffers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientRequestOffers {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientRequestOffers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestOffers {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestOffers {
        <CMsgGCCStrike15_v2_ClientRequestOffers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestOffers {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestOffers {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientRequestOffers>(
            "CMsgGCCStrike15_v2_ClientRequestOffers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestOffers {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientRequestOffers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestOffers {
        CMsgGCCStrike15_v2_ClientRequestOffers::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestOffers {
        static instance: CMsgGCCStrike15_v2_ClientRequestOffers = CMsgGCCStrike15_v2_ClientRequestOffers {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientRequestOffers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientRequestOffers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientRequestOffers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestOffers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientRequestSouvenir)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientRequestSouvenir {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestSouvenir.itemid)
    pub itemid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestSouvenir.matchid)
    pub matchid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestSouvenir.eventid)
    pub eventid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientRequestSouvenir.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestSouvenir {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestSouvenir {
        <CMsgGCCStrike15_v2_ClientRequestSouvenir as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestSouvenir {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestSouvenir {
        ::std::default::Default::default()
    }

    // optional uint64 itemid = 1;

    pub fn itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    // optional uint64 matchid = 2;

    pub fn matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    // optional int32 eventid = 3;

    pub fn eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemid",
            |m: &CMsgGCCStrike15_v2_ClientRequestSouvenir| { &m.itemid },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestSouvenir| { &mut m.itemid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchid",
            |m: &CMsgGCCStrike15_v2_ClientRequestSouvenir| { &m.matchid },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestSouvenir| { &mut m.matchid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CMsgGCCStrike15_v2_ClientRequestSouvenir| { &m.eventid },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestSouvenir| { &mut m.eventid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientRequestSouvenir>(
            "CMsgGCCStrike15_v2_ClientRequestSouvenir",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestSouvenir {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientRequestSouvenir";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.itemid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.matchid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.eventid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.itemid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.matchid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.eventid {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestSouvenir {
        CMsgGCCStrike15_v2_ClientRequestSouvenir::new()
    }

    fn clear(&mut self) {
        self.itemid = ::std::option::Option::None;
        self.matchid = ::std::option::Option::None;
        self.eventid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestSouvenir {
        static instance: CMsgGCCStrike15_v2_ClientRequestSouvenir = CMsgGCCStrike15_v2_ClientRequestSouvenir {
            itemid: ::std::option::Option::None,
            matchid: ::std::option::Option::None,
            eventid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientRequestSouvenir {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientRequestSouvenir").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientRequestSouvenir {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestSouvenir {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientAccountBalance)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientAccountBalance {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientAccountBalance.amount)
    pub amount: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientAccountBalance.url)
    pub url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientAccountBalance.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientAccountBalance {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientAccountBalance {
        <CMsgGCCStrike15_v2_ClientAccountBalance as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientAccountBalance {
    pub fn new() -> CMsgGCCStrike15_v2_ClientAccountBalance {
        ::std::default::Default::default()
    }

    // optional uint64 amount = 1;

    pub fn amount(&self) -> u64 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: u64) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional string url = 2;

    pub fn url(&self) -> &str {
        match self.url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_url(&mut self) {
        self.url = ::std::option::Option::None;
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url(&mut self) -> &mut ::std::string::String {
        if self.url.is_none() {
            self.url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &CMsgGCCStrike15_v2_ClientAccountBalance| { &m.amount },
            |m: &mut CMsgGCCStrike15_v2_ClientAccountBalance| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "url",
            |m: &CMsgGCCStrike15_v2_ClientAccountBalance| { &m.url },
            |m: &mut CMsgGCCStrike15_v2_ClientAccountBalance| { &mut m.url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientAccountBalance>(
            "CMsgGCCStrike15_v2_ClientAccountBalance",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientAccountBalance {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientAccountBalance";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.amount = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.url.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.amount {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.url.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientAccountBalance {
        CMsgGCCStrike15_v2_ClientAccountBalance::new()
    }

    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientAccountBalance {
        static instance: CMsgGCCStrike15_v2_ClientAccountBalance = CMsgGCCStrike15_v2_ClientAccountBalance {
            amount: ::std::option::Option::None,
            url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientAccountBalance {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientAccountBalance").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientAccountBalance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientAccountBalance {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientPartyJoinRelay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPartyJoinRelay.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPartyJoinRelay.lobbyid)
    pub lobbyid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientPartyJoinRelay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientPartyJoinRelay {
        <CMsgGCCStrike15_v2_ClientPartyJoinRelay as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    pub fn new() -> CMsgGCCStrike15_v2_ClientPartyJoinRelay {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 lobbyid = 2;

    pub fn lobbyid(&self) -> u64 {
        self.lobbyid.unwrap_or(0)
    }

    pub fn clear_lobbyid(&mut self) {
        self.lobbyid = ::std::option::Option::None;
    }

    pub fn has_lobbyid(&self) -> bool {
        self.lobbyid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobbyid(&mut self, v: u64) {
        self.lobbyid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_ClientPartyJoinRelay| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_ClientPartyJoinRelay| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lobbyid",
            |m: &CMsgGCCStrike15_v2_ClientPartyJoinRelay| { &m.lobbyid },
            |m: &mut CMsgGCCStrike15_v2_ClientPartyJoinRelay| { &mut m.lobbyid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientPartyJoinRelay>(
            "CMsgGCCStrike15_v2_ClientPartyJoinRelay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientPartyJoinRelay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lobbyid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lobbyid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lobbyid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientPartyJoinRelay {
        CMsgGCCStrike15_v2_ClientPartyJoinRelay::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.lobbyid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientPartyJoinRelay {
        static instance: CMsgGCCStrike15_v2_ClientPartyJoinRelay = CMsgGCCStrike15_v2_ClientPartyJoinRelay {
            accountid: ::std::option::Option::None,
            lobbyid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientPartyJoinRelay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientPartyJoinRelay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientPartyWarning)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientPartyWarning {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPartyWarning.entries)
    pub entries: ::std::vec::Vec<cmsg_gccstrike15_v2_client_party_warning::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientPartyWarning.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientPartyWarning {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientPartyWarning {
        <CMsgGCCStrike15_v2_ClientPartyWarning as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientPartyWarning {
    pub fn new() -> CMsgGCCStrike15_v2_ClientPartyWarning {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgGCCStrike15_v2_ClientPartyWarning| { &m.entries },
            |m: &mut CMsgGCCStrike15_v2_ClientPartyWarning| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientPartyWarning>(
            "CMsgGCCStrike15_v2_ClientPartyWarning",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientPartyWarning {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientPartyWarning";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientPartyWarning {
        CMsgGCCStrike15_v2_ClientPartyWarning::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientPartyWarning {
        static instance: CMsgGCCStrike15_v2_ClientPartyWarning = CMsgGCCStrike15_v2_ClientPartyWarning {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientPartyWarning {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientPartyWarning").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientPartyWarning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientPartyWarning {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_ClientPartyWarning`
pub mod cmsg_gccstrike15_v2_client_party_warning {
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientPartyWarning.Entry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPartyWarning.Entry.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPartyWarning.Entry.warntype)
        pub warntype: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientPartyWarning.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 warntype = 2;

        pub fn warntype(&self) -> u32 {
            self.warntype.unwrap_or(0)
        }

        pub fn clear_warntype(&mut self) {
            self.warntype = ::std::option::Option::None;
        }

        pub fn has_warntype(&self) -> bool {
            self.warntype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_warntype(&mut self, v: u32) {
            self.warntype = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &Entry| { &m.accountid },
                |m: &mut Entry| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "warntype",
                |m: &Entry| { &m.warntype },
                |m: &mut Entry| { &mut m.warntype },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "CMsgGCCStrike15_v2_ClientPartyWarning.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.warntype = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.warntype {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.warntype {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.warntype = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                accountid: ::std::option::Option::None,
                warntype: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientPartyWarning.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_SetEventFavorite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_SetEventFavorite {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_SetEventFavorite.eventid)
    pub eventid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_SetEventFavorite.is_favorite)
    pub is_favorite: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_SetEventFavorite.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_SetEventFavorite {
    fn default() -> &'a CMsgGCCStrike15_v2_SetEventFavorite {
        <CMsgGCCStrike15_v2_SetEventFavorite as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_SetEventFavorite {
    pub fn new() -> CMsgGCCStrike15_v2_SetEventFavorite {
        ::std::default::Default::default()
    }

    // optional uint64 eventid = 1;

    pub fn eventid(&self) -> u64 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: u64) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional bool is_favorite = 2;

    pub fn is_favorite(&self) -> bool {
        self.is_favorite.unwrap_or(false)
    }

    pub fn clear_is_favorite(&mut self) {
        self.is_favorite = ::std::option::Option::None;
    }

    pub fn has_is_favorite(&self) -> bool {
        self.is_favorite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_favorite(&mut self, v: bool) {
        self.is_favorite = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CMsgGCCStrike15_v2_SetEventFavorite| { &m.eventid },
            |m: &mut CMsgGCCStrike15_v2_SetEventFavorite| { &mut m.eventid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_favorite",
            |m: &CMsgGCCStrike15_v2_SetEventFavorite| { &m.is_favorite },
            |m: &mut CMsgGCCStrike15_v2_SetEventFavorite| { &mut m.is_favorite },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_SetEventFavorite>(
            "CMsgGCCStrike15_v2_SetEventFavorite",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_SetEventFavorite {
    const NAME: &'static str = "CMsgGCCStrike15_v2_SetEventFavorite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eventid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.is_favorite = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.is_favorite {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eventid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.is_favorite {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_SetEventFavorite {
        CMsgGCCStrike15_v2_SetEventFavorite::new()
    }

    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.is_favorite = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_SetEventFavorite {
        static instance: CMsgGCCStrike15_v2_SetEventFavorite = CMsgGCCStrike15_v2_SetEventFavorite {
            eventid: ::std::option::Option::None,
            is_favorite: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_SetEventFavorite {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_SetEventFavorite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_SetEventFavorite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_SetEventFavorite {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GetEventFavorites_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GetEventFavorites_Request {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GetEventFavorites_Request.all_events)
    pub all_events: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GetEventFavorites_Request.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GetEventFavorites_Request {
    fn default() -> &'a CMsgGCCStrike15_v2_GetEventFavorites_Request {
        <CMsgGCCStrike15_v2_GetEventFavorites_Request as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GetEventFavorites_Request {
    pub fn new() -> CMsgGCCStrike15_v2_GetEventFavorites_Request {
        ::std::default::Default::default()
    }

    // optional bool all_events = 1;

    pub fn all_events(&self) -> bool {
        self.all_events.unwrap_or(false)
    }

    pub fn clear_all_events(&mut self) {
        self.all_events = ::std::option::Option::None;
    }

    pub fn has_all_events(&self) -> bool {
        self.all_events.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_events(&mut self, v: bool) {
        self.all_events = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "all_events",
            |m: &CMsgGCCStrike15_v2_GetEventFavorites_Request| { &m.all_events },
            |m: &mut CMsgGCCStrike15_v2_GetEventFavorites_Request| { &mut m.all_events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GetEventFavorites_Request>(
            "CMsgGCCStrike15_v2_GetEventFavorites_Request",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GetEventFavorites_Request {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GetEventFavorites_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.all_events = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.all_events {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.all_events {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GetEventFavorites_Request {
        CMsgGCCStrike15_v2_GetEventFavorites_Request::new()
    }

    fn clear(&mut self) {
        self.all_events = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GetEventFavorites_Request {
        static instance: CMsgGCCStrike15_v2_GetEventFavorites_Request = CMsgGCCStrike15_v2_GetEventFavorites_Request {
            all_events: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GetEventFavorites_Request {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GetEventFavorites_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GetEventFavorites_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GetEventFavorites_Request {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GetEventFavorites_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GetEventFavorites_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GetEventFavorites_Response.all_events)
    pub all_events: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GetEventFavorites_Response.json_favorites)
    pub json_favorites: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GetEventFavorites_Response.json_featured)
    pub json_featured: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GetEventFavorites_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GetEventFavorites_Response {
    fn default() -> &'a CMsgGCCStrike15_v2_GetEventFavorites_Response {
        <CMsgGCCStrike15_v2_GetEventFavorites_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GetEventFavorites_Response {
    pub fn new() -> CMsgGCCStrike15_v2_GetEventFavorites_Response {
        ::std::default::Default::default()
    }

    // optional bool all_events = 1;

    pub fn all_events(&self) -> bool {
        self.all_events.unwrap_or(false)
    }

    pub fn clear_all_events(&mut self) {
        self.all_events = ::std::option::Option::None;
    }

    pub fn has_all_events(&self) -> bool {
        self.all_events.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_events(&mut self, v: bool) {
        self.all_events = ::std::option::Option::Some(v);
    }

    // optional string json_favorites = 2;

    pub fn json_favorites(&self) -> &str {
        match self.json_favorites.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_favorites(&mut self) {
        self.json_favorites = ::std::option::Option::None;
    }

    pub fn has_json_favorites(&self) -> bool {
        self.json_favorites.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_favorites(&mut self, v: ::std::string::String) {
        self.json_favorites = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_favorites(&mut self) -> &mut ::std::string::String {
        if self.json_favorites.is_none() {
            self.json_favorites = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_favorites.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_favorites(&mut self) -> ::std::string::String {
        self.json_favorites.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string json_featured = 3;

    pub fn json_featured(&self) -> &str {
        match self.json_featured.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_featured(&mut self) {
        self.json_featured = ::std::option::Option::None;
    }

    pub fn has_json_featured(&self) -> bool {
        self.json_featured.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_featured(&mut self, v: ::std::string::String) {
        self.json_featured = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_featured(&mut self) -> &mut ::std::string::String {
        if self.json_featured.is_none() {
            self.json_featured = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_featured.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_featured(&mut self) -> ::std::string::String {
        self.json_featured.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "all_events",
            |m: &CMsgGCCStrike15_v2_GetEventFavorites_Response| { &m.all_events },
            |m: &mut CMsgGCCStrike15_v2_GetEventFavorites_Response| { &mut m.all_events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "json_favorites",
            |m: &CMsgGCCStrike15_v2_GetEventFavorites_Response| { &m.json_favorites },
            |m: &mut CMsgGCCStrike15_v2_GetEventFavorites_Response| { &mut m.json_favorites },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "json_featured",
            |m: &CMsgGCCStrike15_v2_GetEventFavorites_Response| { &m.json_featured },
            |m: &mut CMsgGCCStrike15_v2_GetEventFavorites_Response| { &mut m.json_featured },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GetEventFavorites_Response>(
            "CMsgGCCStrike15_v2_GetEventFavorites_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GetEventFavorites_Response {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GetEventFavorites_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.all_events = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.json_favorites = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.json_featured = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.all_events {
            my_size += 1 + 1;
        }
        if let Some(v) = self.json_favorites.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.json_featured.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.all_events {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.json_favorites.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.json_featured.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GetEventFavorites_Response {
        CMsgGCCStrike15_v2_GetEventFavorites_Response::new()
    }

    fn clear(&mut self) {
        self.all_events = ::std::option::Option::None;
        self.json_favorites = ::std::option::Option::None;
        self.json_featured = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GetEventFavorites_Response {
        static instance: CMsgGCCStrike15_v2_GetEventFavorites_Response = CMsgGCCStrike15_v2_GetEventFavorites_Response {
            all_events: ::std::option::Option::None,
            json_favorites: ::std::option::Option::None,
            json_featured: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GetEventFavorites_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GetEventFavorites_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GetEventFavorites_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GetEventFavorites_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientPerfReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientPerfReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPerfReport.entries)
    pub entries: ::std::vec::Vec<cmsg_gccstrike15_v2_client_perf_report::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientPerfReport.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientPerfReport {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientPerfReport {
        <CMsgGCCStrike15_v2_ClientPerfReport as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientPerfReport {
    pub fn new() -> CMsgGCCStrike15_v2_ClientPerfReport {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgGCCStrike15_v2_ClientPerfReport| { &m.entries },
            |m: &mut CMsgGCCStrike15_v2_ClientPerfReport| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientPerfReport>(
            "CMsgGCCStrike15_v2_ClientPerfReport",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientPerfReport {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientPerfReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientPerfReport {
        CMsgGCCStrike15_v2_ClientPerfReport::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientPerfReport {
        static instance: CMsgGCCStrike15_v2_ClientPerfReport = CMsgGCCStrike15_v2_ClientPerfReport {
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientPerfReport {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientPerfReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientPerfReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientPerfReport {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_ClientPerfReport`
pub mod cmsg_gccstrike15_v2_client_perf_report {
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientPerfReport.Entry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPerfReport.Entry.perfcounter)
        pub perfcounter: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPerfReport.Entry.length)
        pub length: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPerfReport.Entry.reference)
        pub reference: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPerfReport.Entry.actual)
        pub actual: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPerfReport.Entry.sourceid)
        pub sourceid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientPerfReport.Entry.status)
        pub status: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientPerfReport.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        // optional uint32 perfcounter = 1;

        pub fn perfcounter(&self) -> u32 {
            self.perfcounter.unwrap_or(0)
        }

        pub fn clear_perfcounter(&mut self) {
            self.perfcounter = ::std::option::Option::None;
        }

        pub fn has_perfcounter(&self) -> bool {
            self.perfcounter.is_some()
        }

        // Param is passed by value, moved
        pub fn set_perfcounter(&mut self, v: u32) {
            self.perfcounter = ::std::option::Option::Some(v);
        }

        // optional uint32 length = 2;

        pub fn length(&self) -> u32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: u32) {
            self.length = ::std::option::Option::Some(v);
        }

        // optional bytes reference = 3;

        pub fn reference(&self) -> &[u8] {
            match self.reference.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_reference(&mut self) {
            self.reference = ::std::option::Option::None;
        }

        pub fn has_reference(&self) -> bool {
            self.reference.is_some()
        }

        // Param is passed by value, moved
        pub fn set_reference(&mut self, v: ::std::vec::Vec<u8>) {
            self.reference = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_reference(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.reference.is_none() {
                self.reference = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.reference.as_mut().unwrap()
        }

        // Take field
        pub fn take_reference(&mut self) -> ::std::vec::Vec<u8> {
            self.reference.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional bytes actual = 4;

        pub fn actual(&self) -> &[u8] {
            match self.actual.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_actual(&mut self) {
            self.actual = ::std::option::Option::None;
        }

        pub fn has_actual(&self) -> bool {
            self.actual.is_some()
        }

        // Param is passed by value, moved
        pub fn set_actual(&mut self, v: ::std::vec::Vec<u8>) {
            self.actual = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_actual(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.actual.is_none() {
                self.actual = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.actual.as_mut().unwrap()
        }

        // Take field
        pub fn take_actual(&mut self) -> ::std::vec::Vec<u8> {
            self.actual.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional uint32 sourceid = 5;

        pub fn sourceid(&self) -> u32 {
            self.sourceid.unwrap_or(0)
        }

        pub fn clear_sourceid(&mut self) {
            self.sourceid = ::std::option::Option::None;
        }

        pub fn has_sourceid(&self) -> bool {
            self.sourceid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sourceid(&mut self, v: u32) {
            self.sourceid = ::std::option::Option::Some(v);
        }

        // optional uint32 status = 6;

        pub fn status(&self) -> u32 {
            self.status.unwrap_or(0)
        }

        pub fn clear_status(&mut self) {
            self.status = ::std::option::Option::None;
        }

        pub fn has_status(&self) -> bool {
            self.status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_status(&mut self, v: u32) {
            self.status = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "perfcounter",
                |m: &Entry| { &m.perfcounter },
                |m: &mut Entry| { &mut m.perfcounter },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "length",
                |m: &Entry| { &m.length },
                |m: &mut Entry| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "reference",
                |m: &Entry| { &m.reference },
                |m: &mut Entry| { &mut m.reference },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "actual",
                |m: &Entry| { &m.actual },
                |m: &mut Entry| { &mut m.actual },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sourceid",
                |m: &Entry| { &m.sourceid },
                |m: &mut Entry| { &mut m.sourceid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "status",
                |m: &Entry| { &m.status },
                |m: &mut Entry| { &mut m.status },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "CMsgGCCStrike15_v2_ClientPerfReport.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.perfcounter = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.length = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.reference = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    34 => {
                        self.actual = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    40 => {
                        self.sourceid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.status = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.perfcounter {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.length {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.reference.as_ref() {
                my_size += ::protobuf::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.actual.as_ref() {
                my_size += ::protobuf::rt::bytes_size(4, &v);
            }
            if let Some(v) = self.sourceid {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.status {
                my_size += ::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.perfcounter {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.length {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.reference.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.actual.as_ref() {
                os.write_bytes(4, v)?;
            }
            if let Some(v) = self.sourceid {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.status {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.perfcounter = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.reference = ::std::option::Option::None;
            self.actual = ::std::option::Option::None;
            self.sourceid = ::std::option::Option::None;
            self.status = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                perfcounter: ::std::option::Option::None,
                length: ::std::option::Option::None,
                reference: ::std::option::Option::None,
                actual: ::std::option::Option::None,
                sourceid: ::std::option::Option::None,
                status: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientPerfReport.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CVDiagnostic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVDiagnostic {
    // message fields
    // @@protoc_insertion_point(field:CVDiagnostic.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CVDiagnostic.extended)
    pub extended: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CVDiagnostic.value)
    pub value: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CVDiagnostic.string_value)
    pub string_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CVDiagnostic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVDiagnostic {
    fn default() -> &'a CVDiagnostic {
        <CVDiagnostic as ::protobuf::Message>::default_instance()
    }
}

impl CVDiagnostic {
    pub fn new() -> CVDiagnostic {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 extended = 2;

    pub fn extended(&self) -> u32 {
        self.extended.unwrap_or(0)
    }

    pub fn clear_extended(&mut self) {
        self.extended = ::std::option::Option::None;
    }

    pub fn has_extended(&self) -> bool {
        self.extended.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extended(&mut self, v: u32) {
        self.extended = ::std::option::Option::Some(v);
    }

    // optional uint64 value = 3;

    pub fn value(&self) -> u64 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u64) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional string string_value = 4;

    pub fn string_value(&self) -> &str {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::string::String) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::string::String {
        self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CVDiagnostic| { &m.id },
            |m: &mut CVDiagnostic| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "extended",
            |m: &CVDiagnostic| { &m.extended },
            |m: &mut CVDiagnostic| { &mut m.extended },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CVDiagnostic| { &m.value },
            |m: &mut CVDiagnostic| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_value",
            |m: &CVDiagnostic| { &m.string_value },
            |m: &mut CVDiagnostic| { &mut m.string_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CVDiagnostic>(
            "CVDiagnostic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CVDiagnostic {
    const NAME: &'static str = "CVDiagnostic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.extended = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.value = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.string_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.extended {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.value {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.extended {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVDiagnostic {
        CVDiagnostic::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.extended = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVDiagnostic {
        static instance: CVDiagnostic = CVDiagnostic {
            id: ::std::option::Option::None,
            extended: ::std::option::Option::None,
            value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CVDiagnostic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CVDiagnostic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CVDiagnostic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CVDiagnostic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientReportValidation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_ClientReportValidation {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.file_report)
    pub file_report: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.command_line)
    pub command_line: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.total_files)
    pub total_files: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.internal_error)
    pub internal_error: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.trust_time)
    pub trust_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.count_pending)
    pub count_pending: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.count_completed)
    pub count_completed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.process_id)
    pub process_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.osversion)
    pub osversion: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.clientreportversion)
    pub clientreportversion: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.status_id)
    pub status_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.diagnostic1)
    pub diagnostic1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.diagnostic2)
    pub diagnostic2: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.diagnostic3)
    pub diagnostic3: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.last_launch_data)
    pub last_launch_data: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.report_count)
    pub report_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.client_time)
    pub client_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.diagnostic4)
    pub diagnostic4: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.diagnostic5)
    pub diagnostic5: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportValidation.diagnostics)
    pub diagnostics: ::std::vec::Vec<CVDiagnostic>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientReportValidation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientReportValidation {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientReportValidation {
        <CMsgGCCStrike15_v2_ClientReportValidation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientReportValidation {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportValidation {
        ::std::default::Default::default()
    }

    // optional string file_report = 1;

    pub fn file_report(&self) -> &str {
        match self.file_report.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_report(&mut self) {
        self.file_report = ::std::option::Option::None;
    }

    pub fn has_file_report(&self) -> bool {
        self.file_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_report(&mut self, v: ::std::string::String) {
        self.file_report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_report(&mut self) -> &mut ::std::string::String {
        if self.file_report.is_none() {
            self.file_report = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_report(&mut self) -> ::std::string::String {
        self.file_report.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string command_line = 2;

    pub fn command_line(&self) -> &str {
        match self.command_line.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command_line(&mut self) {
        self.command_line = ::std::option::Option::None;
    }

    pub fn has_command_line(&self) -> bool {
        self.command_line.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command_line(&mut self, v: ::std::string::String) {
        self.command_line = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command_line(&mut self) -> &mut ::std::string::String {
        if self.command_line.is_none() {
            self.command_line = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command_line.as_mut().unwrap()
    }

    // Take field
    pub fn take_command_line(&mut self) -> ::std::string::String {
        self.command_line.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 total_files = 3;

    pub fn total_files(&self) -> u32 {
        self.total_files.unwrap_or(0)
    }

    pub fn clear_total_files(&mut self) {
        self.total_files = ::std::option::Option::None;
    }

    pub fn has_total_files(&self) -> bool {
        self.total_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_files(&mut self, v: u32) {
        self.total_files = ::std::option::Option::Some(v);
    }

    // optional uint32 internal_error = 4;

    pub fn internal_error(&self) -> u32 {
        self.internal_error.unwrap_or(0)
    }

    pub fn clear_internal_error(&mut self) {
        self.internal_error = ::std::option::Option::None;
    }

    pub fn has_internal_error(&self) -> bool {
        self.internal_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_error(&mut self, v: u32) {
        self.internal_error = ::std::option::Option::Some(v);
    }

    // optional uint32 trust_time = 5;

    pub fn trust_time(&self) -> u32 {
        self.trust_time.unwrap_or(0)
    }

    pub fn clear_trust_time(&mut self) {
        self.trust_time = ::std::option::Option::None;
    }

    pub fn has_trust_time(&self) -> bool {
        self.trust_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trust_time(&mut self, v: u32) {
        self.trust_time = ::std::option::Option::Some(v);
    }

    // optional uint32 count_pending = 6;

    pub fn count_pending(&self) -> u32 {
        self.count_pending.unwrap_or(0)
    }

    pub fn clear_count_pending(&mut self) {
        self.count_pending = ::std::option::Option::None;
    }

    pub fn has_count_pending(&self) -> bool {
        self.count_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_pending(&mut self, v: u32) {
        self.count_pending = ::std::option::Option::Some(v);
    }

    // optional uint32 count_completed = 7;

    pub fn count_completed(&self) -> u32 {
        self.count_completed.unwrap_or(0)
    }

    pub fn clear_count_completed(&mut self) {
        self.count_completed = ::std::option::Option::None;
    }

    pub fn has_count_completed(&self) -> bool {
        self.count_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_completed(&mut self, v: u32) {
        self.count_completed = ::std::option::Option::Some(v);
    }

    // optional uint32 process_id = 8;

    pub fn process_id(&self) -> u32 {
        self.process_id.unwrap_or(0)
    }

    pub fn clear_process_id(&mut self) {
        self.process_id = ::std::option::Option::None;
    }

    pub fn has_process_id(&self) -> bool {
        self.process_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_id(&mut self, v: u32) {
        self.process_id = ::std::option::Option::Some(v);
    }

    // optional int32 osversion = 9;

    pub fn osversion(&self) -> i32 {
        self.osversion.unwrap_or(0)
    }

    pub fn clear_osversion(&mut self) {
        self.osversion = ::std::option::Option::None;
    }

    pub fn has_osversion(&self) -> bool {
        self.osversion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osversion(&mut self, v: i32) {
        self.osversion = ::std::option::Option::Some(v);
    }

    // optional uint32 clientreportversion = 10;

    pub fn clientreportversion(&self) -> u32 {
        self.clientreportversion.unwrap_or(0)
    }

    pub fn clear_clientreportversion(&mut self) {
        self.clientreportversion = ::std::option::Option::None;
    }

    pub fn has_clientreportversion(&self) -> bool {
        self.clientreportversion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientreportversion(&mut self, v: u32) {
        self.clientreportversion = ::std::option::Option::Some(v);
    }

    // optional uint32 status_id = 11;

    pub fn status_id(&self) -> u32 {
        self.status_id.unwrap_or(0)
    }

    pub fn clear_status_id(&mut self) {
        self.status_id = ::std::option::Option::None;
    }

    pub fn has_status_id(&self) -> bool {
        self.status_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_id(&mut self, v: u32) {
        self.status_id = ::std::option::Option::Some(v);
    }

    // optional uint32 diagnostic1 = 12;

    pub fn diagnostic1(&self) -> u32 {
        self.diagnostic1.unwrap_or(0)
    }

    pub fn clear_diagnostic1(&mut self) {
        self.diagnostic1 = ::std::option::Option::None;
    }

    pub fn has_diagnostic1(&self) -> bool {
        self.diagnostic1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostic1(&mut self, v: u32) {
        self.diagnostic1 = ::std::option::Option::Some(v);
    }

    // optional uint64 diagnostic2 = 13;

    pub fn diagnostic2(&self) -> u64 {
        self.diagnostic2.unwrap_or(0)
    }

    pub fn clear_diagnostic2(&mut self) {
        self.diagnostic2 = ::std::option::Option::None;
    }

    pub fn has_diagnostic2(&self) -> bool {
        self.diagnostic2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostic2(&mut self, v: u64) {
        self.diagnostic2 = ::std::option::Option::Some(v);
    }

    // optional uint64 diagnostic3 = 14;

    pub fn diagnostic3(&self) -> u64 {
        self.diagnostic3.unwrap_or(0)
    }

    pub fn clear_diagnostic3(&mut self) {
        self.diagnostic3 = ::std::option::Option::None;
    }

    pub fn has_diagnostic3(&self) -> bool {
        self.diagnostic3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostic3(&mut self, v: u64) {
        self.diagnostic3 = ::std::option::Option::Some(v);
    }

    // optional string last_launch_data = 15;

    pub fn last_launch_data(&self) -> &str {
        match self.last_launch_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_last_launch_data(&mut self) {
        self.last_launch_data = ::std::option::Option::None;
    }

    pub fn has_last_launch_data(&self) -> bool {
        self.last_launch_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_launch_data(&mut self, v: ::std::string::String) {
        self.last_launch_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_launch_data(&mut self) -> &mut ::std::string::String {
        if self.last_launch_data.is_none() {
            self.last_launch_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.last_launch_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_launch_data(&mut self) -> ::std::string::String {
        self.last_launch_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 report_count = 16;

    pub fn report_count(&self) -> u32 {
        self.report_count.unwrap_or(0)
    }

    pub fn clear_report_count(&mut self) {
        self.report_count = ::std::option::Option::None;
    }

    pub fn has_report_count(&self) -> bool {
        self.report_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_count(&mut self, v: u32) {
        self.report_count = ::std::option::Option::Some(v);
    }

    // optional uint64 client_time = 17;

    pub fn client_time(&self) -> u64 {
        self.client_time.unwrap_or(0)
    }

    pub fn clear_client_time(&mut self) {
        self.client_time = ::std::option::Option::None;
    }

    pub fn has_client_time(&self) -> bool {
        self.client_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_time(&mut self, v: u64) {
        self.client_time = ::std::option::Option::Some(v);
    }

    // optional uint64 diagnostic4 = 18;

    pub fn diagnostic4(&self) -> u64 {
        self.diagnostic4.unwrap_or(0)
    }

    pub fn clear_diagnostic4(&mut self) {
        self.diagnostic4 = ::std::option::Option::None;
    }

    pub fn has_diagnostic4(&self) -> bool {
        self.diagnostic4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostic4(&mut self, v: u64) {
        self.diagnostic4 = ::std::option::Option::Some(v);
    }

    // optional uint64 diagnostic5 = 19;

    pub fn diagnostic5(&self) -> u64 {
        self.diagnostic5.unwrap_or(0)
    }

    pub fn clear_diagnostic5(&mut self) {
        self.diagnostic5 = ::std::option::Option::None;
    }

    pub fn has_diagnostic5(&self) -> bool {
        self.diagnostic5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostic5(&mut self, v: u64) {
        self.diagnostic5 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_report",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.file_report },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.file_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command_line",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.command_line },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.command_line },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_files",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.total_files },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.total_files },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "internal_error",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.internal_error },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.internal_error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trust_time",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.trust_time },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.trust_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count_pending",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.count_pending },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.count_pending },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count_completed",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.count_completed },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.count_completed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "process_id",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.process_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.process_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "osversion",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.osversion },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.osversion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientreportversion",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.clientreportversion },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.clientreportversion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_id",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.status_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.status_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "diagnostic1",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.diagnostic1 },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.diagnostic1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "diagnostic2",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.diagnostic2 },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.diagnostic2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "diagnostic3",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.diagnostic3 },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.diagnostic3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_launch_data",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.last_launch_data },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.last_launch_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "report_count",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.report_count },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.report_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_time",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.client_time },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.client_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "diagnostic4",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.diagnostic4 },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.diagnostic4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "diagnostic5",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.diagnostic5 },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.diagnostic5 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "diagnostics",
            |m: &CMsgGCCStrike15_v2_ClientReportValidation| { &m.diagnostics },
            |m: &mut CMsgGCCStrike15_v2_ClientReportValidation| { &mut m.diagnostics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientReportValidation>(
            "CMsgGCCStrike15_v2_ClientReportValidation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportValidation {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientReportValidation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_report = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.command_line = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.total_files = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.internal_error = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.trust_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.count_pending = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.count_completed = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.osversion = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.clientreportversion = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.status_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.diagnostic1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.diagnostic2 = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.diagnostic3 = ::std::option::Option::Some(is.read_uint64()?);
                },
                122 => {
                    self.last_launch_data = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.report_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.client_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                144 => {
                    self.diagnostic4 = ::std::option::Option::Some(is.read_uint64()?);
                },
                152 => {
                    self.diagnostic5 = ::std::option::Option::Some(is.read_uint64()?);
                },
                162 => {
                    self.diagnostics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_report.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.command_line.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.total_files {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.internal_error {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.trust_time {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.count_pending {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.count_completed {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.process_id {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.osversion {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.clientreportversion {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.status_id {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.diagnostic1 {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.diagnostic2 {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        if let Some(v) = self.diagnostic3 {
            my_size += ::protobuf::rt::uint64_size(14, v);
        }
        if let Some(v) = self.last_launch_data.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.report_count {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.client_time {
            my_size += ::protobuf::rt::uint64_size(17, v);
        }
        if let Some(v) = self.diagnostic4 {
            my_size += ::protobuf::rt::uint64_size(18, v);
        }
        if let Some(v) = self.diagnostic5 {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.file_report.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.command_line.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.total_files {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.internal_error {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.trust_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.count_pending {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.count_completed {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.process_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.osversion {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.clientreportversion {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.status_id {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.diagnostic1 {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.diagnostic2 {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.diagnostic3 {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.last_launch_data.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.report_count {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.client_time {
            os.write_uint64(17, v)?;
        }
        if let Some(v) = self.diagnostic4 {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.diagnostic5 {
            os.write_uint64(19, v)?;
        }
        for v in &self.diagnostics {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientReportValidation {
        CMsgGCCStrike15_v2_ClientReportValidation::new()
    }

    fn clear(&mut self) {
        self.file_report = ::std::option::Option::None;
        self.command_line = ::std::option::Option::None;
        self.total_files = ::std::option::Option::None;
        self.internal_error = ::std::option::Option::None;
        self.trust_time = ::std::option::Option::None;
        self.count_pending = ::std::option::Option::None;
        self.count_completed = ::std::option::Option::None;
        self.process_id = ::std::option::Option::None;
        self.osversion = ::std::option::Option::None;
        self.clientreportversion = ::std::option::Option::None;
        self.status_id = ::std::option::Option::None;
        self.diagnostic1 = ::std::option::Option::None;
        self.diagnostic2 = ::std::option::Option::None;
        self.diagnostic3 = ::std::option::Option::None;
        self.last_launch_data = ::std::option::Option::None;
        self.report_count = ::std::option::Option::None;
        self.client_time = ::std::option::Option::None;
        self.diagnostic4 = ::std::option::Option::None;
        self.diagnostic5 = ::std::option::Option::None;
        self.diagnostics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportValidation {
        static instance: CMsgGCCStrike15_v2_ClientReportValidation = CMsgGCCStrike15_v2_ClientReportValidation {
            file_report: ::std::option::Option::None,
            command_line: ::std::option::Option::None,
            total_files: ::std::option::Option::None,
            internal_error: ::std::option::Option::None,
            trust_time: ::std::option::Option::None,
            count_pending: ::std::option::Option::None,
            count_completed: ::std::option::Option::None,
            process_id: ::std::option::Option::None,
            osversion: ::std::option::Option::None,
            clientreportversion: ::std::option::Option::None,
            status_id: ::std::option::Option::None,
            diagnostic1: ::std::option::Option::None,
            diagnostic2: ::std::option::Option::None,
            diagnostic3: ::std::option::Option::None,
            last_launch_data: ::std::option::Option::None,
            report_count: ::std::option::Option::None,
            client_time: ::std::option::Option::None,
            diagnostic4: ::std::option::Option::None,
            diagnostic5: ::std::option::Option::None,
            diagnostics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientReportValidation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientReportValidation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientReportValidation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportValidation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode.file_report)
    pub file_report: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode.offer_insecure_mode)
    pub offer_insecure_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode.offer_secure_mode)
    pub offer_secure_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode.show_unsigned_ui)
    pub show_unsigned_ui: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode.kick_user)
    pub kick_user: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode.show_trusted_ui)
    pub show_trusted_ui: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode.show_warning_not_trusted)
    pub show_warning_not_trusted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode.show_warning_not_trusted_2)
    pub show_warning_not_trusted_2: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode.files_prevented_trusted)
    pub files_prevented_trusted: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
        <CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
        ::std::default::Default::default()
    }

    // optional string file_report = 1;

    pub fn file_report(&self) -> &str {
        match self.file_report.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_report(&mut self) {
        self.file_report = ::std::option::Option::None;
    }

    pub fn has_file_report(&self) -> bool {
        self.file_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_report(&mut self, v: ::std::string::String) {
        self.file_report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_report(&mut self) -> &mut ::std::string::String {
        if self.file_report.is_none() {
            self.file_report = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_report(&mut self) -> ::std::string::String {
        self.file_report.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool offer_insecure_mode = 2;

    pub fn offer_insecure_mode(&self) -> bool {
        self.offer_insecure_mode.unwrap_or(false)
    }

    pub fn clear_offer_insecure_mode(&mut self) {
        self.offer_insecure_mode = ::std::option::Option::None;
    }

    pub fn has_offer_insecure_mode(&self) -> bool {
        self.offer_insecure_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer_insecure_mode(&mut self, v: bool) {
        self.offer_insecure_mode = ::std::option::Option::Some(v);
    }

    // optional bool offer_secure_mode = 3;

    pub fn offer_secure_mode(&self) -> bool {
        self.offer_secure_mode.unwrap_or(false)
    }

    pub fn clear_offer_secure_mode(&mut self) {
        self.offer_secure_mode = ::std::option::Option::None;
    }

    pub fn has_offer_secure_mode(&self) -> bool {
        self.offer_secure_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offer_secure_mode(&mut self, v: bool) {
        self.offer_secure_mode = ::std::option::Option::Some(v);
    }

    // optional bool show_unsigned_ui = 4;

    pub fn show_unsigned_ui(&self) -> bool {
        self.show_unsigned_ui.unwrap_or(false)
    }

    pub fn clear_show_unsigned_ui(&mut self) {
        self.show_unsigned_ui = ::std::option::Option::None;
    }

    pub fn has_show_unsigned_ui(&self) -> bool {
        self.show_unsigned_ui.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_unsigned_ui(&mut self, v: bool) {
        self.show_unsigned_ui = ::std::option::Option::Some(v);
    }

    // optional bool kick_user = 5;

    pub fn kick_user(&self) -> bool {
        self.kick_user.unwrap_or(false)
    }

    pub fn clear_kick_user(&mut self) {
        self.kick_user = ::std::option::Option::None;
    }

    pub fn has_kick_user(&self) -> bool {
        self.kick_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kick_user(&mut self, v: bool) {
        self.kick_user = ::std::option::Option::Some(v);
    }

    // optional bool show_trusted_ui = 6;

    pub fn show_trusted_ui(&self) -> bool {
        self.show_trusted_ui.unwrap_or(false)
    }

    pub fn clear_show_trusted_ui(&mut self) {
        self.show_trusted_ui = ::std::option::Option::None;
    }

    pub fn has_show_trusted_ui(&self) -> bool {
        self.show_trusted_ui.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_trusted_ui(&mut self, v: bool) {
        self.show_trusted_ui = ::std::option::Option::Some(v);
    }

    // optional bool show_warning_not_trusted = 7;

    pub fn show_warning_not_trusted(&self) -> bool {
        self.show_warning_not_trusted.unwrap_or(false)
    }

    pub fn clear_show_warning_not_trusted(&mut self) {
        self.show_warning_not_trusted = ::std::option::Option::None;
    }

    pub fn has_show_warning_not_trusted(&self) -> bool {
        self.show_warning_not_trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_warning_not_trusted(&mut self, v: bool) {
        self.show_warning_not_trusted = ::std::option::Option::Some(v);
    }

    // optional bool show_warning_not_trusted_2 = 8;

    pub fn show_warning_not_trusted_2(&self) -> bool {
        self.show_warning_not_trusted_2.unwrap_or(false)
    }

    pub fn clear_show_warning_not_trusted_2(&mut self) {
        self.show_warning_not_trusted_2 = ::std::option::Option::None;
    }

    pub fn has_show_warning_not_trusted_2(&self) -> bool {
        self.show_warning_not_trusted_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_warning_not_trusted_2(&mut self, v: bool) {
        self.show_warning_not_trusted_2 = ::std::option::Option::Some(v);
    }

    // optional string files_prevented_trusted = 9;

    pub fn files_prevented_trusted(&self) -> &str {
        match self.files_prevented_trusted.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_files_prevented_trusted(&mut self) {
        self.files_prevented_trusted = ::std::option::Option::None;
    }

    pub fn has_files_prevented_trusted(&self) -> bool {
        self.files_prevented_trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_files_prevented_trusted(&mut self, v: ::std::string::String) {
        self.files_prevented_trusted = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_files_prevented_trusted(&mut self) -> &mut ::std::string::String {
        if self.files_prevented_trusted.is_none() {
            self.files_prevented_trusted = ::std::option::Option::Some(::std::string::String::new());
        }
        self.files_prevented_trusted.as_mut().unwrap()
    }

    // Take field
    pub fn take_files_prevented_trusted(&mut self) -> ::std::string::String {
        self.files_prevented_trusted.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_report",
            |m: &CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &m.file_report },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &mut m.file_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offer_insecure_mode",
            |m: &CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &m.offer_insecure_mode },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &mut m.offer_insecure_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offer_secure_mode",
            |m: &CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &m.offer_secure_mode },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &mut m.offer_secure_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_unsigned_ui",
            |m: &CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &m.show_unsigned_ui },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &mut m.show_unsigned_ui },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "kick_user",
            |m: &CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &m.kick_user },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &mut m.kick_user },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_trusted_ui",
            |m: &CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &m.show_trusted_ui },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &mut m.show_trusted_ui },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_warning_not_trusted",
            |m: &CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &m.show_warning_not_trusted },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &mut m.show_warning_not_trusted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show_warning_not_trusted_2",
            |m: &CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &m.show_warning_not_trusted_2 },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &mut m.show_warning_not_trusted_2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "files_prevented_trusted",
            |m: &CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &m.files_prevented_trusted },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode| { &mut m.files_prevented_trusted },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode>(
            "CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_report = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.offer_insecure_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.offer_secure_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.show_unsigned_ui = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.kick_user = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.show_trusted_ui = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.show_warning_not_trusted = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.show_warning_not_trusted_2 = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.files_prevented_trusted = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_report.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.offer_insecure_mode {
            my_size += 1 + 1;
        }
        if let Some(v) = self.offer_secure_mode {
            my_size += 1 + 1;
        }
        if let Some(v) = self.show_unsigned_ui {
            my_size += 1 + 1;
        }
        if let Some(v) = self.kick_user {
            my_size += 1 + 1;
        }
        if let Some(v) = self.show_trusted_ui {
            my_size += 1 + 1;
        }
        if let Some(v) = self.show_warning_not_trusted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.show_warning_not_trusted_2 {
            my_size += 1 + 1;
        }
        if let Some(v) = self.files_prevented_trusted.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.file_report.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.offer_insecure_mode {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.offer_secure_mode {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.show_unsigned_ui {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.kick_user {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.show_trusted_ui {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.show_warning_not_trusted {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.show_warning_not_trusted_2 {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.files_prevented_trusted.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
        CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode::new()
    }

    fn clear(&mut self) {
        self.file_report = ::std::option::Option::None;
        self.offer_insecure_mode = ::std::option::Option::None;
        self.offer_secure_mode = ::std::option::Option::None;
        self.show_unsigned_ui = ::std::option::Option::None;
        self.kick_user = ::std::option::Option::None;
        self.show_trusted_ui = ::std::option::Option::None;
        self.show_warning_not_trusted = ::std::option::Option::None;
        self.show_warning_not_trusted_2 = ::std::option::Option::None;
        self.files_prevented_trusted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
        static instance: CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode = CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
            file_report: ::std::option::Option::None,
            offer_insecure_mode: ::std::option::Option::None,
            offer_secure_mode: ::std::option::Option::None,
            show_unsigned_ui: ::std::option::Option::None,
            kick_user: ::std::option::Option::None,
            show_trusted_ui: ::std::option::Option::None,
            show_warning_not_trusted: ::std::option::Option::None,
            show_warning_not_trusted_2: ::std::option::Option::None,
            files_prevented_trusted: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GC2ClientRequestValidation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GC2ClientRequestValidation {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRequestValidation.full_report)
    pub full_report: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientRequestValidation.module)
    pub module: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GC2ClientRequestValidation.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ClientRequestValidation {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ClientRequestValidation {
        <CMsgGCCStrike15_v2_GC2ClientRequestValidation as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ClientRequestValidation {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientRequestValidation {
        ::std::default::Default::default()
    }

    // optional bool full_report = 1;

    pub fn full_report(&self) -> bool {
        self.full_report.unwrap_or(false)
    }

    pub fn clear_full_report(&mut self) {
        self.full_report = ::std::option::Option::None;
    }

    pub fn has_full_report(&self) -> bool {
        self.full_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_report(&mut self, v: bool) {
        self.full_report = ::std::option::Option::Some(v);
    }

    // optional string module = 2;

    pub fn module(&self) -> &str {
        match self.module.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_module(&mut self) {
        self.module = ::std::option::Option::None;
    }

    pub fn has_module(&self) -> bool {
        self.module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: ::std::string::String) {
        self.module = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module(&mut self) -> &mut ::std::string::String {
        if self.module.is_none() {
            self.module = ::std::option::Option::Some(::std::string::String::new());
        }
        self.module.as_mut().unwrap()
    }

    // Take field
    pub fn take_module(&mut self) -> ::std::string::String {
        self.module.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "full_report",
            |m: &CMsgGCCStrike15_v2_GC2ClientRequestValidation| { &m.full_report },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRequestValidation| { &mut m.full_report },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "module",
            |m: &CMsgGCCStrike15_v2_GC2ClientRequestValidation| { &m.module },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientRequestValidation| { &mut m.module },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GC2ClientRequestValidation>(
            "CMsgGCCStrike15_v2_GC2ClientRequestValidation",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientRequestValidation {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GC2ClientRequestValidation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.full_report = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.module = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.full_report {
            my_size += 1 + 1;
        }
        if let Some(v) = self.module.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.full_report {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.module.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ClientRequestValidation {
        CMsgGCCStrike15_v2_GC2ClientRequestValidation::new()
    }

    fn clear(&mut self) {
        self.full_report = ::std::option::Option::None;
        self.module = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientRequestValidation {
        static instance: CMsgGCCStrike15_v2_GC2ClientRequestValidation = CMsgGCCStrike15_v2_GC2ClientRequestValidation {
            full_report: ::std::option::Option::None,
            module: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GC2ClientRequestValidation {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GC2ClientRequestValidation").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GC2ClientRequestValidation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientRequestValidation {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GC2ClientInitSystem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GC2ClientInitSystem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem.load)
    pub load: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem.outputname)
    pub outputname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem.key_data)
    pub key_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem.sha_hash)
    pub sha_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem.cookie)
    pub cookie: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem.manifest)
    pub manifest: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem.system_package)
    pub system_package: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem.load_system)
    pub load_system: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GC2ClientInitSystem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ClientInitSystem {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ClientInitSystem {
        <CMsgGCCStrike15_v2_GC2ClientInitSystem as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ClientInitSystem {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientInitSystem {
        ::std::default::Default::default()
    }

    // optional bool load = 1;

    pub fn load(&self) -> bool {
        self.load.unwrap_or(false)
    }

    pub fn clear_load(&mut self) {
        self.load = ::std::option::Option::None;
    }

    pub fn has_load(&self) -> bool {
        self.load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load(&mut self, v: bool) {
        self.load = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string outputname = 3;

    pub fn outputname(&self) -> &str {
        match self.outputname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_outputname(&mut self) {
        self.outputname = ::std::option::Option::None;
    }

    pub fn has_outputname(&self) -> bool {
        self.outputname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outputname(&mut self, v: ::std::string::String) {
        self.outputname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outputname(&mut self) -> &mut ::std::string::String {
        if self.outputname.is_none() {
            self.outputname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.outputname.as_mut().unwrap()
    }

    // Take field
    pub fn take_outputname(&mut self) -> ::std::string::String {
        self.outputname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes key_data = 4;

    pub fn key_data(&self) -> &[u8] {
        match self.key_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_key_data(&mut self) {
        self.key_data = ::std::option::Option::None;
    }

    pub fn has_key_data(&self) -> bool {
        self.key_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.key_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.key_data.is_none() {
            self.key_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.key_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_data(&mut self) -> ::std::vec::Vec<u8> {
        self.key_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes sha_hash = 5;

    pub fn sha_hash(&self) -> &[u8] {
        match self.sha_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_hash(&mut self) {
        self.sha_hash = ::std::option::Option::None;
    }

    pub fn has_sha_hash(&self) -> bool {
        self.sha_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_hash.is_none() {
            self.sha_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 cookie = 6;

    pub fn cookie(&self) -> i32 {
        self.cookie.unwrap_or(0)
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = ::std::option::Option::Some(v);
    }

    // optional string manifest = 7;

    pub fn manifest(&self) -> &str {
        match self.manifest.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_manifest(&mut self) {
        self.manifest = ::std::option::Option::None;
    }

    pub fn has_manifest(&self) -> bool {
        self.manifest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manifest(&mut self, v: ::std::string::String) {
        self.manifest = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manifest(&mut self) -> &mut ::std::string::String {
        if self.manifest.is_none() {
            self.manifest = ::std::option::Option::Some(::std::string::String::new());
        }
        self.manifest.as_mut().unwrap()
    }

    // Take field
    pub fn take_manifest(&mut self) -> ::std::string::String {
        self.manifest.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes system_package = 8;

    pub fn system_package(&self) -> &[u8] {
        match self.system_package.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_system_package(&mut self) {
        self.system_package = ::std::option::Option::None;
    }

    pub fn has_system_package(&self) -> bool {
        self.system_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_package(&mut self, v: ::std::vec::Vec<u8>) {
        self.system_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_package(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.system_package.is_none() {
            self.system_package = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.system_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_package(&mut self) -> ::std::vec::Vec<u8> {
        self.system_package.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool load_system = 9;

    pub fn load_system(&self) -> bool {
        self.load_system.unwrap_or(false)
    }

    pub fn clear_load_system(&mut self) {
        self.load_system = ::std::option::Option::None;
    }

    pub fn has_load_system(&self) -> bool {
        self.load_system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_system(&mut self, v: bool) {
        self.load_system = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "load",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem| { &m.load },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem| { &mut m.load },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem| { &m.name },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "outputname",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem| { &m.outputname },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem| { &mut m.outputname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_data",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem| { &m.key_data },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem| { &mut m.key_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_hash",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem| { &m.sha_hash },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem| { &mut m.sha_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cookie",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem| { &m.cookie },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem| { &mut m.cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "manifest",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem| { &m.manifest },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem| { &mut m.manifest },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "system_package",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem| { &m.system_package },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem| { &mut m.system_package },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "load_system",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem| { &m.load_system },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem| { &mut m.load_system },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GC2ClientInitSystem>(
            "CMsgGCCStrike15_v2_GC2ClientInitSystem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientInitSystem {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GC2ClientInitSystem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.load = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.outputname = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.key_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.sha_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.cookie = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.manifest = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.system_package = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.load_system = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.load {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.outputname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.key_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.sha_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.cookie {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.manifest.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.system_package.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.load_system {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.load {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.outputname.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.key_data.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.sha_hash.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.cookie {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.manifest.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.system_package.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.load_system {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ClientInitSystem {
        CMsgGCCStrike15_v2_GC2ClientInitSystem::new()
    }

    fn clear(&mut self) {
        self.load = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.outputname = ::std::option::Option::None;
        self.key_data = ::std::option::Option::None;
        self.sha_hash = ::std::option::Option::None;
        self.cookie = ::std::option::Option::None;
        self.manifest = ::std::option::Option::None;
        self.system_package = ::std::option::Option::None;
        self.load_system = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientInitSystem {
        static instance: CMsgGCCStrike15_v2_GC2ClientInitSystem = CMsgGCCStrike15_v2_GC2ClientInitSystem {
            load: ::std::option::Option::None,
            name: ::std::option::Option::None,
            outputname: ::std::option::Option::None,
            key_data: ::std::option::Option::None,
            sha_hash: ::std::option::Option::None,
            cookie: ::std::option::Option::None,
            manifest: ::std::option::Option::None,
            system_package: ::std::option::Option::None,
            load_system: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GC2ClientInitSystem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GC2ClientInitSystem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GC2ClientInitSystem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientInitSystem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.success)
    pub success: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.diagnostic)
    pub diagnostic: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.sha_hash)
    pub sha_hash: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.response)
    pub response: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.error_code1)
    pub error_code1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.error_code2)
    pub error_code2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.handle)
    pub handle: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.einit_result)
    pub einit_result: ::std::option::Option<::protobuf::EnumOrUnknown<EInitSystemResult>>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.aux_system1)
    pub aux_system1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.aux_system2)
    pub aux_system2: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GC2ClientInitSystem_Response.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
        <CMsgGCCStrike15_v2_GC2ClientInitSystem_Response as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    // optional string diagnostic = 2;

    pub fn diagnostic(&self) -> &str {
        match self.diagnostic.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_diagnostic(&mut self) {
        self.diagnostic = ::std::option::Option::None;
    }

    pub fn has_diagnostic(&self) -> bool {
        self.diagnostic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diagnostic(&mut self, v: ::std::string::String) {
        self.diagnostic = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diagnostic(&mut self) -> &mut ::std::string::String {
        if self.diagnostic.is_none() {
            self.diagnostic = ::std::option::Option::Some(::std::string::String::new());
        }
        self.diagnostic.as_mut().unwrap()
    }

    // Take field
    pub fn take_diagnostic(&mut self) -> ::std::string::String {
        self.diagnostic.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes sha_hash = 3;

    pub fn sha_hash(&self) -> &[u8] {
        match self.sha_hash.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_sha_hash(&mut self) {
        self.sha_hash = ::std::option::Option::None;
    }

    pub fn has_sha_hash(&self) -> bool {
        self.sha_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sha_hash.is_none() {
            self.sha_hash = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.sha_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 response = 4;

    pub fn response(&self) -> i32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: i32) {
        self.response = ::std::option::Option::Some(v);
    }

    // optional int32 error_code1 = 5;

    pub fn error_code1(&self) -> i32 {
        self.error_code1.unwrap_or(0)
    }

    pub fn clear_error_code1(&mut self) {
        self.error_code1 = ::std::option::Option::None;
    }

    pub fn has_error_code1(&self) -> bool {
        self.error_code1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code1(&mut self, v: i32) {
        self.error_code1 = ::std::option::Option::Some(v);
    }

    // optional int32 error_code2 = 6;

    pub fn error_code2(&self) -> i32 {
        self.error_code2.unwrap_or(0)
    }

    pub fn clear_error_code2(&mut self) {
        self.error_code2 = ::std::option::Option::None;
    }

    pub fn has_error_code2(&self) -> bool {
        self.error_code2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_code2(&mut self, v: i32) {
        self.error_code2 = ::std::option::Option::Some(v);
    }

    // optional int64 handle = 7;

    pub fn handle(&self) -> i64 {
        self.handle.unwrap_or(0)
    }

    pub fn clear_handle(&mut self) {
        self.handle = ::std::option::Option::None;
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i64) {
        self.handle = ::std::option::Option::Some(v);
    }

    // optional .EInitSystemResult einit_result = 8;

    pub fn einit_result(&self) -> EInitSystemResult {
        match self.einit_result {
            Some(e) => e.enum_value_or(EInitSystemResult::k_EInitSystemResult_Invalid),
            None => EInitSystemResult::k_EInitSystemResult_Invalid,
        }
    }

    pub fn clear_einit_result(&mut self) {
        self.einit_result = ::std::option::Option::None;
    }

    pub fn has_einit_result(&self) -> bool {
        self.einit_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_einit_result(&mut self, v: EInitSystemResult) {
        self.einit_result = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 aux_system1 = 9;

    pub fn aux_system1(&self) -> i32 {
        self.aux_system1.unwrap_or(0)
    }

    pub fn clear_aux_system1(&mut self) {
        self.aux_system1 = ::std::option::Option::None;
    }

    pub fn has_aux_system1(&self) -> bool {
        self.aux_system1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aux_system1(&mut self, v: i32) {
        self.aux_system1 = ::std::option::Option::Some(v);
    }

    // optional int32 aux_system2 = 10;

    pub fn aux_system2(&self) -> i32 {
        self.aux_system2.unwrap_or(0)
    }

    pub fn clear_aux_system2(&mut self) {
        self.aux_system2 = ::std::option::Option::None;
    }

    pub fn has_aux_system2(&self) -> bool {
        self.aux_system2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aux_system2(&mut self, v: i32) {
        self.aux_system2 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &m.success },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "diagnostic",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &m.diagnostic },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &mut m.diagnostic },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sha_hash",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &m.sha_hash },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &mut m.sha_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &m.response },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_code1",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &m.error_code1 },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &mut m.error_code1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error_code2",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &m.error_code2 },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &mut m.error_code2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "handle",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &m.handle },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "einit_result",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &m.einit_result },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &mut m.einit_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "aux_system1",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &m.aux_system1 },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &mut m.aux_system1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "aux_system2",
            |m: &CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &m.aux_system2 },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientInitSystem_Response| { &mut m.aux_system2 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GC2ClientInitSystem_Response>(
            "CMsgGCCStrike15_v2_GC2ClientInitSystem_Response",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GC2ClientInitSystem_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.diagnostic = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.sha_hash = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.response = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.error_code1 = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.error_code2 = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.handle = ::std::option::Option::Some(is.read_int64()?);
                },
                64 => {
                    self.einit_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.aux_system1 = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.aux_system2 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        if let Some(v) = self.diagnostic.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sha_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.response {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.error_code1 {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.error_code2 {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.handle {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.einit_result {
            my_size += ::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.aux_system1 {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.aux_system2 {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.diagnostic.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.sha_hash.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.response {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.error_code1 {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.error_code2 {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.handle {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.einit_result {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.aux_system1 {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.aux_system2 {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
        CMsgGCCStrike15_v2_GC2ClientInitSystem_Response::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.diagnostic = ::std::option::Option::None;
        self.sha_hash = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.error_code1 = ::std::option::Option::None;
        self.error_code2 = ::std::option::Option::None;
        self.handle = ::std::option::Option::None;
        self.einit_result = ::std::option::Option::None;
        self.aux_system1 = ::std::option::Option::None;
        self.aux_system2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
        static instance: CMsgGCCStrike15_v2_GC2ClientInitSystem_Response = CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
            success: ::std::option::Option::None,
            diagnostic: ::std::option::Option::None,
            sha_hash: ::std::option::Option::None,
            response: ::std::option::Option::None,
            error_code1: ::std::option::Option::None,
            error_code2: ::std::option::Option::None,
            handle: ::std::option::Option::None,
            einit_result: ::std::option::Option::None,
            aux_system1: ::std::option::Option::None,
            aux_system2: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GC2ClientInitSystem_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientInitSystem_Response {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName.leaderboard_safe_name)
    pub leaderboard_safe_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
    fn default() -> &'a CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
        <CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
    pub fn new() -> CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
        ::std::default::Default::default()
    }

    // optional string leaderboard_safe_name = 1;

    pub fn leaderboard_safe_name(&self) -> &str {
        match self.leaderboard_safe_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_leaderboard_safe_name(&mut self) {
        self.leaderboard_safe_name = ::std::option::Option::None;
    }

    pub fn has_leaderboard_safe_name(&self) -> bool {
        self.leaderboard_safe_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_safe_name(&mut self, v: ::std::string::String) {
        self.leaderboard_safe_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_safe_name(&mut self) -> &mut ::std::string::String {
        if self.leaderboard_safe_name.is_none() {
            self.leaderboard_safe_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.leaderboard_safe_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_safe_name(&mut self) -> ::std::string::String {
        self.leaderboard_safe_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leaderboard_safe_name",
            |m: &CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName| { &m.leaderboard_safe_name },
            |m: &mut CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName| { &mut m.leaderboard_safe_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName>(
            "CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
    const NAME: &'static str = "CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.leaderboard_safe_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.leaderboard_safe_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.leaderboard_safe_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
        CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName::new()
    }

    fn clear(&mut self) {
        self.leaderboard_safe_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
        static instance: CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName = CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
            leaderboard_safe_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECsgoGCMsg)
pub enum ECsgoGCMsg {
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Base)
    k_EMsgGCCStrike15_v2_Base = 9100,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingStart)
    k_EMsgGCCStrike15_v2_MatchmakingStart = 9101,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingStop)
    k_EMsgGCCStrike15_v2_MatchmakingStop = 9102,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing)
    k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing = 9103,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = 9104,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse)
    k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse = 9106,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = 9107,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello)
    k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello = 9109,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello = 9110,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = 9112,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate)
    k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = 9117,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty)
    k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty = 9118,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientReportPlayer)
    k_EMsgGCCStrike15_v2_ClientReportPlayer = 9119,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientReportServer)
    k_EMsgGCCStrike15_v2_ClientReportServer = 9120,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientCommendPlayer)
    k_EMsgGCCStrike15_v2_ClientCommendPlayer = 9121,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientReportResponse)
    k_EMsgGCCStrike15_v2_ClientReportResponse = 9122,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery)
    k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery = 9123,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse)
    k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse = 9124,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_WatchInfoUsers)
    k_EMsgGCCStrike15_v2_WatchInfoUsers = 9126,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile)
    k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile = 9127,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_PlayersProfile)
    k_EMsgGCCStrike15_v2_PlayersProfile = 9128,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate)
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = 9131,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment)
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = 9132,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus)
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = 9133,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ClientTextMsg)
    k_EMsgGCCStrike15_v2_GC2ClientTextMsg = 9134,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Client2GCTextMsg)
    k_EMsgGCCStrike15_v2_Client2GCTextMsg = 9135,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops)
    k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops = 9136,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification)
    k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification = 9137,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2)
    k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 = 9138,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchList)
    k_EMsgGCCStrike15_v2_MatchList = 9139,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames)
    k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = 9140,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames)
    k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames = 9141,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate)
    k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate = 9142,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo)
    k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo = 9144,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames)
    k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames = 9146,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo)
    k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo = 9147,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest)
    k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest = 9148,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse)
    k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse = 9149,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo)
    k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo = 9150,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote)
    k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote = 9152,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Server2GCClientValidate)
    k_EMsgGCCStrike15_v2_Server2GCClientValidate = 9153,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser)
    k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = 9154,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest)
    k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = 9156,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse)
    k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = 9157,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_AccountPrivacySettings)
    k_EMsgGCCStrike15_v2_AccountPrivacySettings = 9158,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_SetMyActivityInfo)
    k_EMsgGCCStrike15_v2_SetMyActivityInfo = 9159,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions)
    k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions = 9160,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions)
    k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions = 9161,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_DraftSummary)
    k_EMsgGCCStrike15_v2_DraftSummary = 9162,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData)
    k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData = 9163,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestJoinServerData)
    k_EMsgGCCStrike15_v2_ClientRequestJoinServerData = 9164,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestNewMission)
    k_EMsgGCCStrike15_v2_ClientRequestNewMission = 9165,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo)
    k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo = 9167,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGC_GlobalGame_Subscribe)
    k_EMsgGC_GlobalGame_Subscribe = 9168,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGC_GlobalGame_Unsubscribe)
    k_EMsgGC_GlobalGame_Unsubscribe = 9169,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGC_GlobalGame_Play)
    k_EMsgGC_GlobalGame_Play = 9170,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_AcknowledgePenalty)
    k_EMsgGCCStrike15_v2_AcknowledgePenalty = 9171,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin)
    k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = 9172,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ClientGlobalStats)
    k_EMsgGCCStrike15_v2_GC2ClientGlobalStats = 9173,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Client2GCStreamUnlock)
    k_EMsgGCCStrike15_v2_Client2GCStreamUnlock = 9174,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_FantasyRequestClientData)
    k_EMsgGCCStrike15_v2_FantasyRequestClientData = 9175,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_FantasyUpdateClientData)
    k_EMsgGCCStrike15_v2_FantasyUpdateClientData = 9176,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket)
    k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket = 9177,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientToGCRequestTicket)
    k_EMsgGCCStrike15_v2_ClientToGCRequestTicket = 9178,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientToGCRequestElevate)
    k_EMsgGCCStrike15_v2_ClientToGCRequestElevate = 9179,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GlobalChat)
    k_EMsgGCCStrike15_v2_GlobalChat = 9180,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GlobalChat_Subscribe)
    k_EMsgGCCStrike15_v2_GlobalChat_Subscribe = 9181,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe)
    k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe = 9182,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientAuthKeyCode)
    k_EMsgGCCStrike15_v2_ClientAuthKeyCode = 9183,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GotvSyncPacket)
    k_EMsgGCCStrike15_v2_GotvSyncPacket = 9184,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientPlayerDecalSign)
    k_EMsgGCCStrike15_v2_ClientPlayerDecalSign = 9185,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientLogonFatalError)
    k_EMsgGCCStrike15_v2_ClientLogonFatalError = 9187,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientPollState)
    k_EMsgGCCStrike15_v2_ClientPollState = 9188,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Party_Register)
    k_EMsgGCCStrike15_v2_Party_Register = 9189,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Party_Unregister)
    k_EMsgGCCStrike15_v2_Party_Unregister = 9190,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Party_Search)
    k_EMsgGCCStrike15_v2_Party_Search = 9191,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Party_Invite)
    k_EMsgGCCStrike15_v2_Party_Invite = 9192,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Account_RequestCoPlays)
    k_EMsgGCCStrike15_v2_Account_RequestCoPlays = 9193,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientGCRankUpdate)
    k_EMsgGCCStrike15_v2_ClientGCRankUpdate = 9194,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestOffers)
    k_EMsgGCCStrike15_v2_ClientRequestOffers = 9195,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientAccountBalance)
    k_EMsgGCCStrike15_v2_ClientAccountBalance = 9196,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientPartyJoinRelay)
    k_EMsgGCCStrike15_v2_ClientPartyJoinRelay = 9197,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientPartyWarning)
    k_EMsgGCCStrike15_v2_ClientPartyWarning = 9198,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_SetEventFavorite)
    k_EMsgGCCStrike15_v2_SetEventFavorite = 9200,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GetEventFavorites_Request)
    k_EMsgGCCStrike15_v2_GetEventFavorites_Request = 9201,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientPerfReport)
    k_EMsgGCCStrike15_v2_ClientPerfReport = 9202,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GetEventFavorites_Response)
    k_EMsgGCCStrike15_v2_GetEventFavorites_Response = 9203,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestSouvenir)
    k_EMsgGCCStrike15_v2_ClientRequestSouvenir = 9204,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientReportValidation)
    k_EMsgGCCStrike15_v2_ClientReportValidation = 9205,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode)
    k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode = 9206,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ClientRequestValidation)
    k_EMsgGCCStrike15_v2_GC2ClientRequestValidation = 9207,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRedeemMissionReward)
    k_EMsgGCCStrike15_v2_ClientRedeemMissionReward = 9209,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_ClientDeepStats)
    k_EMsgGCCStrike15_ClientDeepStats = 9210,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_StartAgreementSessionInGame)
    k_EMsgGCCStrike15_StartAgreementSessionInGame = 9211,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ClientInitSystem)
    k_EMsgGCCStrike15_v2_GC2ClientInitSystem = 9212,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response)
    k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response = 9213,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_PrivateQueues)
    k_EMsgGCCStrike15_v2_PrivateQueues = 9214,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt)
    k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt = 9215,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName)
    k_EMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName = 9218,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRedeemFreeReward)
    k_EMsgGCCStrike15_v2_ClientRedeemFreeReward = 9219,
}

impl ::protobuf::Enum for ECsgoGCMsg {
    const NAME: &'static str = "ECsgoGCMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECsgoGCMsg> {
        match value {
            9100 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base),
            9101 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart),
            9102 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop),
            9103 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing),
            9104 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate),
            9106 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse),
            9107 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve),
            9109 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello),
            9110 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello),
            9112 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon),
            9117 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate),
            9118 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty),
            9119 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer),
            9120 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer),
            9121 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer),
            9122 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse),
            9123 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery),
            9124 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse),
            9126 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers),
            9127 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile),
            9128 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile),
            9131 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate),
            9132 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment),
            9133 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus),
            9134 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg),
            9135 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg),
            9136 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops),
            9137 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification),
            9138 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2),
            9139 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList),
            9140 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames),
            9141 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames),
            9142 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate),
            9144 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo),
            9146 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames),
            9147 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo),
            9148 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest),
            9149 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse),
            9150 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo),
            9152 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote),
            9153 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate),
            9154 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser),
            9156 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest),
            9157 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse),
            9158 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings),
            9159 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo),
            9160 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions),
            9161 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions),
            9162 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary),
            9163 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData),
            9164 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData),
            9165 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission),
            9167 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo),
            9168 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe),
            9169 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe),
            9170 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Play),
            9171 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty),
            9172 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin),
            9173 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats),
            9174 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock),
            9175 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData),
            9176 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData),
            9177 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket),
            9178 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket),
            9179 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate),
            9180 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat),
            9181 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe),
            9182 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe),
            9183 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAuthKeyCode),
            9184 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GotvSyncPacket),
            9185 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPlayerDecalSign),
            9187 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientLogonFatalError),
            9188 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPollState),
            9189 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Register),
            9190 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Unregister),
            9191 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Search),
            9192 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Invite),
            9193 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Account_RequestCoPlays),
            9194 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientGCRankUpdate),
            9195 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestOffers),
            9196 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAccountBalance),
            9197 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyJoinRelay),
            9198 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyWarning),
            9200 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetEventFavorite),
            9201 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Request),
            9202 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPerfReport),
            9203 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Response),
            9204 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestSouvenir),
            9205 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportValidation),
            9206 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode),
            9207 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientRequestValidation),
            9209 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRedeemMissionReward),
            9210 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_ClientDeepStats),
            9211 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_StartAgreementSessionInGame),
            9212 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientInitSystem),
            9213 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response),
            9214 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PrivateQueues),
            9215 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt),
            9218 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName),
            9219 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRedeemFreeReward),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECsgoGCMsg> {
        match str {
            "k_EMsgGCCStrike15_v2_Base" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base),
            "k_EMsgGCCStrike15_v2_MatchmakingStart" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart),
            "k_EMsgGCCStrike15_v2_MatchmakingStop" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop),
            "k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing),
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate),
            "k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse),
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve),
            "k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello),
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello),
            "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon),
            "k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate),
            "k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty),
            "k_EMsgGCCStrike15_v2_ClientReportPlayer" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer),
            "k_EMsgGCCStrike15_v2_ClientReportServer" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer),
            "k_EMsgGCCStrike15_v2_ClientCommendPlayer" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer),
            "k_EMsgGCCStrike15_v2_ClientReportResponse" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse),
            "k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery),
            "k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse),
            "k_EMsgGCCStrike15_v2_WatchInfoUsers" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers),
            "k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile),
            "k_EMsgGCCStrike15_v2_PlayersProfile" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile),
            "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate),
            "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment),
            "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus),
            "k_EMsgGCCStrike15_v2_GC2ClientTextMsg" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg),
            "k_EMsgGCCStrike15_v2_Client2GCTextMsg" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg),
            "k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops),
            "k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification),
            "k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2),
            "k_EMsgGCCStrike15_v2_MatchList" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList),
            "k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames),
            "k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames),
            "k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate),
            "k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo),
            "k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames),
            "k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo),
            "k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest),
            "k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse),
            "k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo),
            "k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote),
            "k_EMsgGCCStrike15_v2_Server2GCClientValidate" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate),
            "k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser),
            "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest),
            "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse),
            "k_EMsgGCCStrike15_v2_AccountPrivacySettings" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings),
            "k_EMsgGCCStrike15_v2_SetMyActivityInfo" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo),
            "k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions),
            "k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions),
            "k_EMsgGCCStrike15_v2_DraftSummary" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary),
            "k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData),
            "k_EMsgGCCStrike15_v2_ClientRequestJoinServerData" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData),
            "k_EMsgGCCStrike15_v2_ClientRequestNewMission" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission),
            "k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo),
            "k_EMsgGC_GlobalGame_Subscribe" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe),
            "k_EMsgGC_GlobalGame_Unsubscribe" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe),
            "k_EMsgGC_GlobalGame_Play" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Play),
            "k_EMsgGCCStrike15_v2_AcknowledgePenalty" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty),
            "k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin),
            "k_EMsgGCCStrike15_v2_GC2ClientGlobalStats" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats),
            "k_EMsgGCCStrike15_v2_Client2GCStreamUnlock" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock),
            "k_EMsgGCCStrike15_v2_FantasyRequestClientData" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData),
            "k_EMsgGCCStrike15_v2_FantasyUpdateClientData" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData),
            "k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket),
            "k_EMsgGCCStrike15_v2_ClientToGCRequestTicket" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket),
            "k_EMsgGCCStrike15_v2_ClientToGCRequestElevate" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate),
            "k_EMsgGCCStrike15_v2_GlobalChat" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat),
            "k_EMsgGCCStrike15_v2_GlobalChat_Subscribe" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe),
            "k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe),
            "k_EMsgGCCStrike15_v2_ClientAuthKeyCode" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAuthKeyCode),
            "k_EMsgGCCStrike15_v2_GotvSyncPacket" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GotvSyncPacket),
            "k_EMsgGCCStrike15_v2_ClientPlayerDecalSign" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPlayerDecalSign),
            "k_EMsgGCCStrike15_v2_ClientLogonFatalError" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientLogonFatalError),
            "k_EMsgGCCStrike15_v2_ClientPollState" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPollState),
            "k_EMsgGCCStrike15_v2_Party_Register" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Register),
            "k_EMsgGCCStrike15_v2_Party_Unregister" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Unregister),
            "k_EMsgGCCStrike15_v2_Party_Search" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Search),
            "k_EMsgGCCStrike15_v2_Party_Invite" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Invite),
            "k_EMsgGCCStrike15_v2_Account_RequestCoPlays" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Account_RequestCoPlays),
            "k_EMsgGCCStrike15_v2_ClientGCRankUpdate" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientGCRankUpdate),
            "k_EMsgGCCStrike15_v2_ClientRequestOffers" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestOffers),
            "k_EMsgGCCStrike15_v2_ClientAccountBalance" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAccountBalance),
            "k_EMsgGCCStrike15_v2_ClientPartyJoinRelay" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyJoinRelay),
            "k_EMsgGCCStrike15_v2_ClientPartyWarning" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyWarning),
            "k_EMsgGCCStrike15_v2_SetEventFavorite" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetEventFavorite),
            "k_EMsgGCCStrike15_v2_GetEventFavorites_Request" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Request),
            "k_EMsgGCCStrike15_v2_ClientPerfReport" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPerfReport),
            "k_EMsgGCCStrike15_v2_GetEventFavorites_Response" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Response),
            "k_EMsgGCCStrike15_v2_ClientRequestSouvenir" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestSouvenir),
            "k_EMsgGCCStrike15_v2_ClientReportValidation" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportValidation),
            "k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode),
            "k_EMsgGCCStrike15_v2_GC2ClientRequestValidation" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientRequestValidation),
            "k_EMsgGCCStrike15_v2_ClientRedeemMissionReward" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRedeemMissionReward),
            "k_EMsgGCCStrike15_ClientDeepStats" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_ClientDeepStats),
            "k_EMsgGCCStrike15_StartAgreementSessionInGame" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_StartAgreementSessionInGame),
            "k_EMsgGCCStrike15_v2_GC2ClientInitSystem" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientInitSystem),
            "k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response),
            "k_EMsgGCCStrike15_v2_PrivateQueues" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PrivateQueues),
            "k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt),
            "k_EMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName),
            "k_EMsgGCCStrike15_v2_ClientRedeemFreeReward" => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRedeemFreeReward),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECsgoGCMsg] = &[
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo,
        ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe,
        ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe,
        ECsgoGCMsg::k_EMsgGC_GlobalGame_Play,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAuthKeyCode,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GotvSyncPacket,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPlayerDecalSign,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientLogonFatalError,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPollState,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Register,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Unregister,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Search,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Invite,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Account_RequestCoPlays,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientGCRankUpdate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestOffers,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAccountBalance,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyJoinRelay,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyWarning,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetEventFavorite,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Request,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPerfReport,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Response,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestSouvenir,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportValidation,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientRequestValidation,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRedeemMissionReward,
        ECsgoGCMsg::k_EMsgGCCStrike15_ClientDeepStats,
        ECsgoGCMsg::k_EMsgGCCStrike15_StartAgreementSessionInGame,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientInitSystem,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_PrivateQueues,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRedeemFreeReward,
    ];
}

impl ::protobuf::EnumFull for ECsgoGCMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECsgoGCMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base => 0,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart => 1,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop => 2,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing => 3,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate => 4,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse => 5,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve => 6,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello => 7,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello => 8,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon => 9,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate => 10,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty => 11,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer => 12,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer => 13,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer => 14,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse => 15,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery => 16,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse => 17,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers => 18,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile => 19,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile => 20,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate => 21,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment => 22,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus => 23,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg => 24,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg => 25,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops => 26,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification => 27,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 => 28,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList => 29,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames => 30,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames => 31,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate => 32,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo => 33,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames => 34,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo => 35,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest => 36,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse => 37,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo => 38,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote => 39,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate => 40,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser => 41,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest => 42,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse => 43,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings => 44,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo => 45,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions => 46,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions => 47,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary => 48,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData => 49,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData => 50,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission => 51,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo => 52,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe => 53,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe => 54,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Play => 55,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty => 56,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin => 57,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats => 58,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock => 59,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData => 60,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData => 61,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket => 62,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket => 63,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate => 64,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat => 65,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe => 66,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe => 67,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAuthKeyCode => 68,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GotvSyncPacket => 69,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPlayerDecalSign => 70,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientLogonFatalError => 71,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPollState => 72,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Register => 73,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Unregister => 74,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Search => 75,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Party_Invite => 76,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Account_RequestCoPlays => 77,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientGCRankUpdate => 78,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestOffers => 79,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientAccountBalance => 80,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyJoinRelay => 81,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPartyWarning => 82,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetEventFavorite => 83,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Request => 84,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientPerfReport => 85,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GetEventFavorites_Response => 86,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestSouvenir => 87,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportValidation => 88,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode => 89,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientRequestValidation => 90,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRedeemMissionReward => 91,
            ECsgoGCMsg::k_EMsgGCCStrike15_ClientDeepStats => 92,
            ECsgoGCMsg::k_EMsgGCCStrike15_StartAgreementSessionInGame => 93,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientInitSystem => 94,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response => 95,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PrivateQueues => 96,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt => 97,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName => 98,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRedeemFreeReward => 99,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ECsgoGCMsg {
    fn default() -> Self {
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base
    }
}

impl ECsgoGCMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECsgoGCMsg>("ECsgoGCMsg")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECsgoSteamUserStat)
pub enum ECsgoSteamUserStat {
    // @@protoc_insertion_point(enum_value:ECsgoSteamUserStat.k_ECsgoSteamUserStat_XpEarnedGames)
    k_ECsgoSteamUserStat_XpEarnedGames = 1,
    // @@protoc_insertion_point(enum_value:ECsgoSteamUserStat.k_ECsgoSteamUserStat_MatchWinsCompetitive)
    k_ECsgoSteamUserStat_MatchWinsCompetitive = 2,
    // @@protoc_insertion_point(enum_value:ECsgoSteamUserStat.k_ECsgoSteamUserStat_SurvivedDangerZone)
    k_ECsgoSteamUserStat_SurvivedDangerZone = 3,
}

impl ::protobuf::Enum for ECsgoSteamUserStat {
    const NAME: &'static str = "ECsgoSteamUserStat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECsgoSteamUserStat> {
        match value {
            1 => ::std::option::Option::Some(ECsgoSteamUserStat::k_ECsgoSteamUserStat_XpEarnedGames),
            2 => ::std::option::Option::Some(ECsgoSteamUserStat::k_ECsgoSteamUserStat_MatchWinsCompetitive),
            3 => ::std::option::Option::Some(ECsgoSteamUserStat::k_ECsgoSteamUserStat_SurvivedDangerZone),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECsgoSteamUserStat> {
        match str {
            "k_ECsgoSteamUserStat_XpEarnedGames" => ::std::option::Option::Some(ECsgoSteamUserStat::k_ECsgoSteamUserStat_XpEarnedGames),
            "k_ECsgoSteamUserStat_MatchWinsCompetitive" => ::std::option::Option::Some(ECsgoSteamUserStat::k_ECsgoSteamUserStat_MatchWinsCompetitive),
            "k_ECsgoSteamUserStat_SurvivedDangerZone" => ::std::option::Option::Some(ECsgoSteamUserStat::k_ECsgoSteamUserStat_SurvivedDangerZone),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECsgoSteamUserStat] = &[
        ECsgoSteamUserStat::k_ECsgoSteamUserStat_XpEarnedGames,
        ECsgoSteamUserStat::k_ECsgoSteamUserStat_MatchWinsCompetitive,
        ECsgoSteamUserStat::k_ECsgoSteamUserStat_SurvivedDangerZone,
    ];
}

impl ::protobuf::EnumFull for ECsgoSteamUserStat {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECsgoSteamUserStat").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ECsgoSteamUserStat::k_ECsgoSteamUserStat_XpEarnedGames => 0,
            ECsgoSteamUserStat::k_ECsgoSteamUserStat_MatchWinsCompetitive => 1,
            ECsgoSteamUserStat::k_ECsgoSteamUserStat_SurvivedDangerZone => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ECsgoSteamUserStat {
    fn default() -> Self {
        ECsgoSteamUserStat::k_ECsgoSteamUserStat_XpEarnedGames
    }
}

impl ECsgoSteamUserStat {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECsgoSteamUserStat>("ECsgoSteamUserStat")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EClientReportingVersion)
pub enum EClientReportingVersion {
    // @@protoc_insertion_point(enum_value:EClientReportingVersion.k_EClientReportingVersion_OldVersion)
    k_EClientReportingVersion_OldVersion = 0,
    // @@protoc_insertion_point(enum_value:EClientReportingVersion.k_EClientReportingVersion_BetaVersion)
    k_EClientReportingVersion_BetaVersion = 1,
    // @@protoc_insertion_point(enum_value:EClientReportingVersion.k_EClientReportingVersion_SupportsTrustedMode)
    k_EClientReportingVersion_SupportsTrustedMode = 2,
}

impl ::protobuf::Enum for EClientReportingVersion {
    const NAME: &'static str = "EClientReportingVersion";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EClientReportingVersion> {
        match value {
            0 => ::std::option::Option::Some(EClientReportingVersion::k_EClientReportingVersion_OldVersion),
            1 => ::std::option::Option::Some(EClientReportingVersion::k_EClientReportingVersion_BetaVersion),
            2 => ::std::option::Option::Some(EClientReportingVersion::k_EClientReportingVersion_SupportsTrustedMode),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EClientReportingVersion> {
        match str {
            "k_EClientReportingVersion_OldVersion" => ::std::option::Option::Some(EClientReportingVersion::k_EClientReportingVersion_OldVersion),
            "k_EClientReportingVersion_BetaVersion" => ::std::option::Option::Some(EClientReportingVersion::k_EClientReportingVersion_BetaVersion),
            "k_EClientReportingVersion_SupportsTrustedMode" => ::std::option::Option::Some(EClientReportingVersion::k_EClientReportingVersion_SupportsTrustedMode),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EClientReportingVersion] = &[
        EClientReportingVersion::k_EClientReportingVersion_OldVersion,
        EClientReportingVersion::k_EClientReportingVersion_BetaVersion,
        EClientReportingVersion::k_EClientReportingVersion_SupportsTrustedMode,
    ];
}

impl ::protobuf::EnumFull for EClientReportingVersion {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EClientReportingVersion").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EClientReportingVersion {
    fn default() -> Self {
        EClientReportingVersion::k_EClientReportingVersion_OldVersion
    }
}

impl EClientReportingVersion {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EClientReportingVersion>("EClientReportingVersion")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EInitSystemResult)
pub enum EInitSystemResult {
    // @@protoc_insertion_point(enum_value:EInitSystemResult.k_EInitSystemResult_Invalid)
    k_EInitSystemResult_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EInitSystemResult.k_EInitSystemResult_Success)
    k_EInitSystemResult_Success = 1,
    // @@protoc_insertion_point(enum_value:EInitSystemResult.k_EInitSystemResult_None)
    k_EInitSystemResult_None = 2,
    // @@protoc_insertion_point(enum_value:EInitSystemResult.k_EInitSystemResult_NotFound)
    k_EInitSystemResult_NotFound = 3,
    // @@protoc_insertion_point(enum_value:EInitSystemResult.k_EInitSystemResult_Existing)
    k_EInitSystemResult_Existing = 4,
    // @@protoc_insertion_point(enum_value:EInitSystemResult.k_EInitSystemResult_FailedOpen)
    k_EInitSystemResult_FailedOpen = 5,
    // @@protoc_insertion_point(enum_value:EInitSystemResult.k_EInitSystemResult_Mismatch)
    k_EInitSystemResult_Mismatch = 6,
    // @@protoc_insertion_point(enum_value:EInitSystemResult.k_EInitSystemResult_FailedInit)
    k_EInitSystemResult_FailedInit = 7,
    // @@protoc_insertion_point(enum_value:EInitSystemResult.k_EInitSystemResult_Max)
    k_EInitSystemResult_Max = 8,
}

impl ::protobuf::Enum for EInitSystemResult {
    const NAME: &'static str = "EInitSystemResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EInitSystemResult> {
        match value {
            0 => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_Invalid),
            1 => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_Success),
            2 => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_None),
            3 => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_NotFound),
            4 => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_Existing),
            5 => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_FailedOpen),
            6 => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_Mismatch),
            7 => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_FailedInit),
            8 => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_Max),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EInitSystemResult> {
        match str {
            "k_EInitSystemResult_Invalid" => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_Invalid),
            "k_EInitSystemResult_Success" => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_Success),
            "k_EInitSystemResult_None" => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_None),
            "k_EInitSystemResult_NotFound" => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_NotFound),
            "k_EInitSystemResult_Existing" => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_Existing),
            "k_EInitSystemResult_FailedOpen" => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_FailedOpen),
            "k_EInitSystemResult_Mismatch" => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_Mismatch),
            "k_EInitSystemResult_FailedInit" => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_FailedInit),
            "k_EInitSystemResult_Max" => ::std::option::Option::Some(EInitSystemResult::k_EInitSystemResult_Max),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EInitSystemResult] = &[
        EInitSystemResult::k_EInitSystemResult_Invalid,
        EInitSystemResult::k_EInitSystemResult_Success,
        EInitSystemResult::k_EInitSystemResult_None,
        EInitSystemResult::k_EInitSystemResult_NotFound,
        EInitSystemResult::k_EInitSystemResult_Existing,
        EInitSystemResult::k_EInitSystemResult_FailedOpen,
        EInitSystemResult::k_EInitSystemResult_Mismatch,
        EInitSystemResult::k_EInitSystemResult_FailedInit,
        EInitSystemResult::k_EInitSystemResult_Max,
    ];
}

impl ::protobuf::EnumFull for EInitSystemResult {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EInitSystemResult").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EInitSystemResult {
    fn default() -> Self {
        EInitSystemResult::k_EInitSystemResult_Invalid
    }
}

impl EInitSystemResult {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EInitSystemResult>("EInitSystemResult")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1acstrike15_gcmessages.proto\x1a\x13steammessages.proto\x1a\x17engin\
    e_gcmessages.proto\x1a\x16gcsdk_gcmessages.proto\"R\n\x0eGameServerPing\
    \x12\x12\n\x04ping\x18\x02\x20\x01(\x05R\x04ping\x12\x0e\n\x02ip\x18\x03\
    \x20\x01(\rR\x02ip\x12\x1c\n\tinstances\x18\x05\x20\x01(\rR\tinstances\"\
    J\n\x0eDataCenterPing\x12$\n\x0edata_center_id\x18\x01\x20\x01(\x07R\x0c\
    dataCenterId\x12\x12\n\x04ping\x18\x02\x20\x01(\x11R\x04ping\"\x8b\x01\n\
    \x17DetailedSearchStatistic\x12\x1b\n\tgame_type\x18\x01\x20\x01(\rR\x08\
    gameType\x12&\n\x0fsearch_time_avg\x18\x02\x20\x01(\rR\rsearchTimeAvg\
    \x12+\n\x11players_searching\x18\x04\x20\x01(\rR\x10playersSearching\"\
    \xfd\x01\n\x10TournamentPlayer\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\
    \taccountId\x12\x1f\n\x0bplayer_nick\x18\x02\x20\x01(\tR\nplayerNick\x12\
    \x1f\n\x0bplayer_name\x18\x03\x20\x01(\tR\nplayerName\x12\x1d\n\nplayer_\
    dob\x18\x04\x20\x01(\rR\tplayerDob\x12\x1f\n\x0bplayer_flag\x18\x05\x20\
    \x01(\tR\nplayerFlag\x12'\n\x0fplayer_location\x18\x06\x20\x01(\tR\x0epl\
    ayerLocation\x12\x1f\n\x0bplayer_desc\x18\x07\x20\x01(\tR\nplayerDesc\"\
    \xab\x01\n\x0eTournamentTeam\x12\x17\n\x07team_id\x18\x01\x20\x01(\x05R\
    \x06teamId\x12\x19\n\x08team_tag\x18\x02\x20\x01(\tR\x07teamTag\x12\x1b\
    \n\tteam_flag\x18\x03\x20\x01(\tR\x08teamFlag\x12\x1b\n\tteam_name\x18\
    \x04\x20\x01(\tR\x08teamName\x12+\n\x07players\x18\x05\x20\x03(\x0b2\x11\
    .TournamentPlayerR\x07players\"\xd7\x02\n\x0fTournamentEvent\x12\x19\n\
    \x08event_id\x18\x01\x20\x01(\x05R\x07eventId\x12\x1b\n\tevent_tag\x18\
    \x02\x20\x01(\tR\x08eventTag\x12\x1d\n\nevent_name\x18\x03\x20\x01(\tR\t\
    eventName\x12(\n\x10event_time_start\x18\x04\x20\x01(\rR\x0eeventTimeSta\
    rt\x12$\n\x0eevent_time_end\x18\x05\x20\x01(\rR\x0ceventTimeEnd\x12!\n\
    \x0cevent_public\x18\x06\x20\x01(\x05R\x0beventPublic\x12$\n\x0eevent_st\
    age_id\x18\x07\x20\x01(\x05R\x0ceventStageId\x12(\n\x10event_stage_name\
    \x18\x08\x20\x01(\tR\x0eeventStageName\x12*\n\x11active_section_id\x18\t\
    \x20\x01(\rR\x0factiveSectionId\"\x80\x06\n\x10GlobalStatistics\x12%\n\
    \x0eplayers_online\x18\x01\x20\x01(\rR\rplayersOnline\x12%\n\x0eservers_\
    online\x18\x02\x20\x01(\rR\rserversOnline\x12+\n\x11players_searching\
    \x18\x03\x20\x01(\rR\x10playersSearching\x12+\n\x11servers_available\x18\
    \x04\x20\x01(\rR\x10serversAvailable\x12'\n\x0fongoing_matches\x18\x05\
    \x20\x01(\rR\x0eongoingMatches\x12&\n\x0fsearch_time_avg\x18\x06\x20\x01\
    (\rR\rsearchTimeAvg\x12E\n\x11search_statistics\x18\x07\x20\x03(\x0b2\
    \x18.DetailedSearchStatisticR\x10searchStatistics\x12\"\n\rmain_post_url\
    \x18\x08\x20\x01(\tR\x0bmainPostUrl\x124\n\x16required_appid_version\x18\
    \t\x20\x01(\rR\x14requiredAppidVersion\x12-\n\x12pricesheet_version\x18\
    \n\x20\x01(\rR\x11pricesheetVersion\x124\n\x16twitch_streams_version\x18\
    \x0b\x20\x01(\rR\x14twitchStreamsVersion\x12:\n\x19active_tournament_eve\
    ntid\x18\x0c\x20\x01(\rR\x17activeTournamentEventid\x12(\n\x10active_sur\
    vey_id\x18\r\x20\x01(\rR\x0eactiveSurveyId\x12\x1f\n\x0brtime32_cur\x18\
    \x0e\x20\x01(\rR\nrtime32Cur\x12.\n\x13rtime32_event_start\x18\x0f\x20\
    \x01(\rR\x11rtime32EventStart\x126\n\x17required_appid_version2\x18\x10\
    \x20\x01(\rR\x15requiredAppidVersion2\"K\n\x1fOperationalStatisticDescri\
    ption\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05idkey\
    \x18\x02\x20\x01(\rR\x05idkey\"K\n\x1bOperationalStatisticElement\x12\
    \x14\n\x05idkey\x18\x01\x20\x01(\rR\x05idkey\x12\x16\n\x06values\x18\x02\
    \x20\x03(\x05R\x06values\"\x91\x01\n\x1bOperationalStatisticsPacket\x12\
    \x1a\n\x08packetid\x18\x01\x20\x01(\x05R\x08packetid\x12\x20\n\x0bmstime\
    stamp\x18\x02\x20\x01(\x05R\x0bmstimestamp\x124\n\x06values\x18\x03\x20\
    \x03(\x0b2\x1c.OperationalStatisticElementR\x06values\"q\n\x13Operationa\
    lVarValue\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06iva\
    lue\x18\x02\x20\x01(\x05R\x06ivalue\x12\x16\n\x06fvalue\x18\x03\x20\x01(\
    \x02R\x06fvalue\x12\x16\n\x06svalue\x18\x04\x20\x01(\x0cR\x06svalue\"\
    \xc5\x04\n\x11PlayerRankingInfo\x12\x1d\n\naccount_id\x18\x01\x20\x01(\r\
    R\taccountId\x12\x17\n\x07rank_id\x18\x02\x20\x01(\rR\x06rankId\x12\x12\
    \n\x04wins\x18\x03\x20\x01(\rR\x04wins\x12\x1f\n\x0brank_change\x18\x04\
    \x20\x01(\x02R\nrankChange\x12\x20\n\x0crank_type_id\x18\x06\x20\x01(\rR\
    \nrankTypeId\x12\x1d\n\ntv_control\x18\x07\x20\x01(\rR\ttvControl\x12*\n\
    \x11rank_window_stats\x18\x08\x20\x01(\x04R\x0frankWindowStats\x12)\n\
    \x10leaderboard_name\x18\t\x20\x01(\tR\x0fleaderboardName\x12\x1e\n\x0br\
    ank_if_win\x18\n\x20\x01(\rR\trankIfWin\x12\x20\n\x0crank_if_lose\x18\
    \x0b\x20\x01(\rR\nrankIfLose\x12\x1e\n\x0brank_if_tie\x18\x0c\x20\x01(\r\
    R\trankIfTie\x12?\n\x0cper_map_rank\x18\r\x20\x03(\x0b2\x1d.PlayerRankin\
    gInfo.PerMapRankR\nperMapRank\x126\n\x17leaderboard_name_status\x18\x0e\
    \x20\x01(\rR\x15leaderboardNameStatus\x1aP\n\nPerMapRank\x12\x15\n\x06ma\
    p_id\x18\x01\x20\x01(\rR\x05mapId\x12\x17\n\x07rank_id\x18\x02\x20\x01(\
    \rR\x06rankId\x12\x12\n\x04wins\x18\x03\x20\x01(\rR\x04wins\"}\n\x16Play\
    erCommendationInfo\x12!\n\x0ccmd_friendly\x18\x01\x20\x01(\rR\x0bcmdFrie\
    ndly\x12!\n\x0ccmd_teaching\x18\x02\x20\x01(\rR\x0bcmdTeaching\x12\x1d\n\
    \ncmd_leader\x18\x04\x20\x01(\rR\tcmdLeader\"\x85\x01\n\x10PlayerMedalsI\
    nfo\x120\n\x14display_items_defidx\x18\x07\x20\x03(\rR\x12displayItemsDe\
    fidx\x12?\n\x1cfeatured_display_item_defidx\x18\x08\x20\x01(\rR\x19featu\
    redDisplayItemDefidx\"m\n\x0fAccountActivity\x12\x1a\n\x08activity\x18\
    \x01\x20\x01(\rR\x08activity\x12\x12\n\x04mode\x18\x02\x20\x01(\rR\x04mo\
    de\x12\x10\n\x03map\x18\x03\x20\x01(\rR\x03map\x12\x18\n\x07matchid\x18\
    \x04\x20\x01(\x04R\x07matchid\"\x91\x01\n\x14TournamentMatchSetup\x12\
    \x19\n\x08event_id\x18\x01\x20\x01(\x05R\x07eventId\x12\x1c\n\nteam_id_c\
    t\x18\x02\x20\x01(\x05R\x08teamIdCt\x12\x1a\n\tteam_id_t\x18\x03\x20\x01\
    (\x05R\x07teamIdT\x12$\n\x0eevent_stage_id\x18\x04\x20\x01(\x05R\x0ceven\
    tStageId\"\xcf\x05\n\x0eServerHltvInfo\x12\x1e\n\x0btv_udp_port\x18\x01\
    \x20\x01(\rR\ttvUdpPort\x12\x20\n\x0ctv_watch_key\x18\x02\x20\x01(\x04R\
    \ntvWatchKey\x12\x19\n\x08tv_slots\x18\x03\x20\x01(\rR\x07tvSlots\x12\
    \x1d\n\ntv_clients\x18\x04\x20\x01(\rR\ttvClients\x12\x1d\n\ntv_proxies\
    \x18\x05\x20\x01(\rR\ttvProxies\x12\x17\n\x07tv_time\x18\x06\x20\x01(\rR\
    \x06tvTime\x12\x1b\n\tgame_type\x18\x08\x20\x01(\rR\x08gameType\x12#\n\r\
    game_mapgroup\x18\t\x20\x01(\tR\x0cgameMapgroup\x12\x19\n\x08game_map\
    \x18\n\x20\x01(\tR\x07gameMap\x12*\n\x11tv_master_steamid\x18\x0b\x20\
    \x01(\x04R\x0ftvMasterSteamid\x12$\n\x0etv_local_slots\x18\x0c\x20\x01(\
    \rR\x0ctvLocalSlots\x12(\n\x10tv_local_clients\x18\r\x20\x01(\rR\x0etvLo\
    calClients\x12(\n\x10tv_local_proxies\x18\x0e\x20\x01(\rR\x0etvLocalProx\
    ies\x12$\n\x0etv_relay_slots\x18\x0f\x20\x01(\rR\x0ctvRelaySlots\x12(\n\
    \x10tv_relay_clients\x18\x10\x20\x01(\rR\x0etvRelayClients\x12(\n\x10tv_\
    relay_proxies\x18\x11\x20\x01(\rR\x0etvRelayProxies\x12(\n\x10tv_relay_a\
    ddress\x18\x12\x20\x01(\rR\x0etvRelayAddress\x12\"\n\rtv_relay_port\x18\
    \x13\x20\x01(\rR\x0btvRelayPort\x12(\n\x10tv_relay_steamid\x18\x14\x20\
    \x01(\x04R\x0etvRelaySteamid\x12\x14\n\x05flags\x18\x15\x20\x01(\rR\x05f\
    lags\"q\n\rIpAddressMask\x12\x0c\n\x01a\x18\x01\x20\x01(\rR\x01a\x12\x0c\
    \n\x01b\x18\x02\x20\x01(\rR\x01b\x12\x0c\n\x01c\x18\x03\x20\x01(\rR\x01c\
    \x12\x0c\n\x01d\x18\x04\x20\x01(\rR\x01d\x12\x12\n\x04bits\x18\x05\x20\
    \x01(\rR\x04bits\x12\x14\n\x05token\x18\x06\x20\x01(\rR\x05token\"\x7f\n\
    \x1bCMsgCsgoSteamUserStatChange\x12.\n\x12ecsgosteamuserstat\x18\x01\x20\
    \x01(\x05R\x12ecsgosteamuserstat\x12\x14\n\x05delta\x18\x02\x20\x01(\x05\
    R\x05delta\x12\x1a\n\x08absolute\x18\x03\x20\x01(\x08R\x08absolute\"N\n\
    \x0eXpProgressData\x12\x1b\n\txp_points\x18\x01\x20\x01(\rR\x08xpPoints\
    \x12\x1f\n\x0bxp_category\x18\x02\x20\x01(\x05R\nxpCategory\"\x8b\x01\n\
    \x13MatchEndItemUpdates\x12\x17\n\x07item_id\x18\x01\x20\x01(\x04R\x06it\
    emId\x12(\n\x10item_attr_defidx\x18\x02\x20\x01(\rR\x0eitemAttrDefidx\
    \x121\n\x15item_attr_delta_value\x18\x03\x20\x01(\rR\x12itemAttrDeltaVal\
    ue\"\x95\x03\n\x14ScoreLeaderboardData\x12\x19\n\x08quest_id\x18\x01\x20\
    \x01(\x04R\x07questId\x12\x14\n\x05score\x18\x02\x20\x01(\rR\x05score\
    \x12L\n\x0eaccountentries\x18\x03\x20\x03(\x0b2$.ScoreLeaderboardData.Ac\
    countEntriesR\x0eaccountentries\x12?\n\x0cmatchentries\x18\x05\x20\x03(\
    \x0b2\x1b.ScoreLeaderboardData.EntryR\x0cmatchentries\x12)\n\x10leaderbo\
    ard_name\x18\x06\x20\x01(\tR\x0fleaderboardName\x1a+\n\x05Entry\x12\x10\
    \n\x03tag\x18\x01\x20\x01(\rR\x03tag\x12\x10\n\x03val\x18\x02\x20\x01(\r\
    R\x03val\x1ae\n\x0eAccountEntries\x12\x1c\n\taccountid\x18\x01\x20\x01(\
    \rR\taccountid\x125\n\x07entries\x18\x02\x20\x03(\x0b2\x1b.ScoreLeaderbo\
    ardData.EntryR\x07entries\"\xe7\x04\n\x0fPlayerQuestData\x12,\n\x12quest\
    er_account_id\x18\x01\x20\x01(\rR\x10questerAccountId\x12F\n\x0fquest_it\
    em_data\x18\x02\x20\x03(\x0b2\x1e.PlayerQuestData.QuestItemDataR\rquestI\
    temData\x129\n\x10xp_progress_data\x18\x03\x20\x03(\x0b2\x0f.XpProgressD\
    ataR\x0expProgressData\x12\x1f\n\x0btime_played\x18\x04\x20\x01(\rR\ntim\
    ePlayed\x12\x20\n\x0cmm_game_mode\x18\x05\x20\x01(\rR\nmmGameMode\x127\n\
    \x0citem_updates\x18\x06\x20\x03(\x0b2\x14.MatchEndItemUpdatesR\x0bitemU\
    pdates\x12:\n\x19operation_points_eligible\x18\x07\x20\x01(\x08R\x17oper\
    ationPointsEligible\x12F\n\x0fuserstatchanges\x18\x08\x20\x03(\x0b2\x1c.\
    CMsgCsgoSteamUserStatChangeR\x0fuserstatchanges\x1a\xa2\x01\n\rQuestItem\
    Data\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\x12;\n\x1aqu\
    est_normal_points_earned\x18\x02\x20\x01(\x05R\x17questNormalPointsEarne\
    d\x129\n\x19quest_bonus_points_earned\x18\x03\x20\x01(\x05R\x16questBonu\
    sPointsEarned\"\x95\x08\n\x14DeepPlayerStatsEntry\x12\x1c\n\taccountid\
    \x18\x01\x20\x01(\rR\taccountid\x12\x19\n\x08match_id\x18\x02\x20\x01(\
    \x04R\x07matchId\x12\x20\n\x0cmm_game_mode\x18\x03\x20\x01(\rR\nmmGameMo\
    de\x12\x14\n\x05mapid\x18\x04\x20\x01(\rR\x05mapid\x12\"\n\rb_starting_c\
    t\x18\x05\x20\x01(\x08R\x0bbStartingCt\x12#\n\rmatch_outcome\x18\x06\x20\
    \x01(\rR\x0cmatchOutcome\x12\x1d\n\nrounds_won\x18\x07\x20\x01(\rR\troun\
    dsWon\x12\x1f\n\x0brounds_lost\x18\x08\x20\x01(\rR\nroundsLost\x12\x1d\n\
    \nstat_score\x18\t\x20\x01(\rR\tstatScore\x12\x1f\n\x0bstat_deaths\x18\
    \x0c\x20\x01(\rR\nstatDeaths\x12\x1b\n\tstat_mvps\x18\r\x20\x01(\rR\x08s\
    tatMvps\x12\x1f\n\x0benemy_kills\x18\x0e\x20\x01(\rR\nenemyKills\x12'\n\
    \x0fenemy_headshots\x18\x0f\x20\x01(\rR\x0eenemyHeadshots\x12\x1b\n\tene\
    my_2ks\x18\x10\x20\x01(\rR\x08enemy2ks\x12\x1b\n\tenemy_3ks\x18\x11\x20\
    \x01(\rR\x08enemy3ks\x12\x1b\n\tenemy_4ks\x18\x12\x20\x01(\rR\x08enemy4k\
    s\x12!\n\x0ctotal_damage\x18\x13\x20\x01(\rR\x0btotalDamage\x126\n\x17en\
    gagements_entry_count\x18\x17\x20\x01(\rR\x15engagementsEntryCount\x124\
    \n\x16engagements_entry_wins\x18\x18\x20\x01(\rR\x14engagementsEntryWins\
    \x122\n\x15engagements_1v1_count\x18\x19\x20\x01(\rR\x13engagements1v1Co\
    unt\x120\n\x14engagements_1v1_wins\x18\x1a\x20\x01(\rR\x12engagements1v1\
    Wins\x122\n\x15engagements_1v2_count\x18\x1b\x20\x01(\rR\x13engagements1\
    v2Count\x120\n\x14engagements_1v2_wins\x18\x1c\x20\x01(\rR\x12engagement\
    s1v2Wins\x12#\n\rutility_count\x18\x1d\x20\x01(\rR\x0cutilityCount\x12'\
    \n\x0futility_success\x18\x1e\x20\x01(\rR\x0eutilitySuccess\x12\x1f\n\
    \x0bflash_count\x18\x20\x20\x01(\rR\nflashCount\x12#\n\rflash_success\
    \x18!\x20\x01(\rR\x0cflashSuccess\x12\x14\n\x05mates\x18\"\x20\x03(\rR\
    \x05mates\"\xc8\x03\n\x14DeepPlayerMatchEvent\x12\x1c\n\taccountid\x18\
    \x01\x20\x01(\rR\taccountid\x12\x19\n\x08match_id\x18\x02\x20\x01(\x04R\
    \x07matchId\x12\x19\n\x08event_id\x18\x03\x20\x01(\rR\x07eventId\x12\x1d\
    \n\nevent_type\x18\x04\x20\x01(\rR\teventType\x12\x20\n\x0cb_playing_ct\
    \x18\x05\x20\x01(\x08R\nbPlayingCt\x12\x1c\n\nuser_pos_x\x18\x06\x20\x01\
    (\x05R\x08userPosX\x12\x1c\n\nuser_pos_y\x18\x07\x20\x01(\x05R\x08userPo\
    sY\x12\x1c\n\nuser_pos_z\x18\x0c\x20\x01(\x05R\x08userPosZ\x12\x1f\n\x0b\
    user_defidx\x18\x08\x20\x01(\rR\nuserDefidx\x12\x1e\n\x0bother_pos_x\x18\
    \t\x20\x01(\x05R\totherPosX\x12\x1e\n\x0bother_pos_y\x18\n\x20\x01(\x05R\
    \totherPosY\x12\x1e\n\x0bother_pos_z\x18\r\x20\x01(\x05R\totherPosZ\x12!\
    \n\x0cother_defidx\x18\x0b\x20\x01(\rR\x0botherDefidx\x12\x1d\n\nevent_d\
    ata\x18\x0e\x20\x01(\x05R\teventData\"\xde\x01\n\x1cCMsgGC_ServerQuestUp\
    dateData\x12<\n\x11player_quest_data\x18\x01\x20\x03(\x0b2\x10.PlayerQue\
    stDataR\x0fplayerQuestData\x12\x1f\n\x0bbinary_data\x18\x02\x20\x01(\x0c\
    R\nbinaryData\x12\x20\n\x0cmm_game_mode\x18\x03\x20\x01(\rR\nmmGameMode\
    \x12=\n\x0emissionlbsdata\x18\x04\x20\x01(\x0b2\x15.ScoreLeaderboardData\
    R\x0emissionlbsdata\"\x8e\x01\n.CMsgGCCStrike15_v2_MatchmakingGC2ServerC\
    onfirm\x12\x14\n\x05token\x18\x01\x20\x01(\rR\x05token\x12\x14\n\x05stam\
    p\x18\x02\x20\x01(\rR\x05stamp\x12\x1a\n\x08exchange\x18\x03\x20\x01(\
    \x04R\x08exchange\x12\x14\n\x05retry\x18\x04\x20\x01(\rR\x05retry\"\x9b\
    \x01\n-CMsgGCCStrike15_v2_GC2ServerReservationUpdate\x124\n\x16viewers_e\
    xternal_total\x18\x01\x20\x01(\rR\x14viewersExternalTotal\x124\n\x16view\
    ers_external_steam\x18\x02\x20\x01(\rR\x14viewersExternalSteam\"\xc6\x02\
    \n#CMsgGCCStrike15_v2_MatchmakingStart\x12\x1f\n\x0baccount_ids\x18\x01\
    \x20\x03(\rR\naccountIds\x12\x1b\n\tgame_type\x18\x02\x20\x01(\rR\x08gam\
    eType\x12\x1f\n\x0bticket_data\x18\x03\x20\x01(\tR\nticketData\x12%\n\
    \x0eclient_version\x18\x04\x20\x01(\rR\rclientVersion\x12@\n\x10tourname\
    nt_match\x18\x05\x20\x01(\x0b2\x15.TournamentMatchSetupR\x0ftournamentMa\
    tch\x12\x1d\n\nprime_only\x18\x06\x20\x01(\x08R\tprimeOnly\x12\x1d\n\ntv\
    _control\x18\x07\x20\x01(\rR\ttvControl\x12\x19\n\x08lobby_id\x18\x08\
    \x20\x01(\x04R\x07lobbyId\">\n\"CMsgGCCStrike15_v2_MatchmakingStop\x12\
    \x18\n\x07abandon\x18\x01\x20\x01(\x05R\x07abandon\"\x9c\x01\n2CMsgGCCSt\
    rike15_v2_MatchmakingGC2ClientUpdate_Note\x12\x12\n\x04type\x18\x01\x20\
    \x01(\x05R\x04type\x12\x1b\n\tregion_id\x18\x02\x20\x01(\x05R\x08regionI\
    d\x12\x19\n\x08region_r\x18\x03\x20\x01(\x02R\x07regionR\x12\x1a\n\x08di\
    stance\x18\x04\x20\x01(\x02R\x08distance\"\xb6\x03\n/CMsgGCCStrike15_v2_\
    MatchmakingClient2ServerPing\x129\n\x0fgameserverpings\x18\x01\x20\x03(\
    \x0b2\x0f.GameServerPingR\x0fgameserverpings\x12!\n\x0coffset_index\x18\
    \x02\x20\x01(\x05R\x0boffsetIndex\x12\x1f\n\x0bfinal_batch\x18\x03\x20\
    \x01(\x05R\nfinalBatch\x12;\n\x11data_center_pings\x18\x04\x20\x03(\x0b2\
    \x0f.DataCenterPingR\x0fdataCenterPings\x12\x19\n\x08max_ping\x18\x05\
    \x20\x01(\rR\x07maxPing\x12\x1d\n\ntest_token\x18\x06\x20\x01(\x07R\ttes\
    tToken\x12\x1d\n\nsearch_key\x18\x07\x20\x01(\x0cR\tsearchKey\x12I\n\x05\
    notes\x18\x08\x20\x03(\x0b23.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpda\
    te_NoteR\x05notes\x12#\n\rdebug_message\x18\t\x20\x01(\tR\x0cdebugMessag\
    e\"\x83\x08\n-CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\x12\x20\n\
    \x0bmatchmaking\x18\x01\x20\x01(\x05R\x0bmatchmaking\x12=\n\x1bwaiting_a\
    ccount_id_sessions\x18\x02\x20\x03(\rR\x18waitingAccountIdSessions\x12\
    \x14\n\x05error\x18\x03\x20\x01(\tR\x05error\x12G\n\x20ongoingmatch_acco\
    unt_id_sessions\x18\x06\x20\x03(\rR\x1dongoingmatchAccountIdSessions\x12\
    4\n\x0cglobal_stats\x18\x07\x20\x01(\x0b2\x11.GlobalStatisticsR\x0bgloba\
    lStats\x12?\n\x1cfailping_account_id_sessions\x18\x08\x20\x03(\rR\x19fai\
    lpingAccountIdSessions\x12=\n\x1bpenalty_account_id_sessions\x18\t\x20\
    \x03(\rR\x18penaltyAccountIdSessions\x12A\n\x1dfailready_account_id_sess\
    ions\x18\n\x20\x03(\rR\x1afailreadyAccountIdSessions\x12A\n\x1dvacbanned\
    _account_id_sessions\x18\x0b\x20\x03(\rR\x1avacbannedAccountIdSessions\
    \x12B\n\x15server_ipaddress_mask\x18\x0c\x20\x01(\x0b2\x0e.IpAddressMask\
    R\x13serverIpaddressMask\x12I\n\x05notes\x18\r\x20\x03(\x0b23.CMsgGCCStr\
    ike15_v2_MatchmakingGC2ClientUpdate_NoteR\x05notes\x12H\n!penalty_accoun\
    t_id_sessions_green\x18\x0e\x20\x03(\rR\x1dpenaltyAccountIdSessionsGreen\
    \x12=\n\x1ainsufficientlevel_sessions\x18\x0f\x20\x03(\rR\x19insufficien\
    tlevelSessions\x12?\n\x1cvsncheck_account_id_sessions\x18\x10\x20\x03(\r\
    R\x19vsncheckAccountIdSessions\x12<\n\x1alauncher_mismatch_sessions\x18\
    \x11\x20\x03(\rR\x18launcherMismatchSessions\x12?\n\x1cinsecure_account_\
    id_sessions\x18\x12\x20\x03(\rR\x19insecureAccountIdSessions\"\xc6\x06\n\
    (CDataGCCStrike15_v2_TournamentMatchDraft\x12\x19\n\x08event_id\x18\x01\
    \x20\x01(\x05R\x07eventId\x12$\n\x0eevent_stage_id\x18\x02\x20\x01(\x05R\
    \x0ceventStageId\x12\x1a\n\tteam_id_0\x18\x03\x20\x01(\x05R\x07teamId0\
    \x12\x1a\n\tteam_id_1\x18\x04\x20\x01(\x05R\x07teamId1\x12\x1d\n\nmaps_c\
    ount\x18\x05\x20\x01(\x05R\tmapsCount\x12!\n\x0cmaps_current\x18\x06\x20\
    \x01(\x05R\x0bmapsCurrent\x12\"\n\rteam_id_start\x18\x07\x20\x01(\x05R\
    \x0bteamIdStart\x12\"\n\rteam_id_veto1\x18\x08\x20\x01(\x05R\x0bteamIdVe\
    to1\x12\"\n\rteam_id_pickn\x18\t\x20\x01(\x05R\x0bteamIdPickn\x12G\n\x06\
    drafts\x18\n\x20\x03(\x0b2/.CDataGCCStrike15_v2_TournamentMatchDraft.Ent\
    ryR\x06drafts\x12\x20\n\x0cvote_mapid_0\x18\x0b\x20\x03(\x05R\nvoteMapid\
    0\x12\x20\n\x0cvote_mapid_1\x18\x0c\x20\x03(\x05R\nvoteMapid1\x12\x20\n\
    \x0cvote_mapid_2\x18\r\x20\x03(\x05R\nvoteMapid2\x12\x20\n\x0cvote_mapid\
    _3\x18\x0e\x20\x03(\x05R\nvoteMapid3\x12\x20\n\x0cvote_mapid_4\x18\x0f\
    \x20\x03(\x05R\nvoteMapid4\x12\x20\n\x0cvote_mapid_5\x18\x10\x20\x03(\
    \x05R\nvoteMapid5\x12,\n\x12vote_starting_side\x18\x11\x20\x03(\x05R\x10\
    voteStartingSide\x12\x1d\n\nvote_phase\x18\x12\x20\x01(\x05R\tvotePhase\
    \x12(\n\x10vote_phase_start\x18\x13\x20\x01(\x02R\x0evotePhaseStart\x12*\
    \n\x11vote_phase_length\x18\x14\x20\x01(\x02R\x0fvotePhaseLength\x1a;\n\
    \x05Entry\x12\x14\n\x05mapid\x18\x01\x20\x01(\x05R\x05mapid\x12\x1c\n\nt\
    eam_id_ct\x18\x02\x20\x01(\x05R\x08teamIdCt\"\xcf\x02\n\x11CPreMatchInfo\
    Data\x12'\n\x0fpredictions_pct\x18\x01\x20\x01(\x05R\x0epredictionsPct\
    \x12?\n\x05draft\x18\x04\x20\x01(\x0b2).CDataGCCStrike15_v2_TournamentMa\
    tchDraftR\x05draft\x122\n\x05stats\x18\x05\x20\x03(\x0b2\x1c.CPreMatchIn\
    foData.TeamStatsR\x05stats\x12\x12\n\x04wins\x18\x06\x20\x03(\x05R\x04wi\
    ns\x1a\x87\x01\n\tTeamStats\x12*\n\x11match_info_idxtxt\x18\x01\x20\x01(\
    \x05R\x0fmatchInfoIdxtxt\x12$\n\x0ematch_info_txt\x18\x02\x20\x01(\tR\
    \x0cmatchInfoTxt\x12(\n\x10match_info_teams\x18\x03\x20\x03(\tR\x0ematch\
    InfoTeams\"\xed\x06\n.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\x12\
    \x1f\n\x0baccount_ids\x18\x01\x20\x03(\rR\naccountIds\x12\x1b\n\tgame_ty\
    pe\x18\x02\x20\x01(\rR\x08gameType\x12\x19\n\x08match_id\x18\x03\x20\x01\
    (\x04R\x07matchId\x12%\n\x0eserver_version\x18\x04\x20\x01(\rR\rserverVe\
    rsion\x12\x14\n\x05flags\x18\x12\x20\x01(\rR\x05flags\x12.\n\x08rankings\
    \x18\x05\x20\x03(\x0b2\x12.PlayerRankingInfoR\x08rankings\x12%\n\x0eencr\
    yption_key\x18\x06\x20\x01(\x04R\rencryptionKey\x12,\n\x12encryption_key\
    _pub\x18\x07\x20\x01(\x04R\x10encryptionKeyPub\x12\x1b\n\tparty_ids\x18\
    \x08\x20\x03(\rR\x08partyIds\x12,\n\twhitelist\x18\t\x20\x03(\x0b2\x0e.I\
    pAddressMaskR\twhitelist\x12*\n\x11tv_master_steamid\x18\n\x20\x01(\x04R\
    \x0ftvMasterSteamid\x12;\n\x10tournament_event\x18\x0b\x20\x01(\x0b2\x10\
    .TournamentEventR\x0ftournamentEvent\x12:\n\x10tournament_teams\x18\x0c\
    \x20\x03(\x0b2\x0f.TournamentTeamR\x0ftournamentTeams\x12C\n\x1etourname\
    nt_casters_account_ids\x18\r\x20\x03(\rR\x1btournamentCastersAccountIds\
    \x12(\n\x10tv_relay_steamid\x18\x0e\x20\x01(\x04R\x0etvRelaySteamid\x128\
    \n\x0epre_match_data\x18\x0f\x20\x01(\x0b2\x12.CPreMatchInfoDataR\x0cpre\
    MatchData\x12.\n\x13rtime32_event_start\x18\x10\x20\x01(\rR\x11rtime32Ev\
    entStart\x12\x1d\n\ntv_control\x18\x11\x20\x01(\rR\ttvControl\x128\n\rop\
    _var_values\x18\x13\x20\x03(\x0b2\x14.OperationalVarValueR\x0bopVarValue\
    s\"\xcf\x06\n7CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\
    \x12$\n\rreservationid\x18\x01\x20\x01(\x04R\rreservationid\x12Q\n\x0bre\
    servation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2Server\
    ReserveR\x0breservation\x12\x10\n\x03map\x18\x03\x20\x01(\tR\x03map\x12.\
    \n\x13gc_reservation_sent\x18\x04\x20\x01(\x04R\x11gcReservationSent\x12\
    %\n\x0eserver_version\x18\x05\x20\x01(\rR\rserverVersion\x12(\n\x07tv_in\
    fo\x18\x06\x20\x01(\x0b2\x0f.ServerHltvInfoR\x06tvInfo\x124\n\x16reward_\
    player_accounts\x18\x07\x20\x03(\rR\x14rewardPlayerAccounts\x120\n\x14id\
    le_player_accounts\x18\x08\x20\x03(\rR\x12idlePlayerAccounts\x126\n\x18r\
    eward_item_attr_def_idx\x18\t\x20\x01(\rR\x14rewardItemAttrDefIdx\x123\n\
    \x16reward_item_attr_value\x18\n\x20\x01(\rR\x13rewardItemAttrValue\x12<\
    \n\x1breward_item_attr_reward_idx\x18\x0b\x20\x01(\rR\x17rewardItemAttrR\
    ewardIdx\x12(\n\x10reward_drop_list\x18\x0c\x20\x01(\rR\x0erewardDropLis\
    t\x12%\n\x0etournament_tag\x18\r\x20\x01(\tR\rtournamentTag\x12:\n\x19le\
    gacy_steamdatagram_port\x18\x0e\x20\x01(\rR\x17legacySteamdatagramPort\
    \x123\n\x15steamdatagram_routing\x18\x11\x20\x01(\rR\x14steamdatagramRou\
    ting\x12\x1d\n\ntest_token\x18\x0f\x20\x01(\x07R\ttestToken\x12\x14\n\
    \x05flags\x18\x10\x20\x01(\rR\x05flags\"\xca\x02\n.CMsgGCCStrike15_v2_Ma\
    tchmakingGC2ClientReserve\x12\x1a\n\x08serverid\x18\x01\x20\x01(\x04R\
    \x08serverid\x12\"\n\rdirect_udp_ip\x18\x02\x20\x01(\rR\x0bdirectUdpIp\
    \x12&\n\x0fdirect_udp_port\x18\x03\x20\x01(\rR\rdirectUdpPort\x12$\n\rre\
    servationid\x18\x04\x20\x01(\x04R\rreservationid\x12Q\n\x0breservation\
    \x18\x05\x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserveR\
    \x0breservation\x12\x10\n\x03map\x18\x06\x20\x01(\tR\x03map\x12%\n\x0ese\
    rver_address\x18\x07\x20\x01(\tR\rserverAddress\"\xf2\t\n.CMsgGCCStrike1\
    5_v2_MatchmakingServerRoundStats\x12$\n\rreservationid\x18\x01\x20\x01(\
    \x04R\rreservationid\x12Q\n\x0breservation\x18\x02\x20\x01(\x0b2/.CMsgGC\
    CStrike15_v2_MatchmakingGC2ServerReserveR\x0breservation\x12\x10\n\x03ma\
    p\x18\x03\x20\x01(\tR\x03map\x12\x14\n\x05round\x18\x04\x20\x01(\x05R\
    \x05round\x12\x14\n\x05kills\x18\x05\x20\x03(\x05R\x05kills\x12\x18\n\
    \x07assists\x18\x06\x20\x03(\x05R\x07assists\x12\x16\n\x06deaths\x18\x07\
    \x20\x03(\x05R\x06deaths\x12\x16\n\x06scores\x18\x08\x20\x03(\x05R\x06sc\
    ores\x12\x14\n\x05pings\x18\t\x20\x03(\x05R\x05pings\x12!\n\x0cround_res\
    ult\x18\n\x20\x01(\x05R\x0broundResult\x12!\n\x0cmatch_result\x18\x0b\
    \x20\x01(\x05R\x0bmatchResult\x12\x1f\n\x0bteam_scores\x18\x0c\x20\x03(\
    \x05R\nteamScores\x12I\n\x07confirm\x18\r\x20\x01(\x0b2/.CMsgGCCStrike15\
    _v2_MatchmakingGC2ServerConfirmR\x07confirm\x12+\n\x11reservation_stage\
    \x18\x0e\x20\x01(\x05R\x10reservationStage\x12%\n\x0ematch_duration\x18\
    \x0f\x20\x01(\x05R\rmatchDuration\x12\x1f\n\x0benemy_kills\x18\x10\x20\
    \x03(\x05R\nenemyKills\x12'\n\x0fenemy_headshots\x18\x11\x20\x03(\x05R\
    \x0eenemyHeadshots\x12\x1b\n\tenemy_3ks\x18\x12\x20\x03(\x05R\x08enemy3k\
    s\x12\x1b\n\tenemy_4ks\x18\x13\x20\x03(\x05R\x08enemy4ks\x12\x1b\n\tenem\
    y_5ks\x18\x14\x20\x03(\x05R\x08enemy5ks\x12\x12\n\x04mvps\x18\x15\x20\
    \x03(\x05R\x04mvps\x12)\n\x10spectators_count\x18\x16\x20\x01(\rR\x0fspe\
    ctatorsCount\x12.\n\x13spectators_count_tv\x18\x17\x20\x01(\rR\x11specta\
    torsCountTv\x120\n\x14spectators_count_lnk\x18\x18\x20\x01(\rR\x12specta\
    torsCountLnk\x12&\n\x0fenemy_kills_agg\x18\x19\x20\x03(\x05R\renemyKills\
    Agg\x12U\n\tdrop_info\x18\x1a\x20\x01(\x0b28.CMsgGCCStrike15_v2_Matchmak\
    ingServerRoundStats.DropInfoR\x08dropInfo\x12(\n\x10b_switched_teams\x18\
    \x1b\x20\x01(\x08R\x0ebSwitchedTeams\x12\x1b\n\tenemy_2ks\x18\x1c\x20\
    \x03(\x05R\x08enemy2ks\x12%\n\x0eplayer_spawned\x18\x1d\x20\x03(\x05R\rp\
    layerSpawned\x12(\n\x10team_spawn_count\x18\x1e\x20\x03(\x05R\x0eteamSpa\
    wnCount\x12\x1d\n\nmax_rounds\x18\x1f\x20\x01(\rR\tmaxRounds\x1a+\n\x08D\
    ropInfo\x12\x1f\n\x0baccount_mvp\x18\x01\x20\x01(\rR\naccountMvp\".\n,CM\
    sgGCCStrike15_v2_MatchmakingClient2GCHello\"\xda\x07\n,CMsgGCCStrike15_v\
    2_MatchmakingGC2ClientHello\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\ta\
    ccountId\x12S\n\x0congoingmatch\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v\
    2_MatchmakingGC2ClientReserveR\x0congoingmatch\x124\n\x0cglobal_stats\
    \x18\x03\x20\x01(\x0b2\x11.GlobalStatisticsR\x0bglobalStats\x12'\n\x0fpe\
    nalty_seconds\x18\x04\x20\x01(\rR\x0epenaltySeconds\x12%\n\x0epenalty_re\
    ason\x18\x05\x20\x01(\rR\rpenaltyReason\x12\x1d\n\nvac_banned\x18\x06\
    \x20\x01(\x05R\tvacBanned\x12,\n\x07ranking\x18\x07\x20\x01(\x0b2\x12.Pl\
    ayerRankingInfoR\x07ranking\x12;\n\x0ccommendation\x18\x08\x20\x01(\x0b2\
    \x17.PlayerCommendationInfoR\x0ccommendation\x12)\n\x06medals\x18\t\x20\
    \x01(\x0b2\x11.PlayerMedalsInfoR\x06medals\x12:\n\x10my_current_event\
    \x18\n\x20\x01(\x0b2\x10.TournamentEventR\x0emyCurrentEvent\x12D\n\x16my\
    _current_event_teams\x18\x0b\x20\x03(\x0b2\x0f.TournamentTeamR\x13myCurr\
    entEventTeams\x127\n\x0fmy_current_team\x18\x0c\x20\x01(\x0b2\x0f.Tourna\
    mentTeamR\rmyCurrentTeam\x12G\n\x17my_current_event_stages\x18\r\x20\x03\
    (\x0b2\x10.TournamentEventR\x14myCurrentEventStages\x12\x1f\n\x0bsurvey_\
    vote\x18\x0e\x20\x01(\rR\nsurveyVote\x12,\n\x08activity\x18\x0f\x20\x01(\
    \x0b2\x10.AccountActivityR\x08activity\x12!\n\x0cplayer_level\x18\x11\
    \x20\x01(\x05R\x0bplayerLevel\x12\"\n\rplayer_cur_xp\x18\x12\x20\x01(\
    \x05R\x0bplayerCurXp\x121\n\x15player_xp_bonus_flags\x18\x13\x20\x01(\
    \x05R\x12playerXpBonusFlags\x12.\n\x08rankings\x18\x14\x20\x03(\x0b2\x12\
    .PlayerRankingInfoR\x08rankings\"\xce\x01\n)CMsgGCCStrike15_v2_AccountPr\
    ivacySettings\x12N\n\x08settings\x18\x01\x20\x03(\x0b22.CMsgGCCStrike15_\
    v2_AccountPrivacySettings.SettingR\x08settings\x1aQ\n\x07Setting\x12!\n\
    \x0csetting_type\x18\x01\x20\x01(\rR\x0bsettingType\x12#\n\rsetting_valu\
    e\x18\x02\x20\x01(\rR\x0csettingValue\"\xf9\x01\n.CMsgGCCStrike15_v2_Mat\
    chmakingGC2ClientAbandon\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\tacco\
    untId\x12X\n\x0fabandoned_match\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v\
    2_MatchmakingGC2ClientReserveR\x0eabandonedMatch\x12'\n\x0fpenalty_secon\
    ds\x18\x03\x20\x01(\rR\x0epenaltySeconds\x12%\n\x0epenalty_reason\x18\
    \x04\x20\x01(\rR\rpenaltyReason\"W\n%CMsgGCCStrike15_v2_ClientGCRankUpda\
    te\x12.\n\x08rankings\x18\x01\x20\x03(\x0b2\x12.PlayerRankingInfoR\x08ra\
    nkings\"Y\n3CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\x12\"\n\
    \rmain_post_url\x18\x01\x20\x01(\tR\x0bmainPostUrl\"\xbd\x01\n3CMsgGCCSt\
    rike15_v2_ServerNotificationForUserPenalty\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12\x16\n\x06reason\x18\x02\x20\x01(\rR\x06reaso\
    n\x12\x18\n\x07seconds\x18\x03\x20\x01(\rR\x07seconds\x125\n\x16communic\
    ation_cooldown\x18\x04\x20\x01(\x08R\x15communicationCooldown\"\xe1\x02\
    \n%CMsgGCCStrike15_v2_ClientReportPlayer\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12\x1d\n\nrpt_aimbot\x18\x02\x20\x01(\rR\trptAi\
    mbot\x12!\n\x0crpt_wallhack\x18\x03\x20\x01(\rR\x0brptWallhack\x12#\n\rr\
    pt_speedhack\x18\x04\x20\x01(\rR\x0crptSpeedhack\x12!\n\x0crpt_teamharm\
    \x18\x05\x20\x01(\rR\x0brptTeamharm\x12#\n\rrpt_textabuse\x18\x06\x20\
    \x01(\rR\x0crptTextabuse\x12%\n\x0erpt_voiceabuse\x18\x07\x20\x01(\rR\rr\
    ptVoiceabuse\x12\x19\n\x08match_id\x18\x08\x20\x01(\x04R\x07matchId\x12(\
    \n\x10report_from_demo\x18\t\x20\x01(\x08R\x0ereportFromDemo\"\xb7\x01\n\
    &CMsgGCCStrike15_v2_ClientCommendPlayer\x12\x1d\n\naccount_id\x18\x01\
    \x20\x01(\rR\taccountId\x12\x19\n\x08match_id\x18\x08\x20\x01(\x04R\x07m\
    atchId\x12;\n\x0ccommendation\x18\t\x20\x01(\x0b2\x17.PlayerCommendation\
    InfoR\x0ccommendation\x12\x16\n\x06tokens\x18\n\x20\x01(\rR\x06tokens\"\
    \x8d\x02\n%CMsgGCCStrike15_v2_ClientReportServer\x12!\n\x0crpt_poorperf\
    \x18\x01\x20\x01(\rR\x0brptPoorperf\x12+\n\x11rpt_abusivemodels\x18\x02\
    \x20\x01(\rR\x10rptAbusivemodels\x12\x1f\n\x0brpt_badmotd\x18\x03\x20\
    \x01(\rR\nrptBadmotd\x12)\n\x10rpt_listingabuse\x18\x04\x20\x01(\rR\x0fr\
    ptListingabuse\x12-\n\x12rpt_inventoryabuse\x18\x05\x20\x01(\rR\x11rptIn\
    ventoryabuse\x12\x19\n\x08match_id\x18\x08\x20\x01(\x04R\x07matchId\"\
    \xf4\x01\n'CMsgGCCStrike15_v2_ClientReportResponse\x12'\n\x0fconfirmatio\
    n_id\x18\x01\x20\x01(\x04R\x0econfirmationId\x12\x1d\n\naccount_id\x18\
    \x02\x20\x01(\rR\taccountId\x12\x1b\n\tserver_ip\x18\x03\x20\x01(\rR\x08\
    serverIp\x12#\n\rresponse_type\x18\x04\x20\x01(\rR\x0cresponseType\x12'\
    \n\x0fresponse_result\x18\x05\x20\x01(\rR\x0eresponseResult\x12\x16\n\
    \x06tokens\x18\x06\x20\x01(\rR\x06tokens\"\x8e\x02\n0CMsgGCCStrike15_v2_\
    ClientRequestWatchInfoFriends\x12\x1d\n\nrequest_id\x18\x01\x20\x01(\rR\
    \trequestId\x12\x1f\n\x0baccount_ids\x18\x02\x20\x03(\rR\naccountIds\x12\
    \x1a\n\x08serverid\x18\x03\x20\x01(\x04R\x08serverid\x12\x18\n\x07matchi\
    d\x18\x04\x20\x01(\x04R\x07matchid\x12'\n\x0fclient_launcher\x18\x05\x20\
    \x01(\rR\x0eclientLauncher\x12;\n\x11data_center_pings\x18\x06\x20\x03(\
    \x0b2\x0f.DataCenterPingR\x0fdataCenterPings\"\xd3\x03\n\x12WatchableMat\
    chInfo\x12\x1b\n\tserver_ip\x18\x01\x20\x01(\rR\x08serverIp\x12\x17\n\
    \x07tv_port\x18\x02\x20\x01(\rR\x06tvPort\x12#\n\rtv_spectators\x18\x03\
    \x20\x01(\rR\x0ctvSpectators\x12\x17\n\x07tv_time\x18\x04\x20\x01(\rR\
    \x06tvTime\x12*\n\x11tv_watch_password\x18\x05\x20\x01(\x0cR\x0ftvWatchP\
    assword\x12,\n\x12cl_decryptdata_key\x18\x06\x20\x01(\x04R\x10clDecryptd\
    ataKey\x123\n\x16cl_decryptdata_key_pub\x18\x07\x20\x01(\x04R\x13clDecry\
    ptdataKeyPub\x12\x1b\n\tgame_type\x18\x08\x20\x01(\rR\x08gameType\x12#\n\
    \rgame_mapgroup\x18\t\x20\x01(\tR\x0cgameMapgroup\x12\x19\n\x08game_map\
    \x18\n\x20\x01(\tR\x07gameMap\x12\x1b\n\tserver_id\x18\x0b\x20\x01(\x04R\
    \x08serverId\x12\x19\n\x08match_id\x18\x0c\x20\x01(\x04R\x07matchId\x12%\
    \n\x0ereservation_id\x18\r\x20\x01(\x04R\rreservationId\"\x82\x02\n.CMsg\
    GCCStrike15_v2_ClientRequestJoinFriendData\x12\x18\n\x07version\x18\x01\
    \x20\x01(\rR\x07version\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccou\
    ntId\x12\x1d\n\njoin_token\x18\x03\x20\x01(\rR\tjoinToken\x12\x19\n\x08j\
    oin_ipp\x18\x04\x20\x01(\rR\x07joinIpp\x12A\n\x03res\x18\x05\x20\x01(\
    \x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserveR\x03res\x12\x1a\n\
    \x08errormsg\x18\x06\x20\x01(\tR\x08errormsg\"\xa2\x02\n.CMsgGCCStrike15\
    _v2_ClientRequestJoinServerData\x12\x18\n\x07version\x18\x01\x20\x01(\rR\
    \x07version\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x1a\
    \n\x08serverid\x18\x03\x20\x01(\x04R\x08serverid\x12\x1b\n\tserver_ip\
    \x18\x04\x20\x01(\rR\x08serverIp\x12\x1f\n\x0bserver_port\x18\x05\x20\
    \x01(\rR\nserverPort\x12A\n\x03res\x18\x06\x20\x01(\x0b2/.CMsgGCCStrike1\
    5_v2_MatchmakingGC2ClientReserveR\x03res\x12\x1a\n\x08errormsg\x18\x07\
    \x20\x01(\tR\x08errormsg\"l\n*CMsgGCCstrike15_v2_ClientRequestNewMission\
    \x12\x1d\n\nmission_id\x18\x02\x20\x01(\rR\tmissionId\x12\x1f\n\x0bcampa\
    ign_id\x18\x03\x20\x01(\rR\ncampaignId\"\xc0\x01\n,CMsgGCCstrike15_v2_Cl\
    ientRedeemMissionReward\x12\x1f\n\x0bcampaign_id\x18\x01\x20\x01(\rR\nca\
    mpaignId\x12\x1b\n\tredeem_id\x18\x02\x20\x01(\rR\x08redeemId\x12-\n\x12\
    redeemable_balance\x18\x03\x20\x01(\rR\x11redeemableBalance\x12#\n\rexpe\
    cted_cost\x18\x04\x20\x01(\rR\x0cexpectedCost\"\x99\x01\n)CMsgGCCstrike1\
    5_v2_ClientRedeemFreeReward\x12'\n\x0fgeneration_time\x18\x01\x20\x01(\r\
    R\x0egenerationTime\x12-\n\x12redeemable_balance\x18\x02\x20\x01(\rR\x11\
    redeemableBalance\x12\x14\n\x05items\x18\x03\x20\x03(\x04R\x05items\"\
    \xd2\x02\n,CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\x129\n\x10xp_pro\
    gress_data\x18\x01\x20\x03(\x0b2\x0f.XpProgressDataR\x0expProgressData\
    \x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x1d\n\ncurrent\
    _xp\x18\x03\x20\x01(\rR\tcurrentXp\x12#\n\rcurrent_level\x18\x04\x20\x01\
    (\rR\x0ccurrentLevel\x12'\n\x0fupgraded_defidx\x18\x05\x20\x01(\rR\x0eup\
    gradedDefidx\x128\n\x18operation_points_awarded\x18\x06\x20\x01(\rR\x16o\
    perationPointsAwarded\x12!\n\x0cfree_rewards\x18\x07\x20\x01(\rR\x0bfree\
    Rewards\"\x94\x03\n\x1fCMsgGCCStrike15_ClientDeepStats\x12\x1d\n\naccoun\
    t_id\x18\x01\x20\x01(\rR\taccountId\x12E\n\x05range\x18\x02\x20\x01(\x0b\
    2/.CMsgGCCStrike15_ClientDeepStats.DeepStatsRangeR\x05range\x12I\n\x07ma\
    tches\x18\x03\x20\x03(\x0b2/.CMsgGCCStrike15_ClientDeepStats.DeepStatsMa\
    tchR\x07matches\x1aP\n\x0eDeepStatsRange\x12\x14\n\x05begin\x18\x01\x20\
    \x01(\rR\x05begin\x12\x10\n\x03end\x18\x02\x20\x01(\rR\x03end\x12\x16\n\
    \x06frozen\x18\x03\x20\x01(\x08R\x06frozen\x1an\n\x0eDeepStatsMatch\x12-\
    \n\x06player\x18\x01\x20\x01(\x0b2\x15.DeepPlayerStatsEntryR\x06player\
    \x12-\n\x06events\x18\x02\x20\x03(\x0b2\x15.DeepPlayerMatchEventR\x06eve\
    nts\"\xd7\x01\n!CMsgGCCStrike15_v2_WatchInfoUsers\x12\x1d\n\nrequest_id\
    \x18\x01\x20\x01(\rR\trequestId\x12\x1f\n\x0baccount_ids\x18\x02\x20\x03\
    (\rR\naccountIds\x12G\n\x15watchable_match_infos\x18\x03\x20\x03(\x0b2\
    \x13.WatchableMatchInfoR\x13watchableMatchInfos\x12)\n\x10extended_timeo\
    ut\x18\x05\x20\x01(\rR\x0fextendedTimeout\"\xe0\x01\n.CMsgGCCStrike15_v2\
    _ClientRequestPlayersProfile\x123\n\x16request_id__deprecated\x18\x01\
    \x20\x01(\rR\x13requestIdDeprecated\x125\n\x17account_ids__deprecated\
    \x18\x02\x20\x03(\rR\x14accountIdsDeprecated\x12\x1d\n\naccount_id\x18\
    \x03\x20\x01(\rR\taccountId\x12#\n\rrequest_level\x18\x04\x20\x01(\rR\
    \x0crequestLevel\"\x9c\x01\n!CMsgGCCStrike15_v2_PlayersProfile\x12\x1d\n\
    \nrequest_id\x18\x01\x20\x01(\rR\trequestId\x12X\n\x10account_profiles\
    \x18\x02\x20\x03(\x0b2-.CMsgGCCStrike15_v2_MatchmakingGC2ClientHelloR\
    \x0faccountProfiles\"\xa6\x02\n,CMsgGCCStrike15_v2_PlayerOverwatchCaseUp\
    date\x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\x1c\n\tsusp\
    ectid\x18\x03\x20\x01(\rR\tsuspectid\x12\x1e\n\nfractionid\x18\x04\x20\
    \x01(\rR\nfractionid\x12\x1d\n\nrpt_aimbot\x18\x05\x20\x01(\rR\trptAimbo\
    t\x12!\n\x0crpt_wallhack\x18\x06\x20\x01(\rR\x0brptWallhack\x12#\n\rrpt_\
    speedhack\x18\x07\x20\x01(\rR\x0crptSpeedhack\x12!\n\x0crpt_teamharm\x18\
    \x08\x20\x01(\rR\x0brptTeamharm\x12\x16\n\x06reason\x18\t\x20\x01(\rR\
    \x06reason\"\x90\x03\n0CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\
    \x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\x18\n\x07caseur\
    l\x18\x02\x20\x01(\tR\x07caseurl\x12\x18\n\x07verdict\x18\x03\x20\x01(\r\
    R\x07verdict\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\rR\ttimestamp\x12(\n\
    \x0fthrottleseconds\x18\x05\x20\x01(\rR\x0fthrottleseconds\x12\x1c\n\tsu\
    spectid\x18\x06\x20\x01(\rR\tsuspectid\x12\x1e\n\nfractionid\x18\x07\x20\
    \x01(\rR\nfractionid\x12\x1c\n\tnumrounds\x18\x08\x20\x01(\rR\tnumrounds\
    \x12&\n\x0efractionrounds\x18\t\x20\x01(\rR\x0efractionrounds\x12,\n\x11\
    streakconvictions\x18\n\x20\x01(\x05R\x11streakconvictions\x12\x16\n\x06\
    reason\x18\x0b\x20\x01(\rR\x06reason\"b\n,CMsgGCCStrike15_v2_PlayerOverw\
    atchCaseStatus\x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\
    \x1a\n\x08statusid\x18\x02\x20\x01(\rR\x08statusid\"V\n\x1eCClientHeader\
    OverwatchEvidence\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\
    \x12\x16\n\x06caseid\x18\x02\x20\x01(\x04R\x06caseid\"c\n#CMsgGCCStrike1\
    5_v2_GC2ClientTextMsg\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\
    \n\x04type\x18\x02\x20\x01(\rR\x04type\x12\x18\n\x07payload\x18\x03\x20\
    \x01(\x0cR\x07payload\"I\n#CMsgGCCStrike15_v2_Client2GCTextMsg\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04args\x18\x02\x20\x03(\x0cR\
    \x04args\"\xd5\x01\n)CMsgGCCStrike15_v2_MatchEndRunRewardDrops\x12X\n\ns\
    erverinfo\x18\x03\x20\x01(\x0b28.CMsgGCCStrike15_v2_MatchmakingServerRes\
    ervationResponseR\nserverinfo\x12N\n\x14match_end_quest_data\x18\x04\x20\
    \x01(\x0b2\x1d.CMsgGC_ServerQuestUpdateDataR\x11matchEndQuestData\"\xfd\
    \x05\n\x19CEconItemPreviewDataBlock\x12\x1c\n\taccountid\x18\x01\x20\x01\
    (\rR\taccountid\x12\x16\n\x06itemid\x18\x02\x20\x01(\x04R\x06itemid\x12\
    \x1a\n\x08defindex\x18\x03\x20\x01(\rR\x08defindex\x12\x1e\n\npaintindex\
    \x18\x04\x20\x01(\rR\npaintindex\x12\x16\n\x06rarity\x18\x05\x20\x01(\rR\
    \x06rarity\x12\x18\n\x07quality\x18\x06\x20\x01(\rR\x07quality\x12\x1c\n\
    \tpaintwear\x18\x07\x20\x01(\rR\tpaintwear\x12\x1c\n\tpaintseed\x18\x08\
    \x20\x01(\rR\tpaintseed\x12.\n\x12killeaterscoretype\x18\t\x20\x01(\rR\
    \x12killeaterscoretype\x12&\n\x0ekilleatervalue\x18\n\x20\x01(\rR\x0ekil\
    leatervalue\x12\x1e\n\ncustomname\x18\x0b\x20\x01(\tR\ncustomname\x12>\n\
    \x08stickers\x18\x0c\x20\x03(\x0b2\".CEconItemPreviewDataBlock.StickerR\
    \x08stickers\x12\x1c\n\tinventory\x18\r\x20\x01(\rR\tinventory\x12\x16\n\
    \x06origin\x18\x0e\x20\x01(\rR\x06origin\x12\x18\n\x07questid\x18\x0f\
    \x20\x01(\rR\x07questid\x12\x1e\n\ndropreason\x18\x10\x20\x01(\rR\ndropr\
    eason\x12\x1e\n\nmusicindex\x18\x11\x20\x01(\rR\nmusicindex\x12\x1a\n\
    \x08entindex\x18\x12\x20\x01(\x05R\x08entindex\x1a\x9b\x01\n\x07Sticker\
    \x12\x12\n\x04slot\x18\x01\x20\x01(\rR\x04slot\x12\x1d\n\nsticker_id\x18\
    \x02\x20\x01(\rR\tstickerId\x12\x12\n\x04wear\x18\x03\x20\x01(\x02R\x04w\
    ear\x12\x14\n\x05scale\x18\x04\x20\x01(\x02R\x05scale\x12\x1a\n\x08rotat\
    ion\x18\x05\x20\x01(\x02R\x08rotation\x12\x17\n\x07tint_id\x18\x06\x20\
    \x01(\rR\x06tintId\"l\n2CMsgGCCStrike15_v2_MatchEndRewardDropsNotificati\
    on\x126\n\x08iteminfo\x18\x06\x20\x01(\x0b2\x1a.CEconItemPreviewDataBloc\
    kR\x08iteminfo\"\x9d\x01\n7CMsgGCCStrike15_v2_Client2GCEconPreviewDataBl\
    ockRequest\x12\x17\n\x07param_s\x18\x01\x20\x01(\x04R\x06paramS\x12\x17\
    \n\x07param_a\x18\x02\x20\x01(\x04R\x06paramA\x12\x17\n\x07param_d\x18\
    \x03\x20\x01(\x04R\x06paramD\x12\x17\n\x07param_m\x18\x04\x20\x01(\x04R\
    \x06paramM\"r\n8CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\
    \x126\n\x08iteminfo\x18\x01\x20\x01(\x0b2\x1a.CEconItemPreviewDataBlockR\
    \x08iteminfo\"5\n3CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\"R\
    \n2CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\x12\x1c\n\taccount\
    id\x18\x01\x20\x01(\rR\taccountid\"R\n2CMsgGCCStrike15_v2_MatchListReque\
    stRecentUserGames\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\"N\
    \n2CMsgGCCStrike15_v2_MatchListRequestTournamentGames\x12\x18\n\x07event\
    id\x18\x01\x20\x01(\x05R\x07eventid\"\x7f\n/CMsgGCCStrike15_v2_MatchList\
    RequestFullGameInfo\x12\x18\n\x07matchid\x18\x01\x20\x01(\x04R\x07matchi\
    d\x12\x1c\n\toutcomeid\x18\x02\x20\x01(\x04R\toutcomeid\x12\x14\n\x05tok\
    en\x18\x03\x20\x01(\rR\x05token\"\xd1\x02\n\x1dCDataGCCStrike15_v2_Match\
    Info\x12\x18\n\x07matchid\x18\x01\x20\x01(\x04R\x07matchid\x12\x1c\n\tma\
    tchtime\x18\x02\x20\x01(\rR\tmatchtime\x12C\n\x12watchablematchinfo\x18\
    \x03\x20\x01(\x0b2\x13.WatchableMatchInfoR\x12watchablematchinfo\x12\\\n\
    \x11roundstats_legacy\x18\x04\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matchmak\
    ingServerRoundStatsR\x10roundstatsLegacy\x12U\n\rroundstatsall\x18\x05\
    \x20\x03(\x0b2/.CMsgGCCStrike15_v2_MatchmakingServerRoundStatsR\rroundst\
    atsall\"z\n'CDataGCCStrike15_v2_TournamentGroupTeam\x12\x17\n\x07team_id\
    \x18\x01\x20\x01(\x05R\x06teamId\x12\x14\n\x05score\x18\x02\x20\x01(\x05\
    R\x05score\x12\x20\n\x0bcorrectpick\x18\x03\x20\x01(\x08R\x0bcorrectpick\
    \"\xd1\x03\n#CDataGCCStrike15_v2_TournamentGroup\x12\x18\n\x07groupid\
    \x18\x01\x20\x01(\rR\x07groupid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12\x12\n\x04desc\x18\x03\x20\x01(\tR\x04desc\x12*\n\x11picks__\
    deprecated\x18\x04\x20\x01(\rR\x0fpicksDeprecated\x12>\n\x05teams\x18\
    \x05\x20\x03(\x0b2(.CDataGCCStrike15_v2_TournamentGroupTeamR\x05teams\
    \x12\x1b\n\tstage_ids\x18\x06\x20\x03(\x05R\x08stageIds\x12,\n\x11picklo\
    ckuntiltime\x18\x07\x20\x01(\rR\x11picklockuntiltime\x12$\n\rpickabletea\
    ms\x18\x08\x20\x01(\rR\rpickableteams\x12&\n\x0fpoints_per_pick\x18\t\
    \x20\x01(\rR\rpointsPerPick\x12@\n\x05picks\x18\n\x20\x03(\x0b2*.CDataGC\
    CStrike15_v2_TournamentGroup.PicksR\x05picks\x1a!\n\x05Picks\x12\x18\n\
    \x07pickids\x18\x01\x20\x03(\x05R\x07pickids\"\xab\x01\n%CDataGCCStrike1\
    5_v2_TournamentSection\x12\x1c\n\tsectionid\x18\x01\x20\x01(\rR\tsection\
    id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04desc\x18\
    \x03\x20\x01(\tR\x04desc\x12<\n\x06groups\x18\x04\x20\x03(\x0b2$.CDataGC\
    CStrike15_v2_TournamentGroupR\x06groups\"\xe1\x01\n\"CDataGCCStrike15_v2\
    _TournamentInfo\x12B\n\x08sections\x18\x01\x20\x03(\x0b2&.CDataGCCStrike\
    15_v2_TournamentSectionR\x08sections\x12;\n\x10tournament_event\x18\x02\
    \x20\x01(\x0b2\x10.TournamentEventR\x0ftournamentEvent\x12:\n\x10tournam\
    ent_teams\x18\x03\x20\x03(\x0b2\x0f.TournamentTeamR\x0ftournamentTeams\"\
    \xb2\x02\n\x1cCMsgGCCStrike15_v2_MatchList\x12\"\n\x0cmsgrequestid\x18\
    \x01\x20\x01(\rR\x0cmsgrequestid\x12\x1c\n\taccountid\x18\x02\x20\x01(\r\
    R\taccountid\x12\x1e\n\nservertime\x18\x03\x20\x01(\rR\nservertime\x128\
    \n\x07matches\x18\x04\x20\x03(\x0b2\x1e.CDataGCCStrike15_v2_MatchInfoR\
    \x07matches\x12)\n\x07streams\x18\x05\x20\x03(\x0b2\x0f.TournamentTeamR\
    \x07streams\x12K\n\x0etournamentinfo\x18\x06\x20\x01(\x0b2#.CDataGCCStri\
    ke15_v2_TournamentInfoR\x0etournamentinfo\"\xa6\x01\n2CMsgGCCStrike15_v2\
    _MatchListTournamentOperatorMgmt\x12\x18\n\x07eventid\x18\x01\x20\x01(\
    \x05R\x07eventid\x128\n\x07matches\x18\x02\x20\x03(\x0b2\x1e.CDataGCCStr\
    ike15_v2_MatchInfoR\x07matches\x12\x1c\n\taccountid\x18\x03\x20\x01(\rR\
    \taccountid\"\xb9\x02\n\x1eCMsgGCCStrike15_v2_Predictions\x12\x19\n\x08e\
    vent_id\x18\x01\x20\x01(\rR\x07eventId\x12g\n\x16group_match_team_picks\
    \x18\x02\x20\x03(\x0b22.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPic\
    kR\x13groupMatchTeamPicks\x1a\x92\x01\n\x12GroupMatchTeamPick\x12\x1c\n\
    \tsectionid\x18\x01\x20\x01(\x05R\tsectionid\x12\x18\n\x07groupid\x18\
    \x02\x20\x01(\x05R\x07groupid\x12\x14\n\x05index\x18\x03\x20\x01(\x05R\
    \x05index\x12\x16\n\x06teamid\x18\x04\x20\x01(\x05R\x06teamid\x12\x16\n\
    \x06itemid\x18\x05\x20\x01(\x04R\x06itemid\"\xb1\x02\n\x1aCMsgGCCStrike1\
    5_v2_Fantasy\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12=\n\
    \x05teams\x18\x02\x20\x03(\x0b2'.CMsgGCCStrike15_v2_Fantasy.FantasyTeamR\
    \x05teams\x1aM\n\x0bFantasySlot\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\
    \x04type\x12\x12\n\x04pick\x18\x02\x20\x01(\x05R\x04pick\x12\x16\n\x06it\
    emid\x18\x03\x20\x01(\x04R\x06itemid\x1aj\n\x0bFantasyTeam\x12\x1c\n\tse\
    ctionid\x18\x01\x20\x01(\x05R\tsectionid\x12=\n\x05slots\x18\x02\x20\x03\
    (\x0b2'.CMsgGCCStrike15_v2_Fantasy.FantasySlotR\x05slots\"\x93\x05\n\x1e\
    CMsgLegacySource1ClientWelcome\x12\x18\n\x07version\x18\x01\x20\x01(\rR\
    \x07version\x12\x1b\n\tgame_data\x18\x02\x20\x01(\x0cR\x08gameData\x12V\
    \n\x1boutofdate_subscribed_caches\x18\x03\x20\x03(\x0b2\x16.CMsgSOCacheS\
    ubscribedR\x19outofdateSubscribedCaches\x12[\n\x1auptodate_subscribed_ca\
    ches\x18\x04\x20\x03(\x0b2\x1d.CMsgSOCacheSubscriptionCheckR\x18uptodate\
    SubscribedCaches\x12D\n\x08location\x18\x05\x20\x01(\x0b2(.CMsgLegacySou\
    rce1ClientWelcome.LocationR\x08location\x12\x1d\n\ngame_data2\x18\x06\
    \x20\x01(\x0cR\tgameData2\x12?\n\x1crtime32_gc_welcome_timestamp\x18\x07\
    \x20\x01(\rR\x19rtime32GcWelcomeTimestamp\x12\x1a\n\x08currency\x18\x08\
    \x20\x01(\rR\x08currency\x12\x18\n\x07balance\x18\t\x20\x01(\rR\x07balan\
    ce\x12\x1f\n\x0bbalance_url\x18\n\x20\x01(\tR\nbalanceUrl\x12(\n\x10txn_\
    country_code\x18\x0b\x20\x01(\tR\x0etxnCountryCode\x1a^\n\x08Location\
    \x12\x1a\n\x08latitude\x18\x01\x20\x01(\x02R\x08latitude\x12\x1c\n\tlong\
    itude\x18\x02\x20\x01(\x02R\tlongitude\x12\x18\n\x07country\x18\x03\x20\
    \x01(\tR\x07country\"\xb2\x02\n\x14CMsgCStrike15Welcome\x12&\n\x0fstore_\
    item_hash\x18\x05\x20\x01(\rR\rstoreItemHash\x128\n\x17timeplayedconsecu\
    tively\x18\x06\x20\x01(\rR\x17timeplayedconsecutively\x12*\n\x11time_fir\
    st_played\x18\n\x20\x01(\rR\x0ftimeFirstPlayed\x12(\n\x10last_time_playe\
    d\x18\x0c\x20\x01(\rR\x0elastTimePlayed\x12&\n\x0flast_ip_address\x18\r\
    \x20\x01(\rR\rlastIpAddress\x12\x1e\n\ngscookieid\x18\x12\x20\x01(\x04R\
    \ngscookieid\x12\x1a\n\x08uniqueid\x18\x13\x20\x01(\x04R\x08uniqueid\"\
    \xd6\x01\n1CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\x12\x1d\n\n\
    value_name\x18\x01\x20\x01(\tR\tvalueName\x12\x1b\n\tvalue_int\x18\x02\
    \x20\x01(\x05R\x08valueInt\x12\x1f\n\x0bserver_addr\x18\x03\x20\x01(\rR\
    \nserverAddr\x12\x1f\n\x0bserver_port\x18\x04\x20\x01(\rR\nserverPort\
    \x12#\n\rchoked_blocks\x18\x05\x20\x03(\tR\x0cchokedBlocks\"\xa1\x01\n1C\
    MsgGCCStrike15_v2_ServerVarValueNotificationInfo\x12\x1c\n\taccountid\
    \x18\x01\x20\x01(\rR\taccountid\x12\x1e\n\nviewangles\x18\x02\x20\x03(\r\
    R\nviewangles\x12\x12\n\x04type\x18\x03\x20\x01(\rR\x04type\x12\x1a\n\
    \x08userdata\x18\x04\x20\x03(\rR\x08userdata\",\n*CMsgGCCStrike15_v2_Gif\
    tsLeaderboardRequest\"\xf5\x02\n+CMsgGCCStrike15_v2_GiftsLeaderboardResp\
    onse\x12\x1e\n\nservertime\x18\x01\x20\x01(\rR\nservertime\x12.\n\x13tim\
    e_period_seconds\x18\x02\x20\x01(\rR\x11timePeriodSeconds\x12*\n\x11tota\
    l_gifts_given\x18\x03\x20\x01(\rR\x0ftotalGiftsGiven\x12!\n\x0ctotal_giv\
    ers\x18\x04\x20\x01(\rR\x0btotalGivers\x12[\n\x07entries\x18\x05\x20\x03\
    (\x0b2A.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry\
    R\x07entries\x1aJ\n\x14GiftLeaderboardEntry\x12\x1c\n\taccountid\x18\x01\
    \x20\x01(\rR\taccountid\x12\x14\n\x05gifts\x18\x02\x20\x01(\rR\x05gifts\
    \"\\\n)CMsgGCCStrike15_v2_ClientSubmitSurveyVote\x12\x1b\n\tsurvey_id\
    \x18\x01\x20\x01(\rR\x08surveyId\x12\x12\n\x04vote\x18\x02\x20\x01(\rR\
    \x04vote\"J\n*CMsgGCCStrike15_v2_Server2GCClientValidate\x12\x1c\n\tacco\
    untid\x18\x01\x20\x01(\rR\taccountid\"\x97\x01\n*CMsgGCCStrike15_v2_GC2C\
    lientTournamentInfo\x12\x18\n\x07eventid\x18\x01\x20\x01(\rR\x07eventid\
    \x12\x18\n\x07stageid\x18\x02\x20\x01(\rR\x07stageid\x12\x1b\n\tgame_typ\
    e\x18\x03\x20\x01(\rR\x08gameType\x12\x18\n\x07teamids\x18\x04\x20\x03(\
    \rR\x07teamids\"p\n\rCSOEconCoupon\x12\x1e\n\x07entryid\x18\x01\x20\x01(\
    \rR\x07entryidB\x04\x80\xa6\x1d\x01\x12\x16\n\x06defidx\x18\x02\x20\x01(\
    \rR\x06defidx\x12'\n\x0fexpiration_date\x18\x03\x20\x01(\x07R\x0eexpirat\
    ionDate\"\x91\x01\n\x1bCSOAccountItemPersonalStore\x12-\n\x0fgeneration_\
    time\x18\x01\x20\x01(\rR\x0egenerationTimeB\x04\x80\xa6\x1d\x01\x12-\n\
    \x12redeemable_balance\x18\x02\x20\x01(\rR\x11redeemableBalance\x12\x14\
    \n\x05items\x18\x03\x20\x03(\x04R\x05items\"\x80\x01\n\x10CSOQuestProgre\
    ss\x12\x1e\n\x07questid\x18\x01\x20\x01(\rR\x07questidB\x04\x80\xa6\x1d\
    \x01\x12)\n\x10points_remaining\x18\x02\x20\x01(\rR\x0fpointsRemaining\
    \x12!\n\x0cbonus_points\x18\x03\x20\x01(\rR\x0bbonusPoints\"\xb7\x02\n\
    \x1bCSOAccountSeasonalOperation\x12'\n\x0cseason_value\x18\x01\x20\x01(\
    \rR\x0bseasonValueB\x04\x80\xa6\x1d\x01\x12#\n\rtier_unlocked\x18\x02\
    \x20\x01(\rR\x0ctierUnlocked\x12#\n\rpremium_tiers\x18\x03\x20\x01(\rR\
    \x0cpremiumTiers\x12\x1d\n\nmission_id\x18\x04\x20\x01(\rR\tmissionId\
    \x12-\n\x12missions_completed\x18\x05\x20\x01(\rR\x11missionsCompleted\
    \x12-\n\x12redeemable_balance\x18\x06\x20\x01(\rR\x11redeemableBalance\
    \x12(\n\x10season_pass_time\x18\x07\x20\x01(\rR\x0eseasonPassTime\"p\n\
    \x1fCSOAccountRecurringSubscription\x12&\n\x0ftime_next_cycle\x18\x01\
    \x20\x01(\rR\rtimeNextCycle\x12%\n\x0etime_initiated\x18\x02\x20\x01(\rR\
    \rtimeInitiated\"\x9d\x01\n\x14CSOPersonaDataPublic\x12!\n\x0cplayer_lev\
    el\x18\x01\x20\x01(\x05R\x0bplayerLevel\x12;\n\x0ccommendation\x18\x02\
    \x20\x01(\x0b2\x17.PlayerCommendationInfoR\x0ccommendation\x12%\n\x0eele\
    vated_state\x18\x03\x20\x01(\x08R\relevatedState\"5\n\x1bCMsgGC_GlobalGa\
    me_Subscribe\x12\x16\n\x06ticket\x18\x01\x20\x01(\x04R\x06ticket\";\n\
    \x1dCMsgGC_GlobalGame_Unsubscribe\x12\x1a\n\x08timeleft\x18\x01\x20\x01(\
    \x05R\x08timeleft\"p\n\x16CMsgGC_GlobalGame_Play\x12\x16\n\x06ticket\x18\
    \x01\x20\x01(\x04R\x06ticket\x12\x1e\n\ngametimems\x18\x02\x20\x01(\rR\n\
    gametimems\x12\x1e\n\nmsperpoint\x18\x03\x20\x01(\rR\nmsperpoint\"K\n%CM\
    sgGCCStrike15_v2_AcknowledgePenalty\x12\"\n\x0cacknowledged\x18\x01\x20\
    \x01(\x05R\x0cacknowledged\"\xa5\x01\n/CMsgGCCStrike15_v2_Client2GCReque\
    stPrestigeCoin\x12\x1a\n\x08defindex\x18\x01\x20\x01(\rR\x08defindex\x12\
    \x1c\n\tupgradeid\x18\x02\x20\x01(\x04R\tupgradeid\x12\x14\n\x05hours\
    \x18\x03\x20\x01(\rR\x05hours\x12\"\n\x0cprestigetime\x18\x04\x20\x01(\r\
    R\x0cprestigetime\"R\n(CMsgGCCStrike15_v2_Client2GCStreamUnlock\x12\x16\
    \n\x06ticket\x18\x01\x20\x01(\x04R\x06ticket\x12\x0e\n\x02os\x18\x02\x20\
    \x01(\x05R\x02os\"C\n+CMsgGCCStrike15_v2_ClientToGCRequestElevate\x12\
    \x14\n\x05stage\x18\x01\x20\x01(\rR\x05stage\"R\n!CMsgGCCStrike15_v2_Cli\
    entToGCChat\x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\
    \x12\n\x04text\x18\x02\x20\x01(\tR\x04text\"V\n!CMsgGCCStrike15_v2_GCToC\
    lientChat\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x12\n\
    \x04text\x18\x02\x20\x01(\tR\x04text\"T\n$CMsgGCCStrike15_v2_ClientAuthK\
    eyCode\x12\x18\n\x07eventid\x18\x01\x20\x01(\rR\x07eventid\x12\x12\n\x04\
    code\x18\x02\x20\x01(\tR\x04code\"L\n\x1eCMsgGCCStrike15_GotvSyncPacket\
    \x12*\n\x04data\x18\x01\x20\x01(\x0b2\x16.CEngineGotvSyncPacketR\x04data\
    \"\x96\x03\n\x1bPlayerDecalDigitalSignature\x12\x1c\n\tsignature\x18\x01\
    \x20\x01(\x0cR\tsignature\x12\x1c\n\taccountid\x18\x02\x20\x01(\rR\tacco\
    untid\x12\x14\n\x05rtime\x18\x03\x20\x01(\rR\x05rtime\x12\x16\n\x06endpo\
    s\x18\x04\x20\x03(\x02R\x06endpos\x12\x1a\n\x08startpos\x18\x05\x20\x03(\
    \x02R\x08startpos\x12\x12\n\x04left\x18\x06\x20\x03(\x02R\x04left\x12\
    \x1b\n\ttx_defidx\x18\x07\x20\x01(\rR\x08txDefidx\x12\x1a\n\x08entindex\
    \x18\x08\x20\x01(\x05R\x08entindex\x12\x16\n\x06hitbox\x18\t\x20\x01(\rR\
    \x06hitbox\x12\"\n\x0ccreationtime\x18\n\x20\x01(\x02R\x0ccreationtime\
    \x12\x1c\n\tequipslot\x18\x0b\x20\x01(\rR\tequipslot\x12\x19\n\x08trace_\
    id\x18\x0c\x20\x01(\rR\x07traceId\x12\x16\n\x06normal\x18\r\x20\x03(\x02\
    R\x06normal\x12\x17\n\x07tint_id\x18\x0e\x20\x01(\rR\x06tintId\"t\n(CMsg\
    GCCStrike15_v2_ClientPlayerDecalSign\x120\n\x04data\x18\x01\x20\x01(\x0b\
    2\x1c.PlayerDecalDigitalSignatureR\x04data\x12\x16\n\x06itemid\x18\x02\
    \x20\x01(\x04R\x06itemid\"|\n(CMsgGCCStrike15_v2_ClientLogonFatalError\
    \x12\x1c\n\terrorcode\x18\x01\x20\x01(\rR\terrorcode\x12\x18\n\x07messag\
    e\x18\x02\x20\x01(\tR\x07message\x12\x18\n\x07country\x18\x03\x20\x01(\t\
    R\x07country\"j\n\"CMsgGCCStrike15_v2_ClientPollState\x12\x16\n\x06polli\
    d\x18\x01\x20\x01(\rR\x06pollid\x12\x14\n\x05names\x18\x02\x20\x03(\tR\
    \x05names\x12\x16\n\x06values\x18\x03\x20\x03(\x05R\x06values\"\xdc\x01\
    \n!CMsgGCCStrike15_v2_Party_Register\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\
    \x02id\x12\x10\n\x03ver\x18\x02\x20\x01(\rR\x03ver\x12\x10\n\x03apr\x18\
    \x03\x20\x01(\rR\x03apr\x12\x10\n\x03ark\x18\x04\x20\x01(\rR\x03ark\x12\
    \x10\n\x03nby\x18\x05\x20\x01(\rR\x03nby\x12\x10\n\x03grp\x18\x06\x20\
    \x01(\rR\x03grp\x12\x14\n\x05slots\x18\x07\x20\x01(\rR\x05slots\x12\x1a\
    \n\x08launcher\x18\x08\x20\x01(\rR\x08launcher\x12\x1b\n\tgame_type\x18\
    \t\x20\x01(\rR\x08gameType\"\xa4\x01\n\x1fCMsgGCCStrike15_v2_Party_Searc\
    h\x12\x10\n\x03ver\x18\x01\x20\x01(\rR\x03ver\x12\x10\n\x03apr\x18\x02\
    \x20\x01(\rR\x03apr\x12\x10\n\x03ark\x18\x03\x20\x01(\rR\x03ark\x12\x12\
    \n\x04grps\x18\x04\x20\x03(\rR\x04grps\x12\x1a\n\x08launcher\x18\x05\x20\
    \x01(\rR\x08launcher\x12\x1b\n\tgame_type\x18\x06\x20\x01(\rR\x08gameTyp\
    e\"\x8e\x02\n&CMsgGCCStrike15_v2_Party_SearchResults\x12G\n\x07entries\
    \x18\x01\x20\x03(\x0b2-.CMsgGCCStrike15_v2_Party_SearchResults.EntryR\
    \x07entries\x1a\x9a\x01\n\x05Entry\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\
    \x02id\x12\x10\n\x03grp\x18\x02\x20\x01(\rR\x03grp\x12\x1b\n\tgame_type\
    \x18\x03\x20\x01(\rR\x08gameType\x12\x10\n\x03apr\x18\x04\x20\x01(\rR\
    \x03apr\x12\x10\n\x03ark\x18\x05\x20\x01(\rR\x03ark\x12\x10\n\x03loc\x18\
    \x06\x20\x01(\rR\x03loc\x12\x1c\n\taccountid\x18\x07\x20\x01(\rR\taccoun\
    tid\"Y\n\x1fCMsgGCCStrike15_v2_Party_Invite\x12\x1c\n\taccountid\x18\x01\
    \x20\x01(\rR\taccountid\x12\x18\n\x07lobbyid\x18\x02\x20\x01(\rR\x07lobb\
    yid\"\xf4\x01\n)CMsgGCCStrike15_v2_Account_RequestCoPlays\x12K\n\x07play\
    ers\x18\x01\x20\x03(\x0b21.CMsgGCCStrike15_v2_Account_RequestCoPlays.Pla\
    yerR\x07players\x12\x1e\n\nservertime\x18\x02\x20\x01(\rR\nservertime\
    \x1aZ\n\x06Player\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\
    \x12\x1a\n\x08rtcoplay\x18\x02\x20\x01(\rR\x08rtcoplay\x12\x16\n\x06onli\
    ne\x18\x03\x20\x01(\x08R\x06online\"\xf4\x01\n*CMsgGCCStrike15_v2_Client\
    ToGCRequestTicket\x12.\n\x13authorized_steam_id\x18\x01\x20\x01(\x06R\
    \x11authorizedSteamId\x120\n\x14authorized_public_ip\x18\x02\x20\x01(\
    \x07R\x12authorizedPublicIp\x12.\n\x13gameserver_steam_id\x18\x03\x20\
    \x01(\x06R\x11gameserverSteamId\x124\n\x16gameserver_sdr_routing\x18\x05\
    \x20\x01(\tR\x14gameserverSdrRouting\"P\n!CMsgGCToClientSteamDatagramTic\
    ket\x12+\n\x11serialized_ticket\x18\x10\x20\x01(\x0cR\x10serializedTicke\
    t\"(\n&CMsgGCCStrike15_v2_ClientRequestOffers\"v\n(CMsgGCCStrike15_v2_Cl\
    ientRequestSouvenir\x12\x16\n\x06itemid\x18\x01\x20\x01(\x04R\x06itemid\
    \x12\x18\n\x07matchid\x18\x02\x20\x01(\x04R\x07matchid\x12\x18\n\x07even\
    tid\x18\x03\x20\x01(\x05R\x07eventid\"S\n'CMsgGCCStrike15_v2_ClientAccou\
    ntBalance\x12\x16\n\x06amount\x18\x01\x20\x01(\x04R\x06amount\x12\x10\n\
    \x03url\x18\x02\x20\x01(\tR\x03url\"a\n'CMsgGCCStrike15_v2_ClientPartyJo\
    inRelay\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x18\n\
    \x07lobbyid\x18\x02\x20\x01(\x04R\x07lobbyid\"\xb2\x01\n%CMsgGCCStrike15\
    _v2_ClientPartyWarning\x12F\n\x07entries\x18\x01\x20\x03(\x0b2,.CMsgGCCS\
    trike15_v2_ClientPartyWarning.EntryR\x07entries\x1aA\n\x05Entry\x12\x1c\
    \n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\x1a\n\x08warntype\x18\
    \x02\x20\x01(\rR\x08warntype\"`\n#CMsgGCCStrike15_v2_SetEventFavorite\
    \x12\x18\n\x07eventid\x18\x01\x20\x01(\x04R\x07eventid\x12\x1f\n\x0bis_f\
    avorite\x18\x02\x20\x01(\x08R\nisFavorite\"M\n,CMsgGCCStrike15_v2_GetEve\
    ntFavorites_Request\x12\x1d\n\nall_events\x18\x01\x20\x01(\x08R\tallEven\
    ts\"\x9a\x01\n-CMsgGCCStrike15_v2_GetEventFavorites_Response\x12\x1d\n\n\
    all_events\x18\x01\x20\x01(\x08R\tallEvents\x12%\n\x0ejson_favorites\x18\
    \x02\x20\x01(\tR\rjsonFavorites\x12#\n\rjson_featured\x18\x03\x20\x01(\t\
    R\x0cjsonFeatured\"\x99\x02\n#CMsgGCCStrike15_v2_ClientPerfReport\x12D\n\
    \x07entries\x18\x01\x20\x03(\x0b2*.CMsgGCCStrike15_v2_ClientPerfReport.E\
    ntryR\x07entries\x1a\xab\x01\n\x05Entry\x12\x20\n\x0bperfcounter\x18\x01\
    \x20\x01(\rR\x0bperfcounter\x12\x16\n\x06length\x18\x02\x20\x01(\rR\x06l\
    ength\x12\x1c\n\treference\x18\x03\x20\x01(\x0cR\treference\x12\x16\n\
    \x06actual\x18\x04\x20\x01(\x0cR\x06actual\x12\x1a\n\x08sourceid\x18\x05\
    \x20\x01(\rR\x08sourceid\x12\x16\n\x06status\x18\x06\x20\x01(\rR\x06stat\
    us\"s\n\x0cCVDiagnostic\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\
    \x1a\n\x08extended\x18\x02\x20\x01(\rR\x08extended\x12\x14\n\x05value\
    \x18\x03\x20\x01(\x04R\x05value\x12!\n\x0cstring_value\x18\x04\x20\x01(\
    \tR\x0bstringValue\"\xf9\x05\n)CMsgGCCStrike15_v2_ClientReportValidation\
    \x12\x1f\n\x0bfile_report\x18\x01\x20\x01(\tR\nfileReport\x12!\n\x0ccomm\
    and_line\x18\x02\x20\x01(\tR\x0bcommandLine\x12\x1f\n\x0btotal_files\x18\
    \x03\x20\x01(\rR\ntotalFiles\x12%\n\x0einternal_error\x18\x04\x20\x01(\r\
    R\rinternalError\x12\x1d\n\ntrust_time\x18\x05\x20\x01(\rR\ttrustTime\
    \x12#\n\rcount_pending\x18\x06\x20\x01(\rR\x0ccountPending\x12'\n\x0fcou\
    nt_completed\x18\x07\x20\x01(\rR\x0ecountCompleted\x12\x1d\n\nprocess_id\
    \x18\x08\x20\x01(\rR\tprocessId\x12\x1c\n\tosversion\x18\t\x20\x01(\x05R\
    \tosversion\x120\n\x13clientreportversion\x18\n\x20\x01(\rR\x13clientrep\
    ortversion\x12\x1b\n\tstatus_id\x18\x0b\x20\x01(\rR\x08statusId\x12\x20\
    \n\x0bdiagnostic1\x18\x0c\x20\x01(\rR\x0bdiagnostic1\x12\x20\n\x0bdiagno\
    stic2\x18\r\x20\x01(\x04R\x0bdiagnostic2\x12\x20\n\x0bdiagnostic3\x18\
    \x0e\x20\x01(\x04R\x0bdiagnostic3\x12(\n\x10last_launch_data\x18\x0f\x20\
    \x01(\tR\x0elastLaunchData\x12!\n\x0creport_count\x18\x10\x20\x01(\rR\
    \x0breportCount\x12\x1f\n\x0bclient_time\x18\x11\x20\x01(\x04R\nclientTi\
    me\x12\x20\n\x0bdiagnostic4\x18\x12\x20\x01(\x04R\x0bdiagnostic4\x12\x20\
    \n\x0bdiagnostic5\x18\x13\x20\x01(\x04R\x0bdiagnostic5\x12/\n\x0bdiagnos\
    tics\x18\x14\x20\x03(\x0b2\r.CVDiagnosticR\x0bdiagnostics\"\xc7\x03\n,CM\
    sgGCCStrike15_v2_GC2ClientRefuseSecureMode\x12\x1f\n\x0bfile_report\x18\
    \x01\x20\x01(\tR\nfileReport\x12.\n\x13offer_insecure_mode\x18\x02\x20\
    \x01(\x08R\x11offerInsecureMode\x12*\n\x11offer_secure_mode\x18\x03\x20\
    \x01(\x08R\x0fofferSecureMode\x12(\n\x10show_unsigned_ui\x18\x04\x20\x01\
    (\x08R\x0eshowUnsignedUi\x12\x1b\n\tkick_user\x18\x05\x20\x01(\x08R\x08k\
    ickUser\x12&\n\x0fshow_trusted_ui\x18\x06\x20\x01(\x08R\rshowTrustedUi\
    \x127\n\x18show_warning_not_trusted\x18\x07\x20\x01(\x08R\x15showWarning\
    NotTrusted\x12:\n\x1ashow_warning_not_trusted_2\x18\x08\x20\x01(\x08R\
    \x16showWarningNotTrusted2\x126\n\x17files_prevented_trusted\x18\t\x20\
    \x01(\tR\x15filesPreventedTrusted\"h\n-CMsgGCCStrike15_v2_GC2ClientReque\
    stValidation\x12\x1f\n\x0bfull_report\x18\x01\x20\x01(\x08R\nfullReport\
    \x12\x16\n\x06module\x18\x02\x20\x01(\tR\x06module\"\xa2\x02\n&CMsgGCCSt\
    rike15_v2_GC2ClientInitSystem\x12\x12\n\x04load\x18\x01\x20\x01(\x08R\
    \x04load\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1e\n\noutput\
    name\x18\x03\x20\x01(\tR\noutputname\x12\x19\n\x08key_data\x18\x04\x20\
    \x01(\x0cR\x07keyData\x12\x19\n\x08sha_hash\x18\x05\x20\x01(\x0cR\x07sha\
    Hash\x12\x16\n\x06cookie\x18\x06\x20\x01(\x05R\x06cookie\x12\x1a\n\x08ma\
    nifest\x18\x07\x20\x01(\tR\x08manifest\x12%\n\x0esystem_package\x18\x08\
    \x20\x01(\x0cR\rsystemPackage\x12\x1f\n\x0bload_system\x18\t\x20\x01(\
    \x08R\nloadSystem\"\x92\x03\n/CMsgGCCStrike15_v2_GC2ClientInitSystem_Res\
    ponse\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success\x12\x1e\n\nd\
    iagnostic\x18\x02\x20\x01(\tR\ndiagnostic\x12\x19\n\x08sha_hash\x18\x03\
    \x20\x01(\x0cR\x07shaHash\x12\x1a\n\x08response\x18\x04\x20\x01(\x05R\
    \x08response\x12\x1f\n\x0berror_code1\x18\x05\x20\x01(\x05R\nerrorCode1\
    \x12\x1f\n\x0berror_code2\x18\x06\x20\x01(\x05R\nerrorCode2\x12\x16\n\
    \x06handle\x18\x07\x20\x01(\x03R\x06handle\x12R\n\x0ceinit_result\x18\
    \x08\x20\x01(\x0e2\x12.EInitSystemResult:\x1bk_EInitSystemResult_Invalid\
    R\x0beinitResult\x12\x1f\n\x0baux_system1\x18\t\x20\x01(\x05R\nauxSystem\
    1\x12\x1f\n\x0baux_system2\x18\n\x20\x01(\x05R\nauxSystem2\"e\n/CMsgGCCS\
    trike15_v2_SetPlayerLeaderboardSafeName\x122\n\x15leaderboard_safe_name\
    \x18\x01\x20\x01(\tR\x13leaderboardSafeName*\xb3'\n\nECsgoGCMsg\x12\x1e\
    \n\x19k_EMsgGCCStrike15_v2_Base\x10\x8cG\x12*\n%k_EMsgGCCStrike15_v2_Mat\
    chmakingStart\x10\x8dG\x12)\n$k_EMsgGCCStrike15_v2_MatchmakingStop\x10\
    \x8eG\x126\n1k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing\x10\x8fG\
    \x124\n/k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\x10\x90G\x12>\n9\
    k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse\x10\x92G\x125\
    \n0k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\x10\x93G\x123\n.k_EM\
    sgGCCStrike15_v2_MatchmakingClient2GCHello\x10\x95G\x123\n.k_EMsgGCCStri\
    ke15_v2_MatchmakingGC2ClientHello\x10\x96G\x125\n0k_EMsgGCCStrike15_v2_M\
    atchmakingGC2ClientAbandon\x10\x98G\x12:\n5k_EMsgGCCStrike15_v2_Matchmak\
    ingOperator2GCBlogUpdate\x10\x9dG\x12:\n5k_EMsgGCCStrike15_v2_ServerNoti\
    ficationForUserPenalty\x10\x9eG\x12,\n'k_EMsgGCCStrike15_v2_ClientReport\
    Player\x10\x9fG\x12,\n'k_EMsgGCCStrike15_v2_ClientReportServer\x10\xa0G\
    \x12-\n(k_EMsgGCCStrike15_v2_ClientCommendPlayer\x10\xa1G\x12.\n)k_EMsgG\
    CCStrike15_v2_ClientReportResponse\x10\xa2G\x122\n-k_EMsgGCCStrike15_v2_\
    ClientCommendPlayerQuery\x10\xa3G\x12:\n5k_EMsgGCCStrike15_v2_ClientComm\
    endPlayerQueryResponse\x10\xa4G\x12(\n#k_EMsgGCCStrike15_v2_WatchInfoUse\
    rs\x10\xa6G\x125\n0k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile\x10\
    \xa7G\x12(\n#k_EMsgGCCStrike15_v2_PlayersProfile\x10\xa8G\x123\n.k_EMsgG\
    CCStrike15_v2_PlayerOverwatchCaseUpdate\x10\xabG\x127\n2k_EMsgGCCStrike1\
    5_v2_PlayerOverwatchCaseAssignment\x10\xacG\x123\n.k_EMsgGCCStrike15_v2_\
    PlayerOverwatchCaseStatus\x10\xadG\x12*\n%k_EMsgGCCStrike15_v2_GC2Client\
    TextMsg\x10\xaeG\x12*\n%k_EMsgGCCStrike15_v2_Client2GCTextMsg\x10\xafG\
    \x120\n+k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops\x10\xb0G\x129\n4k_EM\
    sgGCCStrike15_v2_MatchEndRewardDropsNotification\x10\xb1G\x128\n3k_EMsgG\
    CCStrike15_v2_ClientRequestWatchInfoFriends2\x10\xb2G\x12#\n\x1ek_EMsgGC\
    CStrike15_v2_MatchList\x10\xb3G\x12:\n5k_EMsgGCCStrike15_v2_MatchListReq\
    uestCurrentLiveGames\x10\xb4G\x129\n4k_EMsgGCCStrike15_v2_MatchListReque\
    stRecentUserGames\x10\xb5G\x124\n/k_EMsgGCCStrike15_v2_GC2ServerReservat\
    ionUpdate\x10\xb6G\x128\n3k_EMsgGCCStrike15_v2_ClientVarValueNotificatio\
    nInfo\x10\xb8G\x129\n4k_EMsgGCCStrike15_v2_MatchListRequestTournamentGam\
    es\x10\xbaG\x126\n1k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo\x10\
    \xbbG\x121\n,k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest\x10\xbcG\x122\
    \n-k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse\x10\xbdG\x128\n3k_EMsgG\
    CCStrike15_v2_ServerVarValueNotificationInfo\x10\xbeG\x120\n+k_EMsgGCCSt\
    rike15_v2_ClientSubmitSurveyVote\x10\xc0G\x121\n,k_EMsgGCCStrike15_v2_Se\
    rver2GCClientValidate\x10\xc1G\x129\n4k_EMsgGCCStrike15_v2_MatchListRequ\
    estLiveGameForUser\x10\xc2G\x12>\n9k_EMsgGCCStrike15_v2_Client2GCEconPre\
    viewDataBlockRequest\x10\xc4G\x12?\n:k_EMsgGCCStrike15_v2_Client2GCEconP\
    reviewDataBlockResponse\x10\xc5G\x120\n+k_EMsgGCCStrike15_v2_AccountPriv\
    acySettings\x10\xc6G\x12+\n&k_EMsgGCCStrike15_v2_SetMyActivityInfo\x10\
    \xc7G\x12?\n:k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions\
    \x10\xc8G\x12>\n9k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictio\
    ns\x10\xc9G\x12&\n!k_EMsgGCCStrike15_v2_DraftSummary\x10\xcaG\x125\n0k_E\
    MsgGCCStrike15_v2_ClientRequestJoinFriendData\x10\xcbG\x125\n0k_EMsgGCCS\
    trike15_v2_ClientRequestJoinServerData\x10\xccG\x121\n,k_EMsgGCCStrike15\
    _v2_ClientRequestNewMission\x10\xcdG\x121\n,k_EMsgGCCStrike15_v2_GC2Clie\
    ntTournamentInfo\x10\xcfG\x12\"\n\x1dk_EMsgGC_GlobalGame_Subscribe\x10\
    \xd0G\x12$\n\x1fk_EMsgGC_GlobalGame_Unsubscribe\x10\xd1G\x12\x1d\n\x18k_\
    EMsgGC_GlobalGame_Play\x10\xd2G\x12,\n'k_EMsgGCCStrike15_v2_AcknowledgeP\
    enalty\x10\xd3G\x126\n1k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\
    \x10\xd4G\x12.\n)k_EMsgGCCStrike15_v2_GC2ClientGlobalStats\x10\xd5G\x12/\
    \n*k_EMsgGCCStrike15_v2_Client2GCStreamUnlock\x10\xd6G\x122\n-k_EMsgGCCS\
    trike15_v2_FantasyRequestClientData\x10\xd7G\x121\n,k_EMsgGCCStrike15_v2\
    _FantasyUpdateClientData\x10\xd8G\x127\n2k_EMsgGCCStrike15_v2_GCToClient\
    SteamdatagramTicket\x10\xd9G\x121\n,k_EMsgGCCStrike15_v2_ClientToGCReque\
    stTicket\x10\xdaG\x122\n-k_EMsgGCCStrike15_v2_ClientToGCRequestElevate\
    \x10\xdbG\x12$\n\x1fk_EMsgGCCStrike15_v2_GlobalChat\x10\xdcG\x12.\n)k_EM\
    sgGCCStrike15_v2_GlobalChat_Subscribe\x10\xddG\x120\n+k_EMsgGCCStrike15_\
    v2_GlobalChat_Unsubscribe\x10\xdeG\x12+\n&k_EMsgGCCStrike15_v2_ClientAut\
    hKeyCode\x10\xdfG\x12(\n#k_EMsgGCCStrike15_v2_GotvSyncPacket\x10\xe0G\
    \x12/\n*k_EMsgGCCStrike15_v2_ClientPlayerDecalSign\x10\xe1G\x12/\n*k_EMs\
    gGCCStrike15_v2_ClientLogonFatalError\x10\xe3G\x12)\n$k_EMsgGCCStrike15_\
    v2_ClientPollState\x10\xe4G\x12(\n#k_EMsgGCCStrike15_v2_Party_Register\
    \x10\xe5G\x12*\n%k_EMsgGCCStrike15_v2_Party_Unregister\x10\xe6G\x12&\n!k\
    _EMsgGCCStrike15_v2_Party_Search\x10\xe7G\x12&\n!k_EMsgGCCStrike15_v2_Pa\
    rty_Invite\x10\xe8G\x120\n+k_EMsgGCCStrike15_v2_Account_RequestCoPlays\
    \x10\xe9G\x12,\n'k_EMsgGCCStrike15_v2_ClientGCRankUpdate\x10\xeaG\x12-\n\
    (k_EMsgGCCStrike15_v2_ClientRequestOffers\x10\xebG\x12.\n)k_EMsgGCCStrik\
    e15_v2_ClientAccountBalance\x10\xecG\x12.\n)k_EMsgGCCStrike15_v2_ClientP\
    artyJoinRelay\x10\xedG\x12,\n'k_EMsgGCCStrike15_v2_ClientPartyWarning\
    \x10\xeeG\x12*\n%k_EMsgGCCStrike15_v2_SetEventFavorite\x10\xf0G\x123\n.k\
    _EMsgGCCStrike15_v2_GetEventFavorites_Request\x10\xf1G\x12*\n%k_EMsgGCCS\
    trike15_v2_ClientPerfReport\x10\xf2G\x124\n/k_EMsgGCCStrike15_v2_GetEven\
    tFavorites_Response\x10\xf3G\x12/\n*k_EMsgGCCStrike15_v2_ClientRequestSo\
    uvenir\x10\xf4G\x120\n+k_EMsgGCCStrike15_v2_ClientReportValidation\x10\
    \xf5G\x123\n.k_EMsgGCCStrike15_v2_GC2ClientRefuseSecureMode\x10\xf6G\x12\
    4\n/k_EMsgGCCStrike15_v2_GC2ClientRequestValidation\x10\xf7G\x123\n.k_EM\
    sgGCCStrike15_v2_ClientRedeemMissionReward\x10\xf9G\x12&\n!k_EMsgGCCStri\
    ke15_ClientDeepStats\x10\xfaG\x122\n-k_EMsgGCCStrike15_StartAgreementSes\
    sionInGame\x10\xfbG\x12-\n(k_EMsgGCCStrike15_v2_GC2ClientInitSystem\x10\
    \xfcG\x126\n1k_EMsgGCCStrike15_v2_GC2ClientInitSystem_Response\x10\xfdG\
    \x12'\n\"k_EMsgGCCStrike15_v2_PrivateQueues\x10\xfeG\x129\n4k_EMsgGCCStr\
    ike15_v2_MatchListTournamentOperatorMgmt\x10\xffG\x126\n1k_EMsgGCCStrike\
    15_v2_SetPlayerLeaderboardSafeName\x10\x82H\x120\n+k_EMsgGCCStrike15_v2_\
    ClientRedeemFreeReward\x10\x83H*\x98\x01\n\x12ECsgoSteamUserStat\x12&\n\
    \"k_ECsgoSteamUserStat_XpEarnedGames\x10\x01\x12-\n)k_ECsgoSteamUserStat\
    _MatchWinsCompetitive\x10\x02\x12+\n'k_ECsgoSteamUserStat_SurvivedDanger\
    Zone\x10\x03*\xa1\x01\n\x17EClientReportingVersion\x12(\n$k_EClientRepor\
    tingVersion_OldVersion\x10\0\x12)\n%k_EClientReportingVersion_BetaVersio\
    n\x10\x01\x121\n-k_EClientReportingVersion_SupportsTrustedMode\x10\x02*\
    \xbe\x02\n\x11EInitSystemResult\x12\x1f\n\x1bk_EInitSystemResult_Invalid\
    \x10\0\x12\x1f\n\x1bk_EInitSystemResult_Success\x10\x01\x12\x1c\n\x18k_E\
    InitSystemResult_None\x10\x02\x12\x20\n\x1ck_EInitSystemResult_NotFound\
    \x10\x03\x12\x20\n\x1ck_EInitSystemResult_Existing\x10\x04\x12\"\n\x1ek_\
    EInitSystemResult_FailedOpen\x10\x05\x12\x20\n\x1ck_EInitSystemResult_Mi\
    smatch\x10\x06\x12\"\n\x1ek_EInitSystemResult_FailedInit\x10\x07\x12\x1b\
    \n\x17k_EInitSystemResult_Max\x10\x08\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::steammessages::file_descriptor().clone());
            deps.push(super::engine_gcmessages::file_descriptor().clone());
            deps.push(super::gcsdk_gcmessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(161);
            messages.push(GameServerPing::generated_message_descriptor_data());
            messages.push(DataCenterPing::generated_message_descriptor_data());
            messages.push(DetailedSearchStatistic::generated_message_descriptor_data());
            messages.push(TournamentPlayer::generated_message_descriptor_data());
            messages.push(TournamentTeam::generated_message_descriptor_data());
            messages.push(TournamentEvent::generated_message_descriptor_data());
            messages.push(GlobalStatistics::generated_message_descriptor_data());
            messages.push(OperationalStatisticDescription::generated_message_descriptor_data());
            messages.push(OperationalStatisticElement::generated_message_descriptor_data());
            messages.push(OperationalStatisticsPacket::generated_message_descriptor_data());
            messages.push(OperationalVarValue::generated_message_descriptor_data());
            messages.push(PlayerRankingInfo::generated_message_descriptor_data());
            messages.push(PlayerCommendationInfo::generated_message_descriptor_data());
            messages.push(PlayerMedalsInfo::generated_message_descriptor_data());
            messages.push(AccountActivity::generated_message_descriptor_data());
            messages.push(TournamentMatchSetup::generated_message_descriptor_data());
            messages.push(ServerHltvInfo::generated_message_descriptor_data());
            messages.push(IpAddressMask::generated_message_descriptor_data());
            messages.push(CMsgCsgoSteamUserStatChange::generated_message_descriptor_data());
            messages.push(XpProgressData::generated_message_descriptor_data());
            messages.push(MatchEndItemUpdates::generated_message_descriptor_data());
            messages.push(ScoreLeaderboardData::generated_message_descriptor_data());
            messages.push(PlayerQuestData::generated_message_descriptor_data());
            messages.push(DeepPlayerStatsEntry::generated_message_descriptor_data());
            messages.push(DeepPlayerMatchEvent::generated_message_descriptor_data());
            messages.push(CMsgGC_ServerQuestUpdateData::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GC2ServerReservationUpdate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingStart::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingStop::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate_Note::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_TournamentMatchDraft::generated_message_descriptor_data());
            messages.push(CPreMatchInfoData::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingServerRoundStats::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingClient2GCHello::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_AccountPrivacySettings::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientGCRankUpdate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientReportPlayer::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientCommendPlayer::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientReportServer::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientReportResponse::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::generated_message_descriptor_data());
            messages.push(WatchableMatchInfo::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientRequestJoinFriendData::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientRequestJoinServerData::generated_message_descriptor_data());
            messages.push(CMsgGCCstrike15_v2_ClientRequestNewMission::generated_message_descriptor_data());
            messages.push(CMsgGCCstrike15_v2_ClientRedeemMissionReward::generated_message_descriptor_data());
            messages.push(CMsgGCCstrike15_v2_ClientRedeemFreeReward::generated_message_descriptor_data());
            messages.push(CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_ClientDeepStats::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_WatchInfoUsers::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientRequestPlayersProfile::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_PlayersProfile::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::generated_message_descriptor_data());
            messages.push(CClientHeaderOverwatchEvidence::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GC2ClientTextMsg::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Client2GCTextMsg::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchEndRunRewardDrops::generated_message_descriptor_data());
            messages.push(CEconItemPreviewDataBlock::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchEndRewardDropsNotification::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListRequestRecentUserGames::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListRequestTournamentGames::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_MatchInfo::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_TournamentGroupTeam::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_TournamentGroup::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_TournamentSection::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_TournamentInfo::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchList::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListTournamentOperatorMgmt::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Predictions::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Fantasy::generated_message_descriptor_data());
            messages.push(CMsgLegacySource1ClientWelcome::generated_message_descriptor_data());
            messages.push(CMsgCStrike15Welcome::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GiftsLeaderboardRequest::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GiftsLeaderboardResponse::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientSubmitSurveyVote::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Server2GCClientValidate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GC2ClientTournamentInfo::generated_message_descriptor_data());
            messages.push(CSOEconCoupon::generated_message_descriptor_data());
            messages.push(CSOAccountItemPersonalStore::generated_message_descriptor_data());
            messages.push(CSOQuestProgress::generated_message_descriptor_data());
            messages.push(CSOAccountSeasonalOperation::generated_message_descriptor_data());
            messages.push(CSOAccountRecurringSubscription::generated_message_descriptor_data());
            messages.push(CSOPersonaDataPublic::generated_message_descriptor_data());
            messages.push(CMsgGC_GlobalGame_Subscribe::generated_message_descriptor_data());
            messages.push(CMsgGC_GlobalGame_Unsubscribe::generated_message_descriptor_data());
            messages.push(CMsgGC_GlobalGame_Play::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_AcknowledgePenalty::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Client2GCStreamUnlock::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientToGCRequestElevate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientToGCChat::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GCToClientChat::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientAuthKeyCode::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_GotvSyncPacket::generated_message_descriptor_data());
            messages.push(PlayerDecalDigitalSignature::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientPlayerDecalSign::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientLogonFatalError::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientPollState::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Party_Register::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Party_Search::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Party_SearchResults::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Party_Invite::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Account_RequestCoPlays::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientToGCRequestTicket::generated_message_descriptor_data());
            messages.push(CMsgGCToClientSteamDatagramTicket::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientRequestOffers::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientRequestSouvenir::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientAccountBalance::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientPartyJoinRelay::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientPartyWarning::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_SetEventFavorite::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GetEventFavorites_Request::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GetEventFavorites_Response::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientPerfReport::generated_message_descriptor_data());
            messages.push(CVDiagnostic::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientReportValidation::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GC2ClientRefuseSecureMode::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GC2ClientRequestValidation::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GC2ClientInitSystem::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GC2ClientInitSystem_Response::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_SetPlayerLeaderboardSafeName::generated_message_descriptor_data());
            messages.push(player_ranking_info::PerMapRank::generated_message_descriptor_data());
            messages.push(score_leaderboard_data::Entry::generated_message_descriptor_data());
            messages.push(score_leaderboard_data::AccountEntries::generated_message_descriptor_data());
            messages.push(player_quest_data::QuestItemData::generated_message_descriptor_data());
            messages.push(cdata_gccstrike15_v2_tournament_match_draft::Entry::generated_message_descriptor_data());
            messages.push(cpre_match_info_data::TeamStats::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_matchmaking_server_round_stats::DropInfo::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_account_privacy_settings::Setting::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_client_deep_stats::DeepStatsRange::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_client_deep_stats::DeepStatsMatch::generated_message_descriptor_data());
            messages.push(cecon_item_preview_data_block::Sticker::generated_message_descriptor_data());
            messages.push(cdata_gccstrike15_v2_tournament_group::Picks::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_predictions::GroupMatchTeamPick::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_fantasy::FantasySlot::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_fantasy::FantasyTeam::generated_message_descriptor_data());
            messages.push(cmsg_legacy_source1client_welcome::Location::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_gifts_leaderboard_response::GiftLeaderboardEntry::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_party_search_results::Entry::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_account_request_co_plays::Player::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_client_party_warning::Entry::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_client_perf_report::Entry::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(ECsgoGCMsg::generated_enum_descriptor_data());
            enums.push(ECsgoSteamUserStat::generated_enum_descriptor_data());
            enums.push(EClientReportingVersion::generated_enum_descriptor_data());
            enums.push(EInitSystemResult::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
