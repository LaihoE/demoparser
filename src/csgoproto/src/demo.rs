// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.1
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `demo.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CDemoFileHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoFileHeader {
    // message fields
    // @@protoc_insertion_point(field:CDemoFileHeader.demo_file_stamp)
    pub demo_file_stamp: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDemoFileHeader.network_protocol)
    pub network_protocol: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDemoFileHeader.server_name)
    pub server_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDemoFileHeader.client_name)
    pub client_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDemoFileHeader.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDemoFileHeader.game_directory)
    pub game_directory: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDemoFileHeader.fullpackets_version)
    pub fullpackets_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDemoFileHeader.allow_clientside_entities)
    pub allow_clientside_entities: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDemoFileHeader.allow_clientside_particles)
    pub allow_clientside_particles: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CDemoFileHeader.addons)
    pub addons: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDemoFileHeader.demo_version_name)
    pub demo_version_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDemoFileHeader.demo_version_guid)
    pub demo_version_guid: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDemoFileHeader.build_num)
    pub build_num: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDemoFileHeader.game)
    pub game: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoFileHeader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoFileHeader {
    fn default() -> &'a CDemoFileHeader {
        <CDemoFileHeader as ::protobuf::Message>::default_instance()
    }
}

impl CDemoFileHeader {
    pub fn new() -> CDemoFileHeader {
        ::std::default::Default::default()
    }

    // required string demo_file_stamp = 1;

    pub fn demo_file_stamp(&self) -> &str {
        match self.demo_file_stamp.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_demo_file_stamp(&mut self) {
        self.demo_file_stamp = ::std::option::Option::None;
    }

    pub fn has_demo_file_stamp(&self) -> bool {
        self.demo_file_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo_file_stamp(&mut self, v: ::std::string::String) {
        self.demo_file_stamp = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_demo_file_stamp(&mut self) -> &mut ::std::string::String {
        if self.demo_file_stamp.is_none() {
            self.demo_file_stamp = ::std::option::Option::Some(::std::string::String::new());
        }
        self.demo_file_stamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_demo_file_stamp(&mut self) -> ::std::string::String {
        self.demo_file_stamp.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 network_protocol = 2;

    pub fn network_protocol(&self) -> i32 {
        self.network_protocol.unwrap_or(0)
    }

    pub fn clear_network_protocol(&mut self) {
        self.network_protocol = ::std::option::Option::None;
    }

    pub fn has_network_protocol(&self) -> bool {
        self.network_protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_protocol(&mut self, v: i32) {
        self.network_protocol = ::std::option::Option::Some(v);
    }

    // optional string server_name = 3;

    pub fn server_name(&self) -> &str {
        match self.server_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_name(&mut self) {
        self.server_name = ::std::option::Option::None;
    }

    pub fn has_server_name(&self) -> bool {
        self.server_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_name(&mut self, v: ::std::string::String) {
        self.server_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_name(&mut self) -> &mut ::std::string::String {
        if self.server_name.is_none() {
            self.server_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_name(&mut self) -> ::std::string::String {
        self.server_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string client_name = 4;

    pub fn client_name(&self) -> &str {
        match self.client_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_client_name(&mut self) {
        self.client_name = ::std::option::Option::None;
    }

    pub fn has_client_name(&self) -> bool {
        self.client_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_name(&mut self, v: ::std::string::String) {
        self.client_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_name(&mut self) -> &mut ::std::string::String {
        if self.client_name.is_none() {
            self.client_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.client_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_name(&mut self) -> ::std::string::String {
        self.client_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map_name = 5;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_directory = 6;

    pub fn game_directory(&self) -> &str {
        match self.game_directory.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_directory(&mut self) {
        self.game_directory = ::std::option::Option::None;
    }

    pub fn has_game_directory(&self) -> bool {
        self.game_directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_directory(&mut self, v: ::std::string::String) {
        self.game_directory = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_directory(&mut self) -> &mut ::std::string::String {
        if self.game_directory.is_none() {
            self.game_directory = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_directory.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_directory(&mut self) -> ::std::string::String {
        self.game_directory.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 fullpackets_version = 7;

    pub fn fullpackets_version(&self) -> i32 {
        self.fullpackets_version.unwrap_or(0)
    }

    pub fn clear_fullpackets_version(&mut self) {
        self.fullpackets_version = ::std::option::Option::None;
    }

    pub fn has_fullpackets_version(&self) -> bool {
        self.fullpackets_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullpackets_version(&mut self, v: i32) {
        self.fullpackets_version = ::std::option::Option::Some(v);
    }

    // optional bool allow_clientside_entities = 8;

    pub fn allow_clientside_entities(&self) -> bool {
        self.allow_clientside_entities.unwrap_or(false)
    }

    pub fn clear_allow_clientside_entities(&mut self) {
        self.allow_clientside_entities = ::std::option::Option::None;
    }

    pub fn has_allow_clientside_entities(&self) -> bool {
        self.allow_clientside_entities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_clientside_entities(&mut self, v: bool) {
        self.allow_clientside_entities = ::std::option::Option::Some(v);
    }

    // optional bool allow_clientside_particles = 9;

    pub fn allow_clientside_particles(&self) -> bool {
        self.allow_clientside_particles.unwrap_or(false)
    }

    pub fn clear_allow_clientside_particles(&mut self) {
        self.allow_clientside_particles = ::std::option::Option::None;
    }

    pub fn has_allow_clientside_particles(&self) -> bool {
        self.allow_clientside_particles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_clientside_particles(&mut self, v: bool) {
        self.allow_clientside_particles = ::std::option::Option::Some(v);
    }

    // optional string addons = 10;

    pub fn addons(&self) -> &str {
        match self.addons.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_addons(&mut self) {
        self.addons = ::std::option::Option::None;
    }

    pub fn has_addons(&self) -> bool {
        self.addons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addons(&mut self, v: ::std::string::String) {
        self.addons = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addons(&mut self) -> &mut ::std::string::String {
        if self.addons.is_none() {
            self.addons = ::std::option::Option::Some(::std::string::String::new());
        }
        self.addons.as_mut().unwrap()
    }

    // Take field
    pub fn take_addons(&mut self) -> ::std::string::String {
        self.addons.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string demo_version_name = 11;

    pub fn demo_version_name(&self) -> &str {
        match self.demo_version_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_demo_version_name(&mut self) {
        self.demo_version_name = ::std::option::Option::None;
    }

    pub fn has_demo_version_name(&self) -> bool {
        self.demo_version_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo_version_name(&mut self, v: ::std::string::String) {
        self.demo_version_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_demo_version_name(&mut self) -> &mut ::std::string::String {
        if self.demo_version_name.is_none() {
            self.demo_version_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.demo_version_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_demo_version_name(&mut self) -> ::std::string::String {
        self.demo_version_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string demo_version_guid = 12;

    pub fn demo_version_guid(&self) -> &str {
        match self.demo_version_guid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_demo_version_guid(&mut self) {
        self.demo_version_guid = ::std::option::Option::None;
    }

    pub fn has_demo_version_guid(&self) -> bool {
        self.demo_version_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo_version_guid(&mut self, v: ::std::string::String) {
        self.demo_version_guid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_demo_version_guid(&mut self) -> &mut ::std::string::String {
        if self.demo_version_guid.is_none() {
            self.demo_version_guid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.demo_version_guid.as_mut().unwrap()
    }

    // Take field
    pub fn take_demo_version_guid(&mut self) -> ::std::string::String {
        self.demo_version_guid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 build_num = 13;

    pub fn build_num(&self) -> i32 {
        self.build_num.unwrap_or(0)
    }

    pub fn clear_build_num(&mut self) {
        self.build_num = ::std::option::Option::None;
    }

    pub fn has_build_num(&self) -> bool {
        self.build_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_num(&mut self, v: i32) {
        self.build_num = ::std::option::Option::Some(v);
    }

    // optional string game = 14;

    pub fn game(&self) -> &str {
        match self.game.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game(&mut self) {
        self.game = ::std::option::Option::None;
    }

    pub fn has_game(&self) -> bool {
        self.game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game(&mut self, v: ::std::string::String) {
        self.game = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game(&mut self) -> &mut ::std::string::String {
        if self.game.is_none() {
            self.game = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game.as_mut().unwrap()
    }

    // Take field
    pub fn take_game(&mut self) -> ::std::string::String {
        self.game.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "demo_file_stamp",
            |m: &CDemoFileHeader| { &m.demo_file_stamp },
            |m: &mut CDemoFileHeader| { &mut m.demo_file_stamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_protocol",
            |m: &CDemoFileHeader| { &m.network_protocol },
            |m: &mut CDemoFileHeader| { &mut m.network_protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_name",
            |m: &CDemoFileHeader| { &m.server_name },
            |m: &mut CDemoFileHeader| { &mut m.server_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_name",
            |m: &CDemoFileHeader| { &m.client_name },
            |m: &mut CDemoFileHeader| { &mut m.client_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &CDemoFileHeader| { &m.map_name },
            |m: &mut CDemoFileHeader| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_directory",
            |m: &CDemoFileHeader| { &m.game_directory },
            |m: &mut CDemoFileHeader| { &mut m.game_directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fullpackets_version",
            |m: &CDemoFileHeader| { &m.fullpackets_version },
            |m: &mut CDemoFileHeader| { &mut m.fullpackets_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_clientside_entities",
            |m: &CDemoFileHeader| { &m.allow_clientside_entities },
            |m: &mut CDemoFileHeader| { &mut m.allow_clientside_entities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_clientside_particles",
            |m: &CDemoFileHeader| { &m.allow_clientside_particles },
            |m: &mut CDemoFileHeader| { &mut m.allow_clientside_particles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "addons",
            |m: &CDemoFileHeader| { &m.addons },
            |m: &mut CDemoFileHeader| { &mut m.addons },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "demo_version_name",
            |m: &CDemoFileHeader| { &m.demo_version_name },
            |m: &mut CDemoFileHeader| { &mut m.demo_version_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "demo_version_guid",
            |m: &CDemoFileHeader| { &m.demo_version_guid },
            |m: &mut CDemoFileHeader| { &mut m.demo_version_guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "build_num",
            |m: &CDemoFileHeader| { &m.build_num },
            |m: &mut CDemoFileHeader| { &mut m.build_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game",
            |m: &CDemoFileHeader| { &m.game },
            |m: &mut CDemoFileHeader| { &mut m.game },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoFileHeader>(
            "CDemoFileHeader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoFileHeader {
    const NAME: &'static str = "CDemoFileHeader";

    fn is_initialized(&self) -> bool {
        if self.demo_file_stamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.demo_file_stamp = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.network_protocol = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.server_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.client_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.game_directory = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.fullpackets_version = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.allow_clientside_entities = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.allow_clientside_particles = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    self.addons = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.demo_version_name = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.demo_version_guid = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.build_num = ::std::option::Option::Some(is.read_int32()?);
                },
                114 => {
                    self.game = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.demo_file_stamp.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.network_protocol {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.server_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.client_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.game_directory.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.fullpackets_version {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.allow_clientside_entities {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_clientside_particles {
            my_size += 1 + 1;
        }
        if let Some(v) = self.addons.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.demo_version_name.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.demo_version_guid.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.build_num {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.game.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.demo_file_stamp.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.network_protocol {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.server_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.client_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.game_directory.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.fullpackets_version {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.allow_clientside_entities {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.allow_clientside_particles {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.addons.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.demo_version_name.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.demo_version_guid.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.build_num {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.game.as_ref() {
            os.write_string(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoFileHeader {
        CDemoFileHeader::new()
    }

    fn clear(&mut self) {
        self.demo_file_stamp = ::std::option::Option::None;
        self.network_protocol = ::std::option::Option::None;
        self.server_name = ::std::option::Option::None;
        self.client_name = ::std::option::Option::None;
        self.map_name = ::std::option::Option::None;
        self.game_directory = ::std::option::Option::None;
        self.fullpackets_version = ::std::option::Option::None;
        self.allow_clientside_entities = ::std::option::Option::None;
        self.allow_clientside_particles = ::std::option::Option::None;
        self.addons = ::std::option::Option::None;
        self.demo_version_name = ::std::option::Option::None;
        self.demo_version_guid = ::std::option::Option::None;
        self.build_num = ::std::option::Option::None;
        self.game = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoFileHeader {
        static instance: CDemoFileHeader = CDemoFileHeader {
            demo_file_stamp: ::std::option::Option::None,
            network_protocol: ::std::option::Option::None,
            server_name: ::std::option::Option::None,
            client_name: ::std::option::Option::None,
            map_name: ::std::option::Option::None,
            game_directory: ::std::option::Option::None,
            fullpackets_version: ::std::option::Option::None,
            allow_clientside_entities: ::std::option::Option::None,
            allow_clientside_particles: ::std::option::Option::None,
            addons: ::std::option::Option::None,
            demo_version_name: ::std::option::Option::None,
            demo_version_guid: ::std::option::Option::None,
            build_num: ::std::option::Option::None,
            game: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoFileHeader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoFileHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoFileHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoFileHeader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameInfo {
    // message fields
    // @@protoc_insertion_point(field:CGameInfo.dota)
    pub dota: ::protobuf::MessageField<cgame_info::CDotaGameInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameInfo {
    fn default() -> &'a CGameInfo {
        <CGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl CGameInfo {
    pub fn new() -> CGameInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cgame_info::CDotaGameInfo>(
            "dota",
            |m: &CGameInfo| { &m.dota },
            |m: &mut CGameInfo| { &mut m.dota },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CGameInfo>(
            "CGameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CGameInfo {
    const NAME: &'static str = "CGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.dota)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dota.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dota.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameInfo {
        CGameInfo::new()
    }

    fn clear(&mut self) {
        self.dota.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameInfo {
        static instance: CGameInfo = CGameInfo {
            dota: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CGameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CGameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CGameInfo`
pub mod cgame_info {
    // @@protoc_insertion_point(message:CGameInfo.CDotaGameInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CDotaGameInfo {
        // message fields
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.game_mode)
        pub game_mode: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.game_winner)
        pub game_winner: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.player_info)
        pub player_info: ::std::vec::Vec<cdota_game_info::CPlayerInfo>,
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.leagueid)
        pub leagueid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.picks_bans)
        pub picks_bans: ::std::vec::Vec<cdota_game_info::CHeroSelectEvent>,
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.radiant_team_id)
        pub radiant_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.dire_team_id)
        pub dire_team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.radiant_team_tag)
        pub radiant_team_tag: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.dire_team_tag)
        pub dire_team_tag: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.end_time)
        pub end_time: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CGameInfo.CDotaGameInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CDotaGameInfo {
        fn default() -> &'a CDotaGameInfo {
            <CDotaGameInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl CDotaGameInfo {
        pub fn new() -> CDotaGameInfo {
            ::std::default::Default::default()
        }

        // optional uint64 match_id = 1;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional int32 game_mode = 2;

        pub fn game_mode(&self) -> i32 {
            self.game_mode.unwrap_or(0)
        }

        pub fn clear_game_mode(&mut self) {
            self.game_mode = ::std::option::Option::None;
        }

        pub fn has_game_mode(&self) -> bool {
            self.game_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_mode(&mut self, v: i32) {
            self.game_mode = ::std::option::Option::Some(v);
        }

        // optional int32 game_winner = 3;

        pub fn game_winner(&self) -> i32 {
            self.game_winner.unwrap_or(0)
        }

        pub fn clear_game_winner(&mut self) {
            self.game_winner = ::std::option::Option::None;
        }

        pub fn has_game_winner(&self) -> bool {
            self.game_winner.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_winner(&mut self, v: i32) {
            self.game_winner = ::std::option::Option::Some(v);
        }

        // optional uint32 leagueid = 5;

        pub fn leagueid(&self) -> u32 {
            self.leagueid.unwrap_or(0)
        }

        pub fn clear_leagueid(&mut self) {
            self.leagueid = ::std::option::Option::None;
        }

        pub fn has_leagueid(&self) -> bool {
            self.leagueid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leagueid(&mut self, v: u32) {
            self.leagueid = ::std::option::Option::Some(v);
        }

        // optional uint32 radiant_team_id = 7;

        pub fn radiant_team_id(&self) -> u32 {
            self.radiant_team_id.unwrap_or(0)
        }

        pub fn clear_radiant_team_id(&mut self) {
            self.radiant_team_id = ::std::option::Option::None;
        }

        pub fn has_radiant_team_id(&self) -> bool {
            self.radiant_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_id(&mut self, v: u32) {
            self.radiant_team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 dire_team_id = 8;

        pub fn dire_team_id(&self) -> u32 {
            self.dire_team_id.unwrap_or(0)
        }

        pub fn clear_dire_team_id(&mut self) {
            self.dire_team_id = ::std::option::Option::None;
        }

        pub fn has_dire_team_id(&self) -> bool {
            self.dire_team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_id(&mut self, v: u32) {
            self.dire_team_id = ::std::option::Option::Some(v);
        }

        // optional string radiant_team_tag = 9;

        pub fn radiant_team_tag(&self) -> &str {
            match self.radiant_team_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_radiant_team_tag(&mut self) {
            self.radiant_team_tag = ::std::option::Option::None;
        }

        pub fn has_radiant_team_tag(&self) -> bool {
            self.radiant_team_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_radiant_team_tag(&mut self, v: ::std::string::String) {
            self.radiant_team_tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_radiant_team_tag(&mut self) -> &mut ::std::string::String {
            if self.radiant_team_tag.is_none() {
                self.radiant_team_tag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.radiant_team_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_radiant_team_tag(&mut self) -> ::std::string::String {
            self.radiant_team_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string dire_team_tag = 10;

        pub fn dire_team_tag(&self) -> &str {
            match self.dire_team_tag.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dire_team_tag(&mut self) {
            self.dire_team_tag = ::std::option::Option::None;
        }

        pub fn has_dire_team_tag(&self) -> bool {
            self.dire_team_tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dire_team_tag(&mut self, v: ::std::string::String) {
            self.dire_team_tag = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dire_team_tag(&mut self) -> &mut ::std::string::String {
            if self.dire_team_tag.is_none() {
                self.dire_team_tag = ::std::option::Option::Some(::std::string::String::new());
            }
            self.dire_team_tag.as_mut().unwrap()
        }

        // Take field
        pub fn take_dire_team_tag(&mut self) -> ::std::string::String {
            self.dire_team_tag.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 end_time = 11;

        pub fn end_time(&self) -> u32 {
            self.end_time.unwrap_or(0)
        }

        pub fn clear_end_time(&mut self) {
            self.end_time = ::std::option::Option::None;
        }

        pub fn has_end_time(&self) -> bool {
            self.end_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end_time(&mut self, v: u32) {
            self.end_time = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_id",
                |m: &CDotaGameInfo| { &m.match_id },
                |m: &mut CDotaGameInfo| { &mut m.match_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_mode",
                |m: &CDotaGameInfo| { &m.game_mode },
                |m: &mut CDotaGameInfo| { &mut m.game_mode },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_winner",
                |m: &CDotaGameInfo| { &m.game_winner },
                |m: &mut CDotaGameInfo| { &mut m.game_winner },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "player_info",
                |m: &CDotaGameInfo| { &m.player_info },
                |m: &mut CDotaGameInfo| { &mut m.player_info },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "leagueid",
                |m: &CDotaGameInfo| { &m.leagueid },
                |m: &mut CDotaGameInfo| { &mut m.leagueid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "picks_bans",
                |m: &CDotaGameInfo| { &m.picks_bans },
                |m: &mut CDotaGameInfo| { &mut m.picks_bans },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "radiant_team_id",
                |m: &CDotaGameInfo| { &m.radiant_team_id },
                |m: &mut CDotaGameInfo| { &mut m.radiant_team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dire_team_id",
                |m: &CDotaGameInfo| { &m.dire_team_id },
                |m: &mut CDotaGameInfo| { &mut m.dire_team_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "radiant_team_tag",
                |m: &CDotaGameInfo| { &m.radiant_team_tag },
                |m: &mut CDotaGameInfo| { &mut m.radiant_team_tag },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dire_team_tag",
                |m: &CDotaGameInfo| { &m.dire_team_tag },
                |m: &mut CDotaGameInfo| { &mut m.dire_team_tag },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "end_time",
                |m: &CDotaGameInfo| { &m.end_time },
                |m: &mut CDotaGameInfo| { &mut m.end_time },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDotaGameInfo>(
                "CGameInfo.CDotaGameInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CDotaGameInfo {
        const NAME: &'static str = "CDotaGameInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.game_mode = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.game_winner = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.player_info.push(is.read_message()?);
                    },
                    40 => {
                        self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    50 => {
                        self.picks_bans.push(is.read_message()?);
                    },
                    56 => {
                        self.radiant_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.dire_team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    74 => {
                        self.radiant_team_tag = ::std::option::Option::Some(is.read_string()?);
                    },
                    82 => {
                        self.dire_team_tag = ::std::option::Option::Some(is.read_string()?);
                    },
                    88 => {
                        self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.game_mode {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.game_winner {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            for value in &self.player_info {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.leagueid {
                my_size += ::protobuf::rt::uint32_size(5, v);
            }
            for value in &self.picks_bans {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.radiant_team_id {
                my_size += ::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.dire_team_id {
                my_size += ::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.radiant_team_tag.as_ref() {
                my_size += ::protobuf::rt::string_size(9, &v);
            }
            if let Some(v) = self.dire_team_tag.as_ref() {
                my_size += ::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.end_time {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.game_mode {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.game_winner {
                os.write_int32(3, v)?;
            }
            for v in &self.player_info {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            if let Some(v) = self.leagueid {
                os.write_uint32(5, v)?;
            }
            for v in &self.picks_bans {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.radiant_team_id {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.dire_team_id {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.radiant_team_tag.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.dire_team_tag.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.end_time {
                os.write_uint32(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CDotaGameInfo {
            CDotaGameInfo::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.game_mode = ::std::option::Option::None;
            self.game_winner = ::std::option::Option::None;
            self.player_info.clear();
            self.leagueid = ::std::option::Option::None;
            self.picks_bans.clear();
            self.radiant_team_id = ::std::option::Option::None;
            self.dire_team_id = ::std::option::Option::None;
            self.radiant_team_tag = ::std::option::Option::None;
            self.dire_team_tag = ::std::option::Option::None;
            self.end_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CDotaGameInfo {
            static instance: CDotaGameInfo = CDotaGameInfo {
                match_id: ::std::option::Option::None,
                game_mode: ::std::option::Option::None,
                game_winner: ::std::option::Option::None,
                player_info: ::std::vec::Vec::new(),
                leagueid: ::std::option::Option::None,
                picks_bans: ::std::vec::Vec::new(),
                radiant_team_id: ::std::option::Option::None,
                dire_team_id: ::std::option::Option::None,
                radiant_team_tag: ::std::option::Option::None,
                dire_team_tag: ::std::option::Option::None,
                end_time: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CDotaGameInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CGameInfo.CDotaGameInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CDotaGameInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CDotaGameInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `CDotaGameInfo`
    pub mod cdota_game_info {
        // @@protoc_insertion_point(message:CGameInfo.CDotaGameInfo.CPlayerInfo)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CPlayerInfo {
            // message fields
            // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.CPlayerInfo.hero_name)
            pub hero_name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.CPlayerInfo.player_name)
            pub player_name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.CPlayerInfo.is_fake_client)
            pub is_fake_client: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.CPlayerInfo.steamid)
            pub steamid: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.CPlayerInfo.game_team)
            pub game_team: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CGameInfo.CDotaGameInfo.CPlayerInfo.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CPlayerInfo {
            fn default() -> &'a CPlayerInfo {
                <CPlayerInfo as ::protobuf::Message>::default_instance()
            }
        }

        impl CPlayerInfo {
            pub fn new() -> CPlayerInfo {
                ::std::default::Default::default()
            }

            // optional string hero_name = 1;

            pub fn hero_name(&self) -> &str {
                match self.hero_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_hero_name(&mut self) {
                self.hero_name = ::std::option::Option::None;
            }

            pub fn has_hero_name(&self) -> bool {
                self.hero_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_name(&mut self, v: ::std::string::String) {
                self.hero_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
                if self.hero_name.is_none() {
                    self.hero_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.hero_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_hero_name(&mut self) -> ::std::string::String {
                self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string player_name = 2;

            pub fn player_name(&self) -> &str {
                match self.player_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_player_name(&mut self) {
                self.player_name = ::std::option::Option::None;
            }

            pub fn has_player_name(&self) -> bool {
                self.player_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_name(&mut self, v: ::std::string::String) {
                self.player_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
                if self.player_name.is_none() {
                    self.player_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.player_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_player_name(&mut self) -> ::std::string::String {
                self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional bool is_fake_client = 3;

            pub fn is_fake_client(&self) -> bool {
                self.is_fake_client.unwrap_or(false)
            }

            pub fn clear_is_fake_client(&mut self) {
                self.is_fake_client = ::std::option::Option::None;
            }

            pub fn has_is_fake_client(&self) -> bool {
                self.is_fake_client.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_fake_client(&mut self, v: bool) {
                self.is_fake_client = ::std::option::Option::Some(v);
            }

            // optional uint64 steamid = 4;

            pub fn steamid(&self) -> u64 {
                self.steamid.unwrap_or(0)
            }

            pub fn clear_steamid(&mut self) {
                self.steamid = ::std::option::Option::None;
            }

            pub fn has_steamid(&self) -> bool {
                self.steamid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_steamid(&mut self, v: u64) {
                self.steamid = ::std::option::Option::Some(v);
            }

            // optional int32 game_team = 5;

            pub fn game_team(&self) -> i32 {
                self.game_team.unwrap_or(0)
            }

            pub fn clear_game_team(&mut self) {
                self.game_team = ::std::option::Option::None;
            }

            pub fn has_game_team(&self) -> bool {
                self.game_team.is_some()
            }

            // Param is passed by value, moved
            pub fn set_game_team(&mut self, v: i32) {
                self.game_team = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_name",
                    |m: &CPlayerInfo| { &m.hero_name },
                    |m: &mut CPlayerInfo| { &mut m.hero_name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "player_name",
                    |m: &CPlayerInfo| { &m.player_name },
                    |m: &mut CPlayerInfo| { &mut m.player_name },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "is_fake_client",
                    |m: &CPlayerInfo| { &m.is_fake_client },
                    |m: &mut CPlayerInfo| { &mut m.is_fake_client },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "steamid",
                    |m: &CPlayerInfo| { &m.steamid },
                    |m: &mut CPlayerInfo| { &mut m.steamid },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "game_team",
                    |m: &CPlayerInfo| { &m.game_team },
                    |m: &mut CPlayerInfo| { &mut m.game_team },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CPlayerInfo>(
                    "CGameInfo.CDotaGameInfo.CPlayerInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CPlayerInfo {
            const NAME: &'static str = "CPlayerInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.hero_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.player_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        24 => {
                            self.is_fake_client = ::std::option::Option::Some(is.read_bool()?);
                        },
                        32 => {
                            self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        40 => {
                            self.game_team = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.hero_name.as_ref() {
                    my_size += ::protobuf::rt::string_size(1, &v);
                }
                if let Some(v) = self.player_name.as_ref() {
                    my_size += ::protobuf::rt::string_size(2, &v);
                }
                if let Some(v) = self.is_fake_client {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.steamid {
                    my_size += ::protobuf::rt::uint64_size(4, v);
                }
                if let Some(v) = self.game_team {
                    my_size += ::protobuf::rt::int32_size(5, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.hero_name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.player_name.as_ref() {
                    os.write_string(2, v)?;
                }
                if let Some(v) = self.is_fake_client {
                    os.write_bool(3, v)?;
                }
                if let Some(v) = self.steamid {
                    os.write_uint64(4, v)?;
                }
                if let Some(v) = self.game_team {
                    os.write_int32(5, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CPlayerInfo {
                CPlayerInfo::new()
            }

            fn clear(&mut self) {
                self.hero_name = ::std::option::Option::None;
                self.player_name = ::std::option::Option::None;
                self.is_fake_client = ::std::option::Option::None;
                self.steamid = ::std::option::Option::None;
                self.game_team = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CPlayerInfo {
                static instance: CPlayerInfo = CPlayerInfo {
                    hero_name: ::std::option::Option::None,
                    player_name: ::std::option::Option::None,
                    is_fake_client: ::std::option::Option::None,
                    steamid: ::std::option::Option::None,
                    game_team: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for CPlayerInfo {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CGameInfo.CDotaGameInfo.CPlayerInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CPlayerInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CPlayerInfo {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:CGameInfo.CDotaGameInfo.CHeroSelectEvent)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CHeroSelectEvent {
            // message fields
            // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.CHeroSelectEvent.is_pick)
            pub is_pick: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.CHeroSelectEvent.team)
            pub team: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CGameInfo.CDotaGameInfo.CHeroSelectEvent.hero_id)
            pub hero_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CGameInfo.CDotaGameInfo.CHeroSelectEvent.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CHeroSelectEvent {
            fn default() -> &'a CHeroSelectEvent {
                <CHeroSelectEvent as ::protobuf::Message>::default_instance()
            }
        }

        impl CHeroSelectEvent {
            pub fn new() -> CHeroSelectEvent {
                ::std::default::Default::default()
            }

            // optional bool is_pick = 1;

            pub fn is_pick(&self) -> bool {
                self.is_pick.unwrap_or(false)
            }

            pub fn clear_is_pick(&mut self) {
                self.is_pick = ::std::option::Option::None;
            }

            pub fn has_is_pick(&self) -> bool {
                self.is_pick.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_pick(&mut self, v: bool) {
                self.is_pick = ::std::option::Option::Some(v);
            }

            // optional uint32 team = 2;

            pub fn team(&self) -> u32 {
                self.team.unwrap_or(0)
            }

            pub fn clear_team(&mut self) {
                self.team = ::std::option::Option::None;
            }

            pub fn has_team(&self) -> bool {
                self.team.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team(&mut self, v: u32) {
                self.team = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_id = 3;

            pub fn hero_id(&self) -> u32 {
                self.hero_id.unwrap_or(0)
            }

            pub fn clear_hero_id(&mut self) {
                self.hero_id = ::std::option::Option::None;
            }

            pub fn has_hero_id(&self) -> bool {
                self.hero_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_id(&mut self, v: u32) {
                self.hero_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "is_pick",
                    |m: &CHeroSelectEvent| { &m.is_pick },
                    |m: &mut CHeroSelectEvent| { &mut m.is_pick },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team",
                    |m: &CHeroSelectEvent| { &m.team },
                    |m: &mut CHeroSelectEvent| { &mut m.team },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "hero_id",
                    |m: &CHeroSelectEvent| { &m.hero_id },
                    |m: &mut CHeroSelectEvent| { &mut m.hero_id },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CHeroSelectEvent>(
                    "CGameInfo.CDotaGameInfo.CHeroSelectEvent",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for CHeroSelectEvent {
            const NAME: &'static str = "CHeroSelectEvent";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.is_pick = ::std::option::Option::Some(is.read_bool()?);
                        },
                        16 => {
                            self.team = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        24 => {
                            self.hero_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.is_pick {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.team {
                    my_size += ::protobuf::rt::uint32_size(2, v);
                }
                if let Some(v) = self.hero_id {
                    my_size += ::protobuf::rt::uint32_size(3, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.is_pick {
                    os.write_bool(1, v)?;
                }
                if let Some(v) = self.team {
                    os.write_uint32(2, v)?;
                }
                if let Some(v) = self.hero_id {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CHeroSelectEvent {
                CHeroSelectEvent::new()
            }

            fn clear(&mut self) {
                self.is_pick = ::std::option::Option::None;
                self.team = ::std::option::Option::None;
                self.hero_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CHeroSelectEvent {
                static instance: CHeroSelectEvent = CHeroSelectEvent {
                    is_pick: ::std::option::Option::None,
                    team: ::std::option::Option::None,
                    hero_id: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for CHeroSelectEvent {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CGameInfo.CDotaGameInfo.CHeroSelectEvent").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CHeroSelectEvent {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for CHeroSelectEvent {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CDemoFileInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoFileInfo {
    // message fields
    // @@protoc_insertion_point(field:CDemoFileInfo.playback_time)
    pub playback_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CDemoFileInfo.playback_ticks)
    pub playback_ticks: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDemoFileInfo.playback_frames)
    pub playback_frames: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDemoFileInfo.game_info)
    pub game_info: ::protobuf::MessageField<CGameInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoFileInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoFileInfo {
    fn default() -> &'a CDemoFileInfo {
        <CDemoFileInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDemoFileInfo {
    pub fn new() -> CDemoFileInfo {
        ::std::default::Default::default()
    }

    // optional float playback_time = 1;

    pub fn playback_time(&self) -> f32 {
        self.playback_time.unwrap_or(0.)
    }

    pub fn clear_playback_time(&mut self) {
        self.playback_time = ::std::option::Option::None;
    }

    pub fn has_playback_time(&self) -> bool {
        self.playback_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playback_time(&mut self, v: f32) {
        self.playback_time = ::std::option::Option::Some(v);
    }

    // optional int32 playback_ticks = 2;

    pub fn playback_ticks(&self) -> i32 {
        self.playback_ticks.unwrap_or(0)
    }

    pub fn clear_playback_ticks(&mut self) {
        self.playback_ticks = ::std::option::Option::None;
    }

    pub fn has_playback_ticks(&self) -> bool {
        self.playback_ticks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playback_ticks(&mut self, v: i32) {
        self.playback_ticks = ::std::option::Option::Some(v);
    }

    // optional int32 playback_frames = 3;

    pub fn playback_frames(&self) -> i32 {
        self.playback_frames.unwrap_or(0)
    }

    pub fn clear_playback_frames(&mut self) {
        self.playback_frames = ::std::option::Option::None;
    }

    pub fn has_playback_frames(&self) -> bool {
        self.playback_frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playback_frames(&mut self, v: i32) {
        self.playback_frames = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playback_time",
            |m: &CDemoFileInfo| { &m.playback_time },
            |m: &mut CDemoFileInfo| { &mut m.playback_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playback_ticks",
            |m: &CDemoFileInfo| { &m.playback_ticks },
            |m: &mut CDemoFileInfo| { &mut m.playback_ticks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playback_frames",
            |m: &CDemoFileInfo| { &m.playback_frames },
            |m: &mut CDemoFileInfo| { &mut m.playback_frames },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CGameInfo>(
            "game_info",
            |m: &CDemoFileInfo| { &m.game_info },
            |m: &mut CDemoFileInfo| { &mut m.game_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoFileInfo>(
            "CDemoFileInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoFileInfo {
    const NAME: &'static str = "CDemoFileInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.playback_time = ::std::option::Option::Some(is.read_float()?);
                },
                16 => {
                    self.playback_ticks = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.playback_frames = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.game_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playback_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.playback_ticks {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.playback_frames {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.game_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.playback_time {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.playback_ticks {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.playback_frames {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.game_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoFileInfo {
        CDemoFileInfo::new()
    }

    fn clear(&mut self) {
        self.playback_time = ::std::option::Option::None;
        self.playback_ticks = ::std::option::Option::None;
        self.playback_frames = ::std::option::Option::None;
        self.game_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoFileInfo {
        static instance: CDemoFileInfo = CDemoFileInfo {
            playback_time: ::std::option::Option::None,
            playback_ticks: ::std::option::Option::None,
            playback_frames: ::std::option::Option::None,
            game_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoFileInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoFileInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoFileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoFileInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoPacket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoPacket {
    // message fields
    // @@protoc_insertion_point(field:CDemoPacket.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoPacket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoPacket {
    fn default() -> &'a CDemoPacket {
        <CDemoPacket as ::protobuf::Message>::default_instance()
    }
}

impl CDemoPacket {
    pub fn new() -> CDemoPacket {
        ::std::default::Default::default()
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CDemoPacket| { &m.data },
            |m: &mut CDemoPacket| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoPacket>(
            "CDemoPacket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoPacket {
    const NAME: &'static str = "CDemoPacket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoPacket {
        CDemoPacket::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoPacket {
        static instance: CDemoPacket = CDemoPacket {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoPacket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoPacket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoPacket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoFullPacket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoFullPacket {
    // message fields
    // @@protoc_insertion_point(field:CDemoFullPacket.string_table)
    pub string_table: ::protobuf::MessageField<CDemoStringTables>,
    // @@protoc_insertion_point(field:CDemoFullPacket.packet)
    pub packet: ::protobuf::MessageField<CDemoPacket>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoFullPacket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoFullPacket {
    fn default() -> &'a CDemoFullPacket {
        <CDemoFullPacket as ::protobuf::Message>::default_instance()
    }
}

impl CDemoFullPacket {
    pub fn new() -> CDemoFullPacket {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDemoStringTables>(
            "string_table",
            |m: &CDemoFullPacket| { &m.string_table },
            |m: &mut CDemoFullPacket| { &mut m.string_table },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDemoPacket>(
            "packet",
            |m: &CDemoFullPacket| { &m.packet },
            |m: &mut CDemoFullPacket| { &mut m.packet },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoFullPacket>(
            "CDemoFullPacket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoFullPacket {
    const NAME: &'static str = "CDemoFullPacket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.string_table)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.packet)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.string_table.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.packet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.string_table.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.packet.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoFullPacket {
        CDemoFullPacket::new()
    }

    fn clear(&mut self) {
        self.string_table.clear();
        self.packet.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoFullPacket {
        static instance: CDemoFullPacket = CDemoFullPacket {
            string_table: ::protobuf::MessageField::none(),
            packet: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoFullPacket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoFullPacket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoFullPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoFullPacket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoSaveGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoSaveGame {
    // message fields
    // @@protoc_insertion_point(field:CDemoSaveGame.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CDemoSaveGame.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDemoSaveGame.signature)
    pub signature: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDemoSaveGame.version)
    pub version: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoSaveGame.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoSaveGame {
    fn default() -> &'a CDemoSaveGame {
        <CDemoSaveGame as ::protobuf::Message>::default_instance()
    }
}

impl CDemoSaveGame {
    pub fn new() -> CDemoSaveGame {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 steam_id = 2;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 signature = 3;

    pub fn signature(&self) -> u64 {
        self.signature.unwrap_or(0)
    }

    pub fn clear_signature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signature(&self) -> bool {
        self.signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: u64) {
        self.signature = ::std::option::Option::Some(v);
    }

    // optional int32 version = 4;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CDemoSaveGame| { &m.data },
            |m: &mut CDemoSaveGame| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_id",
            |m: &CDemoSaveGame| { &m.steam_id },
            |m: &mut CDemoSaveGame| { &mut m.steam_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signature",
            |m: &CDemoSaveGame| { &m.signature },
            |m: &mut CDemoSaveGame| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CDemoSaveGame| { &m.version },
            |m: &mut CDemoSaveGame| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoSaveGame>(
            "CDemoSaveGame",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoSaveGame {
    const NAME: &'static str = "CDemoSaveGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                17 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.signature = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.signature {
            my_size += 1 + 8;
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.signature {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoSaveGame {
        CDemoSaveGame::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.steam_id = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoSaveGame {
        static instance: CDemoSaveGame = CDemoSaveGame {
            data: ::std::option::Option::None,
            steam_id: ::std::option::Option::None,
            signature: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoSaveGame {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoSaveGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoSaveGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoSaveGame {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoSyncTick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoSyncTick {
    // special fields
    // @@protoc_insertion_point(special_field:CDemoSyncTick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoSyncTick {
    fn default() -> &'a CDemoSyncTick {
        <CDemoSyncTick as ::protobuf::Message>::default_instance()
    }
}

impl CDemoSyncTick {
    pub fn new() -> CDemoSyncTick {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoSyncTick>(
            "CDemoSyncTick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoSyncTick {
    const NAME: &'static str = "CDemoSyncTick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoSyncTick {
        CDemoSyncTick::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoSyncTick {
        static instance: CDemoSyncTick = CDemoSyncTick {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoSyncTick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoSyncTick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoSyncTick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoSyncTick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoConsoleCmd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoConsoleCmd {
    // message fields
    // @@protoc_insertion_point(field:CDemoConsoleCmd.cmdstring)
    pub cmdstring: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoConsoleCmd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoConsoleCmd {
    fn default() -> &'a CDemoConsoleCmd {
        <CDemoConsoleCmd as ::protobuf::Message>::default_instance()
    }
}

impl CDemoConsoleCmd {
    pub fn new() -> CDemoConsoleCmd {
        ::std::default::Default::default()
    }

    // optional string cmdstring = 1;

    pub fn cmdstring(&self) -> &str {
        match self.cmdstring.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cmdstring(&mut self) {
        self.cmdstring = ::std::option::Option::None;
    }

    pub fn has_cmdstring(&self) -> bool {
        self.cmdstring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmdstring(&mut self, v: ::std::string::String) {
        self.cmdstring = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmdstring(&mut self) -> &mut ::std::string::String {
        if self.cmdstring.is_none() {
            self.cmdstring = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cmdstring.as_mut().unwrap()
    }

    // Take field
    pub fn take_cmdstring(&mut self) -> ::std::string::String {
        self.cmdstring.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmdstring",
            |m: &CDemoConsoleCmd| { &m.cmdstring },
            |m: &mut CDemoConsoleCmd| { &mut m.cmdstring },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoConsoleCmd>(
            "CDemoConsoleCmd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoConsoleCmd {
    const NAME: &'static str = "CDemoConsoleCmd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cmdstring = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cmdstring.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cmdstring.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoConsoleCmd {
        CDemoConsoleCmd::new()
    }

    fn clear(&mut self) {
        self.cmdstring = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoConsoleCmd {
        static instance: CDemoConsoleCmd = CDemoConsoleCmd {
            cmdstring: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoConsoleCmd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoConsoleCmd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoConsoleCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoConsoleCmd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoSendTables)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoSendTables {
    // message fields
    // @@protoc_insertion_point(field:CDemoSendTables.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoSendTables.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoSendTables {
    fn default() -> &'a CDemoSendTables {
        <CDemoSendTables as ::protobuf::Message>::default_instance()
    }
}

impl CDemoSendTables {
    pub fn new() -> CDemoSendTables {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CDemoSendTables| { &m.data },
            |m: &mut CDemoSendTables| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoSendTables>(
            "CDemoSendTables",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoSendTables {
    const NAME: &'static str = "CDemoSendTables";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoSendTables {
        CDemoSendTables::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoSendTables {
        static instance: CDemoSendTables = CDemoSendTables {
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoSendTables {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoSendTables").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoSendTables {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoSendTables {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoClassInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoClassInfo {
    // message fields
    // @@protoc_insertion_point(field:CDemoClassInfo.classes)
    pub classes: ::std::vec::Vec<cdemo_class_info::Class_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoClassInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoClassInfo {
    fn default() -> &'a CDemoClassInfo {
        <CDemoClassInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDemoClassInfo {
    pub fn new() -> CDemoClassInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "classes",
            |m: &CDemoClassInfo| { &m.classes },
            |m: &mut CDemoClassInfo| { &mut m.classes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoClassInfo>(
            "CDemoClassInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoClassInfo {
    const NAME: &'static str = "CDemoClassInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.classes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.classes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.classes {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoClassInfo {
        CDemoClassInfo::new()
    }

    fn clear(&mut self) {
        self.classes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoClassInfo {
        static instance: CDemoClassInfo = CDemoClassInfo {
            classes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoClassInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoClassInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoClassInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoClassInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDemoClassInfo`
pub mod cdemo_class_info {
    // @@protoc_insertion_point(message:CDemoClassInfo.class_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Class_t {
        // message fields
        // @@protoc_insertion_point(field:CDemoClassInfo.class_t.class_id)
        pub class_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDemoClassInfo.class_t.network_name)
        pub network_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CDemoClassInfo.class_t.table_name)
        pub table_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CDemoClassInfo.class_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Class_t {
        fn default() -> &'a Class_t {
            <Class_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Class_t {
        pub fn new() -> Class_t {
            ::std::default::Default::default()
        }

        // optional int32 class_id = 1;

        pub fn class_id(&self) -> i32 {
            self.class_id.unwrap_or(0)
        }

        pub fn clear_class_id(&mut self) {
            self.class_id = ::std::option::Option::None;
        }

        pub fn has_class_id(&self) -> bool {
            self.class_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_id(&mut self, v: i32) {
            self.class_id = ::std::option::Option::Some(v);
        }

        // optional string network_name = 2;

        pub fn network_name(&self) -> &str {
            match self.network_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_network_name(&mut self) {
            self.network_name = ::std::option::Option::None;
        }

        pub fn has_network_name(&self) -> bool {
            self.network_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_network_name(&mut self, v: ::std::string::String) {
            self.network_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_network_name(&mut self) -> &mut ::std::string::String {
            if self.network_name.is_none() {
                self.network_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.network_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_network_name(&mut self) -> ::std::string::String {
            self.network_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string table_name = 3;

        pub fn table_name(&self) -> &str {
            match self.table_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_table_name(&mut self) {
            self.table_name = ::std::option::Option::None;
        }

        pub fn has_table_name(&self) -> bool {
            self.table_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_table_name(&mut self, v: ::std::string::String) {
            self.table_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
            if self.table_name.is_none() {
                self.table_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.table_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_table_name(&mut self) -> ::std::string::String {
            self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "class_id",
                |m: &Class_t| { &m.class_id },
                |m: &mut Class_t| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "network_name",
                |m: &Class_t| { &m.network_name },
                |m: &mut Class_t| { &mut m.network_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "table_name",
                |m: &Class_t| { &m.table_name },
                |m: &mut Class_t| { &mut m.table_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Class_t>(
                "CDemoClassInfo.class_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Class_t {
        const NAME: &'static str = "class_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.class_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.network_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.table_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.class_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.network_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.table_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.class_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.network_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.table_name.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Class_t {
            Class_t::new()
        }

        fn clear(&mut self) {
            self.class_id = ::std::option::Option::None;
            self.network_name = ::std::option::Option::None;
            self.table_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Class_t {
            static instance: Class_t = Class_t {
                class_id: ::std::option::Option::None,
                network_name: ::std::option::Option::None,
                table_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Class_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDemoClassInfo.class_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Class_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Class_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CDemoCustomData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoCustomData {
    // message fields
    // @@protoc_insertion_point(field:CDemoCustomData.callback_index)
    pub callback_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDemoCustomData.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoCustomData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoCustomData {
    fn default() -> &'a CDemoCustomData {
        <CDemoCustomData as ::protobuf::Message>::default_instance()
    }
}

impl CDemoCustomData {
    pub fn new() -> CDemoCustomData {
        ::std::default::Default::default()
    }

    // optional int32 callback_index = 1;

    pub fn callback_index(&self) -> i32 {
        self.callback_index.unwrap_or(0)
    }

    pub fn clear_callback_index(&mut self) {
        self.callback_index = ::std::option::Option::None;
    }

    pub fn has_callback_index(&self) -> bool {
        self.callback_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_callback_index(&mut self, v: i32) {
        self.callback_index = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "callback_index",
            |m: &CDemoCustomData| { &m.callback_index },
            |m: &mut CDemoCustomData| { &mut m.callback_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CDemoCustomData| { &m.data },
            |m: &mut CDemoCustomData| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoCustomData>(
            "CDemoCustomData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoCustomData {
    const NAME: &'static str = "CDemoCustomData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.callback_index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.callback_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.callback_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoCustomData {
        CDemoCustomData::new()
    }

    fn clear(&mut self) {
        self.callback_index = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoCustomData {
        static instance: CDemoCustomData = CDemoCustomData {
            callback_index: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoCustomData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoCustomData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoCustomData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoCustomData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoCustomDataCallbacks)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoCustomDataCallbacks {
    // message fields
    // @@protoc_insertion_point(field:CDemoCustomDataCallbacks.save_id)
    pub save_id: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoCustomDataCallbacks.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoCustomDataCallbacks {
    fn default() -> &'a CDemoCustomDataCallbacks {
        <CDemoCustomDataCallbacks as ::protobuf::Message>::default_instance()
    }
}

impl CDemoCustomDataCallbacks {
    pub fn new() -> CDemoCustomDataCallbacks {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "save_id",
            |m: &CDemoCustomDataCallbacks| { &m.save_id },
            |m: &mut CDemoCustomDataCallbacks| { &mut m.save_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoCustomDataCallbacks>(
            "CDemoCustomDataCallbacks",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoCustomDataCallbacks {
    const NAME: &'static str = "CDemoCustomDataCallbacks";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.save_id.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.save_id {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.save_id {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoCustomDataCallbacks {
        CDemoCustomDataCallbacks::new()
    }

    fn clear(&mut self) {
        self.save_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoCustomDataCallbacks {
        static instance: CDemoCustomDataCallbacks = CDemoCustomDataCallbacks {
            save_id: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoCustomDataCallbacks {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoCustomDataCallbacks").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoCustomDataCallbacks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoCustomDataCallbacks {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoAnimationData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoAnimationData {
    // message fields
    // @@protoc_insertion_point(field:CDemoAnimationData.entity_id)
    pub entity_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDemoAnimationData.start_tick)
    pub start_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDemoAnimationData.end_tick)
    pub end_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDemoAnimationData.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CDemoAnimationData.data_checksum)
    pub data_checksum: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoAnimationData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoAnimationData {
    fn default() -> &'a CDemoAnimationData {
        <CDemoAnimationData as ::protobuf::Message>::default_instance()
    }
}

impl CDemoAnimationData {
    pub fn new() -> CDemoAnimationData {
        ::std::default::Default::default()
    }

    // optional sint32 entity_id = 1;

    pub fn entity_id(&self) -> i32 {
        self.entity_id.unwrap_or(0)
    }

    pub fn clear_entity_id(&mut self) {
        self.entity_id = ::std::option::Option::None;
    }

    pub fn has_entity_id(&self) -> bool {
        self.entity_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_id(&mut self, v: i32) {
        self.entity_id = ::std::option::Option::Some(v);
    }

    // optional int32 start_tick = 2;

    pub fn start_tick(&self) -> i32 {
        self.start_tick.unwrap_or(0)
    }

    pub fn clear_start_tick(&mut self) {
        self.start_tick = ::std::option::Option::None;
    }

    pub fn has_start_tick(&self) -> bool {
        self.start_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_tick(&mut self, v: i32) {
        self.start_tick = ::std::option::Option::Some(v);
    }

    // optional int32 end_tick = 3;

    pub fn end_tick(&self) -> i32 {
        self.end_tick.unwrap_or(0)
    }

    pub fn clear_end_tick(&mut self) {
        self.end_tick = ::std::option::Option::None;
    }

    pub fn has_end_tick(&self) -> bool {
        self.end_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_tick(&mut self, v: i32) {
        self.end_tick = ::std::option::Option::Some(v);
    }

    // optional bytes data = 4;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int64 data_checksum = 5;

    pub fn data_checksum(&self) -> i64 {
        self.data_checksum.unwrap_or(0)
    }

    pub fn clear_data_checksum(&mut self) {
        self.data_checksum = ::std::option::Option::None;
    }

    pub fn has_data_checksum(&self) -> bool {
        self.data_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_checksum(&mut self, v: i64) {
        self.data_checksum = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_id",
            |m: &CDemoAnimationData| { &m.entity_id },
            |m: &mut CDemoAnimationData| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_tick",
            |m: &CDemoAnimationData| { &m.start_tick },
            |m: &mut CDemoAnimationData| { &mut m.start_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_tick",
            |m: &CDemoAnimationData| { &m.end_tick },
            |m: &mut CDemoAnimationData| { &mut m.end_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CDemoAnimationData| { &m.data },
            |m: &mut CDemoAnimationData| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_checksum",
            |m: &CDemoAnimationData| { &m.data_checksum },
            |m: &mut CDemoAnimationData| { &mut m.data_checksum },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoAnimationData>(
            "CDemoAnimationData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoAnimationData {
    const NAME: &'static str = "CDemoAnimationData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity_id = ::std::option::Option::Some(is.read_sint32()?);
                },
                16 => {
                    self.start_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.end_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.data_checksum = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_id {
            my_size += ::protobuf::rt::sint32_size(1, v);
        }
        if let Some(v) = self.start_tick {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.end_tick {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.data_checksum {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity_id {
            os.write_sint32(1, v)?;
        }
        if let Some(v) = self.start_tick {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.end_tick {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.data_checksum {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoAnimationData {
        CDemoAnimationData::new()
    }

    fn clear(&mut self) {
        self.entity_id = ::std::option::Option::None;
        self.start_tick = ::std::option::Option::None;
        self.end_tick = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data_checksum = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoAnimationData {
        static instance: CDemoAnimationData = CDemoAnimationData {
            entity_id: ::std::option::Option::None,
            start_tick: ::std::option::Option::None,
            end_tick: ::std::option::Option::None,
            data: ::std::option::Option::None,
            data_checksum: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoAnimationData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoAnimationData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoAnimationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoAnimationData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoStringTables)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoStringTables {
    // message fields
    // @@protoc_insertion_point(field:CDemoStringTables.tables)
    pub tables: ::std::vec::Vec<cdemo_string_tables::Table_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoStringTables.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoStringTables {
    fn default() -> &'a CDemoStringTables {
        <CDemoStringTables as ::protobuf::Message>::default_instance()
    }
}

impl CDemoStringTables {
    pub fn new() -> CDemoStringTables {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tables",
            |m: &CDemoStringTables| { &m.tables },
            |m: &mut CDemoStringTables| { &mut m.tables },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoStringTables>(
            "CDemoStringTables",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoStringTables {
    const NAME: &'static str = "CDemoStringTables";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tables.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.tables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.tables {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoStringTables {
        CDemoStringTables::new()
    }

    fn clear(&mut self) {
        self.tables.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoStringTables {
        static instance: CDemoStringTables = CDemoStringTables {
            tables: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoStringTables {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoStringTables").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoStringTables {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoStringTables {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDemoStringTables`
pub mod cdemo_string_tables {
    // @@protoc_insertion_point(message:CDemoStringTables.items_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Items_t {
        // message fields
        // @@protoc_insertion_point(field:CDemoStringTables.items_t.str)
        pub str: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CDemoStringTables.items_t.data)
        pub data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CDemoStringTables.items_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Items_t {
        fn default() -> &'a Items_t {
            <Items_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Items_t {
        pub fn new() -> Items_t {
            ::std::default::Default::default()
        }

        // optional string str = 1;

        pub fn str(&self) -> &str {
            match self.str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_str(&mut self) {
            self.str = ::std::option::Option::None;
        }

        pub fn has_str(&self) -> bool {
            self.str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_str(&mut self, v: ::std::string::String) {
            self.str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_str(&mut self) -> &mut ::std::string::String {
            if self.str.is_none() {
                self.str = ::std::option::Option::Some(::std::string::String::new());
            }
            self.str.as_mut().unwrap()
        }

        // Take field
        pub fn take_str(&mut self) -> ::std::string::String {
            self.str.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes data = 2;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
            self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "str",
                |m: &Items_t| { &m.str },
                |m: &mut Items_t| { &mut m.str },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &Items_t| { &m.data },
                |m: &mut Items_t| { &mut m.data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Items_t>(
                "CDemoStringTables.items_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Items_t {
        const NAME: &'static str = "items_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.str = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.str.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.data.as_ref() {
                my_size += ::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.str.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Items_t {
            Items_t::new()
        }

        fn clear(&mut self) {
            self.str = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Items_t {
            static instance: Items_t = Items_t {
                str: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Items_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDemoStringTables.items_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Items_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Items_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CDemoStringTables.table_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Table_t {
        // message fields
        // @@protoc_insertion_point(field:CDemoStringTables.table_t.table_name)
        pub table_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CDemoStringTables.table_t.items)
        pub items: ::std::vec::Vec<Items_t>,
        // @@protoc_insertion_point(field:CDemoStringTables.table_t.items_clientside)
        pub items_clientside: ::std::vec::Vec<Items_t>,
        // @@protoc_insertion_point(field:CDemoStringTables.table_t.table_flags)
        pub table_flags: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDemoStringTables.table_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Table_t {
        fn default() -> &'a Table_t {
            <Table_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Table_t {
        pub fn new() -> Table_t {
            ::std::default::Default::default()
        }

        // optional string table_name = 1;

        pub fn table_name(&self) -> &str {
            match self.table_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_table_name(&mut self) {
            self.table_name = ::std::option::Option::None;
        }

        pub fn has_table_name(&self) -> bool {
            self.table_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_table_name(&mut self, v: ::std::string::String) {
            self.table_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_table_name(&mut self) -> &mut ::std::string::String {
            if self.table_name.is_none() {
                self.table_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.table_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_table_name(&mut self) -> ::std::string::String {
            self.table_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 table_flags = 4;

        pub fn table_flags(&self) -> i32 {
            self.table_flags.unwrap_or(0)
        }

        pub fn clear_table_flags(&mut self) {
            self.table_flags = ::std::option::Option::None;
        }

        pub fn has_table_flags(&self) -> bool {
            self.table_flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_table_flags(&mut self, v: i32) {
            self.table_flags = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "table_name",
                |m: &Table_t| { &m.table_name },
                |m: &mut Table_t| { &mut m.table_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "items",
                |m: &Table_t| { &m.items },
                |m: &mut Table_t| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "items_clientside",
                |m: &Table_t| { &m.items_clientside },
                |m: &mut Table_t| { &mut m.items_clientside },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "table_flags",
                |m: &Table_t| { &m.table_flags },
                |m: &mut Table_t| { &mut m.table_flags },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Table_t>(
                "CDemoStringTables.table_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Table_t {
        const NAME: &'static str = "table_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.table_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.items.push(is.read_message()?);
                    },
                    26 => {
                        self.items_clientside.push(is.read_message()?);
                    },
                    32 => {
                        self.table_flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.table_name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            for value in &self.items {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.items_clientside {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.table_flags {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.table_name.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.items {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.items_clientside {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            if let Some(v) = self.table_flags {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Table_t {
            Table_t::new()
        }

        fn clear(&mut self) {
            self.table_name = ::std::option::Option::None;
            self.items.clear();
            self.items_clientside.clear();
            self.table_flags = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Table_t {
            static instance: Table_t = Table_t {
                table_name: ::std::option::Option::None,
                items: ::std::vec::Vec::new(),
                items_clientside: ::std::vec::Vec::new(),
                table_flags: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Table_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDemoStringTables.table_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Table_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Table_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CDemoStop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoStop {
    // special fields
    // @@protoc_insertion_point(special_field:CDemoStop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoStop {
    fn default() -> &'a CDemoStop {
        <CDemoStop as ::protobuf::Message>::default_instance()
    }
}

impl CDemoStop {
    pub fn new() -> CDemoStop {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoStop>(
            "CDemoStop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoStop {
    const NAME: &'static str = "CDemoStop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoStop {
        CDemoStop::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoStop {
        static instance: CDemoStop = CDemoStop {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoStop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoStop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoStop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoUserCmd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoUserCmd {
    // message fields
    // @@protoc_insertion_point(field:CDemoUserCmd.cmd_number)
    pub cmd_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDemoUserCmd.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoUserCmd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoUserCmd {
    fn default() -> &'a CDemoUserCmd {
        <CDemoUserCmd as ::protobuf::Message>::default_instance()
    }
}

impl CDemoUserCmd {
    pub fn new() -> CDemoUserCmd {
        ::std::default::Default::default()
    }

    // optional int32 cmd_number = 1;

    pub fn cmd_number(&self) -> i32 {
        self.cmd_number.unwrap_or(0)
    }

    pub fn clear_cmd_number(&mut self) {
        self.cmd_number = ::std::option::Option::None;
    }

    pub fn has_cmd_number(&self) -> bool {
        self.cmd_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_number(&mut self, v: i32) {
        self.cmd_number = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd_number",
            |m: &CDemoUserCmd| { &m.cmd_number },
            |m: &mut CDemoUserCmd| { &mut m.cmd_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CDemoUserCmd| { &m.data },
            |m: &mut CDemoUserCmd| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoUserCmd>(
            "CDemoUserCmd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoUserCmd {
    const NAME: &'static str = "CDemoUserCmd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cmd_number = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cmd_number {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cmd_number {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoUserCmd {
        CDemoUserCmd::new()
    }

    fn clear(&mut self) {
        self.cmd_number = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoUserCmd {
        static instance: CDemoUserCmd = CDemoUserCmd {
            cmd_number: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoUserCmd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoUserCmd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoUserCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoUserCmd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDemoSpawnGroups)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDemoSpawnGroups {
    // message fields
    // @@protoc_insertion_point(field:CDemoSpawnGroups.msgs)
    pub msgs: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CDemoSpawnGroups.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDemoSpawnGroups {
    fn default() -> &'a CDemoSpawnGroups {
        <CDemoSpawnGroups as ::protobuf::Message>::default_instance()
    }
}

impl CDemoSpawnGroups {
    pub fn new() -> CDemoSpawnGroups {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "msgs",
            |m: &CDemoSpawnGroups| { &m.msgs },
            |m: &mut CDemoSpawnGroups| { &mut m.msgs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDemoSpawnGroups>(
            "CDemoSpawnGroups",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDemoSpawnGroups {
    const NAME: &'static str = "CDemoSpawnGroups";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    self.msgs.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.msgs {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.msgs {
            os.write_bytes(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDemoSpawnGroups {
        CDemoSpawnGroups::new()
    }

    fn clear(&mut self) {
        self.msgs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDemoSpawnGroups {
        static instance: CDemoSpawnGroups = CDemoSpawnGroups {
            msgs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDemoSpawnGroups {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDemoSpawnGroups").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDemoSpawnGroups {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDemoSpawnGroups {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDemoCommands)
pub enum EDemoCommands {
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_Error)
    DEM_Error = -1,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_Stop)
    DEM_Stop = 0,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_FileHeader)
    DEM_FileHeader = 1,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_FileInfo)
    DEM_FileInfo = 2,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_SyncTick)
    DEM_SyncTick = 3,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_SendTables)
    DEM_SendTables = 4,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_ClassInfo)
    DEM_ClassInfo = 5,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_StringTables)
    DEM_StringTables = 6,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_Packet)
    DEM_Packet = 7,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_SignonPacket)
    DEM_SignonPacket = 8,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_ConsoleCmd)
    DEM_ConsoleCmd = 9,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_CustomData)
    DEM_CustomData = 10,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_CustomDataCallbacks)
    DEM_CustomDataCallbacks = 11,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_UserCmd)
    DEM_UserCmd = 12,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_FullPacket)
    DEM_FullPacket = 13,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_SaveGame)
    DEM_SaveGame = 14,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_SpawnGroups)
    DEM_SpawnGroups = 15,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_AnimationData)
    DEM_AnimationData = 16,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_Max)
    DEM_Max = 17,
    // @@protoc_insertion_point(enum_value:EDemoCommands.DEM_IsCompressed)
    DEM_IsCompressed = 64,
}

impl ::protobuf::Enum for EDemoCommands {
    const NAME: &'static str = "EDemoCommands";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDemoCommands> {
        match value {
            -1 => ::std::option::Option::Some(EDemoCommands::DEM_Error),
            0 => ::std::option::Option::Some(EDemoCommands::DEM_Stop),
            1 => ::std::option::Option::Some(EDemoCommands::DEM_FileHeader),
            2 => ::std::option::Option::Some(EDemoCommands::DEM_FileInfo),
            3 => ::std::option::Option::Some(EDemoCommands::DEM_SyncTick),
            4 => ::std::option::Option::Some(EDemoCommands::DEM_SendTables),
            5 => ::std::option::Option::Some(EDemoCommands::DEM_ClassInfo),
            6 => ::std::option::Option::Some(EDemoCommands::DEM_StringTables),
            7 => ::std::option::Option::Some(EDemoCommands::DEM_Packet),
            8 => ::std::option::Option::Some(EDemoCommands::DEM_SignonPacket),
            9 => ::std::option::Option::Some(EDemoCommands::DEM_ConsoleCmd),
            10 => ::std::option::Option::Some(EDemoCommands::DEM_CustomData),
            11 => ::std::option::Option::Some(EDemoCommands::DEM_CustomDataCallbacks),
            12 => ::std::option::Option::Some(EDemoCommands::DEM_UserCmd),
            13 => ::std::option::Option::Some(EDemoCommands::DEM_FullPacket),
            14 => ::std::option::Option::Some(EDemoCommands::DEM_SaveGame),
            15 => ::std::option::Option::Some(EDemoCommands::DEM_SpawnGroups),
            16 => ::std::option::Option::Some(EDemoCommands::DEM_AnimationData),
            17 => ::std::option::Option::Some(EDemoCommands::DEM_Max),
            64 => ::std::option::Option::Some(EDemoCommands::DEM_IsCompressed),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDemoCommands> {
        match str {
            "DEM_Error" => ::std::option::Option::Some(EDemoCommands::DEM_Error),
            "DEM_Stop" => ::std::option::Option::Some(EDemoCommands::DEM_Stop),
            "DEM_FileHeader" => ::std::option::Option::Some(EDemoCommands::DEM_FileHeader),
            "DEM_FileInfo" => ::std::option::Option::Some(EDemoCommands::DEM_FileInfo),
            "DEM_SyncTick" => ::std::option::Option::Some(EDemoCommands::DEM_SyncTick),
            "DEM_SendTables" => ::std::option::Option::Some(EDemoCommands::DEM_SendTables),
            "DEM_ClassInfo" => ::std::option::Option::Some(EDemoCommands::DEM_ClassInfo),
            "DEM_StringTables" => ::std::option::Option::Some(EDemoCommands::DEM_StringTables),
            "DEM_Packet" => ::std::option::Option::Some(EDemoCommands::DEM_Packet),
            "DEM_SignonPacket" => ::std::option::Option::Some(EDemoCommands::DEM_SignonPacket),
            "DEM_ConsoleCmd" => ::std::option::Option::Some(EDemoCommands::DEM_ConsoleCmd),
            "DEM_CustomData" => ::std::option::Option::Some(EDemoCommands::DEM_CustomData),
            "DEM_CustomDataCallbacks" => ::std::option::Option::Some(EDemoCommands::DEM_CustomDataCallbacks),
            "DEM_UserCmd" => ::std::option::Option::Some(EDemoCommands::DEM_UserCmd),
            "DEM_FullPacket" => ::std::option::Option::Some(EDemoCommands::DEM_FullPacket),
            "DEM_SaveGame" => ::std::option::Option::Some(EDemoCommands::DEM_SaveGame),
            "DEM_SpawnGroups" => ::std::option::Option::Some(EDemoCommands::DEM_SpawnGroups),
            "DEM_AnimationData" => ::std::option::Option::Some(EDemoCommands::DEM_AnimationData),
            "DEM_Max" => ::std::option::Option::Some(EDemoCommands::DEM_Max),
            "DEM_IsCompressed" => ::std::option::Option::Some(EDemoCommands::DEM_IsCompressed),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDemoCommands] = &[
        EDemoCommands::DEM_Error,
        EDemoCommands::DEM_Stop,
        EDemoCommands::DEM_FileHeader,
        EDemoCommands::DEM_FileInfo,
        EDemoCommands::DEM_SyncTick,
        EDemoCommands::DEM_SendTables,
        EDemoCommands::DEM_ClassInfo,
        EDemoCommands::DEM_StringTables,
        EDemoCommands::DEM_Packet,
        EDemoCommands::DEM_SignonPacket,
        EDemoCommands::DEM_ConsoleCmd,
        EDemoCommands::DEM_CustomData,
        EDemoCommands::DEM_CustomDataCallbacks,
        EDemoCommands::DEM_UserCmd,
        EDemoCommands::DEM_FullPacket,
        EDemoCommands::DEM_SaveGame,
        EDemoCommands::DEM_SpawnGroups,
        EDemoCommands::DEM_AnimationData,
        EDemoCommands::DEM_Max,
        EDemoCommands::DEM_IsCompressed,
    ];
}

impl ::protobuf::EnumFull for EDemoCommands {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EDemoCommands").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EDemoCommands::DEM_Error => 0,
            EDemoCommands::DEM_Stop => 1,
            EDemoCommands::DEM_FileHeader => 2,
            EDemoCommands::DEM_FileInfo => 3,
            EDemoCommands::DEM_SyncTick => 4,
            EDemoCommands::DEM_SendTables => 5,
            EDemoCommands::DEM_ClassInfo => 6,
            EDemoCommands::DEM_StringTables => 7,
            EDemoCommands::DEM_Packet => 8,
            EDemoCommands::DEM_SignonPacket => 9,
            EDemoCommands::DEM_ConsoleCmd => 10,
            EDemoCommands::DEM_CustomData => 11,
            EDemoCommands::DEM_CustomDataCallbacks => 12,
            EDemoCommands::DEM_UserCmd => 13,
            EDemoCommands::DEM_FullPacket => 14,
            EDemoCommands::DEM_SaveGame => 15,
            EDemoCommands::DEM_SpawnGroups => 16,
            EDemoCommands::DEM_AnimationData => 17,
            EDemoCommands::DEM_Max => 18,
            EDemoCommands::DEM_IsCompressed => 19,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EDemoCommands {
    fn default() -> Self {
        EDemoCommands::DEM_Error
    }
}

impl EDemoCommands {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EDemoCommands>("EDemoCommands")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\ndemo.proto\"\xb4\x04\n\x0fCDemoFileHeader\x12&\n\x0fdemo_file_stamp\
    \x18\x01\x20\x02(\tR\rdemoFileStamp\x12)\n\x10network_protocol\x18\x02\
    \x20\x01(\x05R\x0fnetworkProtocol\x12\x1f\n\x0bserver_name\x18\x03\x20\
    \x01(\tR\nserverName\x12\x1f\n\x0bclient_name\x18\x04\x20\x01(\tR\nclien\
    tName\x12\x19\n\x08map_name\x18\x05\x20\x01(\tR\x07mapName\x12%\n\x0egam\
    e_directory\x18\x06\x20\x01(\tR\rgameDirectory\x12/\n\x13fullpackets_ver\
    sion\x18\x07\x20\x01(\x05R\x12fullpacketsVersion\x12:\n\x19allow_clients\
    ide_entities\x18\x08\x20\x01(\x08R\x17allowClientsideEntities\x12<\n\x1a\
    allow_clientside_particles\x18\t\x20\x01(\x08R\x18allowClientsideParticl\
    es\x12\x16\n\x06addons\x18\n\x20\x01(\tR\x06addons\x12*\n\x11demo_versio\
    n_name\x18\x0b\x20\x01(\tR\x0fdemoVersionName\x12*\n\x11demo_version_gui\
    d\x18\x0c\x20\x01(\tR\x0fdemoVersionGuid\x12\x1b\n\tbuild_num\x18\r\x20\
    \x01(\x05R\x08buildNum\x12\x12\n\x04game\x18\x0e\x20\x01(\tR\x04game\"\
    \x89\x06\n\tCGameInfo\x12,\n\x04dota\x18\x04\x20\x01(\x0b2\x18.CGameInfo\
    .CDotaGameInfoR\x04dota\x1a\xcd\x05\n\rCDotaGameInfo\x12\x19\n\x08match_\
    id\x18\x01\x20\x01(\x04R\x07matchId\x12\x1b\n\tgame_mode\x18\x02\x20\x01\
    (\x05R\x08gameMode\x12\x1f\n\x0bgame_winner\x18\x03\x20\x01(\x05R\ngameW\
    inner\x12E\n\x0bplayer_info\x18\x04\x20\x03(\x0b2$.CGameInfo.CDotaGameIn\
    fo.CPlayerInfoR\nplayerInfo\x12\x1a\n\x08leagueid\x18\x05\x20\x01(\rR\
    \x08leagueid\x12H\n\npicks_bans\x18\x06\x20\x03(\x0b2).CGameInfo.CDotaGa\
    meInfo.CHeroSelectEventR\tpicksBans\x12&\n\x0fradiant_team_id\x18\x07\
    \x20\x01(\rR\rradiantTeamId\x12\x20\n\x0cdire_team_id\x18\x08\x20\x01(\r\
    R\ndireTeamId\x12(\n\x10radiant_team_tag\x18\t\x20\x01(\tR\x0eradiantTea\
    mTag\x12\"\n\rdire_team_tag\x18\n\x20\x01(\tR\x0bdireTeamTag\x12\x19\n\
    \x08end_time\x18\x0b\x20\x01(\rR\x07endTime\x1a\xa8\x01\n\x0bCPlayerInfo\
    \x12\x1b\n\thero_name\x18\x01\x20\x01(\tR\x08heroName\x12\x1f\n\x0bplaye\
    r_name\x18\x02\x20\x01(\tR\nplayerName\x12$\n\x0eis_fake_client\x18\x03\
    \x20\x01(\x08R\x0cisFakeClient\x12\x18\n\x07steamid\x18\x04\x20\x01(\x04\
    R\x07steamid\x12\x1b\n\tgame_team\x18\x05\x20\x01(\x05R\x08gameTeam\x1aX\
    \n\x10CHeroSelectEvent\x12\x17\n\x07is_pick\x18\x01\x20\x01(\x08R\x06isP\
    ick\x12\x12\n\x04team\x18\x02\x20\x01(\rR\x04team\x12\x17\n\x07hero_id\
    \x18\x03\x20\x01(\rR\x06heroId\"\xad\x01\n\rCDemoFileInfo\x12#\n\rplayba\
    ck_time\x18\x01\x20\x01(\x02R\x0cplaybackTime\x12%\n\x0eplayback_ticks\
    \x18\x02\x20\x01(\x05R\rplaybackTicks\x12'\n\x0fplayback_frames\x18\x03\
    \x20\x01(\x05R\x0eplaybackFrames\x12'\n\tgame_info\x18\x04\x20\x01(\x0b2\
    \n.CGameInfoR\x08gameInfo\"!\n\x0bCDemoPacket\x12\x12\n\x04data\x18\x03\
    \x20\x01(\x0cR\x04data\"n\n\x0fCDemoFullPacket\x125\n\x0cstring_table\
    \x18\x01\x20\x01(\x0b2\x12.CDemoStringTablesR\x0bstringTable\x12$\n\x06p\
    acket\x18\x02\x20\x01(\x0b2\x0c.CDemoPacketR\x06packet\"v\n\rCDemoSaveGa\
    me\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x19\n\x08steam_id\
    \x18\x02\x20\x01(\x06R\x07steamId\x12\x1c\n\tsignature\x18\x03\x20\x01(\
    \x06R\tsignature\x12\x18\n\x07version\x18\x04\x20\x01(\x05R\x07version\"\
    \x0f\n\rCDemoSyncTick\"/\n\x0fCDemoConsoleCmd\x12\x1c\n\tcmdstring\x18\
    \x01\x20\x01(\tR\tcmdstring\"%\n\x0fCDemoSendTables\x12\x12\n\x04data\
    \x18\x01\x20\x01(\x0cR\x04data\"\xab\x01\n\x0eCDemoClassInfo\x121\n\x07c\
    lasses\x18\x01\x20\x03(\x0b2\x17.CDemoClassInfo.class_tR\x07classes\x1af\
    \n\x07class_t\x12\x19\n\x08class_id\x18\x01\x20\x01(\x05R\x07classId\x12\
    !\n\x0cnetwork_name\x18\x02\x20\x01(\tR\x0bnetworkName\x12\x1d\n\ntable_\
    name\x18\x03\x20\x01(\tR\ttableName\"L\n\x0fCDemoCustomData\x12%\n\x0eca\
    llback_index\x18\x01\x20\x01(\x05R\rcallbackIndex\x12\x12\n\x04data\x18\
    \x02\x20\x01(\x0cR\x04data\"3\n\x18CDemoCustomDataCallbacks\x12\x17\n\
    \x07save_id\x18\x01\x20\x03(\tR\x06saveId\"\xa4\x01\n\x12CDemoAnimationD\
    ata\x12\x1b\n\tentity_id\x18\x01\x20\x01(\x11R\x08entityId\x12\x1d\n\nst\
    art_tick\x18\x02\x20\x01(\x05R\tstartTick\x12\x19\n\x08end_tick\x18\x03\
    \x20\x01(\x05R\x07endTick\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04dat\
    a\x12#\n\rdata_checksum\x18\x05\x20\x01(\x03R\x0cdataChecksum\"\xbd\x02\
    \n\x11CDemoStringTables\x122\n\x06tables\x18\x01\x20\x03(\x0b2\x1a.CDemo\
    StringTables.table_tR\x06tables\x1a/\n\x07items_t\x12\x10\n\x03str\x18\
    \x01\x20\x01(\tR\x03str\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\
    \x1a\xc2\x01\n\x07table_t\x12\x1d\n\ntable_name\x18\x01\x20\x01(\tR\ttab\
    leName\x120\n\x05items\x18\x02\x20\x03(\x0b2\x1a.CDemoStringTables.items\
    _tR\x05items\x12E\n\x10items_clientside\x18\x03\x20\x03(\x0b2\x1a.CDemoS\
    tringTables.items_tR\x0fitemsClientside\x12\x1f\n\x0btable_flags\x18\x04\
    \x20\x01(\x05R\ntableFlags\"\x0b\n\tCDemoStop\"A\n\x0cCDemoUserCmd\x12\
    \x1d\n\ncmd_number\x18\x01\x20\x01(\x05R\tcmdNumber\x12\x12\n\x04data\
    \x18\x02\x20\x01(\x0cR\x04data\"&\n\x10CDemoSpawnGroups\x12\x12\n\x04msg\
    s\x18\x03\x20\x03(\x0cR\x04msgs*\x9b\x03\n\rEDemoCommands\x12\x16\n\tDEM\
    _Error\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x0c\n\x08DEM_Stop\
    \x10\0\x12\x12\n\x0eDEM_FileHeader\x10\x01\x12\x10\n\x0cDEM_FileInfo\x10\
    \x02\x12\x10\n\x0cDEM_SyncTick\x10\x03\x12\x12\n\x0eDEM_SendTables\x10\
    \x04\x12\x11\n\rDEM_ClassInfo\x10\x05\x12\x14\n\x10DEM_StringTables\x10\
    \x06\x12\x0e\n\nDEM_Packet\x10\x07\x12\x14\n\x10DEM_SignonPacket\x10\x08\
    \x12\x12\n\x0eDEM_ConsoleCmd\x10\t\x12\x12\n\x0eDEM_CustomData\x10\n\x12\
    \x1b\n\x17DEM_CustomDataCallbacks\x10\x0b\x12\x0f\n\x0bDEM_UserCmd\x10\
    \x0c\x12\x12\n\x0eDEM_FullPacket\x10\r\x12\x10\n\x0cDEM_SaveGame\x10\x0e\
    \x12\x13\n\x0fDEM_SpawnGroups\x10\x0f\x12\x15\n\x11DEM_AnimationData\x10\
    \x10\x12\x0b\n\x07DEM_Max\x10\x11\x12\x14\n\x10DEM_IsCompressed\x10@\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(23);
            messages.push(CDemoFileHeader::generated_message_descriptor_data());
            messages.push(CGameInfo::generated_message_descriptor_data());
            messages.push(CDemoFileInfo::generated_message_descriptor_data());
            messages.push(CDemoPacket::generated_message_descriptor_data());
            messages.push(CDemoFullPacket::generated_message_descriptor_data());
            messages.push(CDemoSaveGame::generated_message_descriptor_data());
            messages.push(CDemoSyncTick::generated_message_descriptor_data());
            messages.push(CDemoConsoleCmd::generated_message_descriptor_data());
            messages.push(CDemoSendTables::generated_message_descriptor_data());
            messages.push(CDemoClassInfo::generated_message_descriptor_data());
            messages.push(CDemoCustomData::generated_message_descriptor_data());
            messages.push(CDemoCustomDataCallbacks::generated_message_descriptor_data());
            messages.push(CDemoAnimationData::generated_message_descriptor_data());
            messages.push(CDemoStringTables::generated_message_descriptor_data());
            messages.push(CDemoStop::generated_message_descriptor_data());
            messages.push(CDemoUserCmd::generated_message_descriptor_data());
            messages.push(CDemoSpawnGroups::generated_message_descriptor_data());
            messages.push(cgame_info::CDotaGameInfo::generated_message_descriptor_data());
            messages.push(cgame_info::cdota_game_info::CPlayerInfo::generated_message_descriptor_data());
            messages.push(cgame_info::cdota_game_info::CHeroSelectEvent::generated_message_descriptor_data());
            messages.push(cdemo_class_info::Class_t::generated_message_descriptor_data());
            messages.push(cdemo_string_tables::Items_t::generated_message_descriptor_data());
            messages.push(cdemo_string_tables::Table_t::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(EDemoCommands::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
