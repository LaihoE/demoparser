// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.12.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gameevents.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:CMsgVDebugGameSessionIDEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgVDebugGameSessionIDEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgVDebugGameSessionIDEvent.clientid)
    pub clientid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgVDebugGameSessionIDEvent.gamesessionid)
    pub gamesessionid: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVDebugGameSessionIDEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVDebugGameSessionIDEvent {
    fn default() -> &'a CMsgVDebugGameSessionIDEvent {
        <CMsgVDebugGameSessionIDEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVDebugGameSessionIDEvent {
    pub fn new() -> CMsgVDebugGameSessionIDEvent {
        ::std::default::Default::default()
    }

    // optional int32 clientid = 1;

    pub fn clientid(&self) -> i32 {
        self.clientid.unwrap_or(0)
    }

    pub fn clear_clientid(&mut self) {
        self.clientid = ::std::option::Option::None;
    }

    pub fn has_clientid(&self) -> bool {
        self.clientid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientid(&mut self, v: i32) {
        self.clientid = ::std::option::Option::Some(v);
    }

    // optional string gamesessionid = 2;

    pub fn gamesessionid(&self) -> &str {
        match self.gamesessionid.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_gamesessionid(&mut self) {
        self.gamesessionid = ::std::option::Option::None;
    }

    pub fn has_gamesessionid(&self) -> bool {
        self.gamesessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamesessionid(&mut self, v: ::std::string::String) {
        self.gamesessionid = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamesessionid(&mut self) -> &mut ::std::string::String {
        if self.gamesessionid.is_none() {
            self.gamesessionid = ::std::option::Option::Some(::std::string::String::new());
        }
        self.gamesessionid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamesessionid(&mut self) -> ::std::string::String {
        self.gamesessionid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientid",
            |m: &CMsgVDebugGameSessionIDEvent| { &m.clientid },
            |m: &mut CMsgVDebugGameSessionIDEvent| { &mut m.clientid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamesessionid",
            |m: &CMsgVDebugGameSessionIDEvent| { &m.gamesessionid },
            |m: &mut CMsgVDebugGameSessionIDEvent| { &mut m.gamesessionid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVDebugGameSessionIDEvent>(
            "CMsgVDebugGameSessionIDEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVDebugGameSessionIDEvent {
    const NAME: &'static str = "CMsgVDebugGameSessionIDEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.clientid = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.gamesessionid = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.clientid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.gamesessionid.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.clientid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.gamesessionid.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVDebugGameSessionIDEvent {
        CMsgVDebugGameSessionIDEvent::new()
    }

    fn clear(&mut self) {
        self.clientid = ::std::option::Option::None;
        self.gamesessionid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVDebugGameSessionIDEvent {
        static instance: CMsgVDebugGameSessionIDEvent = CMsgVDebugGameSessionIDEvent {
            clientid: ::std::option::Option::None,
            gamesessionid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVDebugGameSessionIDEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVDebugGameSessionIDEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVDebugGameSessionIDEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVDebugGameSessionIDEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgPlaceDecalEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlaceDecalEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.position)
    pub position: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.normal)
    pub normal: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.saxis)
    pub saxis: ::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.decalmaterialindex)
    pub decalmaterialindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.width)
    pub width: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.height)
    pub height: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.depth)
    pub depth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.entityhandleindex)
    pub entityhandleindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.skeletoninstancehash)
    pub skeletoninstancehash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.boneindex)
    pub boneindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.translucenthit)
    pub translucenthit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPlaceDecalEvent.is_adjacent)
    pub is_adjacent: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlaceDecalEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlaceDecalEvent {
    fn default() -> &'a CMsgPlaceDecalEvent {
        <CMsgPlaceDecalEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPlaceDecalEvent {
    pub fn new() -> CMsgPlaceDecalEvent {
        ::std::default::Default::default()
    }

    // optional uint32 decalmaterialindex = 4;

    pub fn decalmaterialindex(&self) -> u32 {
        self.decalmaterialindex.unwrap_or(0)
    }

    pub fn clear_decalmaterialindex(&mut self) {
        self.decalmaterialindex = ::std::option::Option::None;
    }

    pub fn has_decalmaterialindex(&self) -> bool {
        self.decalmaterialindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decalmaterialindex(&mut self, v: u32) {
        self.decalmaterialindex = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 5;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 color = 6;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional float width = 7;

    pub fn width(&self) -> f32 {
        self.width.unwrap_or(0.)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: f32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional float height = 8;

    pub fn height(&self) -> f32 {
        self.height.unwrap_or(0.)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: f32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional float depth = 9;

    pub fn depth(&self) -> f32 {
        self.depth.unwrap_or(0.)
    }

    pub fn clear_depth(&mut self) {
        self.depth = ::std::option::Option::None;
    }

    pub fn has_depth(&self) -> bool {
        self.depth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depth(&mut self, v: f32) {
        self.depth = ::std::option::Option::Some(v);
    }

    // optional uint32 entityhandleindex = 10;

    pub fn entityhandleindex(&self) -> u32 {
        self.entityhandleindex.unwrap_or(0)
    }

    pub fn clear_entityhandleindex(&mut self) {
        self.entityhandleindex = ::std::option::Option::None;
    }

    pub fn has_entityhandleindex(&self) -> bool {
        self.entityhandleindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entityhandleindex(&mut self, v: u32) {
        self.entityhandleindex = ::std::option::Option::Some(v);
    }

    // optional fixed32 skeletoninstancehash = 11;

    pub fn skeletoninstancehash(&self) -> u32 {
        self.skeletoninstancehash.unwrap_or(0)
    }

    pub fn clear_skeletoninstancehash(&mut self) {
        self.skeletoninstancehash = ::std::option::Option::None;
    }

    pub fn has_skeletoninstancehash(&self) -> bool {
        self.skeletoninstancehash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skeletoninstancehash(&mut self, v: u32) {
        self.skeletoninstancehash = ::std::option::Option::Some(v);
    }

    // optional int32 boneindex = 12;

    pub fn boneindex(&self) -> i32 {
        self.boneindex.unwrap_or(0)
    }

    pub fn clear_boneindex(&mut self) {
        self.boneindex = ::std::option::Option::None;
    }

    pub fn has_boneindex(&self) -> bool {
        self.boneindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boneindex(&mut self, v: i32) {
        self.boneindex = ::std::option::Option::Some(v);
    }

    // optional bool translucenthit = 13;

    pub fn translucenthit(&self) -> bool {
        self.translucenthit.unwrap_or(false)
    }

    pub fn clear_translucenthit(&mut self) {
        self.translucenthit = ::std::option::Option::None;
    }

    pub fn has_translucenthit(&self) -> bool {
        self.translucenthit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_translucenthit(&mut self, v: bool) {
        self.translucenthit = ::std::option::Option::Some(v);
    }

    // optional bool is_adjacent = 14;

    pub fn is_adjacent(&self) -> bool {
        self.is_adjacent.unwrap_or(false)
    }

    pub fn clear_is_adjacent(&mut self) {
        self.is_adjacent = ::std::option::Option::None;
    }

    pub fn has_is_adjacent(&self) -> bool {
        self.is_adjacent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_adjacent(&mut self, v: bool) {
        self.is_adjacent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "position",
            |m: &CMsgPlaceDecalEvent| { &m.position },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "normal",
            |m: &CMsgPlaceDecalEvent| { &m.normal },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.normal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::networkbasetypes::CMsgVector>(
            "saxis",
            |m: &CMsgPlaceDecalEvent| { &m.saxis },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.saxis },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decalmaterialindex",
            |m: &CMsgPlaceDecalEvent| { &m.decalmaterialindex },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.decalmaterialindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMsgPlaceDecalEvent| { &m.flags },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CMsgPlaceDecalEvent| { &m.color },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.color },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CMsgPlaceDecalEvent| { &m.width },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CMsgPlaceDecalEvent| { &m.height },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "depth",
            |m: &CMsgPlaceDecalEvent| { &m.depth },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.depth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entityhandleindex",
            |m: &CMsgPlaceDecalEvent| { &m.entityhandleindex },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.entityhandleindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skeletoninstancehash",
            |m: &CMsgPlaceDecalEvent| { &m.skeletoninstancehash },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.skeletoninstancehash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "boneindex",
            |m: &CMsgPlaceDecalEvent| { &m.boneindex },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.boneindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "translucenthit",
            |m: &CMsgPlaceDecalEvent| { &m.translucenthit },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.translucenthit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_adjacent",
            |m: &CMsgPlaceDecalEvent| { &m.is_adjacent },
            |m: &mut CMsgPlaceDecalEvent| { &mut m.is_adjacent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgPlaceDecalEvent>(
            "CMsgPlaceDecalEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgPlaceDecalEvent {
    const NAME: &'static str = "CMsgPlaceDecalEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.normal)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.saxis)?;
                },
                32 => {
                    self.decalmaterialindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.width = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.height = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.depth = ::std::option::Option::Some(is.read_float()?);
                },
                80 => {
                    self.entityhandleindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                93 => {
                    self.skeletoninstancehash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                96 => {
                    self.boneindex = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.translucenthit = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_adjacent = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.normal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.saxis.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.decalmaterialindex {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        if let Some(v) = self.width {
            my_size += 1 + 4;
        }
        if let Some(v) = self.height {
            my_size += 1 + 4;
        }
        if let Some(v) = self.depth {
            my_size += 1 + 4;
        }
        if let Some(v) = self.entityhandleindex {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.skeletoninstancehash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.boneindex {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.translucenthit {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_adjacent {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.normal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.saxis.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.decalmaterialindex {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.width {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.height {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.depth {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.entityhandleindex {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.skeletoninstancehash {
            os.write_fixed32(11, v)?;
        }
        if let Some(v) = self.boneindex {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.translucenthit {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_adjacent {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlaceDecalEvent {
        CMsgPlaceDecalEvent::new()
    }

    fn clear(&mut self) {
        self.position.clear();
        self.normal.clear();
        self.saxis.clear();
        self.decalmaterialindex = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.depth = ::std::option::Option::None;
        self.entityhandleindex = ::std::option::Option::None;
        self.skeletoninstancehash = ::std::option::Option::None;
        self.boneindex = ::std::option::Option::None;
        self.translucenthit = ::std::option::Option::None;
        self.is_adjacent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlaceDecalEvent {
        static instance: CMsgPlaceDecalEvent = CMsgPlaceDecalEvent {
            position: ::protobuf::MessageField::none(),
            normal: ::protobuf::MessageField::none(),
            saxis: ::protobuf::MessageField::none(),
            decalmaterialindex: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            color: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            depth: ::std::option::Option::None,
            entityhandleindex: ::std::option::Option::None,
            skeletoninstancehash: ::std::option::Option::None,
            boneindex: ::std::option::Option::None,
            translucenthit: ::std::option::Option::None,
            is_adjacent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgPlaceDecalEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgPlaceDecalEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgPlaceDecalEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPlaceDecalEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClearWorldDecalsEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearWorldDecalsEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearWorldDecalsEvent.flagstoclear)
    pub flagstoclear: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearWorldDecalsEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearWorldDecalsEvent {
    fn default() -> &'a CMsgClearWorldDecalsEvent {
        <CMsgClearWorldDecalsEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearWorldDecalsEvent {
    pub fn new() -> CMsgClearWorldDecalsEvent {
        ::std::default::Default::default()
    }

    // optional uint32 flagstoclear = 1;

    pub fn flagstoclear(&self) -> u32 {
        self.flagstoclear.unwrap_or(0)
    }

    pub fn clear_flagstoclear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
    }

    pub fn has_flagstoclear(&self) -> bool {
        self.flagstoclear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flagstoclear(&mut self, v: u32) {
        self.flagstoclear = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flagstoclear",
            |m: &CMsgClearWorldDecalsEvent| { &m.flagstoclear },
            |m: &mut CMsgClearWorldDecalsEvent| { &mut m.flagstoclear },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClearWorldDecalsEvent>(
            "CMsgClearWorldDecalsEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClearWorldDecalsEvent {
    const NAME: &'static str = "CMsgClearWorldDecalsEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flagstoclear = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flagstoclear {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.flagstoclear {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearWorldDecalsEvent {
        CMsgClearWorldDecalsEvent::new()
    }

    fn clear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearWorldDecalsEvent {
        static instance: CMsgClearWorldDecalsEvent = CMsgClearWorldDecalsEvent {
            flagstoclear: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClearWorldDecalsEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClearWorldDecalsEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClearWorldDecalsEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClearWorldDecalsEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClearEntityDecalsEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearEntityDecalsEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearEntityDecalsEvent.flagstoclear)
    pub flagstoclear: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearEntityDecalsEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearEntityDecalsEvent {
    fn default() -> &'a CMsgClearEntityDecalsEvent {
        <CMsgClearEntityDecalsEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearEntityDecalsEvent {
    pub fn new() -> CMsgClearEntityDecalsEvent {
        ::std::default::Default::default()
    }

    // optional uint32 flagstoclear = 1;

    pub fn flagstoclear(&self) -> u32 {
        self.flagstoclear.unwrap_or(0)
    }

    pub fn clear_flagstoclear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
    }

    pub fn has_flagstoclear(&self) -> bool {
        self.flagstoclear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flagstoclear(&mut self, v: u32) {
        self.flagstoclear = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flagstoclear",
            |m: &CMsgClearEntityDecalsEvent| { &m.flagstoclear },
            |m: &mut CMsgClearEntityDecalsEvent| { &mut m.flagstoclear },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClearEntityDecalsEvent>(
            "CMsgClearEntityDecalsEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClearEntityDecalsEvent {
    const NAME: &'static str = "CMsgClearEntityDecalsEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flagstoclear = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flagstoclear {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.flagstoclear {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearEntityDecalsEvent {
        CMsgClearEntityDecalsEvent::new()
    }

    fn clear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearEntityDecalsEvent {
        static instance: CMsgClearEntityDecalsEvent = CMsgClearEntityDecalsEvent {
            flagstoclear: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClearEntityDecalsEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClearEntityDecalsEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClearEntityDecalsEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClearEntityDecalsEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgClearDecalsForSkeletonInstanceEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClearDecalsForSkeletonInstanceEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgClearDecalsForSkeletonInstanceEvent.flagstoclear)
    pub flagstoclear: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClearDecalsForSkeletonInstanceEvent.entityhandleindex)
    pub entityhandleindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClearDecalsForSkeletonInstanceEvent.skeletoninstancehash)
    pub skeletoninstancehash: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClearDecalsForSkeletonInstanceEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClearDecalsForSkeletonInstanceEvent {
    fn default() -> &'a CMsgClearDecalsForSkeletonInstanceEvent {
        <CMsgClearDecalsForSkeletonInstanceEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClearDecalsForSkeletonInstanceEvent {
    pub fn new() -> CMsgClearDecalsForSkeletonInstanceEvent {
        ::std::default::Default::default()
    }

    // optional uint32 flagstoclear = 1;

    pub fn flagstoclear(&self) -> u32 {
        self.flagstoclear.unwrap_or(0)
    }

    pub fn clear_flagstoclear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
    }

    pub fn has_flagstoclear(&self) -> bool {
        self.flagstoclear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flagstoclear(&mut self, v: u32) {
        self.flagstoclear = ::std::option::Option::Some(v);
    }

    // optional uint32 entityhandleindex = 2;

    pub fn entityhandleindex(&self) -> u32 {
        self.entityhandleindex.unwrap_or(0)
    }

    pub fn clear_entityhandleindex(&mut self) {
        self.entityhandleindex = ::std::option::Option::None;
    }

    pub fn has_entityhandleindex(&self) -> bool {
        self.entityhandleindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entityhandleindex(&mut self, v: u32) {
        self.entityhandleindex = ::std::option::Option::Some(v);
    }

    // optional uint32 skeletoninstancehash = 3;

    pub fn skeletoninstancehash(&self) -> u32 {
        self.skeletoninstancehash.unwrap_or(0)
    }

    pub fn clear_skeletoninstancehash(&mut self) {
        self.skeletoninstancehash = ::std::option::Option::None;
    }

    pub fn has_skeletoninstancehash(&self) -> bool {
        self.skeletoninstancehash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skeletoninstancehash(&mut self, v: u32) {
        self.skeletoninstancehash = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flagstoclear",
            |m: &CMsgClearDecalsForSkeletonInstanceEvent| { &m.flagstoclear },
            |m: &mut CMsgClearDecalsForSkeletonInstanceEvent| { &mut m.flagstoclear },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entityhandleindex",
            |m: &CMsgClearDecalsForSkeletonInstanceEvent| { &m.entityhandleindex },
            |m: &mut CMsgClearDecalsForSkeletonInstanceEvent| { &mut m.entityhandleindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skeletoninstancehash",
            |m: &CMsgClearDecalsForSkeletonInstanceEvent| { &m.skeletoninstancehash },
            |m: &mut CMsgClearDecalsForSkeletonInstanceEvent| { &mut m.skeletoninstancehash },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgClearDecalsForSkeletonInstanceEvent>(
            "CMsgClearDecalsForSkeletonInstanceEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgClearDecalsForSkeletonInstanceEvent {
    const NAME: &'static str = "CMsgClearDecalsForSkeletonInstanceEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flagstoclear = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.entityhandleindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.skeletoninstancehash = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flagstoclear {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.entityhandleindex {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.skeletoninstancehash {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.flagstoclear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.entityhandleindex {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.skeletoninstancehash {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClearDecalsForSkeletonInstanceEvent {
        CMsgClearDecalsForSkeletonInstanceEvent::new()
    }

    fn clear(&mut self) {
        self.flagstoclear = ::std::option::Option::None;
        self.entityhandleindex = ::std::option::Option::None;
        self.skeletoninstancehash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClearDecalsForSkeletonInstanceEvent {
        static instance: CMsgClearDecalsForSkeletonInstanceEvent = CMsgClearDecalsForSkeletonInstanceEvent {
            flagstoclear: ::std::option::Option::None,
            entityhandleindex: ::std::option::Option::None,
            skeletoninstancehash: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgClearDecalsForSkeletonInstanceEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgClearDecalsForSkeletonInstanceEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgClearDecalsForSkeletonInstanceEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClearDecalsForSkeletonInstanceEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSource1LegacyGameEventList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource1LegacyGameEventList {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.descriptors)
    pub descriptors: ::std::vec::Vec<cmsg_source1legacy_game_event_list::Descriptor_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource1LegacyGameEventList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource1LegacyGameEventList {
    fn default() -> &'a CMsgSource1LegacyGameEventList {
        <CMsgSource1LegacyGameEventList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSource1LegacyGameEventList {
    pub fn new() -> CMsgSource1LegacyGameEventList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "descriptors",
            |m: &CMsgSource1LegacyGameEventList| { &m.descriptors },
            |m: &mut CMsgSource1LegacyGameEventList| { &mut m.descriptors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSource1LegacyGameEventList>(
            "CMsgSource1LegacyGameEventList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSource1LegacyGameEventList {
    const NAME: &'static str = "CMsgSource1LegacyGameEventList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.descriptors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.descriptors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.descriptors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource1LegacyGameEventList {
        CMsgSource1LegacyGameEventList::new()
    }

    fn clear(&mut self) {
        self.descriptors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource1LegacyGameEventList {
        static instance: CMsgSource1LegacyGameEventList = CMsgSource1LegacyGameEventList {
            descriptors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSource1LegacyGameEventList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSource1LegacyGameEventList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSource1LegacyGameEventList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSource1LegacyGameEventList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSource1LegacyGameEventList`
pub mod cmsg_source1legacy_game_event_list {
    // @@protoc_insertion_point(message:CMsgSource1LegacyGameEventList.key_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.key_t.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSource1LegacyGameEventList.key_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Key_t| { &m.type_ },
                |m: &mut Key_t| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Key_t| { &m.name },
                |m: &mut Key_t| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key_t>(
                "CMsgSource1LegacyGameEventList.key_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Key_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSource1LegacyGameEventList.key_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Key_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Key_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CMsgSource1LegacyGameEventList.descriptor_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Descriptor_t {
        // message fields
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.descriptor_t.eventid)
        pub eventid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.descriptor_t.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEventList.descriptor_t.keys)
        pub keys: ::std::vec::Vec<Key_t>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSource1LegacyGameEventList.descriptor_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Descriptor_t {
        fn default() -> &'a Descriptor_t {
            <Descriptor_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Descriptor_t {
        pub fn new() -> Descriptor_t {
            ::std::default::Default::default()
        }

        // optional int32 eventid = 1;

        pub fn eventid(&self) -> i32 {
            self.eventid.unwrap_or(0)
        }

        pub fn clear_eventid(&mut self) {
            self.eventid = ::std::option::Option::None;
        }

        pub fn has_eventid(&self) -> bool {
            self.eventid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eventid(&mut self, v: i32) {
            self.eventid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eventid",
                |m: &Descriptor_t| { &m.eventid },
                |m: &mut Descriptor_t| { &mut m.eventid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Descriptor_t| { &m.name },
                |m: &mut Descriptor_t| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "keys",
                |m: &Descriptor_t| { &m.keys },
                |m: &mut Descriptor_t| { &mut m.keys },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Descriptor_t>(
                "CMsgSource1LegacyGameEventList.descriptor_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Descriptor_t {
        const NAME: &'static str = "descriptor_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eventid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.keys.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eventid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            for value in &self.keys {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eventid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.keys {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Descriptor_t {
            Descriptor_t::new()
        }

        fn clear(&mut self) {
            self.eventid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.keys.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Descriptor_t {
            static instance: Descriptor_t = Descriptor_t {
                eventid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                keys: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Descriptor_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSource1LegacyGameEventList.descriptor_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Descriptor_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Descriptor_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSource1LegacyListenEvents)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource1LegacyListenEvents {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource1LegacyListenEvents.playerslot)
    pub playerslot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSource1LegacyListenEvents.eventarraybits)
    pub eventarraybits: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource1LegacyListenEvents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource1LegacyListenEvents {
    fn default() -> &'a CMsgSource1LegacyListenEvents {
        <CMsgSource1LegacyListenEvents as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSource1LegacyListenEvents {
    pub fn new() -> CMsgSource1LegacyListenEvents {
        ::std::default::Default::default()
    }

    // optional int32 playerslot = 1;

    pub fn playerslot(&self) -> i32 {
        self.playerslot.unwrap_or(0)
    }

    pub fn clear_playerslot(&mut self) {
        self.playerslot = ::std::option::Option::None;
    }

    pub fn has_playerslot(&self) -> bool {
        self.playerslot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerslot(&mut self, v: i32) {
        self.playerslot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "playerslot",
            |m: &CMsgSource1LegacyListenEvents| { &m.playerslot },
            |m: &mut CMsgSource1LegacyListenEvents| { &mut m.playerslot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "eventarraybits",
            |m: &CMsgSource1LegacyListenEvents| { &m.eventarraybits },
            |m: &mut CMsgSource1LegacyListenEvents| { &mut m.eventarraybits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSource1LegacyListenEvents>(
            "CMsgSource1LegacyListenEvents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSource1LegacyListenEvents {
    const NAME: &'static str = "CMsgSource1LegacyListenEvents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.playerslot = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.eventarraybits)?;
                },
                16 => {
                    self.eventarraybits.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playerslot {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.eventarraybits {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.playerslot {
            os.write_int32(1, v)?;
        }
        for v in &self.eventarraybits {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource1LegacyListenEvents {
        CMsgSource1LegacyListenEvents::new()
    }

    fn clear(&mut self) {
        self.playerslot = ::std::option::Option::None;
        self.eventarraybits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource1LegacyListenEvents {
        static instance: CMsgSource1LegacyListenEvents = CMsgSource1LegacyListenEvents {
            playerslot: ::std::option::Option::None,
            eventarraybits: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSource1LegacyListenEvents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSource1LegacyListenEvents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSource1LegacyListenEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSource1LegacyListenEvents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSource1LegacyGameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSource1LegacyGameEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.eventid)
    pub eventid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.keys)
    pub keys: ::std::vec::Vec<cmsg_source1legacy_game_event::Key_t>,
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.server_tick)
    pub server_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.passthrough)
    pub passthrough: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSource1LegacyGameEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSource1LegacyGameEvent {
    fn default() -> &'a CMsgSource1LegacyGameEvent {
        <CMsgSource1LegacyGameEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSource1LegacyGameEvent {
    pub fn new() -> CMsgSource1LegacyGameEvent {
        ::std::default::Default::default()
    }

    // optional string event_name = 1;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 eventid = 2;

    pub fn eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional int32 server_tick = 4;

    pub fn server_tick(&self) -> i32 {
        self.server_tick.unwrap_or(0)
    }

    pub fn clear_server_tick(&mut self) {
        self.server_tick = ::std::option::Option::None;
    }

    pub fn has_server_tick(&self) -> bool {
        self.server_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tick(&mut self, v: i32) {
        self.server_tick = ::std::option::Option::Some(v);
    }

    // optional int32 passthrough = 5;

    pub fn passthrough(&self) -> i32 {
        self.passthrough.unwrap_or(0)
    }

    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: i32) {
        self.passthrough = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_name",
            |m: &CMsgSource1LegacyGameEvent| { &m.event_name },
            |m: &mut CMsgSource1LegacyGameEvent| { &mut m.event_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CMsgSource1LegacyGameEvent| { &m.eventid },
            |m: &mut CMsgSource1LegacyGameEvent| { &mut m.eventid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &CMsgSource1LegacyGameEvent| { &m.keys },
            |m: &mut CMsgSource1LegacyGameEvent| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_tick",
            |m: &CMsgSource1LegacyGameEvent| { &m.server_tick },
            |m: &mut CMsgSource1LegacyGameEvent| { &mut m.server_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passthrough",
            |m: &CMsgSource1LegacyGameEvent| { &m.passthrough },
            |m: &mut CMsgSource1LegacyGameEvent| { &mut m.passthrough },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSource1LegacyGameEvent>(
            "CMsgSource1LegacyGameEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSource1LegacyGameEvent {
    const NAME: &'static str = "CMsgSource1LegacyGameEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.eventid = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.keys.push(is.read_message()?);
                },
                32 => {
                    self.server_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.passthrough = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.server_tick {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.passthrough {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eventid {
            os.write_int32(2, v)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.server_tick {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.passthrough {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSource1LegacyGameEvent {
        CMsgSource1LegacyGameEvent::new()
    }

    fn clear(&mut self) {
        self.event_name = ::std::option::Option::None;
        self.eventid = ::std::option::Option::None;
        self.keys.clear();
        self.server_tick = ::std::option::Option::None;
        self.passthrough = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSource1LegacyGameEvent {
        static instance: CMsgSource1LegacyGameEvent = CMsgSource1LegacyGameEvent {
            event_name: ::std::option::Option::None,
            eventid: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            server_tick: ::std::option::Option::None,
            passthrough: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSource1LegacyGameEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSource1LegacyGameEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSource1LegacyGameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSource1LegacyGameEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgSource1LegacyGameEvent`
pub mod cmsg_source1legacy_game_event {
    // @@protoc_insertion_point(message:CMsgSource1LegacyGameEvent.key_t)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_string)
        pub val_string: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_float)
        pub val_float: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_long)
        pub val_long: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_short)
        pub val_short: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_byte)
        pub val_byte: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_bool)
        pub val_bool: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgSource1LegacyGameEvent.key_t.val_uint64)
        pub val_uint64: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSource1LegacyGameEvent.key_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string val_string = 2;

        pub fn val_string(&self) -> &str {
            match self.val_string.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_val_string(&mut self) {
            self.val_string = ::std::option::Option::None;
        }

        pub fn has_val_string(&self) -> bool {
            self.val_string.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_string(&mut self, v: ::std::string::String) {
            self.val_string = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_val_string(&mut self) -> &mut ::std::string::String {
            if self.val_string.is_none() {
                self.val_string = ::std::option::Option::Some(::std::string::String::new());
            }
            self.val_string.as_mut().unwrap()
        }

        // Take field
        pub fn take_val_string(&mut self) -> ::std::string::String {
            self.val_string.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float val_float = 3;

        pub fn val_float(&self) -> f32 {
            self.val_float.unwrap_or(0.)
        }

        pub fn clear_val_float(&mut self) {
            self.val_float = ::std::option::Option::None;
        }

        pub fn has_val_float(&self) -> bool {
            self.val_float.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_float(&mut self, v: f32) {
            self.val_float = ::std::option::Option::Some(v);
        }

        // optional int32 val_long = 4;

        pub fn val_long(&self) -> i32 {
            self.val_long.unwrap_or(0)
        }

        pub fn clear_val_long(&mut self) {
            self.val_long = ::std::option::Option::None;
        }

        pub fn has_val_long(&self) -> bool {
            self.val_long.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_long(&mut self, v: i32) {
            self.val_long = ::std::option::Option::Some(v);
        }

        // optional int32 val_short = 5;

        pub fn val_short(&self) -> i32 {
            self.val_short.unwrap_or(0)
        }

        pub fn clear_val_short(&mut self) {
            self.val_short = ::std::option::Option::None;
        }

        pub fn has_val_short(&self) -> bool {
            self.val_short.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_short(&mut self, v: i32) {
            self.val_short = ::std::option::Option::Some(v);
        }

        // optional int32 val_byte = 6;

        pub fn val_byte(&self) -> i32 {
            self.val_byte.unwrap_or(0)
        }

        pub fn clear_val_byte(&mut self) {
            self.val_byte = ::std::option::Option::None;
        }

        pub fn has_val_byte(&self) -> bool {
            self.val_byte.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_byte(&mut self, v: i32) {
            self.val_byte = ::std::option::Option::Some(v);
        }

        // optional bool val_bool = 7;

        pub fn val_bool(&self) -> bool {
            self.val_bool.unwrap_or(false)
        }

        pub fn clear_val_bool(&mut self) {
            self.val_bool = ::std::option::Option::None;
        }

        pub fn has_val_bool(&self) -> bool {
            self.val_bool.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_bool(&mut self, v: bool) {
            self.val_bool = ::std::option::Option::Some(v);
        }

        // optional uint64 val_uint64 = 8;

        pub fn val_uint64(&self) -> u64 {
            self.val_uint64.unwrap_or(0)
        }

        pub fn clear_val_uint64(&mut self) {
            self.val_uint64 = ::std::option::Option::None;
        }

        pub fn has_val_uint64(&self) -> bool {
            self.val_uint64.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_uint64(&mut self, v: u64) {
            self.val_uint64 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Key_t| { &m.type_ },
                |m: &mut Key_t| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_string",
                |m: &Key_t| { &m.val_string },
                |m: &mut Key_t| { &mut m.val_string },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_float",
                |m: &Key_t| { &m.val_float },
                |m: &mut Key_t| { &mut m.val_float },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_long",
                |m: &Key_t| { &m.val_long },
                |m: &mut Key_t| { &mut m.val_long },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_short",
                |m: &Key_t| { &m.val_short },
                |m: &mut Key_t| { &mut m.val_short },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_byte",
                |m: &Key_t| { &m.val_byte },
                |m: &mut Key_t| { &mut m.val_byte },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_bool",
                |m: &Key_t| { &m.val_bool },
                |m: &mut Key_t| { &mut m.val_bool },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_uint64",
                |m: &Key_t| { &m.val_uint64 },
                |m: &mut Key_t| { &mut m.val_uint64 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key_t>(
                "CMsgSource1LegacyGameEvent.key_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.val_string = ::std::option::Option::Some(is.read_string()?);
                    },
                    29 => {
                        self.val_float = ::std::option::Option::Some(is.read_float()?);
                    },
                    32 => {
                        self.val_long = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.val_short = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.val_byte = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.val_bool = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.val_uint64 = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.val_string.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.val_float {
                my_size += 1 + 4;
            }
            if let Some(v) = self.val_long {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.val_short {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.val_byte {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.val_bool {
                my_size += 1 + 1;
            }
            if let Some(v) = self.val_uint64 {
                my_size += ::protobuf::rt::uint64_size(8, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.val_string.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.val_float {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.val_long {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.val_short {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.val_byte {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.val_bool {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.val_uint64 {
                os.write_uint64(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.val_string = ::std::option::Option::None;
            self.val_float = ::std::option::Option::None;
            self.val_long = ::std::option::Option::None;
            self.val_short = ::std::option::Option::None;
            self.val_byte = ::std::option::Option::None;
            self.val_bool = ::std::option::Option::None;
            self.val_uint64 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                val_string: ::std::option::Option::None,
                val_float: ::std::option::Option::None,
                val_long: ::std::option::Option::None,
                val_short: ::std::option::Option::None,
                val_byte: ::std::option::Option::None,
                val_bool: ::std::option::Option::None,
                val_uint64: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Key_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgSource1LegacyGameEvent.key_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Key_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Key_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgSosStartSoundEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSosStartSoundEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.soundevent_guid)
    pub soundevent_guid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.soundevent_hash)
    pub soundevent_hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.source_entity_index)
    pub source_entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.seed)
    pub seed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.packed_params)
    pub packed_params: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgSosStartSoundEvent.start_time)
    pub start_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSosStartSoundEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSosStartSoundEvent {
    fn default() -> &'a CMsgSosStartSoundEvent {
        <CMsgSosStartSoundEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSosStartSoundEvent {
    pub fn new() -> CMsgSosStartSoundEvent {
        ::std::default::Default::default()
    }

    // optional int32 soundevent_guid = 1;

    pub fn soundevent_guid(&self) -> i32 {
        self.soundevent_guid.unwrap_or(0)
    }

    pub fn clear_soundevent_guid(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
    }

    pub fn has_soundevent_guid(&self) -> bool {
        self.soundevent_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundevent_guid(&mut self, v: i32) {
        self.soundevent_guid = ::std::option::Option::Some(v);
    }

    // optional fixed32 soundevent_hash = 2;

    pub fn soundevent_hash(&self) -> u32 {
        self.soundevent_hash.unwrap_or(0)
    }

    pub fn clear_soundevent_hash(&mut self) {
        self.soundevent_hash = ::std::option::Option::None;
    }

    pub fn has_soundevent_hash(&self) -> bool {
        self.soundevent_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundevent_hash(&mut self, v: u32) {
        self.soundevent_hash = ::std::option::Option::Some(v);
    }

    // optional int32 source_entity_index = 3;

    pub fn source_entity_index(&self) -> i32 {
        self.source_entity_index.unwrap_or(-1i32)
    }

    pub fn clear_source_entity_index(&mut self) {
        self.source_entity_index = ::std::option::Option::None;
    }

    pub fn has_source_entity_index(&self) -> bool {
        self.source_entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_entity_index(&mut self, v: i32) {
        self.source_entity_index = ::std::option::Option::Some(v);
    }

    // optional int32 seed = 4;

    pub fn seed(&self) -> i32 {
        self.seed.unwrap_or(0)
    }

    pub fn clear_seed(&mut self) {
        self.seed = ::std::option::Option::None;
    }

    pub fn has_seed(&self) -> bool {
        self.seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: i32) {
        self.seed = ::std::option::Option::Some(v);
    }

    // optional bytes packed_params = 5;

    pub fn packed_params(&self) -> &[u8] {
        match self.packed_params.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_packed_params(&mut self) {
        self.packed_params = ::std::option::Option::None;
    }

    pub fn has_packed_params(&self) -> bool {
        self.packed_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed_params(&mut self, v: ::bytes::Bytes) {
        self.packed_params = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packed_params(&mut self) -> &mut ::bytes::Bytes {
        if self.packed_params.is_none() {
            self.packed_params = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.packed_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_packed_params(&mut self) -> ::bytes::Bytes {
        self.packed_params.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional float start_time = 6;

    pub fn start_time(&self) -> f32 {
        self.start_time.unwrap_or(0.)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soundevent_guid",
            |m: &CMsgSosStartSoundEvent| { &m.soundevent_guid },
            |m: &mut CMsgSosStartSoundEvent| { &mut m.soundevent_guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soundevent_hash",
            |m: &CMsgSosStartSoundEvent| { &m.soundevent_hash },
            |m: &mut CMsgSosStartSoundEvent| { &mut m.soundevent_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_entity_index",
            |m: &CMsgSosStartSoundEvent| { &m.source_entity_index },
            |m: &mut CMsgSosStartSoundEvent| { &mut m.source_entity_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seed",
            |m: &CMsgSosStartSoundEvent| { &m.seed },
            |m: &mut CMsgSosStartSoundEvent| { &mut m.seed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packed_params",
            |m: &CMsgSosStartSoundEvent| { &m.packed_params },
            |m: &mut CMsgSosStartSoundEvent| { &mut m.packed_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CMsgSosStartSoundEvent| { &m.start_time },
            |m: &mut CMsgSosStartSoundEvent| { &mut m.start_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSosStartSoundEvent>(
            "CMsgSosStartSoundEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSosStartSoundEvent {
    const NAME: &'static str = "CMsgSosStartSoundEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soundevent_guid = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.soundevent_hash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.source_entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.seed = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.packed_params = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                53 => {
                    self.start_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soundevent_guid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.soundevent_hash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.source_entity_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.seed {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.packed_params.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soundevent_guid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.soundevent_hash {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.source_entity_index {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.seed {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.packed_params.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSosStartSoundEvent {
        CMsgSosStartSoundEvent::new()
    }

    fn clear(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
        self.soundevent_hash = ::std::option::Option::None;
        self.source_entity_index = ::std::option::Option::None;
        self.seed = ::std::option::Option::None;
        self.packed_params = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSosStartSoundEvent {
        static instance: CMsgSosStartSoundEvent = CMsgSosStartSoundEvent {
            soundevent_guid: ::std::option::Option::None,
            soundevent_hash: ::std::option::Option::None,
            source_entity_index: ::std::option::Option::None,
            seed: ::std::option::Option::None,
            packed_params: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSosStartSoundEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSosStartSoundEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSosStartSoundEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSosStartSoundEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSosStopSoundEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSosStopSoundEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgSosStopSoundEvent.soundevent_guid)
    pub soundevent_guid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSosStopSoundEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSosStopSoundEvent {
    fn default() -> &'a CMsgSosStopSoundEvent {
        <CMsgSosStopSoundEvent as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSosStopSoundEvent {
    pub fn new() -> CMsgSosStopSoundEvent {
        ::std::default::Default::default()
    }

    // optional int32 soundevent_guid = 1;

    pub fn soundevent_guid(&self) -> i32 {
        self.soundevent_guid.unwrap_or(0)
    }

    pub fn clear_soundevent_guid(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
    }

    pub fn has_soundevent_guid(&self) -> bool {
        self.soundevent_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundevent_guid(&mut self, v: i32) {
        self.soundevent_guid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soundevent_guid",
            |m: &CMsgSosStopSoundEvent| { &m.soundevent_guid },
            |m: &mut CMsgSosStopSoundEvent| { &mut m.soundevent_guid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSosStopSoundEvent>(
            "CMsgSosStopSoundEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSosStopSoundEvent {
    const NAME: &'static str = "CMsgSosStopSoundEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soundevent_guid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soundevent_guid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soundevent_guid {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSosStopSoundEvent {
        CMsgSosStopSoundEvent::new()
    }

    fn clear(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSosStopSoundEvent {
        static instance: CMsgSosStopSoundEvent = CMsgSosStopSoundEvent {
            soundevent_guid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSosStopSoundEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSosStopSoundEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSosStopSoundEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSosStopSoundEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSosStopSoundEventHash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSosStopSoundEventHash {
    // message fields
    // @@protoc_insertion_point(field:CMsgSosStopSoundEventHash.soundevent_hash)
    pub soundevent_hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSosStopSoundEventHash.source_entity_index)
    pub source_entity_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSosStopSoundEventHash.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSosStopSoundEventHash {
    fn default() -> &'a CMsgSosStopSoundEventHash {
        <CMsgSosStopSoundEventHash as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSosStopSoundEventHash {
    pub fn new() -> CMsgSosStopSoundEventHash {
        ::std::default::Default::default()
    }

    // optional fixed32 soundevent_hash = 1;

    pub fn soundevent_hash(&self) -> u32 {
        self.soundevent_hash.unwrap_or(0)
    }

    pub fn clear_soundevent_hash(&mut self) {
        self.soundevent_hash = ::std::option::Option::None;
    }

    pub fn has_soundevent_hash(&self) -> bool {
        self.soundevent_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundevent_hash(&mut self, v: u32) {
        self.soundevent_hash = ::std::option::Option::Some(v);
    }

    // optional int32 source_entity_index = 2;

    pub fn source_entity_index(&self) -> i32 {
        self.source_entity_index.unwrap_or(-1i32)
    }

    pub fn clear_source_entity_index(&mut self) {
        self.source_entity_index = ::std::option::Option::None;
    }

    pub fn has_source_entity_index(&self) -> bool {
        self.source_entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_entity_index(&mut self, v: i32) {
        self.source_entity_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soundevent_hash",
            |m: &CMsgSosStopSoundEventHash| { &m.soundevent_hash },
            |m: &mut CMsgSosStopSoundEventHash| { &mut m.soundevent_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "source_entity_index",
            |m: &CMsgSosStopSoundEventHash| { &m.source_entity_index },
            |m: &mut CMsgSosStopSoundEventHash| { &mut m.source_entity_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSosStopSoundEventHash>(
            "CMsgSosStopSoundEventHash",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSosStopSoundEventHash {
    const NAME: &'static str = "CMsgSosStopSoundEventHash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.soundevent_hash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.source_entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soundevent_hash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.source_entity_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soundevent_hash {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.source_entity_index {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSosStopSoundEventHash {
        CMsgSosStopSoundEventHash::new()
    }

    fn clear(&mut self) {
        self.soundevent_hash = ::std::option::Option::None;
        self.source_entity_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSosStopSoundEventHash {
        static instance: CMsgSosStopSoundEventHash = CMsgSosStopSoundEventHash {
            soundevent_hash: ::std::option::Option::None,
            source_entity_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSosStopSoundEventHash {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSosStopSoundEventHash").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSosStopSoundEventHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSosStopSoundEventHash {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSosSetSoundEventParams)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSosSetSoundEventParams {
    // message fields
    // @@protoc_insertion_point(field:CMsgSosSetSoundEventParams.soundevent_guid)
    pub soundevent_guid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSosSetSoundEventParams.packed_params)
    pub packed_params: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSosSetSoundEventParams.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSosSetSoundEventParams {
    fn default() -> &'a CMsgSosSetSoundEventParams {
        <CMsgSosSetSoundEventParams as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSosSetSoundEventParams {
    pub fn new() -> CMsgSosSetSoundEventParams {
        ::std::default::Default::default()
    }

    // optional int32 soundevent_guid = 1;

    pub fn soundevent_guid(&self) -> i32 {
        self.soundevent_guid.unwrap_or(0)
    }

    pub fn clear_soundevent_guid(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
    }

    pub fn has_soundevent_guid(&self) -> bool {
        self.soundevent_guid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundevent_guid(&mut self, v: i32) {
        self.soundevent_guid = ::std::option::Option::Some(v);
    }

    // optional bytes packed_params = 5;

    pub fn packed_params(&self) -> &[u8] {
        match self.packed_params.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_packed_params(&mut self) {
        self.packed_params = ::std::option::Option::None;
    }

    pub fn has_packed_params(&self) -> bool {
        self.packed_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed_params(&mut self, v: ::bytes::Bytes) {
        self.packed_params = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packed_params(&mut self) -> &mut ::bytes::Bytes {
        if self.packed_params.is_none() {
            self.packed_params = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.packed_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_packed_params(&mut self) -> ::bytes::Bytes {
        self.packed_params.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "soundevent_guid",
            |m: &CMsgSosSetSoundEventParams| { &m.soundevent_guid },
            |m: &mut CMsgSosSetSoundEventParams| { &mut m.soundevent_guid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packed_params",
            |m: &CMsgSosSetSoundEventParams| { &m.packed_params },
            |m: &mut CMsgSosSetSoundEventParams| { &mut m.packed_params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSosSetSoundEventParams>(
            "CMsgSosSetSoundEventParams",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSosSetSoundEventParams {
    const NAME: &'static str = "CMsgSosSetSoundEventParams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.soundevent_guid = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.packed_params = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soundevent_guid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.packed_params.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.soundevent_guid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.packed_params.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSosSetSoundEventParams {
        CMsgSosSetSoundEventParams::new()
    }

    fn clear(&mut self) {
        self.soundevent_guid = ::std::option::Option::None;
        self.packed_params = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSosSetSoundEventParams {
        static instance: CMsgSosSetSoundEventParams = CMsgSosSetSoundEventParams {
            soundevent_guid: ::std::option::Option::None,
            packed_params: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSosSetSoundEventParams {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSosSetSoundEventParams").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSosSetSoundEventParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSosSetSoundEventParams {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgSosSetLibraryStackFields)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSosSetLibraryStackFields {
    // message fields
    // @@protoc_insertion_point(field:CMsgSosSetLibraryStackFields.stack_hash)
    pub stack_hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSosSetLibraryStackFields.packed_fields)
    pub packed_fields: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSosSetLibraryStackFields.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSosSetLibraryStackFields {
    fn default() -> &'a CMsgSosSetLibraryStackFields {
        <CMsgSosSetLibraryStackFields as ::protobuf::Message>::default_instance()
    }
}

impl CMsgSosSetLibraryStackFields {
    pub fn new() -> CMsgSosSetLibraryStackFields {
        ::std::default::Default::default()
    }

    // optional fixed32 stack_hash = 1;

    pub fn stack_hash(&self) -> u32 {
        self.stack_hash.unwrap_or(0)
    }

    pub fn clear_stack_hash(&mut self) {
        self.stack_hash = ::std::option::Option::None;
    }

    pub fn has_stack_hash(&self) -> bool {
        self.stack_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_hash(&mut self, v: u32) {
        self.stack_hash = ::std::option::Option::Some(v);
    }

    // optional bytes packed_fields = 5;

    pub fn packed_fields(&self) -> &[u8] {
        match self.packed_fields.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_packed_fields(&mut self) {
        self.packed_fields = ::std::option::Option::None;
    }

    pub fn has_packed_fields(&self) -> bool {
        self.packed_fields.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed_fields(&mut self, v: ::bytes::Bytes) {
        self.packed_fields = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packed_fields(&mut self) -> &mut ::bytes::Bytes {
        if self.packed_fields.is_none() {
            self.packed_fields = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.packed_fields.as_mut().unwrap()
    }

    // Take field
    pub fn take_packed_fields(&mut self) -> ::bytes::Bytes {
        self.packed_fields.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stack_hash",
            |m: &CMsgSosSetLibraryStackFields| { &m.stack_hash },
            |m: &mut CMsgSosSetLibraryStackFields| { &mut m.stack_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packed_fields",
            |m: &CMsgSosSetLibraryStackFields| { &m.packed_fields },
            |m: &mut CMsgSosSetLibraryStackFields| { &mut m.packed_fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgSosSetLibraryStackFields>(
            "CMsgSosSetLibraryStackFields",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgSosSetLibraryStackFields {
    const NAME: &'static str = "CMsgSosSetLibraryStackFields";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.stack_hash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                42 => {
                    self.packed_fields = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stack_hash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.packed_fields.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stack_hash {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.packed_fields.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSosSetLibraryStackFields {
        CMsgSosSetLibraryStackFields::new()
    }

    fn clear(&mut self) {
        self.stack_hash = ::std::option::Option::None;
        self.packed_fields = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSosSetLibraryStackFields {
        static instance: CMsgSosSetLibraryStackFields = CMsgSosSetLibraryStackFields {
            stack_hash: ::std::option::Option::None,
            packed_fields: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgSosSetLibraryStackFields {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgSosSetLibraryStackFields").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgSosSetLibraryStackFields {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgSosSetLibraryStackFields {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBaseGameEvents)
pub enum EBaseGameEvents {
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_VDebugGameSessionIDEvent)
    GE_VDebugGameSessionIDEvent = 200,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_PlaceDecalEvent)
    GE_PlaceDecalEvent = 201,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_ClearWorldDecalsEvent)
    GE_ClearWorldDecalsEvent = 202,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_ClearEntityDecalsEvent)
    GE_ClearEntityDecalsEvent = 203,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_ClearDecalsForSkeletonInstanceEvent)
    GE_ClearDecalsForSkeletonInstanceEvent = 204,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_Source1LegacyGameEventList)
    GE_Source1LegacyGameEventList = 205,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_Source1LegacyListenEvents)
    GE_Source1LegacyListenEvents = 206,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_Source1LegacyGameEvent)
    GE_Source1LegacyGameEvent = 207,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_SosStartSoundEvent)
    GE_SosStartSoundEvent = 208,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_SosStopSoundEvent)
    GE_SosStopSoundEvent = 209,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_SosSetSoundEventParams)
    GE_SosSetSoundEventParams = 210,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_SosSetLibraryStackFields)
    GE_SosSetLibraryStackFields = 211,
    // @@protoc_insertion_point(enum_value:EBaseGameEvents.GE_SosStopSoundEventHash)
    GE_SosStopSoundEventHash = 212,
}

impl ::protobuf::Enum for EBaseGameEvents {
    const NAME: &'static str = "EBaseGameEvents";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBaseGameEvents> {
        match value {
            200 => ::std::option::Option::Some(EBaseGameEvents::GE_VDebugGameSessionIDEvent),
            201 => ::std::option::Option::Some(EBaseGameEvents::GE_PlaceDecalEvent),
            202 => ::std::option::Option::Some(EBaseGameEvents::GE_ClearWorldDecalsEvent),
            203 => ::std::option::Option::Some(EBaseGameEvents::GE_ClearEntityDecalsEvent),
            204 => ::std::option::Option::Some(EBaseGameEvents::GE_ClearDecalsForSkeletonInstanceEvent),
            205 => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyGameEventList),
            206 => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyListenEvents),
            207 => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyGameEvent),
            208 => ::std::option::Option::Some(EBaseGameEvents::GE_SosStartSoundEvent),
            209 => ::std::option::Option::Some(EBaseGameEvents::GE_SosStopSoundEvent),
            210 => ::std::option::Option::Some(EBaseGameEvents::GE_SosSetSoundEventParams),
            211 => ::std::option::Option::Some(EBaseGameEvents::GE_SosSetLibraryStackFields),
            212 => ::std::option::Option::Some(EBaseGameEvents::GE_SosStopSoundEventHash),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBaseGameEvents> {
        match str {
            "GE_VDebugGameSessionIDEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_VDebugGameSessionIDEvent),
            "GE_PlaceDecalEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_PlaceDecalEvent),
            "GE_ClearWorldDecalsEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_ClearWorldDecalsEvent),
            "GE_ClearEntityDecalsEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_ClearEntityDecalsEvent),
            "GE_ClearDecalsForSkeletonInstanceEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_ClearDecalsForSkeletonInstanceEvent),
            "GE_Source1LegacyGameEventList" => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyGameEventList),
            "GE_Source1LegacyListenEvents" => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyListenEvents),
            "GE_Source1LegacyGameEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_Source1LegacyGameEvent),
            "GE_SosStartSoundEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_SosStartSoundEvent),
            "GE_SosStopSoundEvent" => ::std::option::Option::Some(EBaseGameEvents::GE_SosStopSoundEvent),
            "GE_SosSetSoundEventParams" => ::std::option::Option::Some(EBaseGameEvents::GE_SosSetSoundEventParams),
            "GE_SosSetLibraryStackFields" => ::std::option::Option::Some(EBaseGameEvents::GE_SosSetLibraryStackFields),
            "GE_SosStopSoundEventHash" => ::std::option::Option::Some(EBaseGameEvents::GE_SosStopSoundEventHash),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBaseGameEvents] = &[
        EBaseGameEvents::GE_VDebugGameSessionIDEvent,
        EBaseGameEvents::GE_PlaceDecalEvent,
        EBaseGameEvents::GE_ClearWorldDecalsEvent,
        EBaseGameEvents::GE_ClearEntityDecalsEvent,
        EBaseGameEvents::GE_ClearDecalsForSkeletonInstanceEvent,
        EBaseGameEvents::GE_Source1LegacyGameEventList,
        EBaseGameEvents::GE_Source1LegacyListenEvents,
        EBaseGameEvents::GE_Source1LegacyGameEvent,
        EBaseGameEvents::GE_SosStartSoundEvent,
        EBaseGameEvents::GE_SosStopSoundEvent,
        EBaseGameEvents::GE_SosSetSoundEventParams,
        EBaseGameEvents::GE_SosSetLibraryStackFields,
        EBaseGameEvents::GE_SosStopSoundEventHash,
    ];
}

impl ::protobuf::EnumFull for EBaseGameEvents {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBaseGameEvents").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            EBaseGameEvents::GE_VDebugGameSessionIDEvent => 0,
            EBaseGameEvents::GE_PlaceDecalEvent => 1,
            EBaseGameEvents::GE_ClearWorldDecalsEvent => 2,
            EBaseGameEvents::GE_ClearEntityDecalsEvent => 3,
            EBaseGameEvents::GE_ClearDecalsForSkeletonInstanceEvent => 4,
            EBaseGameEvents::GE_Source1LegacyGameEventList => 5,
            EBaseGameEvents::GE_Source1LegacyListenEvents => 6,
            EBaseGameEvents::GE_Source1LegacyGameEvent => 7,
            EBaseGameEvents::GE_SosStartSoundEvent => 8,
            EBaseGameEvents::GE_SosStopSoundEvent => 9,
            EBaseGameEvents::GE_SosSetSoundEventParams => 10,
            EBaseGameEvents::GE_SosSetLibraryStackFields => 11,
            EBaseGameEvents::GE_SosStopSoundEventHash => 12,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EBaseGameEvents {
    fn default() -> Self {
        EBaseGameEvents::GE_VDebugGameSessionIDEvent
    }
}

impl EBaseGameEvents {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EBaseGameEvents>("EBaseGameEvents")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10gameevents.proto\x1a\x16networkbasetypes.proto\"`\n\x1cCMsgVDebugG\
    ameSessionIDEvent\x12\x1a\n\x08clientid\x18\x01\x20\x01(\x05R\x08clienti\
    d\x12$\n\rgamesessionid\x18\x02\x20\x01(\tR\rgamesessionid\"\xef\x03\n\
    \x13CMsgPlaceDecalEvent\x12'\n\x08position\x18\x01\x20\x01(\x0b2\x0b.CMs\
    gVectorR\x08position\x12#\n\x06normal\x18\x02\x20\x01(\x0b2\x0b.CMsgVect\
    orR\x06normal\x12!\n\x05saxis\x18\x03\x20\x01(\x0b2\x0b.CMsgVectorR\x05s\
    axis\x12.\n\x12decalmaterialindex\x18\x04\x20\x01(\rR\x12decalmaterialin\
    dex\x12\x14\n\x05flags\x18\x05\x20\x01(\rR\x05flags\x12\x14\n\x05color\
    \x18\x06\x20\x01(\x07R\x05color\x12\x14\n\x05width\x18\x07\x20\x01(\x02R\
    \x05width\x12\x16\n\x06height\x18\x08\x20\x01(\x02R\x06height\x12\x14\n\
    \x05depth\x18\t\x20\x01(\x02R\x05depth\x12,\n\x11entityhandleindex\x18\n\
    \x20\x01(\rR\x11entityhandleindex\x122\n\x14skeletoninstancehash\x18\x0b\
    \x20\x01(\x07R\x14skeletoninstancehash\x12\x1c\n\tboneindex\x18\x0c\x20\
    \x01(\x05R\tboneindex\x12&\n\x0etranslucenthit\x18\r\x20\x01(\x08R\x0etr\
    anslucenthit\x12\x1f\n\x0bis_adjacent\x18\x0e\x20\x01(\x08R\nisAdjacent\
    \"?\n\x19CMsgClearWorldDecalsEvent\x12\"\n\x0cflagstoclear\x18\x01\x20\
    \x01(\rR\x0cflagstoclear\"@\n\x1aCMsgClearEntityDecalsEvent\x12\"\n\x0cf\
    lagstoclear\x18\x01\x20\x01(\rR\x0cflagstoclear\"\xaf\x01\n'CMsgClearDec\
    alsForSkeletonInstanceEvent\x12\"\n\x0cflagstoclear\x18\x01\x20\x01(\rR\
    \x0cflagstoclear\x12,\n\x11entityhandleindex\x18\x02\x20\x01(\rR\x11enti\
    tyhandleindex\x122\n\x14skeletoninstancehash\x18\x03\x20\x01(\rR\x14skel\
    etoninstancehash\"\x9a\x02\n\x1eCMsgSource1LegacyGameEventList\x12N\n\
    \x0bdescriptors\x18\x01\x20\x03(\x0b2,.CMsgSource1LegacyGameEventList.de\
    scriptor_tR\x0bdescriptors\x1a/\n\x05key_t\x12\x12\n\x04type\x18\x01\x20\
    \x01(\x05R\x04type\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x1aw\n\
    \x0cdescriptor_t\x12\x18\n\x07eventid\x18\x01\x20\x01(\x05R\x07eventid\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x129\n\x04keys\x18\x03\
    \x20\x03(\x0b2%.CMsgSource1LegacyGameEventList.key_tR\x04keys\"g\n\x1dCM\
    sgSource1LegacyListenEvents\x12\x1e\n\nplayerslot\x18\x01\x20\x01(\x05R\
    \nplayerslot\x12&\n\x0eeventarraybits\x18\x02\x20\x03(\rR\x0eeventarrayb\
    its\"\xb6\x03\n\x1aCMsgSource1LegacyGameEvent\x12\x1d\n\nevent_name\x18\
    \x01\x20\x01(\tR\teventName\x12\x18\n\x07eventid\x18\x02\x20\x01(\x05R\
    \x07eventid\x125\n\x04keys\x18\x03\x20\x03(\x0b2!.CMsgSource1LegacyGameE\
    vent.key_tR\x04keys\x12\x1f\n\x0bserver_tick\x18\x04\x20\x01(\x05R\nserv\
    erTick\x12\x20\n\x0bpassthrough\x18\x05\x20\x01(\x05R\x0bpassthrough\x1a\
    \xe4\x01\n\x05key_t\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\
    \x1d\n\nval_string\x18\x02\x20\x01(\tR\tvalString\x12\x1b\n\tval_float\
    \x18\x03\x20\x01(\x02R\x08valFloat\x12\x19\n\x08val_long\x18\x04\x20\x01\
    (\x05R\x07valLong\x12\x1b\n\tval_short\x18\x05\x20\x01(\x05R\x08valShort\
    \x12\x19\n\x08val_byte\x18\x06\x20\x01(\x05R\x07valByte\x12\x19\n\x08val\
    _bool\x18\x07\x20\x01(\x08R\x07valBool\x12\x1d\n\nval_uint64\x18\x08\x20\
    \x01(\x04R\tvalUint64\"\xf6\x01\n\x16CMsgSosStartSoundEvent\x12'\n\x0fso\
    undevent_guid\x18\x01\x20\x01(\x05R\x0esoundeventGuid\x12'\n\x0fsoundeve\
    nt_hash\x18\x02\x20\x01(\x07R\x0esoundeventHash\x122\n\x13source_entity_\
    index\x18\x03\x20\x01(\x05:\x02-1R\x11sourceEntityIndex\x12\x12\n\x04see\
    d\x18\x04\x20\x01(\x05R\x04seed\x12#\n\rpacked_params\x18\x05\x20\x01(\
    \x0cR\x0cpackedParams\x12\x1d\n\nstart_time\x18\x06\x20\x01(\x02R\tstart\
    Time\"@\n\x15CMsgSosStopSoundEvent\x12'\n\x0fsoundevent_guid\x18\x01\x20\
    \x01(\x05R\x0esoundeventGuid\"x\n\x19CMsgSosStopSoundEventHash\x12'\n\
    \x0fsoundevent_hash\x18\x01\x20\x01(\x07R\x0esoundeventHash\x122\n\x13so\
    urce_entity_index\x18\x02\x20\x01(\x05:\x02-1R\x11sourceEntityIndex\"j\n\
    \x1aCMsgSosSetSoundEventParams\x12'\n\x0fsoundevent_guid\x18\x01\x20\x01\
    (\x05R\x0esoundeventGuid\x12#\n\rpacked_params\x18\x05\x20\x01(\x0cR\x0c\
    packedParams\"b\n\x1cCMsgSosSetLibraryStackFields\x12\x1d\n\nstack_hash\
    \x18\x01\x20\x01(\x07R\tstackHash\x12#\n\rpacked_fields\x18\x05\x20\x01(\
    \x0cR\x0cpackedFields*\xb7\x03\n\x0fEBaseGameEvents\x12\x20\n\x1bGE_VDeb\
    ugGameSessionIDEvent\x10\xc8\x01\x12\x17\n\x12GE_PlaceDecalEvent\x10\xc9\
    \x01\x12\x1d\n\x18GE_ClearWorldDecalsEvent\x10\xca\x01\x12\x1e\n\x19GE_C\
    learEntityDecalsEvent\x10\xcb\x01\x12+\n&GE_ClearDecalsForSkeletonInstan\
    ceEvent\x10\xcc\x01\x12\"\n\x1dGE_Source1LegacyGameEventList\x10\xcd\x01\
    \x12!\n\x1cGE_Source1LegacyListenEvents\x10\xce\x01\x12\x1e\n\x19GE_Sour\
    ce1LegacyGameEvent\x10\xcf\x01\x12\x1a\n\x15GE_SosStartSoundEvent\x10\
    \xd0\x01\x12\x19\n\x14GE_SosStopSoundEvent\x10\xd1\x01\x12\x1e\n\x19GE_S\
    osSetSoundEventParams\x10\xd2\x01\x12\x20\n\x1bGE_SosSetLibraryStackFiel\
    ds\x10\xd3\x01\x12\x1d\n\x18GE_SosStopSoundEventHash\x10\xd4\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::networkbasetypes::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(16);
            messages.push(CMsgVDebugGameSessionIDEvent::generated_message_descriptor_data());
            messages.push(CMsgPlaceDecalEvent::generated_message_descriptor_data());
            messages.push(CMsgClearWorldDecalsEvent::generated_message_descriptor_data());
            messages.push(CMsgClearEntityDecalsEvent::generated_message_descriptor_data());
            messages.push(CMsgClearDecalsForSkeletonInstanceEvent::generated_message_descriptor_data());
            messages.push(CMsgSource1LegacyGameEventList::generated_message_descriptor_data());
            messages.push(CMsgSource1LegacyListenEvents::generated_message_descriptor_data());
            messages.push(CMsgSource1LegacyGameEvent::generated_message_descriptor_data());
            messages.push(CMsgSosStartSoundEvent::generated_message_descriptor_data());
            messages.push(CMsgSosStopSoundEvent::generated_message_descriptor_data());
            messages.push(CMsgSosStopSoundEventHash::generated_message_descriptor_data());
            messages.push(CMsgSosSetSoundEventParams::generated_message_descriptor_data());
            messages.push(CMsgSosSetLibraryStackFields::generated_message_descriptor_data());
            messages.push(cmsg_source1legacy_game_event_list::Key_t::generated_message_descriptor_data());
            messages.push(cmsg_source1legacy_game_event_list::Descriptor_t::generated_message_descriptor_data());
            messages.push(cmsg_source1legacy_game_event::Key_t::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(EBaseGameEvents::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
